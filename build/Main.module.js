import * as THREE$1 from 'three';
import { Ray as Ray$1, Plane, MathUtils, EventDispatcher, Vector3, MOUSE, TOUCH, Spherical, Quaternion as Quaternion$1, Vector2, Matrix4, Euler, BufferGeometry, BufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Loader, LoaderUtils, FileLoader, MeshPhysicalMaterial, Color, LinearSRGBColorSpace, SRGBColorSpace, SpotLight, PointLight, DirectionalLight, InstancedMesh, InstancedBufferAttribute, Object3D, TextureLoader, ImageBitmapLoader, InterleavedBuffer, InterleavedBufferAttribute, LinearMipmapLinearFilter, NearestMipmapLinearFilter, LinearMipmapNearestFilter, NearestMipmapNearestFilter, LinearFilter, NearestFilter, RepeatWrapping, MirroredRepeatWrapping, ClampToEdgeWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, MeshBasicMaterial, PropertyBinding, SkinnedMesh, Mesh, LineSegments, Line as Line$1, LineLoop, Points, Group as Group$1, PerspectiveCamera, OrthographicCamera, Skeleton, AnimationClip, Bone, InterpolateDiscrete, InterpolateLinear, Texture, VectorKeyframeTrack, NumberKeyframeTrack, QuaternionKeyframeTrack, ColorManagement, FrontSide, Interpolant, Box3, Sphere, Vector4, Curve, MeshPhongMaterial, MeshLambertMaterial, EquirectangularReflectionMapping, AmbientLight, Float32BufferAttribute, Uint16BufferAttribute, Matrix3 as Matrix3$1, ShapeUtils, DataTextureLoader, HalfFloatType, FloatType, DataUtils, RGBAFormat, RedFormat, NoColorSpace, RGBA_S3TC_DXT1_Format, RGB_PVRTC_4BPPV1_Format, RGB_ETC2_Format, RGB_ETC1_Format, RGBA_S3TC_DXT5_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_ETC2_EAC_Format, RGBA_BPTC_Format, RGB_BPTC_UNSIGNED_Format, RGBA_ASTC_4x4_Format, UnsignedByteType, CompressedCubeTexture, CompressedArrayTexture, CompressedTexture, RGBA_ASTC_6x6_Format, RGFormat, DataTexture, Data3DTexture, LoadingManager, AnimationMixer, ObjectSpaceNormalMap, IcosahedronGeometry, ShaderMaterial, PlaneGeometry, Scene, WebGLRenderTarget, DirectionalLightHelper, CameraHelper, HemisphereLight, RectAreaLight, HemisphereLightHelper, SpotLightHelper, PointLightHelper, PMREMGenerator, REVISION, DepthTexture, DepthStencilFormat, UnsignedInt248Type, UnsignedIntType, Uniform, BasicDepthPacking, Camera, BackSide, NoBlending, Triangle, BoxGeometry, AdditiveBlending, WebGLCubeRenderTarget, CubeCamera, SphereGeometry, CylinderGeometry, CanvasTexture, ShadowMaterial, MeshToonMaterial, SrcAlphaSaturateFactor, OneMinusDstColorFactor, DstColorFactor, OneMinusDstAlphaFactor, DstAlphaFactor, OneMinusSrcAlphaFactor, SrcAlphaFactor, OneMinusSrcColorFactor, SrcColorFactor, OneFactor, ZeroFactor, MaxEquation, MinEquation, ReverseSubtractEquation, SubtractEquation, AddEquation, MultiplyBlending, SubtractiveBlending, NormalBlending, Layers, CircleGeometry, Line3, Box2, Shape, Path, ShapePath, ShapeGeometry, CustomBlending, SkeletonHelper, AnimationUtils, AdditiveAnimationBlendMode, NormalAnimationBlendMode, Raycaster, NoToneMapping, InstancedBufferGeometry, InstancedInterleavedBuffer, DynamicDrawUsage } from 'three';
import * as TWEEN$1 from 'tween';

const s$1={ui:[],debug:false,dom:null,ID:null,lock:false,wlock:false,current:-1,needReZone:true,needResize:false,forceZone:false,isEventsInit:false,isLeave:false,downTime:0,prevTime:0,prevDefault:["contextmenu"],pointerEvent:["pointerdown","pointermove","pointerup"],eventOut:["pointercancel","pointerout","pointerleave"],xmlserializer:null,tmpTime:null,tmpImage:null,oldCursor:"auto",input:null,parent:null,firstImput:true,hiddenImput:null,hiddenSizer:null,hasFocus:false,startInput:false,inputRange:[0,0],cursorId:0,str:"",pos:0,startX:-1,moveX:-1,debugInput:false,isLoop:false,listens:[],e:{type:null,clientX:0,clientY:0,keyCode:NaN,key:null,delta:0},isMobile:false,now:null,getTime:function(){return self.performance&&self.performance.now?self.performance.now.bind(performance):Date.now},testMobile:function(){let t=navigator.userAgent;return !!(t.match(/Android/i)||t.match(/webOS/i)||t.match(/iPhone/i)||t.match(/iPad/i)||t.match(/iPod/i)||t.match(/BlackBerry/i)||t.match(/Windows Phone/i))},add:function(t){s$1.ui.push(t),s$1.getZone(t),s$1.isEventsInit||s$1.initEvents();},remove:function(t){let i=s$1.ui.indexOf(t);-1!==i&&(s$1.removeListen(t),s$1.ui.splice(i,1)),0===s$1.ui.length&&s$1.removeEvents();},initEvents:function(){if(s$1.isEventsInit)return;let t=document.body;s$1.isMobile=s$1.testMobile(),s$1.now=s$1.getTime(),s$1.isMobile?t.style.touchAction="none":t.addEventListener("wheel",s$1,{passive:false}),t.addEventListener("pointercancel",s$1),t.addEventListener("pointerleave",s$1),t.addEventListener("pointermove",s$1),t.addEventListener("pointerdown",s$1),t.addEventListener("pointerup",s$1),t.addEventListener("keydown",s$1,false),t.addEventListener("keyup",s$1,false),window.addEventListener("resize",s$1.resize,false),s$1.isEventsInit=true,s$1.dom=t;},removeEvents:function(){if(!s$1.isEventsInit)return;let t=document.body;s$1.isMobile||t.removeEventListener("wheel",s$1),t.removeEventListener("pointercancel",s$1),t.removeEventListener("pointerleave",s$1),t.removeEventListener("pointermove",s$1),t.removeEventListener("pointerdown",s$1),t.removeEventListener("pointerup",s$1),t.removeEventListener("keydown",s$1),t.removeEventListener("keyup",s$1),window.removeEventListener("resize",s$1.resize),s$1.isEventsInit=false;},resize:function(){let t,i=s$1.ui.length;for(;i--;)t=s$1.ui[i],t.isGui&&!t.isCanvasOnly&&t.autoResize&&t.calc();s$1.needReZone=true,s$1.needResize=false;},out:function(){console.log("im am out"),s$1.clearOldID();},in:function(){console.log("im am in");},fakeUp:function(){this.handleEvent({type:"pointerup"});},handleEvent:function(t){s$1.needResize&&s$1.resize(),s$1.findZone(s$1.forceZone);let i=s$1.e,e=false;"keydown"===t.type&&s$1.keydown(t),"keyup"===t.type&&s$1.keyup(t),"wheel"===t.type?i.delta=t.deltaY>0?1:-1:i.delta=0;let h=t.pointerType;if(i.clientX=("touch"===h?t.pageX:t.clientX)||0,i.clientY=("touch"===h?t.pageY:t.clientY)||0,i.type=t.type,-1!==s$1.eventOut.indexOf(t.type)&&(e=true,i.type="mouseup"),"pointerleave"===t.type&&(s$1.isLeave=true),"pointerdown"===t.type&&(i.type="mousedown"),"pointerup"===t.type&&(i.type="mouseup"),"pointermove"===t.type&&(s$1.isLeave&&(s$1.isLeave=false,s$1.resize()),i.type="mousemove"),"mousedown"===i.type){if(s$1.downTime=s$1.now(),s$1.downTime-s$1.prevTime<200)return s$1.selectAll(),false;s$1.prevTime=s$1.downTime,s$1.forceZone=false;}"mousedown"===i.type&&s$1.clearInput(),"mousedown"===i.type&&(s$1.lock=true),"mouseup"===i.type&&(s$1.lock=false),s$1.isMobile&&"mousedown"===i.type&&s$1.findID(i),"mousemove"!==i.type||s$1.lock||s$1.findID(i),null!==s$1.ID&&(s$1.ID.isCanvasOnly&&(i.clientX=s$1.ID.mouse.x,i.clientY=s$1.ID.mouse.y),s$1.ID.handleEvent(i)),s$1.isMobile&&"mouseup"===i.type&&s$1.clearOldID(),e&&s$1.clearOldID();},findID:function(t){let i,e,h,o=s$1.ui.length,n=-1;for(;o--;)if(i=s$1.ui[o],i.isCanvasOnly?(e=i.mouse.x,h=i.mouse.y):(e=t.clientX,h=t.clientY),s$1.onZone(i,e,h)){n=o,n!==s$1.current&&(s$1.clearOldID(),s$1.current=n,s$1.ID=i);break} -1===n&&s$1.clearOldID();},clearOldID:function(){s$1.ID&&(s$1.current=-1,s$1.ID.reset(),s$1.ID=null,s$1.cursor());},calcUis:(t,i,e,h=false)=>{s$1.debug&&console.log("calc_uis !!");let o,n,r=t.length,l=0,a=0,c=0;for(;r--;){o=t[a],a++,!h&&o.isGroup&&o.calcUis();let r=o.margin||0;o.zone.w=o.w,o.zone.h=o.h+r,o.autoWidth?(l=0,o.zone.x=i.x+o.dx,o.zone.y=e,e+=o.h+r,c+=o.h+r):(0===l&&(c+=o.h+r),o.zone.x=i.x+l,o.zone.y=e,n=s$1.getWidth(o),n?o.zone.w=o.w=n:o.fw&&(o.zone.w=o.w=o.fw),l+=o.zone.w,l>=i.w&&(e+=o.h+r,l=0));}return c},findTarget:function(t,i){let e=t.length;for(;e--;)if(s$1.onZone(t[e],i.clientX,i.clientY))return e;return  -1},findZone:function(t=false){if(t&&(s$1.needReZone=t),!s$1.needReZone)return;let i,e=s$1.ui.length;for(;e--;)i=s$1.ui[e],s$1.getZone(i);s$1.needReZone=false;},onZone:function(t,s,i){if(void 0===s||void 0===i)return  false;let e=t.zone,h=s-e.x,o=i-e.y,n=h>=0&&o>=0&&h<=e.w&&o<=e.h;return n?t.local.set(h,o):t.local.neg(),n},getWidth:function(t){return t.getDom().clientWidth},getZone:function(t){if(t.isCanvasOnly)return;if(t.isEmpty)return;const s=t.getDom().getBoundingClientRect();t.zone={x:s.left,y:s.top,w:s.width,h:s.height},t.isBottom&&(t.zone.y=t.realTop);},cursor:function(t){(t=t||"auto")!==s$1.oldCursor&&(document.body.style.cursor=t,s$1.oldCursor=t);},toCanvas:function(t,i,e,h){if(s$1.xmlserializer||(s$1.xmlserializer=new XMLSerializer),h&&null!==s$1.tmpTime&&(clearTimeout(s$1.tmpTime),s$1.tmpTime=null),null!==s$1.tmpTime)return;s$1.lock&&(s$1.tmpTime=setTimeout((function(){s$1.tmpTime=null;}),10));let o=false;i===t.canvas.width&&e===t.canvas.height||(o=true),null===s$1.tmpImage&&(s$1.tmpImage=new Image);let n=s$1.tmpImage,r=s$1.xmlserializer.serializeToString(t.content),l='<svg xmlns="http://www.w3.org/2000/svg" width="'+i+'" height="'+e+'"><foreignObject style="pointer-events: none; left:0;" width="100%" height="100%">'+r+"</foreignObject></svg>";n.onload=function(){let s=t.canvas.getContext("2d");o?(t.canvas.width=i,t.canvas.height=e):s.clearRect(0,0,i,e),s.drawImage(this,0,0),t.onDraw();},n.src="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(l),n.crossOrigin="";},setHidden:function(){null===s$1.hiddenImput&&(s$1.hiddenImput=document.createElement("input"),s$1.hiddenImput.type="text",s$1.hiddenSizer=document.createElement("div"),document.body.appendChild(s$1.hiddenImput),document.body.appendChild(s$1.hiddenSizer));let t=s$1.debugInput?"":"opacity:0; zIndex:0;",i=s$1.parent.css.txtselect+"padding:0; width:auto; height:auto; left:10px; top:auto; color:#FFF; background:#000;"+t;s$1.hiddenImput.style.cssText=i+"bottom:10px;"+(s$1.debugInput?"":"transform:scale(0);"),s$1.hiddenSizer.style.cssText=i+"bottom:40px;",s$1.hiddenImput.style.width=s$1.input.clientWidth+"px",s$1.hiddenImput.value=s$1.str,s$1.hiddenSizer.innerHTML=s$1.str,s$1.hasFocus=true;},clearHidden:function(t){null!==s$1.hiddenImput&&(s$1.hasFocus=false);},clickPos:function(t){let i=s$1.str.length,e=0,h=0;for(;i--&&(e+=s$1.textWidth(s$1.str[h]),!(e>=t));)h++;return h},upInput:function(t,i){if(null===s$1.parent)return  false;let e=false;if(i){let i=s$1.clickPos(t);if(s$1.moveX=i,-1===s$1.startX)s$1.startX=i,s$1.cursorId=i,s$1.inputRange=[s$1.startX,s$1.startX];else {s$1.moveX!==s$1.startX&&(s$1.startX>s$1.moveX?s$1.inputRange=[s$1.moveX,s$1.startX]:s$1.inputRange=[s$1.startX,s$1.moveX]);}e=true;}else  -1!==s$1.startX&&(s$1.hasFocus=true,s$1.hiddenImput.focus(),s$1.hiddenImput.selectionStart=s$1.inputRange[0],s$1.hiddenImput.selectionEnd=s$1.inputRange[1],s$1.startX=-1,e=true);return e&&s$1.selectParent(),e},selectAll:function(){s$1.parent&&(s$1.str=s$1.input.textContent,s$1.inputRange=[0,s$1.str.length],s$1.hasFocus=true,s$1.hiddenImput.focus(),s$1.hiddenImput.selectionStart=s$1.inputRange[0],s$1.hiddenImput.selectionEnd=s$1.inputRange[1],s$1.cursorId=s$1.inputRange[1],s$1.selectParent());},selectParent:function(){var t=s$1.textWidth(s$1.str.substring(0,s$1.cursorId)),i=s$1.textWidth(s$1.str.substring(0,s$1.inputRange[0])),e=s$1.textWidth(s$1.str.substring(s$1.inputRange[0],s$1.inputRange[1]));s$1.parent.select(t,i,e,s$1.hiddenSizer.innerHTML);},textWidth:function(t){return null===s$1.hiddenSizer?0:(t=t.replace(/ /g,"&nbsp;"),s$1.hiddenSizer.innerHTML=t,s$1.hiddenSizer.clientWidth)},clearInput:function(){null!==s$1.parent&&(s$1.firstImput||s$1.parent.validate(true),s$1.clearHidden(),s$1.parent.unselect(),s$1.input.style.background=s$1.parent.colors.back,s$1.input.style.borderColor=s$1.parent.colors.border,s$1.parent.isEdit=false,s$1.input=null,s$1.parent=null,s$1.str="",s$1.firstImput=true);},setInput:function(t,i){s$1.clearInput(),s$1.input=t,s$1.parent=i,s$1.input.style.background=s$1.parent.colors.backoff,s$1.input.style.borderColor=s$1.parent.colors.select,s$1.str=s$1.input.textContent,s$1.setHidden();},keydown:function(t){if(null===s$1.parent)return;let i=t.which;t.shiftKey,s$1.firstImput=false,s$1.hasFocus&&(window.focus(),s$1.hiddenImput.focus()),s$1.parent.isEdit=true,13===i?s$1.clearInput():s$1.input.isNum?t.keyCode>47&&t.keyCode<58||t.keyCode>95&&t.keyCode<106||190===t.keyCode||110===t.keyCode||8===t.keyCode||109===t.keyCode?s$1.hiddenImput.readOnly=false:s$1.hiddenImput.readOnly=true:s$1.hiddenImput.readOnly=false;},keyup:function(t){null!==s$1.parent&&(s$1.str=s$1.hiddenImput.value,s$1.parent.allEqual?s$1.parent.sameStr(s$1.str):s$1.input.textContent=s$1.str,s$1.cursorId=s$1.hiddenImput.selectionStart,s$1.inputRange=[s$1.hiddenImput.selectionStart,s$1.hiddenImput.selectionEnd],s$1.selectParent(),s$1.parent.validate());},loop:function(){s$1.isLoop&&requestAnimationFrame(s$1.loop),s$1.update();},update:function(){let t=s$1.listens.length;for(;t--;)s$1.listens[t].listening();},removeListen:function(t){let i=s$1.listens.indexOf(t);-1!==i&&s$1.listens.splice(i,1),0===s$1.listens.length&&(s$1.isLoop=false);},addListen:function(t){return  -1===s$1.listens.indexOf(t)&&(s$1.listens.push(t),s$1.isLoop||(s$1.isLoop=true,s$1.loop()),true)}},i$3=s$1,e$1={size:{w:320,h:24,p:30,s:8},texture:null,transition:.1,frag:document.createDocumentFragment(),colorRing:null,joystick_0:null,joystick_1:null,circular:null,knob:null,pad2d:null,svgns:"http://www.w3.org/2000/svg",links:"http://www.w3.org/1999/xlink",htmls:"http://www.w3.org/1999/xhtml",DOM_SIZE:["height","width","top","left","bottom","right","margin-left","margin-right","margin-top","margin-bottom"],SVG_TYPE_D:["pattern","defs","transform","stop","animate","radialGradient","linearGradient","animateMotion","use","filter","feColorMatrix"],SVG_TYPE_G:["svg","rect","circle","path","polygon","text","g","line","foreignObject"],PI:Math.PI,TwoPI:2*Math.PI,pi90:.5*Math.PI,pi60:Math.PI/3,torad:Math.PI/180,todeg:180/Math.PI,clamp:(t,s,i)=>t=(t=t<s?s:t)>i?i:t,isDivid:t=>.5*t===Math.floor(.5*t),defineColor:(t,s=e$1.colors)=>{let i={...s},h=["fontFamily","fontWeight","fontShadow","fontSize"],o=false;t.font&&(t.fontFamily=t.font),t.shadow&&(t.fontShadow=t.shadow),t.weight&&(t.fontWeight=t.weight),t.fontColor&&(t.text=t.fontColor),t.color&&(t.text=t.color),t.text&&(i.text=t.text,t.fontColor||t.color||(i.title=e$1.ColorLuma(t.text,-0.25),i.titleoff=e$1.ColorLuma(t.text,-0.5)),i.textOver=e$1.ColorLuma(t.text,.25),i.textSelect=e$1.ColorLuma(t.text,.5)),t.button&&(i.button=t.button,i.border=e$1.ColorLuma(t.button,.1),i.overoff=e$1.ColorLuma(t.button,.2)),t.select&&(i.select=t.select,i.over=e$1.ColorLuma(t.select,-0.1)),t.itemBg&&(t.back=t.itemBg),t.back&&(i.back=t.back,i.backoff=e$1.ColorLuma(t.back,-0.1)),t.fontSelect&&(i.textSelect=t.fontSelect),t.groupBorder&&(i.gborder=t.groupBorder),t.bgOver&&(i.backgroundOver=t.bgOver);for(let s in i) void 0!==t[s]&&(i[s]=t[s]);for(let s in t) -1!==h.indexOf(s)&&(o=true);return o&&e$1.defineText(i),i},colors:{sx:4,sy:0,radius:6,showOver:1,content:"#37383d",background:"#28292e",backgroundOver:"rgba(40,40,40,0)",title:"#CCC",titleoff:"#BBB",text:"#DDD",textOver:"#EEE",textSelect:"#FFF",back:"rgba(0,0,0,0.2)",backoff:"rgba(0,0,0,0.3)",border:"#4c4c4c",borderSize:1,gborder:"none",groups:"none",button:"#3c3c3c",overoff:"#5c5c5c",over:"#024699",select:"#308AFF",action:"#FF3300",fontFamily:"'SegoeUI', 'Segoe UI', 'Helvetica Neue', -apple-system, BlinkMacSystemFont, Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif",fontWeight:"normal",fontShadow:"none",fontSize:12,joyOver:"rgba(48,138,255,0.25)",joyOut:"rgba(100,100,100,0.5)",joySelect:"#308AFF",hide:"rgba(0,0,0,0)"},css:{basic:"position:absolute; pointer-events:none; box-sizing:border-box; margin:0; padding:0; overflow:hidden; -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select:none;",button:"display:flex; align-items:center; justify-content:center; text-align:center;",middle:"display:flex; align-items:center; justify-content:left; text-align:left; flex-direction: row-reverse;"},svgs:{g1:"M 6 4 L 0 4 0 6 6 6 6 4 M 6 0 L 0 0 0 2 6 2 6 0 Z",g2:"M 6 0 L 4 0 4 6 6 6 6 0 M 2 0 L 0 0 0 6 2 6 2 0 Z",group:"M 7 7 L 7 8 8 8 8 7 7 7 M 5 7 L 5 8 6 8 6 7 5 7 M 3 7 L 3 8 4 8 4 7 3 7 M 7 5 L 7 6 8 6 8 5 7 5 M 6 6 L 6 5 5 5 5 6 6 6 M 7 3 L 7 4 8 4 8 3 7 3 M 6 4 L 6 3 5 3 5 4 6 4 M 3 5 L 3 6 4 6 4 5 3 5 M 3 3 L 3 4 4 4 4 3 3 3 Z",arrow:"M 3 8 L 8 5 3 2 3 8 Z",arrowDown:"M 5 8 L 8 3 2 3 5 8 Z",arrowUp:"M 5 2 L 2 7 8 7 5 2 Z",solid:"M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 Z",body:"M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 M 5 4 L 4 5 4 10 9 10 10 9 10 4 5 4 Z",vehicle:"M 13 6 L 11 1 3 1 1 6 1 13 3 13 3 11 11 11 11 13 13 13 13 6 M 2.4 6 L 4 2 10 2 11.6 6 2.4 6 M 12 8 L 12 10 10 10 10 8 12 8 M 4 8 L 4 10 2 10 2 8 4 8 Z",articulation:"M 13 9 L 12 9 9 2 9 1 5 1 5 2 2 9 1 9 1 13 5 13 5 9 4 9 6 5 8 5 10 9 9 9 9 13 13 13 13 9 Z",character:"M 13 4 L 12 3 9 4 5 4 2 3 1 4 5 6 5 8 4 13 6 13 7 9 8 13 10 13 9 8 9 6 13 4 M 6 1 L 6 3 8 3 8 1 6 1 Z",terrain:"M 13 8 L 12 7 Q 9.06 -3.67 5.95 4.85 4.04 3.27 2 7 L 1 8 7 13 13 8 M 3 8 Q 3.78 5.420 5.4 6.6 5.20 7.25 5 8 L 7 8 Q 8.39 -0.16 11 8 L 7 11 3 8 Z",joint:"M 7.7 7.7 Q 8 7.45 8 7 8 6.6 7.7 6.3 7.45 6 7 6 6.6 6 6.3 6.3 6 6.6 6 7 6 7.45 6.3 7.7 6.6 8 7 8 7.45 8 7.7 7.7 M 3.35 8.65 L 1 11 3 13 5.35 10.65 Q 6.1 11 7 11 8.28 11 9.25 10.25 L 7.8 8.8 Q 7.45 9 7 9 6.15 9 5.55 8.4 5 7.85 5 7 5 6.54 5.15 6.15 L 3.7 4.7 Q 3 5.712 3 7 3 7.9 3.35 8.65 M 10.25 9.25 Q 11 8.28 11 7 11 6.1 10.65 5.35 L 13 3 11 1 8.65 3.35 Q 7.9 3 7 3 5.7 3 4.7 3.7 L 6.15 5.15 Q 6.54 5 7 5 7.85 5 8.4 5.55 9 6.15 9 7 9 7.45 8.8 7.8 L 10.25 9.25 Z",ray:"M 9 11 L 5 11 5 12 9 12 9 11 M 12 5 L 11 5 11 9 12 9 12 5 M 11.5 10 Q 10.9 10 10.45 10.45 10 10.9 10 11.5 10 12.2 10.45 12.55 10.9 13 11.5 13 12.2 13 12.55 12.55 13 12.2 13 11.5 13 10.9 12.55 10.45 12.2 10 11.5 10 M 9 10 L 10 9 2 1 1 2 9 10 Z",collision:"M 11 12 L 13 10 10 7 13 4 11 2 7.5 5.5 9 7 7.5 8.5 11 12 M 3 2 L 1 4 4 7 1 10 3 12 8 7 3 2 Z",map:"M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z",material:"M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z",texture:"M 13 4 L 13 1 1 1 1 4 5 4 5 13 9 13 9 4 13 4 Z",object:"M 10 1 L 7 4 4 1 1 1 1 13 4 13 4 5 7 8 10 5 10 13 13 13 13 1 10 1 Z",none:"M 9 5 L 5 5 5 9 9 9 9 5 Z",cursor:"M 4 7 L 1 10 1 12 2 13 4 13 7 10 9 14 14 0 0 5 4 7 Z",load:"M 13 8 L 11.5 6.5 9 9 9 3 5 3 5 9 2.5 6.5 1 8 7 14 13 8 M 9 2 L 9 0 5 0 5 2 9 2 Z",save:"M 9 12 L 5 12 5 14 9 14 9 12 M 11.5 7.5 L 13 6 7 0 1 6 2.5 7.5 5 5 5 11 9 11 9 5 11.5 7.5 Z",extern:"M 14 14 L 14 0 0 0 0 14 14 14 M 12 6 L 12 12 2 12 2 6 12 6 M 12 2 L 12 4 2 4 2 2 12 2 Z"},setDebug(t){i$3.debug=t;},rezone(){i$3.needReZone=true;},getImput:function(){return !!i$3.input},setStyle:function(t){for(var s in t)e$1.colors[s]&&(e$1.colors[s]=t[s]);e$1.setText();},defineText:function(t){e$1.setText(t.fontSize,t.text,t.fontFamily,t.fontShadow,t.fontWeight);},setText:function(t,s,i,h,o){let n=e$1.colors;void 0===i&&(i=n.fontFamily),void 0===t&&(t=n.fontSize),void 0===h&&(h=n.fontShadow),void 0===o&&(o=n.fontWeight),void 0===s&&(s=n.text),isNaN(t)?-1===t.search("em")&&(t+="px"):t+="px",e$1.css.txt=e$1.css.basic+e$1.css.middle+" font-family:"+i+"; font-weight:"+o+"; font-size:"+t+"; color:"+n.text+"; padding:0px 8px; left:0; top:2px; height:16px; width:100px; overflow:hidden; white-space: nowrap; letter-spacing: normal;","none"!==h&&(e$1.css.txt+=" text-shadow: 1px 1px 1px "+h+";"),e$1.css.txtselect=e$1.css.txt+"padding:0px 4px; border:1px dashed "+n.border+";",e$1.css.item=e$1.css.txt+"padding:0px 4px; position:relative; margin-bottom:1px; ";},cloneCss:function(){return {...e$1.css}},clone:function(t){return t.cloneNode(true)},setSvg:function(t,s,i,e,h){ -1===e?t.setAttributeNS(null,s,i):void 0!==h?t.childNodes[e||0].childNodes[h||0].setAttributeNS(null,s,i):t.childNodes[e||0].setAttributeNS(null,s,i);},setCss:function(t,s){for(let i in s) -1!==e$1.DOM_SIZE.indexOf(i)?t.style[i]=s[i]+"px":t.style[i]=s[i];},set:function(t,s){for(let i in s)"txt"===i&&(t.textContent=s[i]),"link"===i?t.setAttributeNS(e$1.links,"xlink:href",s[i]):t.setAttributeNS(null,i,s[i]);},get:function(t,s){if(void 0===s)return t;if(!isNaN(s))return t.childNodes[s];if(s instanceof Array){if(2===s.length)return t.childNodes[s[0]].childNodes[s[1]];if(3===s.length)return t.childNodes[s[0]].childNodes[s[1]].childNodes[s[2]]}},dom:function(t,s,i,h,o){return t=t||"div",-1!==e$1.SVG_TYPE_D.indexOf(t)||-1!==e$1.SVG_TYPE_G.indexOf(t)?"svg"===t?(h=document.createElementNS(e$1.svgns,"svg"),e$1.set(h,i)):(void 0===h&&(h=document.createElementNS(e$1.svgns,"svg")),e$1.addAttributes(h,t,i,o)):h=void 0===h?document.createElementNS(e$1.htmls,t):h.appendChild(document.createElementNS(e$1.htmls,t)),s&&(h.style.cssText=s),void 0===o?h:h.childNodes[o||0]},addAttributes:function(t,s,i,h){let o=document.createElementNS(e$1.svgns,s);return e$1.set(o,i),e$1.get(t,h).appendChild(o),-1!==e$1.SVG_TYPE_G.indexOf(s)&&(o.style.pointerEvents="none"),o},clear:function(t){for(e$1.purge(t);t.firstChild;)t.firstChild.firstChild&&e$1.clear(t.firstChild),t.removeChild(t.firstChild);},purge:function(t){let s,i,h=t.attributes;if(h)for(s=h.length;s--;)i=h[s].name,"function"==typeof t[i]&&(t[i]=null);if(h=t.childNodes,h)for(s=h.length;s--;)e$1.purge(t.childNodes[s]);},addSVGGlowEffect:function(){if(null!==document.getElementById("UILGlow"))return;let t=e$1.initUILEffects(),s=e$1.addAttributes(t,"filter",{id:"UILGlow",x:"-20%",y:"-20%",width:"140%",height:"140%"});e$1.addAttributes(s,"feGaussianBlur",{in:"SourceGraphic",stdDeviation:"3",result:"uilBlur"});let i=e$1.addAttributes(s,"feMerge",{});for(let t=0;t<=3;t++)e$1.addAttributes(i,"feMergeNode",{in:"uilBlur"});e$1.addAttributes(i,"feMergeNode",{in:"SourceGraphic"});},initUILEffects:function(){let t=document.getElementById("UILSVGEffects");return null===t&&(t=e$1.dom("svg",void 0,{id:"UILSVGEffects",width:"0",height:"0"}),document.body.appendChild(t)),t},ColorLuma:function(t,s){"n"===t&&(t="#000"),(t=String(t).replace(/[^0-9a-f]/gi,"")).length<6&&(t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]),s=s||0;let i,e,h="#";for(e=0;e<3;e++)i=parseInt(t.substr(2*e,2),16),i=Math.round(Math.min(Math.max(0,i+i*s),255)).toString(16),h+=("00"+i).substr(i.length);return h},findDeepInver:function(t){return .3*t[0]+.59*t[1]+.11*t[2]<=.6},lerpColor:function(t,s,i){let e={};for(let h=0;h<3;h++)e[h]=t[h]+(s[h]-t[h])*i;return e},hexToHtml:function(t){return "#"+("000000"+(t=void 0===t?0:t).toString(16)).substr(-6)},htmlToHex:function(t){return t.toUpperCase().replace("#","0x")},u255:function(t,s){return parseInt(t.substring(s,s+2),16)/255},u16:function(t,s){return parseInt(t.substring(s,s+1),16)/15},unpack:function(t){return 7==t.length?[e$1.u255(t,1),e$1.u255(t,3),e$1.u255(t,5)]:4==t.length?[e$1.u16(t,1),e$1.u16(t,2),e$1.u16(t,3)]:void 0},p255:function(t){let s=Math.round(255*t).toString(16);return s.length<2&&(s="0"+s),s},pack:function(t){return "#"+e$1.p255(t[0])+e$1.p255(t[1])+e$1.p255(t[2])},htmlRgba:function(t,s){return t=e$1.unpack(t),"rgba("+Math.round(255*t[0])+","+Math.round(255*t[1])+","+Math.round(255*t[2])+","+s+")"},htmlRgb:function(t,s){return "rgb("+Math.round(255*t[0])+","+Math.round(255*t[1])+","+Math.round(255*t[2])+")"},pad:function(t){return 1==t.length&&(t="0"+t),t},rgbToHex:function(t){let s=Math.round(255*t[0]).toString(16),i=Math.round(255*t[1]).toString(16),h=Math.round(255*t[2]).toString(16);return "#"+e$1.pad(s)+e$1.pad(i)+e$1.pad(h)},hueToRgb:function(t,s,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(s-t)*i:i<.5?s:i<2/3?t+6*(s-t)*(2/3-i):t},rgbToHsl:function(t){let s=t[0],i=t[1],e=t[2],h=Math.min(s,i,e),o=Math.max(s,i,e),n=o-h,r=0,l=0,a=(h+o)/2;return a>0&&a<1&&(l=n/(a<.5?2*a:2-2*a)),n>0&&(o==s&&o!=i&&(r+=(i-e)/n),o==i&&o!=e&&(r+=2+(e-s)/n),o==e&&o!=s&&(r+=4+(s-i)/n),r/=6),[r,l,a]},hslToRgb:function(t){let s,i,h=t[0],o=t[1],n=t[2];return 0===o?[n,n,n]:(i=n<=.5?n*(o+1):n+o-n*o,s=2*n-i,[e$1.hueToRgb(s,i,h+.33333),e$1.hueToRgb(s,i,h),e$1.hueToRgb(s,i,h-.33333)])},makeGradiant:function(t,s,i,h){e$1.dom(t,null,s,i,0);let o,n=i.childNodes[0].childNodes.length-1;for(let t=0;t<h.length;t++)o=h[t],e$1.dom("stop",null,{offset:o[0]+"%","stop-color":o[1],"stop-opacity":o[2]},i,[0,n]);},makePad:function(t){let s=256,i=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 256 "+s,width:s,height:s,preserveAspectRatio:"none"}),o=200,n=28;h$2.dom("rect","",{x:n,y:n,width:o,height:o,fill:e$1.colors.back},i),h$2.dom("rect","",{x:38,y:38,width:180,height:180,fill:e$1.colors.button},i),h$2.dom("line","",{x1:38,y1:128,x2:218,y2:128,stroke:e$1.colors.back,"stroke-width":2},i),h$2.dom("line","",{x1:128,x2:128,y1:38,y2:218,stroke:e$1.colors.back,"stroke-width":2},i),h$2.dom("circle","",{cx:128,cy:128,r:5,stroke:e$1.colors.text,"stroke-width":5,fill:"none"},i),e$1.pad2d=i;},makeKnob:function(t){let s=128,i=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 128 "+s,width:s,height:s,preserveAspectRatio:"none"});e$1.dom("circle","",{cx:64,cy:64,r:34,fill:e$1.colors.button,stroke:"rgba(0,0,0,0.3)","stroke-width":8},i),e$1.dom("path","",{d:"",stroke:e$1.colors.text,"stroke-width":4,fill:"none","stroke-linecap":"round"},i),e$1.dom("circle","",{cx:64,cy:64,r:41,stroke:"rgba(0,0,0,0.1)","stroke-width":7,fill:"none"},i),e$1.dom("path","",{d:"",stroke:"rgba(255,255,255,0.3)","stroke-width":2,fill:"none","stroke-linecap":"round","stroke-opacity":.5},i),e$1.knob=i;},makeCircular:function(t){let s=128,i=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 128 "+s,width:s,height:s,preserveAspectRatio:"none"});e$1.dom("circle","",{cx:64,cy:64,r:40,stroke:"rgba(0,0,0,0.1)","stroke-width":10,fill:"none"},i),e$1.dom("path","",{d:"",stroke:e$1.colors.text,"stroke-width":7,fill:"none","stroke-linecap":"butt"},i),e$1.circular=i;},makeJoystick:function(t){let s,i=128,h=Math.floor(49),o=Math.floor(.6*h),n=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 128 "+i,width:i,height:i,preserveAspectRatio:"none"});if(e$1.dom("defs",null,{},n),e$1.dom("g",null,{},n),0===t){s=[[40,"rgb(0,0,0)",.3],[80,"rgb(0,0,0)",0],[90,"rgb(50,50,50)",.4],[100,"rgb(50,50,50)",0]],e$1.makeGradiant("radialGradient",{id:"grad",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s),s=[[60,"rgb(0,0,0)",.5],[100,"rgb(0,0,0)",0]],e$1.makeGradiant("radialGradient",{id:"gradS",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s);let t=["rgb(40,40,40)","rgb(48,48,48)","rgb(30,30,30)"],i=["rgb(1,90,197)","rgb(3,95,207)","rgb(0,65,167)"];s=[[30,t[0],1],[60,t[1],1],[80,t[1],1],[100,t[2],1]],e$1.makeGradiant("radialGradient",{id:"gradIn",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s),s=[[30,i[0],1],[60,i[1],1],[80,i[1],1],[100,i[2],1]],e$1.makeGradiant("radialGradient",{id:"gradIn2",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s),e$1.dom("circle","",{cx:64,cy:64,r:h,fill:"url(#grad)"},n),e$1.dom("circle","",{cx:69,cy:74,r:o+10,fill:"url(#gradS)"},n),e$1.dom("circle","",{cx:64,cy:64,r:o,fill:"url(#gradIn)"},n),e$1.joystick_0=n;}else s=[[69,"rgb(0,0,0)",0],[70,"rgb(0,0,0)",.3],[100,"rgb(0,0,0)",0]],e$1.makeGradiant("radialGradient",{id:"gradX",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s),e$1.dom("circle","",{cx:64,cy:64,r:h,fill:"none",stroke:"rgba(100,100,100,0.25)","stroke-width":"4"},n),e$1.dom("circle","",{cx:64,cy:64,r:o+14,fill:"url(#gradX)"},n),e$1.dom("circle","",{cx:64,cy:64,r:o,fill:"none",stroke:"rgb(100,100,100)","stroke-width":"4"},n),e$1.joystick_1=n;},makeColorRing:function(){let t=256,s=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 256 "+t,width:t,height:t,preserveAspectRatio:"none"});e$1.dom("defs",null,{},s),e$1.dom("g",null,{},s);let i,h,o,n,r,l,a,c,d,u=128,p=8/113/24*Math.PI,m=0,g=[];for(l=0;l<=24;++l){if(o=l/24,n=o*e$1.TwoPI,i=.5*(m+n),h=1/Math.cos(.5*(n-m)),r=[Math.sin(m),-Math.cos(m),Math.sin(i)*h,-Math.cos(i)*h,Math.sin(n),-Math.cos(n)],g[1]=e$1.rgbToHex(e$1.hslToRgb([o,1,.5])),l>0){for(a=6;a--;)r[a]=(113*r[a]+u).toFixed(2);c=" M"+r[0]+" "+r[1]+" Q"+r[2]+" "+r[3]+" "+r[4]+" "+r[5],d=[[0,g[0],1],[100,g[1],1]],e$1.makeGradiant("linearGradient",{id:"G"+l,x1:r[0],y1:r[1],x2:r[4],y2:r[5],gradientUnits:"userSpaceOnUse"},s,d),e$1.dom("path","",{d:c,"stroke-width":30,stroke:"url(#G"+l+")","stroke-linecap":"butt"},s,1);}m=n-p,g[0]=g[1];}d=[[0,"#FFFFFF",1],[50,"#FFFFFF",0],[50,"#000000",0],[100,"#000000",1]],e$1.makeGradiant("linearGradient",{id:"GL0",x1:0,y1:u-84.9,x2:0,y2:212.9,gradientUnits:"userSpaceOnUse"},s,d),d=[[0,"#7f7f7f",1],[50,"#7f7f7f",.5],[100,"#7f7f7f",0]],e$1.makeGradiant("linearGradient",{id:"GL1",x1:78.95,y1:0,x2:226,y2:0,gradientUnits:"userSpaceOnUse"},s,d),e$1.dom("g",null,{"transform-origin":"128px 128px",transform:"rotate(0)"},s),e$1.dom("polygon","",{points:"78.95 43.1 78.95 212.85 226 128",fill:"red"},s,2),e$1.dom("polygon","",{points:"78.95 43.1 78.95 212.85 226 128",fill:"url(#GL1)","stroke-width":1,stroke:"url(#GL1)"},s,2),e$1.dom("polygon","",{points:"78.95 43.1 78.95 212.85 226 128",fill:"url(#GL0)","stroke-width":1,stroke:"url(#GL0)"},s,2),e$1.dom("path","",{d:"M 255.75 136.5 Q 256 132.3 256 128 256 123.7 255.75 119.5 L 241 128 255.75 136.5 Z",fill:"none","stroke-width":2,stroke:"#000"},s,2),e$1.dom("circle","",{cx:128,cy:128,r:6,"stroke-width":2,stroke:"#000",fill:"none"},s),e$1.colorRing=s;},icon:function(t,s,i){i=i||40;let h=["<svg xmlns='"+e$1.svgns+"' version='1.1' xmlns:xlink='"+e$1.htmls+"' style='pointer-events:none;' preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='"+i+"px' height='"+i+"px' viewBox='0 0 256 256'><g>"];switch(t){case "logo":h[1]="<path id='logoin' fill='"+s+"' stroke='none' d='"+e$1.logoFill_d+"'/>";break;case "donate":h[1]="<path id='logoin' fill='"+s+"' stroke='none' d='"+e$1.logo_donate+"'/>";break;case "neo":h[1]="<path id='logoin' fill='"+s+"' stroke='none' d='"+e$1.logo_neo+"'/>";break;case "phy":h[1]="<path id='logoin' stroke='"+s+"' stroke-width='49' stroke-linejoin='round' stroke-linecap='butt' fill='none' d='"+e$1.logo_phy+"'/>";break;case "config":h[1]="<path id='logoin' stroke='"+s+"' stroke-width='49' stroke-linejoin='round' stroke-linecap='butt' fill='none' d='"+e$1.logo_config+"'/>";break;case "github":h[1]="<path id='logoin' fill='"+s+"' stroke='none' d='"+e$1.logo_github+"'/>";break;case "save":h[1]="<path stroke='"+s+"' stroke-width='4' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 26.125 17 L 20 22.95 14.05 17 M 20 9.95 L 20 22.95'/><path stroke='"+s,h[1]+="' stroke-width='2.5' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 32.6 23 L 32.6 25.5 Q 32.6 28.5 29.6 28.5 L 10.6 28.5 Q 7.6 28.5 7.6 25.5 L 7.6 23'/>";}return h[2]="</g></svg>",h.join("\n")},logoFill_d:"\n    M 171 150.75 L 171 33.25 155.5 33.25 155.5 150.75 Q 155.5 162.2 147.45 170.2 139.45 178.25 128 178.25 116.6 178.25 108.55 170.2 100.5 162.2 100.5 150.75 \n    L 100.5 33.25 85 33.25 85 150.75 Q 85 168.65 97.55 181.15 110.15 193.75 128 193.75 145.9 193.75 158.4 181.15 171 168.65 171 150.75 \n    M 200 33.25 L 184 33.25 184 150.8 Q 184 174.1 167.6 190.4 151.3 206.8 128 206.8 104.75 206.8 88.3 190.4 72 174.1 72 150.8 L 72 33.25 56 33.25 56 150.75 \n    Q 56 180.55 77.05 201.6 98.2 222.75 128 222.75 157.8 222.75 178.9 201.6 200 180.55 200 150.75 L 200 33.25 Z\n    ",logo_github:"\n    M 180.5 70 Q 186.3 82.4 181.55 96.55 196.5 111.5 189.7 140.65 183.65 168.35 146 172.7 152.5 178.7 152.55 185.9 L 152.55 218.15 Q 152.84 224.56 159.15 223.3 \n    159.21 223.3 159.25 223.3 181.14 216.25 198.7 198.7 228 169.4 228 128 228 86.6 198.7 57.3 169.4 28 128 28 86.6 28 57.3 57.3 28 86.6 28 128 28 169.4 57.3 198.7 74.85 \n    216.25 96.75 223.3 96.78 223.3 96.8 223.3 103.16 224.54 103.45 218.15 L 103.45 200 Q 82.97 203.1 75.1 196.35 69.85 191.65 68.4 185.45 64.27 177.055 59.4 174.15 49.20 \n    166.87 60.8 167.8 69.85 169.61 75.7 180 81.13 188.09 90 188.55 98.18 188.86 103.45 185.9 103.49 178.67 110 172.7 72.33 168.33 66.3 140.65 59.48 111.49 74.45 96.55 69.7 \n    82.41 75.5 70 84.87 68.74 103.15 80 115.125 76.635 128 76.85 140.85 76.65 152.85 80 171.1 68.75 180.5 70 Z\n    ",logo_neo:"\n    M 219 52 L 206 52 206 166 Q 206 183.4 193.75 195.65 181.4 208 164 208 146.6 208 134.35 195.65 122 183.4 122 166 L 122 90 Q 122 77.6 113.15 68.85 104.4 60 92 60 79.55 \n    60 70.75 68.85 62 77.6 62 90 L 62 204 75 204 75 90 Q 75 83 79.95 78 84.95 73 92 73 99 73 104 78 109 83 109 90 L 109 166 Q 109 188.8 125.15 204.85 141.2 221 164 221 \n    186.75 221 202.95 204.85 219 188.8 219 166 L 219 52 M 194 52 L 181 52 181 166 Q 181 173 176.05 178 171.05 183 164 183 157 183 152 178 147 173 147 166 L 147 90 Q 147 \n    67.2 130.85 51.15 114.8 35 92 35 69.25 35 53.05 51.15 37 67.2 37 90 L 37 204 50 204 50 90 Q 50 72.6 62.25 60.35 74.6 48 92 48 109.4 48 121.65 60.35 134 72.6 134 90 L \n    134 166 Q 134 178.4 142.85 187.15 151.6 196 164 196 176.45 196 185.25 187.15 194 178.4 194 166 L 194 52 Z\n    ",logo_phy:"\n    M 103.55 37.95 L 127.95 37.95 Q 162.35 37.95 186.5 55 210.9 72.35 210.9 96.5 210.9 120.65 186.5 137.7 162.35 155 127.95 155 L 127.95 237.95 M 127.95 155 \n    Q 93.55 155 69.15 137.7 45 120.65 45 96.5 45 72.35 69.15 55 70.9 53.8 72.85 52.85 M 127.95 155 L 127.95 37.95\n    ",logo_config:"\n    M 204.35 51.65 L 173.25 82.75 Q 192 101.5 192 128 L 236 128 M 192 128 Q 192 154.55 173.25 173.25 L 204.4 204.4 M 51.65 51.65 L 82.75 82.75 Q 101.5 64 128 64 \n    L 128 20 M 51.6 204.4 L 82.75 173.25 Q 64 154.55 64 128 L 20 128 M 128 236 L 128 192 Q 101.5 192 82.75 173.25 M 64 128 Q 64 101.5 82.75 82.75 M 173.25 173.25 \n    Q 154.55 192 128 192 M 128 64 Q 154.55 64 173.25 82.75\n    ",logo_donate:"\n    M 171.3 80.3 Q 179.5 62.15 171.3 45.8 164.1 32.5 141.35 30.1 L 94.35 30.1 Q 89.35 30.4 88.3 35.15 L 70.5 148.05 Q 70.2 152.5 73.7 152.6 L 100.95 152.6 107 111.6 Q 108.75 \n    106.55 112.6 106.45 130.45 108.05 145.3 103.9 163.35 98.75 171.3 80.3 M 179.8 71.5 Q 178.6 79.75 174.9 87.85 168.45 102.9 151.9 109.15 140.65 113.95 117.55 113 113.15 \n    112.75 111 117.45 L 102.7 169.95 Q 102.45 173.8 105.5 173.85 L 128.95 173.85 Q 132.2 174.2 133.35 169.65 L 138.3 139.95 Q 139.75 135.6 143.1 135.5 146.6 135.75 150.6 135.65 \n    154.55 135.5 157.35 135.1 160.15 134.7 166.75 132.35 181.35 127.4 187.9 111.2 194.25 95.75 189.5 81.95 186.75 74.85 179.8 71.5 M 103.5 209.9 Q 103.5 202.85 99.7 198.85 95.95 \n    194.75 89.4 194.75 82.8 194.75 79.05 198.85 75.3 202.9 75.3 209.9 75.3 216.85 79.05 220.95 82.8 225.05 89.4 225.05 95.95 225.05 99.7 221 103.5 216.95 103.5 209.9 M 95.45 205.5 \n    Q 95.95 207.3 95.95 209.9 95.95 212.65 95.45 214.35 94.95 216 94 217.3 93.1 218.45 91.9 219 90.7 219.55 89.4 219.55 88.15 219.55 86.95 219.05 85.75 218.55 84.8 217.3 83.9 216.15 \n    83.4 214.35 82.85 212.6 82.85 209.9 82.85 207.3 83.4 205.45 83.95 203.55 84.85 202.45 85.9 201.2 86.95 200.75 88.05 200.25 89.4 200.25 90.7 200.25 91.85 200.8 93.05 201.3 94 202.5 \n    94.9 203.65 95.45 205.5 M 153.3 195.35 L 145.3 195.35 135.5 224.45 142.8 224.45 144.6 218.5 153.75 218.5 155.6 224.45 163.1 224.45 153.3 195.35 M 152.15 213.25 L 146.25 213.25 \n    149.2 203.65 152.15 213.25 M 116.75 195.35 L 107.8 195.35 107.8 224.45 114.5 224.45 114.5 204.2 125.7 224.45 132.75 224.45 132.75 195.35 126.05 195.35 126.05 212.05 116.75 195.35 M \n    66.5 197.65 Q 64.15 196.15 61.45 195.75 58.8 195.35 55.75 195.35 L 46.7 195.35 46.7 224.45 55.8 224.45 Q 58.8 224.45 61.5 224.05 64.15 223.6 66.4 222.15 69.15 220.45 70.9 217.2 \n    72.7 214 72.7 209.95 72.7 205.7 71 202.6 69.35 199.5 66.5 197.65 M 64.2 205 Q 65.2 207 65.2 209.9 65.2 212.75 64.25 214.75 63.3 216.75 61.5 217.85 60 218.85 58.3 218.9 56.6 219 \n    54.15 219 L 54 219 54 200.8 54.15 200.8 Q 56.4 200.8 58.05 200.9 59.7 200.95 61.15 201.75 63.2 202.95 64.2 205 M 210.2 195.35 L 190.5 195.35 190.5 224.45 210.2 224.45 210.2 218.9 \n    197.75 218.9 197.75 211.55 209.2 211.55 209.2 206 197.75 206 197.75 200.9 210.2 200.9 210.2 195.35 M 187.5 195.35 L 163 195.35 163 200.9 171.6 200.9 171.6 224.45 178.9 224.45 178.9 \n    200.9 187.5 200.9 187.5 195.35 Z\n    "};e$1.setText();const h$2=e$1;let o$1 = class o{static autoTypes(t){let s=[];switch(t){case "svg":s=[{accept:{"image/svg+xml":".svg"}}];break;case "wav":s=[{accept:{"audio/wav":".wav"}}];break;case "mp3":s=[{accept:{"audio/mpeg":".mp3"}}];break;case "mp4":s=[{accept:{"video/mp4":".mp4"}}];break;case "bin":case "hex":s=[{description:"Binary Files",accept:{"application/octet-stream":[".bin",".hex"]}}];break;case "text":s=[{description:"Text Files",accept:{"text/plain":[".txt",".text"],"text/html":[".html",".htm"]}}];break;case "json":s=[{description:"JSON Files",accept:{"application/json":[".json"]}}];break;case "js":s=[{description:"JavaScript Files",accept:{"text/javascript":[".js"]}}];break;case "ktx2":s=[{description:"ktx2",accept:{"image/ktx2":[".ktx2"]}}];break;case "image":s=[{description:"Images",accept:{"image/*":[".png",".gif",".jpeg",".jpg",".hdr",".exr"]}}];break;case "gif":s=[{description:"Images",accept:{"image/*":[".gif"]}}];break;case "png":s=[{description:"Images",accept:{"image/*":[".png"]}}];break;case "exr":s=[{description:"Images",accept:{"image/exr":[".exr"]}}];break;case "hdr":s=[{description:"Images",accept:{"image/hdr":[".hdr"]}}];break;case "jpg":s=[{description:"Images",accept:{"image/*":[".jpg",".jpeg"]}}];break;case "icon":s=[{description:"Icons",accept:{"image/x-ico":[".ico"]}}];break;case "lut":s=[{description:"Lut",accept:{"text/plain":[".cube",".3dl"]}}];}return s}static async load(t={}){"function"!=typeof window.showOpenFilePicker&&(window.showOpenFilePicker=o.showOpenFilePickerPolyfill);try{let s=t.type||"";const i={excludeAcceptAllOption:!!s,multiple:!1};i.types=o.autoTypes(s);const e=await window.showOpenFilePicker(i),h=await e[0].getFile();if(!h)return null;let n=h.name,r=n.substring(n.lastIndexOf(".")+1,n.length);const l=["png","jpg","jpeg","mp4","webm","ogg","mp3"],a=["sea","z","hex","bvh","BVH","glb","gltf","exr","ktx2","hdr"],c=new FileReader;"ArrayBuffer"===t.forceType?(c.readAsArrayBuffer(h),s=""):-1!==l.indexOf(r)?c.readAsDataURL(h):-1!==a.indexOf(r)?c.readAsArrayBuffer(h):c.readAsText(h),c.onload=function(i){let e=i.target.result;switch(s){case "image":let s=new Image;s.onload=function(){s.width=s.width,s.height=s.height,t.callback&&t.callback(s,n,r,[s.width,s.height]);},s.src=e;break;case "json":t.callback&&t.callback(JSON.parse(e),n,r);break;default:t.callback&&t.callback(e,n,r);}};}catch(s){console.log(s),t.always&&t.callback&&t.callback(null);}}static showOpenFilePickerPolyfill(t){return new Promise((s=>{const i=document.createElement("input");i.type="file",i.multiple=t.multiple,i.accept=t.types.map((t=>t.accept)).flatMap((t=>Object.keys(t).flatMap((s=>t[s])))).join(","),i.addEventListener("change",(()=>{s([...i.files].map((t=>({getFile:async()=>new Promise((s=>{s(t);}))}))));})),i.click();}))}static async save(t={}){let s=false;"function"!=typeof window.showSaveFilePicker&&(window.showSaveFilePicker=o.showSaveFilePickerPolyfill,s=true);try{let i=t.type||"";const e={suggestedName:t.name||"hello",data:t.data||""};e.types=o.autoTypes(i),e.finalType=Object.keys(e.types[0].accept)[0],e.suggestedName+=e.types[0].accept[e.finalType][0];const h=await window.showSaveFilePicker(e);if(s)return;const n=await h.createWritable();let r=new Blob([e.data],{type:e.finalType});await n.write(r),await n.close();}catch(t){console.log(t);}}static showSaveFilePickerPolyfill(t){return new Promise((s=>{const i=document.createElement("a");i.download=t.suggestedName||"my-file.txt";let e=new Blob([t.data],{type:t.finalType});i.href=URL.createObjectURL(e),i.addEventListener("click",(()=>{s(setTimeout((()=>URL.revokeObjectURL(i.href)),1e3));})),i.click();}))}static async getFolder(){try{const t=await window.showDirectoryPicker(),s=[];for await(const i of t.values()){const t=await i.getFile();s.push(t);}return console.log(s),s}catch(t){console.log(t);}}};let n$2 = class n{constructor(t=0,s=0){this.x=t,this.y=s;}set(t,s){return this.x=t,this.y=s,this}divide(t){return this.x/=t.x,this.y/=t.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divideScalar(t){return this.multiplyScalar(1/t)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}angle(){var t=Math.atan2(this.y,this.x);return t<0&&(t+=2*Math.PI),t}addScalar(t){return this.x+=t,this.y+=t,this}negate(){return this.x*=-1,this.y*=-1,this}neg(){return this.x=-1,this.y=-1,this}isZero(){return 0===this.x&&0===this.y}copy(t){return this.x=t.x,this.y=t.y,this}equals(t){return t.x===this.x&&t.y===this.y}nearEquals(t,s){return t.x.toFixed(s)===this.x.toFixed(s)&&t.y.toFixed(s)===this.y.toFixed(s)}lerp(t,s){return null===t?(this.x-=this.x*s,this.y-=this.y*s):(this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s),this}};let r$1 = class r{constructor(t={}){this.lock=t.lock||false,this.neverlock=false,this.isSpace=t.isSpace||false,this.main=t.main||null,this.isUI=t.isUI||false,this.group=t.group||null,this.isListen=false,this.top=0,this.ytop=0,this.dx=t.dx||0,this.isSelectable=void 0!==t.selectable&&t.selectable,this.unselectable=void 0!==t.unselect?t.unselect:this.isSelectable,this.ontop=!!t.ontop&&t.ontop,this.css=this.main?this.main.css:h$2.css,this.colors=h$2.defineColor(t,this.main?this.group?this.group.colors:this.main.colors:h$2.colors),this.overEffect=this.colors.showOver,this.svgs=h$2.svgs,this.zone={x:0,y:0,w:0,h:0,d:0},this.local=(new n$2).neg(),this.isCanvasOnly=false,this.isSelect=false,this.p=void 0!==t.p?t.p:h$2.size.p,this.w=this.isUI?this.main.size.w:h$2.size.w,void 0!==t.w&&(this.w=t.w),this.h=this.isUI?this.main.size.h:h$2.size.h,void 0!==t.h&&(this.h=t.h),this.isSpace?this.lock=true:this.h=this.h<11?11:this.h,this.fw=t.fw||0,this.autoWidth=t.auto||true,this.isOpen=false,this.radius=t.radius||this.colors.radius,this.transition=t.transition||h$2.transition,this.isNumber=false,this.noNeg=t.noNeg||false,this.allEqual=t.allEqual||false,this.mono=false,this.isEdit=false,this.simple=t.simple||false,this.simple&&(this.sa=0),this.setSize(this.w),void 0!==t.sa&&(this.sa=t.sa),void 0!==t.sb&&(this.sb=t.sb),this.simple&&(this.sb=this.w-this.sa),this.sc=void 0===t.sc?47:t.sc,this.objectLink=null,this.isSend=false,this.objectKey=null,this.txt=t.name||"",this.name=t.rename||this.txt,this.target=t.target||null,this.callback=void 0===t.callback?null:t.callback,this.endCallback=null,this.openCallback=void 0===t.openCallback?null:t.openCallback,this.closeCallback=void 0===t.closeCallback?null:t.closeCallback,null===this.callback&&this.isUI&&null!==this.main.callback&&(this.callback=this.group?this.group.callback:this.main.callback),this.c=[],this.s=[],this.useFlex=!!this.isUI&&this.main.useFlex;let s=this.useFlex?"display:flex; justify-content:center; align-items:center; text-align:center; flex: 1 100%;":"float:left;";this.c[0]=h$2.dom("div",this.css.basic+s+"position:relative; height:20px;"),this.s[0]=this.c[0].style,this.margin=this.colors.sy,this.mtop=0;let i=h$2.isDivid(this.margin);if(this.isUI&&this.margin&&(this.s[0].boxSizing="content-box",i?(this.mtop=.5*this.margin,this.s[0].borderTop=this.mtop+"px solid transparent",this.s[0].borderBottom=this.mtop+"px solid transparent"):this.s[0].borderBottom=NaN),this.simple||(this.c[1]=h$2.dom("div",this.css.txt+this.css.middle),this.s[1]=this.c[1].style,this.c[1].textContent=this.name,this.s[1].color=this.lock?this.colors.titleoff:this.colors.title),t.pos){this.s[0].position="absolute";for(let s in t.pos)this.s[0][s]=t.pos[s];this.mono=true;}t.css&&(this.s[0].cssText=t.css);}init(){this.ytop=this.top+this.mtop,this.zone.h=this.h+this.margin,this.zone.w=this.w;let t=this.s,s=this.c;t[0].height=this.h+"px",this.isUI&&(t[0].background=this.colors.background),!this.autoWidth&&this.useFlex?(t[0].flex="1 0 auto",t[0].minWidth=this.minw+"px",t[0].textAlign="center"):this.isUI&&(t[0].width="100%"),void 0!==s[1]&&this.autoWidth&&(t[1]=s[1].style,t[1].top="1px",t[1].height=this.h-2+"px");let e=h$2.frag;for(let i=1,h=s.length;i!==h;i++) void 0!==s[i]&&(e.appendChild(s[i]),t[i]=s[i].style);let o=null!==this.target?this.target:this.isUI?this.main.inner:document.body;this.ontop?o.insertAdjacentElement("afterbegin",s[0]):o.appendChild(s[0]),s[0].appendChild(e),this.rSize(),this.isUI||(this.c[0].style.pointerEvents="auto",i$3.add(this));}addTransition(){this.baseH&&this.transition&&this.isUI&&(this.c[0].style.transition="height "+this.transition+"s ease-out");}dom(t,s,i,e,o){return h$2.dom(t,s,i,e,o)}setSvg(t,s,i,e,o){h$2.setSvg(t,s,i,e,o);}setCss(t,s){h$2.setCss(t,s);}clamp(t,s,i){return h$2.clamp(t,s,i)}getColorRing(){return h$2.colorRing||h$2.makeColorRing(),h$2.clone(h$2.colorRing)}getJoystick(t){return h$2["joystick_"+t]||h$2.makeJoystick(t),h$2.clone(h$2["joystick_"+t])}getCircular(t){return h$2.circular||h$2.makeCircular(t),h$2.clone(h$2.circular)}getKnob(t){return h$2.knob||h$2.makeKnob(t),h$2.clone(h$2.knob)}getPad2d(t){return h$2.pad2d||h$2.makePad(t),h$2.clone(h$2.pad2d)}cursor(t){i$3.cursor(t);}update(){}reset(){}appendChild(t){this.c[0].appendChild(t);}content(){return this.c[0]}getDom(){return this.c[0]}uiout(){this.lock||this.overEffect&&(this.isGroup||this.isTitle||this.s&&(this.s[0].background=this.colors.background));}uiover(){this.lock||this.overEffect&&(this.isGroup||this.isTitle||this.s&&(this.s[0].background=this.colors.backgroundOver));}rename(t){ void 0!==this.c[1]&&(this.c[1].textContent=t);}listen(){return this.isListen=i$3.addListen(this),this}listening(){null!==this.objectLink&&(this.isSend||this.isEdit||this.setValue(this.objectLink[this.objectKey]));}setValue(t){this.isNumber?this.value=this.numValue(t):this.value=t,this.update();}onChange(t){if(!this.isSpace)return this.callback=t||null,this}onFinishChange(t){if(!this.isSpace)return this.callback=null,this.endCallback=t,this}onOpen(t){return this.openCallback=t,this}onClose(t){return this.closeCallback=t,this}send(t){(t=t||this.value)instanceof Array&&1===t.length&&(t=t[0]),this.isSend=true,null!==this.objectLink&&(this.objectLink[this.objectKey]&&this.objectLink[this.objectKey].isColor?this.objectLink[this.objectKey].setHex(t):this.objectLink[this.objectKey]=t),this.callback&&this.callback(t,this.objectKey),this.isSend=false;}sendEnd(t){(t=t||this.value)instanceof Array&&1===t.length&&(t=t[0]),this.endCallback&&this.endCallback(t),null!==this.objectLink&&(this.objectLink[this.objectKey]=t);}dispose(){this.isListen&&i$3.removeListen(this),h$2.clear(this.c[0]),null!==this.target?null!==this.group?this.group.clearOne(this):this.target.removeChild(this.c[0]):this.isUI?this.main.clearOne(this):document.body.removeChild(this.c[0]),this.isUI||i$3.remove(this),this.c=null,this.s=null,this.callback=null,this.target=null,this.isListen=false;}clear(){}getWidth(){let t=i$3.getWidth(this);t&&(this.w=t);}setSize(t){if(this.autoWidth)if(this.w=t,this.simple)this.sb=this.w-this.sa;else {let t=this.w*(this.p/100);this.sa=Math.floor(t+8),this.sb=Math.floor(this.w-t-16);}}rSize(){this.autoWidth&&(this.isUI||(this.s[0].width=this.w+"px"),this.simple||(this.s[1].width=this.sa+"px"));}setTypeNumber(t){let s;switch(this.isNumber=true,this.value=0,void 0!==t.value&&("string"==typeof t.value?this.value=1*t.value:this.value=t.value),this.min=void 0===t.min?-1/0:t.min,this.max=void 0===t.max?1/0:t.max,this.precision=void 0===t.precision?2:t.precision,this.precision){case 0:s=1;break;case 1:s=.1;break;case 2:s=.01;break;case 3:s=.001;break;case 4:s=1e-4;break;case 5:s=1e-5;break;case 6:s=1e-6;}this.step=void 0===t.step?s:t.step,this.range=this.max-this.min,this.value=this.numValue(this.value);}numValue(t){return this.noNeg&&(t=Math.abs(t)),1*Math.min(this.max,Math.max(this.min,t)).toFixed(this.precision)}handleEvent(t){if(!this.lock)return this.neverlock&&(i$3.lock=false),this[t.type]?this[t.type](t):console.error(t.type,"this type of event no existe !")}wheel(t){return  false}mousedown(t){return  false}mousemove(t){return  false}mouseup(t){return  false}keydown(t){return  false}keyup(t){return  false}setReferency(t,s){this.objectLink=t,this.objectKey=s;}display(t=false){this.s[0].visibility=t?"visible":"hidden";}open(){this.isOpen||(this.isOpen=true,i$3.needResize=true,this.openCallback&&this.openCallback());}close(){this.isOpen&&(this.isOpen=false,i$3.needResize=true,this.closeCallback&&this.closeCallback());}needZone(){i$3.needReZone=true;}rezone(){i$3.needReZone=true;}select(){}unselect(){}setInput(t){i$3.setInput(t,this);}upInput(t,s){return i$3.upInput(t,s)}selected(t){this.isSelect=t||false;}};let l$1 = class l extends r$1{constructor(t={}){super(t),this.value=t.value||false,this.model=void 0!==t.mode?t.mode:0,this.onName=t.rename||this.txt,t.onName&&(t.onname=t.onName),t.onname&&(this.onName=t.onname),this.inh=t.inh||Math.floor(.8*this.h),this.inw=t.inw||36;let s=this.colors;if(0===this.model){let t=Math.floor(.5*this.h)-.5*(this.inh-2);this.c[2]=this.dom("div",this.css.basic+"background:"+s.inputBg+"; height:"+(this.inh-2)+"px; width:"+this.inw+"px; top:"+t+"px; border-radius:10px; border:2px solid "+s.back),this.c[3]=this.dom("div",this.css.basic+"height:"+(this.inh-6)+"px; width:16px; top:"+(t+2)+"px; border-radius:10px; background:"+s.button+";");}else this.p=0,void 0!==this.c[1]&&(this.c[1].textContent=""),this.c[2]=this.dom("div",this.css.txt+this.css.button+"top:1px; background:"+s.button+"; height:"+(this.h-2)+"px; border:"+s.borderSize+"px solid "+s.border+"; border-radius:"+this.radius+"px;");this.stat=-1,this.init(),this.update();}mousedown(t){return this.value=!this.value,this.update(true),this.mousemove(t)}mousemove(t){return this.cursor("pointer"),this.mode(true)}reset(){return this.cursor(),this.mode()}mode(t){let s,i=false,e=this.colors,h=this.s,o=this.value;if(s=t?o?4:3:o?2:1,this.stat!==s){if(this.stat=s,0!==this.model){switch(s){case 1:h[2].color=e.text,h[2].background=e.button;break;case 2:h[2].color=e.textSelect,h[2].background=e.select;break;case 3:h[2].color=e.textOver,h[2].background=e.overoff;break;case 4:h[2].color=e.textOver,h[2].background=e.over;}this.c[2].innerHTML=o?this.onName:this.name;}else {switch(s){case 1:h[2].background=h[2].borderColor=e.backoff,h[3].background=e.button;break;case 2:h[2].background=h[2].borderColor=e.back,h[3].background=e.textOver;break;case 3:h[2].background=h[2].borderColor=e.back,h[3].background=e.overoff;break;case 4:h[2].background=h[2].borderColor=e.backoff,h[3].background=e.textSelect;}h[3].marginLeft=o?"17px":"2px",this.c[1].textContent=o?this.onName:this.name;}i=true;}return i}update(t){this.mode(),t&&this.send();}rSize(){super.rSize();let t=this.s,s=this.w-10-this.inw;0===this.model?(t[2].left=s+"px",t[3].left=s+"px"):(t[2].left=this.sa+"px",t[2].width=this.sb+"px");}};let a$1 = class a extends r$1{constructor(t={}){super(t),this.value="",void 0!==t.value&&(this.value=t.value),this.values=t.value||this.txt,t.values&&(this.values=t.values),t.values||t.value||(this.txt=""),this.onName=t.onName||null,this.on=false,this.bw=t.forceWidth||0,t.bw&&(this.bw=t.bw),this.space=t.space||3,"string"==typeof this.values&&(this.values=[this.values]),this.isDown=false,this.neverlock=true,this.res=0,this.lng=this.values.length,this.tmp=[],this.stat=[];let s,i=this.colors;for(let t=0;t<this.lng;t++)s=false,this.values[t]===this.value&&this.isSelectable&&(s=true),this.c[t+2]=this.dom("div",this.css.txt+this.css.button+"top:1px; height:"+(this.h-2)+"px; border:"+i.borderSize+"px solid "+i.border+"; border-radius:"+this.radius+"px;"),this.c[t+2].style.background=s?i.select:i.button,this.c[t+2].style.color=s?i.textSelect:i.text,this.c[t+2].innerHTML=this.values[t],this.stat[t]=s?3:1;""===this.txt&&(this.p=0),(t.value||t.values)&&0!==this.p||void 0!==this.c[1]&&(this.c[1].textContent=""),this.init();}onOff(){this.on=!this.on,this.label(this.on?this.onName:this.value);}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return  -1;let i=this.lng,e=this.tmp;for(;i--;)if(s.x>e[i][0]&&s.x<e[i][2])return i;return  -1}mouseup(t){return !!this.isDown&&(this.isDown=false,-1!==this.res&&(this.value===this.values[this.res]&&this.unselectable?this.value="":this.value=this.values[this.res],null!==this.onName&&this.onOff(),this.send()),this.mousemove(t))}mousedown(t){return !this.isDown&&(this.isDown=true,this.mousemove(t))}mousemove(t){let s=false;return this.res=this.testZone(t),-1!==this.res?(this.cursor("pointer"),s=this.modes(this.isDown?3:2,this.res)):s=this.reset(),s}modes(t=1,s=-1){let i,e,h=this.lng,o=false;for(;h--;)e=t,i=!!this.isSelectable&&this.values[h]===this.value,h===s?i&&2===e&&(e=3):(e=1,i&&(e=4)),o=this.mode(e,h);return o}mode(t,s){let i=false,e=this.colors,h=this.s,o=s+2;if(this.stat[s]!==t){switch(this.stat[s]=t,t){case 1:h[o].color=e.text,h[o].background=e.button;break;case 2:h[o].color=e.textOver,h[o].background=e.overoff;break;case 3:h[o].color=e.textOver,h[o].background=e.over;break;case 4:h[o].color=e.textSelect,h[o].background=e.select;}i=true;}return i}reset(){return this.res=-1,this.cursor(),this.modes()}label(t,s){s=s||2,this.c[s].textContent=t;}switchValues(t,s){this.c[t+2].innerHTML=this.values[t]=s;}icon(t,s=0,i=2){return this.s[i].padding=s+"px 0px",this.c[i].innerHTML=t,this}rSize(){super.rSize();let t=this.s,s=this.sb,i=this.sa,e=this.lng,h=this.colors.sx,o=(s-h*(e-1))/e;for(this.bw&&(o=this.bw<o?this.bw:o,i=.5*(this.w-(o*e+h*(e-1))));e--;)this.tmp[e]=[i+o*e+h*e,o],this.tmp[e][2]=this.tmp[e][0]+this.tmp[e][1],t[e+2].left=this.tmp[e][0]+"px",t[e+2].width=this.tmp[e][1]+"px";}};let c$2 = class c extends r$1{constructor(t={}){super(t),this.isCyclic=t.cyclic||false,this.model=t.stype||0,void 0!==t.mode&&(this.model=t.mode),this.autoWidth=false,this.minw=this.w,this.diam=t.diam||this.w,this.setTypeNumber(t),this.twoPi=h$2.TwoPI,this.pi90=h$2.pi90,this.offset=new n$2,this.h=t.h||this.w+10,this.c[0].style.width=this.w+"px",this.c[0].style.display="block",void 0!==this.c[1]&&(this.c[1].style.width="100%",this.c[1].style.justifyContent="center",this.top=10,this.h+=10),this.percent=0,this.cmode=0;let s=this.colors;this.c[2]=this.dom("div",this.css.txt+"justify-content:center; top:"+(this.h-20)+"px; width:100%; color:"+s.text),this.c[3]=this.getCircular(),this.setSvg(this.c[3],"stroke",s.back,0),this.setSvg(this.c[3],"d",this.makePath(),1),this.setSvg(this.c[3],"stroke",s.text,1),this.setSvg(this.c[3],"viewBox","0 0 "+this.diam+" "+this.diam),this.setCss(this.c[3],{width:this.diam,height:this.diam,left:0,top:this.top}),this.init(),this.update();}mode(t){if(this.cmode===t)return  false;let s,i=this.colors;switch(t){case 0:this.s[2].color=i.text,this.setSvg(this.c[3],"stroke",i.back,0),s=this.model>0?h$2.pack(h$2.lerpColor(h$2.unpack(h$2.ColorLuma(i.text,-0.75)),h$2.unpack(i.text),this.percent)):i.text,this.setSvg(this.c[3],"stroke",s,1);break;case 1:this.s[2].color=i.textOver,this.setSvg(this.c[3],"stroke",i.backoff,0),s=this.model>0?h$2.pack(h$2.lerpColor(h$2.unpack(h$2.ColorLuma(i.text,-0.75)),h$2.unpack(i.text),this.percent)):i.textOver,this.setSvg(this.c[3],"stroke",s,1);}return this.cmode=t,true}reset(){this.isDown=false;}testZone(t){let s=this.local;return  -1===s.x&&-1===s.y?"":s.y<=this.c[1].offsetHeight?"title":s.y>this.h-this.c[2].offsetHeight?"text":"circular"}mouseup(t){return this.isDown=false,this.sendEnd(),this.mode(0)}mousedown(t){return this.isDown=true,this.old=this.value,this.oldr=null,this.mousemove(t),this.mode(1)}mousemove(t){if(!this.isDown)return;let s=this.offset;if(s.x=.5*this.w-(t.clientX-this.zone.x),s.y=.5*this.diam-(t.clientY-this.zone.y-this.ytop),this.r=s.angle()-this.pi90,this.r=(this.r%this.twoPi+this.twoPi)%this.twoPi,null!==this.oldr){let t=this.r-this.oldr;this.r=Math.abs(t)>Math.PI?this.oldr:this.r,t>6&&(this.r=0),t<-6&&(this.r=this.twoPi);}let i=1/this.twoPi,e=this.r*i,h=this.range*e+this.min-this.old;(h>=this.step||h<=this.step)&&(h=~~(h/this.step),this.value=this.numValue(this.old+h*this.step),this.update(true),this.old=this.value,this.oldr=this.r);}wheel(t){if("circular"===this.testZone(t)){let s=this.value-this.step*t.delta;return s>this.max?s=this.isCyclic?this.min:this.max:s<this.min&&(s=this.isCyclic?this.max:this.min),this.setValue(s),this.old=s,this.update(true),true}return  false}makePath(){let t=40,s=this.percent*this.twoPi-.001,i=t+t*Math.sin(s)+24,e=t-t*Math.cos(s)+24;return "M 64,24 A 40,40 0 "+(s>Math.PI?1:0)+" 1 "+i+","+e}update(t){if(this.c[2].textContent=this.value,this.percent=(this.value-this.min)/this.range,this.setSvg(this.c[3],"d",this.makePath(),1),this.model>0){let t=this.colors,s=h$2.pack(h$2.lerpColor(h$2.unpack(h$2.ColorLuma(t.text,-0.75)),h$2.unpack(t.text),this.percent));this.setSvg(this.c[3],"stroke",s,1);}t&&this.send();}};let d$1 = class d extends r$1{constructor(t={}){super(t),this.ctype=t.ctype||"hex",this.wfixe=256,this.cw=this.sb>256?256:this.sb,null!=t.cw&&(this.cw=t.cw),this.side=t.side||"down",this.up="down"===this.side?0:1,this.baseH=this.h,this.offset=new n$2,this.decal=new n$2,this.pp=new n$2;let s=this.colors;this.c[2]=this.dom("div",`${this.css.txt} ${this.css.middle} top:1px; height:${this.h-2}px; border-radius:${this.radius}px; text-shadow:none; border:${s.borderSize}px solid ${s.border};`),this.c[0].style.display="block",this.c[3]=this.getColorRing(),this.c[3].style.visibility="hidden",this.hsl=null,this.value="#ffffff",void 0!==t.value&&(t.value.isColor?this.value="#"+t.value.getHexString():t.value instanceof Array?this.value=h$2.rgbToHex(t.value):isNaN(t.value)?this.value=t.value:this.value=h$2.hexToHtml(t.value)),this.bcolor=null,this.isDown=false,this.fistDown=false,this.notext=t.notext||false,this.tr=98,this.tsl=Math.sqrt(3)*this.tr,this.hue=0,this.d=256,this.init(),this.setColor(this.value),void 0!==t.open&&this.open();}testZone(t,s){let i=this.local;return  -1===i.x&&-1===i.y?"":this.up&&this.isOpen?i.y>this.wfixe?"title":"color":i.y<this.baseH+2?"title":this.isOpen?"color":void 0}mouseup(t){this.isDown=false,this.d=256;}mousedown(t){let s=this.testZone(t.clientX,t.clientY);if("title"===s)return this.isOpen?this.close():this.open(),true;"color"===s&&(this.isDown=true,this.fistDown=true,this.mousemove(t));}mousemove(t){let s,i,e,o,n,r,l,a,c,d=this.testZone(t.clientX,t.clientY),u=h$2;if("title"===d&&this.cursor("pointer"),"color"===d&&(s=this.offset,s.x=t.clientX-(this.zone.x+this.decal.x+this.mid),s.y=t.clientY-(this.zone.y+this.decal.y+this.mid)-this.ytop,i=s.length()*this.ratio,c=s.angle(),c<0&&(c+=2*u.PI),i<128?this.cursor("crosshair"):this.isDown||this.cursor(),this.isDown&&(this.fistDown&&(this.d=i,this.fistDown=false),this.d<128)))if(this.d>this.tr)e=(c+u.pi90)/u.TwoPI,this.hue=(e+1)%1,this.setHSL([(e+1)%1,this.hsl[1],this.hsl[2]]);else {l=s.x*this.ratio,a=s.y*this.ratio;let t=this.hue*u.TwoPI+u.PI;t<0&&(t+=2*u.PI),r=Math.atan2(-a,l),r<0&&(r+=2*u.PI);let i=(r+u.pi90+u.TwoPI+t)%u.TwoPI,e=i%(2/3*u.PI)-u.pi60,h=.5*this.tr,c=Math.tan(e)*h,d=Math.sqrt(l*l+a*a),p=Math.sqrt(h*h+c*c);if(d>p){let s=Math.tan(e)*d,o=Math.atan(s/p);o>u.pi60?o=u.pi60:o<-u.pi60&&(o=-u.pi60),r+=o-e,i=(r+u.pi90+u.TwoPI+t)%u.TwoPI,e=i%(2/3*u.PI)-u.pi60,c=Math.tan(e)*h,d=p=Math.sqrt(h*h+c*c);}n=Math.sin(i)*d/this.tsl+.5;let m=1-2*Math.abs(n-.5);o=(Math.cos(i)*d+this.tr/2)/(1.5*this.tr)/m,o=u.clamp(o,0,1),this.setHSL([this.hsl[0],o,n]);}}setHeight(){this.h=this.isOpen?this.wfixe+this.baseH+5:this.baseH,this.s[0].height=this.h+"px",this.zone.h=this.h;}parentHeight(t){null!==this.group?this.group.calc(t):this.isUI&&this.main.calc(t);}open(){super.open(),this.setHeight(),this.up&&(this.zone.y-=this.wfixe+5);let t=this.h-this.baseH;this.s[3].visibility="visible",this.parentHeight(t);}close(){super.close(),this.up&&(this.zone.y+=this.wfixe+5);let t=this.h-this.baseH;this.setHeight(),this.s[3].visibility="hidden",this.parentHeight(-t);}update(t){let s=h$2.rgbToHex(h$2.hslToRgb([this.hsl[0],1,.5]));this.moveMarkers(),this.value=this.bcolor,this.setSvg(this.c[3],"fill",s,2,0),this.s[2].background=this.bcolor,this.notext||(this.c[2].textContent=h$2.htmlToHex(this.bcolor)),this.invert=h$2.findDeepInver(this.rgb),this.s[2].color=this.invert?"#fff":"#000",t&&("array"===this.ctype&&this.send(this.rgb),"rgb"===this.ctype&&this.send(h$2.htmlRgb(this.rgb)),"hex"===this.ctype&&this.send(h$2.htmlToHex(this.value)),"html"===this.ctype&&this.send());}setValue(t){t instanceof Array?this.value=h$2.rgbToHex(t):isNaN(t)?this.value=t:this.value=h$2.hexToHtml(t),this.setColor(this.value),this.update();}setColor(t){let s=h$2.unpack(t);return this.bcolor!==t&&s&&(this.bcolor=t,this.rgb=s,this.hsl=h$2.rgbToHsl(this.rgb),this.hue=this.hsl[0],this.update()),this}setHSL(t){return this.hsl=t,this.rgb=h$2.hslToRgb(t),this.bcolor=h$2.rgbToHex(this.rgb),this.update(true),this}moveMarkers(){let t=this.pp,s=h$2;this.invert;let i=this.hsl[0]*s.TwoPI,e=2/3*s.PI,o=this.tr,n=this.hsl[0],r=this.hsl[1],l=this.hsl[2],a=(i-s.pi90)*s.todeg;n=-i+s.pi90;let c=Math.cos(n)*o,d=-Math.sin(n)*o,u=Math.cos(n-e)*o,p=-Math.sin(n-e)*o,m=Math.cos(n+e)*o,g=-Math.sin(n+e)*o,x=(u+m)/2,v=(p+g)/2;i=(1-2*Math.abs(l-.5))*r;let b=u+(m-u)*l+(c-x)*i,f=p+(g-p)*l+(d-v)*i;t.set(b,f).addScalar(128),this.setSvg(this.c[3],"transform","rotate("+a+" )",2),this.setSvg(this.c[3],"cx",t.x,3),this.setSvg(this.c[3],"cy",t.y,3),this.setSvg(this.c[3],"stroke",this.invert?"#fff":"#000",2,3),this.setSvg(this.c[3],"stroke",this.invert?"#fff":"#000",3),this.setSvg(this.c[3],"fill",this.bcolor,3);}rSize(){super.rSize();let t=this.s;t[2].width=this.sb+"px",t[2].left=this.sa+"px",this.cw=this.sb>256?256:this.sb,this.rSizeColor(this.cw),this.decal.x=Math.floor(.5*(this.w-this.wfixe));}rSizeColor(t){if(t===this.wfixe)return;this.wfixe=t;let s=this.s;this.decal.y="up"===this.side?2:this.baseH+2,this.mid=Math.floor(.5*this.wfixe),this.setSvg(this.c[3],"viewBox","0 0 "+this.wfixe+" "+this.wfixe),s[3].width=this.wfixe+"px",s[3].height=this.wfixe+"px",s[3].top=this.decal.y+"px",this.ratio=256/this.wfixe,this.square=1/(this.wfixe/256*60),this.setHeight();}};let u$1 = class u extends r$1{constructor(t={}){super(t),this.round=Math.round,this.baseH=this.h,this.hplus=t.hplus||50,this.res=t.res||40,this.l=1,this.precision=t.precision||0,this.custom=t.custom||false,this.names=t.names||["FPS","MS"];let s=t.cc||["220,220,220","255,255,0"];this.adding=t.adding||false,this.range=t.range||[165,100,100],this.alpha=t.alpha||.25,this.values=[],this.points=[],this.textDisplay=[],this.custom||(this.now=i$3.getTime(),this.startTime=0,this.prevTime=0,this.frames=0,this.ms=0,this.fps=0,this.mem=0,this.mm=0,this.isMem=!(!self.performance||!self.performance.memory),this.isMem&&(this.names.push("MEM"),s.push("0,255,255")),this.txt=t.name||"Fps");let e=Math.floor(.5*this.h)-3;const h=this.colors;this.c[1].textContent=this.txt,this.c[0].style.cursor="pointer",this.c[0].style.pointerEvents="auto";let o="display:none; left:10px; top:"+this.h+"px; height:"+(this.hplus-8)+"px; box-sizing:border-box; background: rgba(0, 0, 0, 0.2); border:1px solid "+h.border+";";0!==this.radius&&(o+="border-radius:"+this.radius+"px;"),this.c[2]=this.dom("path",this.css.basic+o,{}),this.c[2].setAttribute("viewBox","0 0 "+this.res+" 50"),this.c[2].setAttribute("height","100%"),this.c[2].setAttribute("width","100%"),this.c[2].setAttribute("preserveAspectRatio","none"),this.c[3]=this.dom("path",this.css.basic+"position:absolute; width:6px; height:6px; left:0; top:"+e+"px;",{d:this.svgs.g1,fill:h.text,stroke:"none"}),this.c[4]=this.dom("div",this.css.txt+"position:absolute; left:10px; top:"+(this.h+2)+"px; display:none; width:100%; text-align:center;"),t.bottomLine&&(this.c[4]=this.dom("div",this.css.basic+"width:100%; bottom:0px; height:1px; background: rgba(255, 255, 255, 0.2);")),this.isShow=false;let n=this.s;n[1].lineHeight=this.h-4,n[1].color=h.text,0!==this.radius&&(n[0].borderRadius=this.radius+"px"),"none"!==this.colors.gborder&&(n[0].border="1px solid "+h.gborder);let r=0;for(r=0;r<this.names.length;r++){let t=[],i=this.res+1;for(;i--;)t.push(50);this.range[r]=1/this.range[r]*49,this.points.push(t),this.values.push(0),this.textDisplay.push("<span style='color:rgb("+s[r]+")'> "+this.names[r]+" ");}for(r=this.names.length;r--;)this.dom("path",null,{fill:"rgba("+s[r]+","+this.alpha+")","stroke-width":1,stroke:"rgba("+s[r]+",1)","vector-effect":"non-scaling-stroke"},this.c[2]);this.init();}mousedown(t){this.isShow?this.close():this.open();}tick(t){this.values=t,this.isShow&&(this.drawGraph(),this.upText());}makePath(t){let s="";s+="M -1 50";for(let i=0;i<this.res+1;i++)s+=" L "+i+" "+t[i];return s+=" L "+(this.res+1)+" 50",s}upText(t){let s=t||this.values,i="";for(let t=0,e=this.names.length;t<e;t++)i+=this.textDisplay[t]+s[t].toFixed(this.precision)+"</span>";this.c[4].innerHTML=i;}drawGraph(){let t,s=this.c[2],i=this.names.length,e=0,h=0;for(;i--;)t=this.adding?(this.values[h]+e)*this.range[h]:this.values[h]*this.range[h],this.points[h].shift(),this.points[h].push(50-t),this.setSvg(s,"d",this.makePath(this.points[h]),i+1),e+=this.values[h],h++;}open(){super.open(),this.h=this.hplus+this.baseH,this.setSvg(this.c[3],"d",this.svgs.g2),null!==this.group?this.group.calc(this.hplus):this.isUI&&this.main.calc(this.hplus),this.s[0].height=this.h+"px",this.s[2].display="block",this.s[4].display="block",this.isShow=true,this.custom||i$3.addListen(this);}close(){super.close(),this.h=this.baseH,this.setSvg(this.c[3],"d",this.svgs.g1),null!==this.group?this.group.calc(-this.hplus):this.isUI&&this.main.calc(-this.hplus),this.s[0].height=this.h+"px",this.s[2].display="none",this.s[4].display="none",this.isShow=false,this.custom||i$3.removeListen(this),this.c[4].innerHTML="";}begin(){this.startTime=this.now();}end(){let t=this.now();if(this.ms=t-this.startTime,this.frames++,t>this.prevTime+1e3&&(this.fps=this.round(1e3*this.frames/(t-this.prevTime)),this.prevTime=t,this.frames=0,this.isMem)){let t=performance.memory.usedJSHeapSize,s=performance.memory.jsHeapSizeLimit;this.mem=this.round(954e-9*t),this.mm=t/s;}return this.values=[this.fps,this.ms,this.mm],this.drawGraph(),this.upText([this.fps,this.ms,this.mem]),t}listening(){this.custom||(this.startTime=this.end());}rSize(){let t=this.s,s=this.w;t[3].left=this.sa+this.sb-6+"px",t[0].width=s+"px",t[1].width=s+"px",t[2].left="10px",t[2].width=s-20+"px",t[4].width=s-20+"px";}};let p$2 = class p extends r$1{constructor(t={}){super(t),this.value=void 0!==t.value?t.value:[0,0,0],this.lng=this.value.length,this.precision=void 0!==t.precision?t.precision:2,this.multiplicator=t.multiplicator||1,this.neg=t.neg||false,this.line=void 0===t.line||t.line,this.autoWidth=void 0===t.autoWidth||t.autoWidth,this.isNumber=false,this.isDown=false,this.h=t.h||138,this.rh=this.h-10,this.top=0,this.c[0].style.width=this.w+"px",void 0!==this.c[1]&&(this.c[1].style.width=this.w+"px",this.autoWidth||(this.c[1].style.width="100%",this.c[1].style.justifyContent="center"),this.top=10,this.h+=10),this.gh=this.rh-28,this.gw=this.w-28,this.c[2]=this.dom("div",this.css.txt+"display:block; text-align:center; padding:0px 0px; top:"+(this.h-20)+"px; left:14px; width:"+this.gw+"px;  color:"+this.colors.text),this.c[2].innerHTML=this.valueToHtml();let s=this.dom("svg",this.css.basic,{viewBox:"0 0 "+this.w+" "+this.rh,width:this.w,height:this.rh,preserveAspectRatio:"none"});this.setCss(s,{width:this.w,height:this.rh,left:0,top:this.top}),this.dom("path","",{d:"",stroke:this.colors.text,"stroke-width":2,fill:"none","stroke-linecap":"butt"},s),this.dom("rect","",{x:10,y:10,width:this.gw+8,height:this.gh+8,stroke:"rgba(0,0,0,0.3)","stroke-width":1,fill:"none"},s),this.iw=(this.gw-4*(this.lng-1))/this.lng;let i=[];this.cMode=[],this.v=[];for(let t=0;t<this.lng;t++)i[t]=[14+t*this.iw+4*t,this.iw],i[t][2]=i[t][0]+i[t][1],this.cMode[t]=0,this.neg?this.v[t]=.5*(1+this.value[t]/this.multiplicator):this.v[t]=this.value[t]/this.multiplicator,this.dom("rect","",{x:i[t][0],y:14,width:i[t][1],height:1,fill:this.colors.text,"fill-opacity":.3},s);this.tmp=i,this.c[3]=s,this.init(),void 0!==this.c[1]&&(this.c[1].style.top="0px",this.c[1].style.height="20px",this.s[1].lineHeight="15px"),this.update(false);}setValue(t){this.value=t,this.lng=this.value.length;for(var s=0;s<this.lng;s++)this.neg?this.v[s]=.5*(1+t[s]/this.multiplicator):this.v[s]=t[s]/this.multiplicator;this.update();}valueToHtml(){let t=this.lng,s=0,i='<table style="width:100%;"><tr>',e="width:"+100/this.lng+"%;";for(;t--;)s===this.lng-1?i+="<td style="+e+">"+this.value[s]+"</td></tr></table>":i+="<td style="+e+">"+this.value[s]+"</td>",s++;return i}updateSVG(){this.line&&this.setSvg(this.c[3],"d",this.makePath(),0);for(let t=0;t<this.lng;t++)this.setSvg(this.c[3],"height",this.v[t]*this.gh,t+2),this.setSvg(this.c[3],"y",this.gh-this.v[t]*this.gh+14,t+2),this.neg?this.value[t]=1*((2*this.v[t]-1)*this.multiplicator).toFixed(this.precision):this.value[t]=1*(this.v[t]*this.multiplicator).toFixed(this.precision);this.c[2].innerHTML=this.valueToHtml();}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";let i=this.lng,e=this.tmp;if(s.y>this.top&&s.y<this.h-20)for(;i--;)if(s.x>e[i][0]&&s.x<e[i][2])return i;return ""}mode(t,s){if(t===this.cMode[s])return  false;let i;switch(t){case 0:i=.3;break;case 1:i=.6;break;case 2:i=1;}return this.reset(),this.setSvg(this.c[3],"fill-opacity",i,s+2),this.cMode[s]=t,true}reset(){let t=false,s=this.lng;for(;s--;)0!==this.cMode[s]&&(this.cMode[s]=0,this.setSvg(this.c[3],"fill-opacity",.3,s+2),t=true);return t}mouseup(t){if(this.isDown=false,-1!==this.current)return this.reset()}mousedown(t){return this.isDown=true,this.mousemove(t)}mousemove(t){let s=false,i=this.testZone(t);return ""===i?s=this.reset():(s=this.mode(this.isDown?2:1,i),this.isDown&&(this.v[i]=this.clamp(1-(t.clientY-this.zone.y-this.ytop-10)/this.gh,0,1),this.update(true))),s}update(t){this.updateSVG(),t&&this.send();}makePath(){let t,s,i,e,h,o,n="";for(let r=0;r<this.lng;r++)t=this.gh-this.v[r]*this.gh+14,s=14+r*this.iw+4*r,e=s+.5*this.iw,i=s+this.iw,n+=0===r?"M "+s+" "+t+" T "+e+" "+t:" C "+h+" "+o+","+s+" "+t+","+e+" "+t,r===this.lng-1&&(n+=" T "+i+" "+t),h=i,o=t;return n}rSize(){super.rSize();let t=this.s;void 0!==this.c[1]&&(t[1].width=this.w+"px"),t[3].width=this.w+"px";let s=this.w-28,i=(s-4*(this.lng-1))/this.lng,e=[];t[2].width=s+"px";for(let t=0;t<this.lng;t++)e[t]=[14+t*i+4*t,i],e[t][2]=e[t][0]+e[t][1];this.tmp=e;}};let m$2 = class m extends r$1{constructor(t={}){t.isSpace=true,t.margin=0,t.h||(t.h=10),super(t),this.init();}};let g$2 = class g extends r$1{constructor(t={}){super(t),this.isGroup=true,this.ADD=t.add,this.autoHeight=true,this.uis=[],this.current=-1,this.proto=null,this.isEmpty=true,this.decal=t.group?8:0,this.baseH=this.h,this.radius=0;let s=Math.floor(.5*this.h)-3;const i=this.colors;this.useFlex=true;let e=this.useFlex?"display:flex; flex-flow: row wrap;":"";this.c[2]=this.dom("div",this.css.basic+e+"width:100%; left:0;  overflow:hidden; top:"+this.h+"px"),this.c[3]=this.dom("path",this.css.basic+"position:absolute; width:6px; height:6px; left:0; top:"+s+"px;",{d:this.svgs.g1,fill:i.text,stroke:"none"}),0===this.mtop?this.margin:this.mtop,this.s,this.c[1].name="group",this.c[1].style.color=i.text,this.init(),this.setBG(t.bg),t.open&&this.open();}setBG(t){const s=this.colors,i=this.s;void 0!==t&&(s.groups=t),"none"===s.groups&&(s.groups=s.background),i[0].background=void 0!==t?"none":s.content,i[1].background=void 0!==t?s.groups:s.content,"none"!==s.gborder&&(i[1].border=s.borderSize+"px solid "+s.gborder),0!==this.radius&&(i[1].borderRadius=this.radius+"px",i[2].borderRadius=this.radius+"px");}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";let i="";return s.y<this.baseH+this.margin?i="title":this.isOpen&&(i="content"),i}clearTarget(){return  -1!==this.current&&(this.proto.s&&(this.proto.uiout(),this.proto.reset()),this.proto=null,this.current=-1,this.cursor(),true)}reset(){this.clearTarget();}handleEvent(t){let s=t.type,e=false,h=false,o=this.testZone(t);if(o){switch(o){case "content":i$3.isMobile&&"mousedown"===s&&this.getNext(t,e),this.proto&&(h=this.proto.handleEvent(t)),i$3.lock||this.getNext(t,e);break;case "title":this.cursor("pointer"),"mousedown"===s&&(this.isOpen?this.close():this.open());}return this.isDown&&(e=true),h&&(e=true),e}}getNext(t,s){let e=i$3.findTarget(this.uis,t);e!==this.current&&(this.clearTarget(),this.current=e),-1!==e&&(this.proto=this.uis[this.current],this.proto.uiover());}add(){let t=arguments;"object"==typeof t[1]?(t[1].isUI=this.isUI,t[1].target=this.c[2],t[1].main=this.main,t[1].group=this):"string"==typeof arguments[1]&&(void 0===t[2]?[].push.call(t,{isUI:true,target:this.c[2],main:this.main}):(t[2].isUI=true,t[2].target=this.c[2],t[2].main=this.main,t[2].group=this));let s=this.ADD.apply(this,t);return s.isGroup&&(s.dx=8),i$3.forceZone=true,this.uis.push(s),this.isEmpty=false,s}remove(t){t.dispose&&t.dispose();}dispose(){this.clear(),this.isUI&&this.main.calc(),super.dispose();}clear(){this.empty();}empty(){this.close();let t,s=this.uis.length;for(;s--;)t=this.uis.pop(),this.c[2].removeChild(t.c[0]),t.clear(true);this.isEmpty=true,this.h=this.baseH;}clearOne(t){let s=this.uis.indexOf(t);-1!==s&&(this.calc(-(this.uis[s].h+this.margin)),this.c[2].removeChild(this.uis[s].c[0]),this.uis.splice(s,1),0===this.uis.length&&(this.isEmpty=true,this.close()));}open(){super.open(),this.setSvg(this.c[3],"d",this.svgs.g2),this.rSizeContent();const t=this.s,s=this.colors;t[2].top=this.h+this.mtop+"px",this.radius&&(t[1].borderRadius="0px",t[2].borderRadius="0px",t[1].borderTopLeftRadius=this.radius+"px",t[1].borderTopRightRadius=this.radius+"px",t[2].borderBottomLeftRadius=this.radius+"px",t[2].borderBottomRightRadius=this.radius+"px"),"none"!==s.gborder&&(t[4].borderLeft=s.borderSize+"px solid "+s.gborder,t[4].borderRight=s.borderSize+"px solid "+s.gborder,t[2].border=s.borderSize+"px solid "+s.gborder,t[2].borderTop="none",t[1].borderBottom=s.borderSize+"px solid rgba(0,0,0,0)"),this.parentHeight();}close(){super.close(),this.setSvg(this.c[3],"d",this.svgs.g1),this.h=this.baseH;const t=this.s,s=this.colors;t[0].height=this.h+"px",t[2].top=this.h+this.mtop+"px","none"!==s.gborder&&(t[4].border="none",t[2].border="none",t[1].border=s.borderSize+"px solid "+s.gborder),this.radius&&(t[1].borderRadius=this.radius+"px"),this.parentHeight();}calcUis(){!this.isOpen||this.isEmpty?this.h=this.baseH:this.h=i$3.calcUis([...this.uis],this.zone,this.zone.y+this.baseH+this.margin,true)+this.baseH,this.s[0].height=this.h+"px",this.s[2].height=this.h-this.baseH+"px";}parentHeight(t){null!==this.group?this.group.calc(t):this.isUI&&this.main.calc(t);}calc(t){this.isOpen&&(this.isUI?this.main.calc():this.calcUis(),this.s[0].height=this.h+"px",this.s[2].height=this.h+"px");}rSizeContent(){let t=this.uis.length;for(;t--;)this.uis[t].setSize(this.w),this.uis[t].rSize();}rSize(){super.rSize();let t=this.s;this.w=this.w-this.decal,t[3].left=this.sa+this.sb-6+"px",t[1].width=this.w+"px",t[2].width=this.w+"px",t[1].left=this.decal+"px",t[2].left=this.decal+"px",this.isOpen&&this.rSizeContent();}};let x$3 = class x extends r$1{constructor(t={}){super(t),this.autoWidth=false,this.value=[0,0],this.minw=this.w,this.diam=t.diam||this.w,this.joyType="analogique",this.model=void 0!==t.mode?t.mode:0,this.precision=t.precision||2,this.multiplicator=t.multiplicator||1,this.pos=new n$2,this.tmp=new n$2,this.interval=null,this.c[0].style.display="block",this.haveText=void 0===t.text||t.text,this.distance=.5*this.diam*.25,this.h=t.h||this.w+(this.haveText?10:0),this.c[0].style.width=this.w+"px",void 0!==this.c[1]&&(this.c[1].style.width="100%",this.c[1].style.justifyContent="center",this.top=10,this.h+=10);let s=this.colors;this.c[2]=this.dom("div",this.css.txt+"justify-content:center; top:"+(this.h-20)+"px; width:100%; color:"+s.text),this.c[2].textContent=this.haveText?this.value:"",this.c[3]=this.getJoystick(this.model),this.setSvg(this.c[3],"viewBox","0 0 "+this.diam+" "+this.diam),this.setCss(this.c[3],{width:this.diam,height:this.diam,left:0,top:this.top}),this.mode(0),this.ratio=128/this.w,this.init(),this.update(false);}mode(t){let s=this.colors;switch(t){case 0:0===this.model?(this.setSvg(this.c[3],"fill","url(#gradIn)",4),this.setSvg(this.c[3],"stroke","#000",4)):(this.setSvg(this.c[3],"stroke",s.joyOut,2),this.setSvg(this.c[3],"stroke",s.joyOut,4),this.setSvg(this.c[3],"fill","none",4));break;case 1:0===this.model?(this.setSvg(this.c[3],"fill","url(#gradIn2)",4),this.setSvg(this.c[3],"stroke","rgba(0,0,0,0)",4)):(this.setSvg(this.c[3],"stroke",s.joyOver,2),this.setSvg(this.c[3],"stroke",s.joySelect,4),this.setSvg(this.c[3],"fill",s.joyOver,4));}}addInterval(){null!==this.interval&&this.stopInterval(),this.pos.isZero()||(this.interval=setInterval(function(){this.update();}.bind(this),10));}stopInterval(){null!==this.interval&&(clearInterval(this.interval),this.interval=null);}reset(){this.addInterval(),this.mode(0);}mouseup(t){this.addInterval(),this.isDown=false;}mousedown(t){this.isDown=true,this.mousemove(t),this.mode(2);}mousemove(t){if(this.mode(1),!this.isDown)return;if(this.tmp.x=.5*this.w-(t.clientX-this.zone.x),this.tmp.y=.5*this.diam-(t.clientY-this.zone.y-this.ytop),this.tmp.length()>this.distance){let t=Math.atan2(this.tmp.x,this.tmp.y);this.tmp.x=Math.sin(t)*this.distance,this.tmp.y=Math.cos(t)*this.distance;}this.pos.copy(this.tmp).divideScalar(this.distance).negate(),this.update();}setValue(t){ void 0===t&&(t=[0,0]),this.pos.set(t[0]||0,t[1]||0),this.updateSVG();}update(t){ void 0===t&&(t=true),null!==this.interval&&(this.isDown||(this.pos.lerp(null,.3),this.pos.x=Math.abs(this.pos.x)<.01?0:this.pos.x,this.pos.y=Math.abs(this.pos.y)<.01?0:this.pos.y,this.isUI&&this.main.isCanvas&&this.main.draw())),this.updateSVG(),t&&this.send(),this.pos.isZero()&&this.stopInterval();}updateSVG(){let t=.5*this.diam- -this.pos.x*this.distance,s=.5*this.diam- -this.pos.y*this.distance;if(0===this.model){let i=t+5*this.pos.x+5,e=s+5*this.pos.y+10;this.setSvg(this.c[3],"cx",i*this.ratio,3),this.setSvg(this.c[3],"cy",e*this.ratio,3);}else this.setSvg(this.c[3],"cx",t*this.ratio,3),this.setSvg(this.c[3],"cy",s*this.ratio,3);this.setSvg(this.c[3],"cx",t*this.ratio,4),this.setSvg(this.c[3],"cy",s*this.ratio,4),this.value[0]=1*(this.pos.x*this.multiplicator).toFixed(this.precision),this.value[1]=1*(this.pos.y*this.multiplicator).toFixed(this.precision),this.haveText&&(this.c[2].textContent=this.value);}clear(){this.stopInterval(),super.clear();}};let v$1 = class v extends r$1{constructor(t={}){super(t),this.isCyclic=t.cyclic||false,this.model=t.stype||0,void 0!==t.mode&&(this.model=t.mode),this.autoWidth=false,this.setTypeNumber(t),this.minw=this.w,this.diam=t.diam||this.w,this.mPI=.8*Math.PI,this.toDeg=180/Math.PI,this.cirRange=2*this.mPI,this.offset=new n$2,this.h=t.h||this.w+10,this.c[0].style.width=this.w+"px",this.c[0].style.display="block",void 0!==this.c[1]&&(this.c[1].style.width="100%",this.c[1].style.justifyContent="center",this.top=10,this.h+=10),this.percent=0,this.cmode=0;let s=this.colors;this.c[2]=this.dom("div",this.css.txt+"justify-content:center; top:"+(this.h-20)+"px; width:100%; color:"+s.text),this.c[3]=this.getKnob(),this.setSvg(this.c[3],"fill",s.button,0),this.setSvg(this.c[3],"stroke",s.text,1),this.setSvg(this.c[3],"stroke",s.text,3),this.setSvg(this.c[3],"d",this.makeGrad(),3),this.setSvg(this.c[3],"viewBox","0 0 "+this.diam+" "+this.diam),this.setCss(this.c[3],{width:this.diam,height:this.diam,left:0,top:this.top}),this.model>0&&(h$2.dom("path","",{d:"",stroke:s.text,"stroke-width":2,fill:"none","stroke-linecap":"round"},this.c[3]),2==this.model&&(h$2.addSVGGlowEffect(),this.setSvg(this.c[3],"style",'filter: url("#UILGlow");',4))),this.r=0,this.init(),this.update();}mode(t){let s=this.colors;if(this.cmode===t)return  false;switch(t){case 0:this.s[2].color=s.text,this.setSvg(this.c[3],"fill",s.button,0),this.setSvg(this.c[3],"stroke",s.text,1);break;case 1:this.s[2].color=s.textOver,this.setSvg(this.c[3],"fill",s.select,0),this.setSvg(this.c[3],"stroke",s.textOver,1);}return this.cmode=t,true}testZone(t){let s=this.local;return  -1===s.x&&-1===s.y?"":s.y<=this.c[1].offsetHeight?"title":s.y>this.h-this.c[2].offsetHeight?"text":"knob"}mouseup(t){return this.isDown=false,this.sendEnd(),this.mode(0)}mousedown(t){return this.isDown=true,this.old=this.value,this.oldr=null,this.mousemove(t),this.mode(1)}mousemove(t){if(!this.isDown)return;let s=this.offset;s.x=.5*this.w-(t.clientX-this.zone.x),s.y=.5*this.diam-(t.clientY-this.zone.y-this.ytop),this.r=-Math.atan2(s.x,s.y),null!==this.oldr&&(this.r=Math.abs(this.r-this.oldr)>Math.PI?this.oldr:this.r),this.r=this.r>this.mPI?this.mPI:this.r,this.r=this.r<-this.mPI?-this.mPI:this.r;let i=1/this.cirRange,e=(this.r+this.mPI)*i,h=this.range*e+this.min-this.old;(h>=this.step||h<=this.step)&&(h=Math.floor(h/this.step),this.value=this.numValue(this.old+h*this.step),this.update(true),this.old=this.value,this.oldr=this.r);}wheel(t){if("knob"===this.testZone(t)){let s=this.value-this.step*t.delta;return s>this.max?s=this.isCyclic?this.min:this.max:s<this.min&&(s=this.isCyclic?this.max:this.min),this.setValue(s),this.old=s,this.update(true),true}return  false}makeGrad(){let t,s,i,e,h,o,n,r="",l=64,a=Math.PI+this.mPI,c=Math.PI-this.mPI;this.step>5?(s=this.range/this.step,t=(a-c)/s):(t=(a-c)/l*2,s=32);for(let c=0;c<=s;++c)i=a-t*c,e=l+44*Math.sin(i),h=l+44*Math.cos(i),o=l+40*Math.sin(i),n=l+40*Math.cos(i),r+="M"+e+" "+h+" L"+o+" "+n+" ";return r}update(t){this.c[2].textContent=this.value,this.percent=(this.value-this.min)/this.range;let s=Math.PI+this.mPI,i=this.percent*this.cirRange-this.mPI,e=Math.sin(i),o=Math.cos(i),n=25*e+64,r=-25*o+64,l=20*e+64,a=-20*o+64;if(this.setSvg(this.c[3],"d","M "+n+" "+r+" L "+l+" "+a,1),this.model>0){let t=36*Math.sin(s)+64,n=36*Math.cos(s)+64,r=36*e+64,l=-36*o+64,a=i<=Math.PI-this.mPI?0:1;this.setSvg(this.c[3],"d","M "+t+","+n+" A 36,36 1 "+a+" 1 "+r+","+l,4);let c=h$2.pack(h$2.lerpColor(h$2.unpack(h$2.ColorLuma(this.colors.text,-0.75)),h$2.unpack(this.colors.text),this.percent));this.setSvg(this.c[3],"stroke",c,4);}t&&this.send();}};class b extends r$1{constructor(t={}){super(t),this.hideCurrent=false,this.path=t.path||"",this.format=t.format||"",this.isWithImage=""!==this.path,this.preLoadComplete=false,this.tmpImage={},this.tmpUrl=[],this.m=void 0!==t.m?t.m:5;let s=t.align||"left",i=t.scrollSize||10;this.ss=i+1,this.sMode=0,this.tMode=0,this.listOnly=t.listOnly||false,this.staticTop=t.staticTop||false,this.isSelectable=this.listOnly,void 0!==t.select&&(t.selectable=t.select),void 0!==t.selectable&&(this.isSelectable=t.selectable),""===this.txt&&(this.p=0);let e=Math.floor(.5*this.h)-3,h=this.colors;if(this.c[2]=this.dom("div",this.css.basic+"top:0; display:none; border-radius:"+this.radius+"px;"),this.c[3]=this.dom("div",this.css.item+"padding:0px "+this.m+"px; margin-bottom:0px; position:absolute; justify-content:"+s+"; text-align:"+s+"; line-height:"+(this.h-4)+"px; top:1px; background:"+h.button+"; height:"+(this.h-2)+"px; border:1px solid "+h.border+"; border-radius:"+this.radius+"px;"),this.c[4]=this.dom("path",this.css.basic+"position:absolute; width:6px; height:6px; top:"+e+"px;",{d:this.svgs.g1,fill:h.text,stroke:"none"}),this.scrollerBack=this.dom("div",this.css.basic+"right:0px; width:"+i+"px; background:"+h.back+"; display:none;"),this.scroller=this.dom("div",this.css.basic+"right:"+.5*(i-.25*i)+"px; width:"+.25*i+"px; background:"+h.text+"; display:none; "),this.c[3].style.color=h.text,this.list=[],this.refObject=null,t.list)if(t.list instanceof Array)this.list=t.list;else if(t.list instanceof Object){this.refObject=t.list;for(let t in this.refObject)this.list.push(t);}this.items=[],this.prevName="",this.tmpId=0,this.baseH=this.h,this.itemHeight=t.itemHeight||this.h,this.full=t.full||false,this.py=0,this.ww=this.sb,this.scroll=false,this.isDown=false,this.current=null,this.side=t.side||"down",this.up="down"===this.side?0:1,this.up?(this.c[2].style.top="auto",this.c[3].style.top="auto",this.c[4].style.top="auto",this.c[2].style.bottom=this.h-2+"px",this.c[3].style.bottom="1px",this.c[4].style.bottom=e+"px"):this.c[2].style.top=this.baseH+"px",this.listIn=this.dom("div",this.css.basic+"left:0; top:0; width:100%; background:none;"),this.listIn.name="list",this.topList=0,this.c[2].appendChild(this.listIn),this.c[2].appendChild(this.scrollerBack),this.c[2].appendChild(this.scroller),void 0!==t.value?isNaN(t.value)?this.value=t.value:this.value=this.list[t.value]:this.value=this.list[0],this.isOpenOnStart=t.open||false,this.listOnly&&(this.baseH=5,this.c[3].style.display="none",this.c[4].style.display="none",this.c[2].style.top=this.baseH+"px",this.isOpenOnStart=true),this.miniCanvas=t.miniCanvas||false,this.canvasBg=t.canvasBg||"rgba(0,0,0,0)",this.imageSize=t.imageSize||[20,20],this.drag=t.drag||false,this.dragout=t.dragout||false,this.dragstart=t.dragstart||null,this.dragend=t.dragend||null,this.setList(this.list),this.init(),this.isWithImage&&this.preloadImage(),this.isOpenOnStart&&this.open(true),this.baseH+=this.mtop;}preloadImage(){this.preLoadComplete=false,this.tmpImage={};for(let t=0;t<this.list.length;t++)this.tmpUrl.push(this.list[t]);this.loadOne();}nextImg(){null!==this.c&&(this.tmpUrl.shift(),0===this.tmpUrl.length?(this.preLoadComplete=true,this.addImages()):this.loadOne());}loadOne(){let t=this,s=this.tmpUrl[0],i=document.createElement("img");i.style.cssText="position:absolute; width:"+t.imageSize[0]+"px; height:"+t.imageSize[1]+"px",i.setAttribute("src",this.path+s+this.format),i.addEventListener("load",(function(){t.imageSize[2]=i.width,t.imageSize[3]=i.height,t.tmpImage[s]=i,t.nextImg();}));}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";if(this.up&&this.isOpen){if(s.y>this.h-this.baseH)return "title";if(this.scroll&&s.x>this.sa+this.sb-this.ss)return "scroll";if(s.x>this.sa)return this.testItems(s.y-this.baseH)}else {if(s.y<this.baseH+2)return "title";if(this.isOpen){if(this.scroll&&s.x>this.sa+this.sb-this.ss)return "scroll";if(s.x>this.sa)return this.testItems(s.y-this.baseH)}}return ""}testItems(t){let s,i,e,h="",o=this.items,n=o.length;for(;n--;)if(s=o[n],i=s.posy+this.topList,e=s.posy+this.itemHeight+1+this.topList,t>=i&&t<=e)return h="item"+n,this.modeItem(0),this.current=s,this.modeItem(1),h;return h}modeItem(t){if(!this.current)return;this.current.select&&0===t&&(t=2);let s=this.colors;switch(t){case 0:this.current.style.background=s.back,this.current.style.color=s.text;break;case 1:this.current.style.background=s.over,this.current.style.color=s.textOver;break;case 2:this.current.style.background=s.select,this.current.style.color=s.textSelect;}}unSelected(){this.current&&(this.modeItem(0),this.current=null);}selected(){this.current&&(this.resetItems(),this.modeItem(2),this.current.select=true);}resetItems(){let t=this.items.length;for(;t--;)this.items[t].select=false,this.items[t].style.background=this.colors.back,this.items[t].style.color=this.colors.text;}hideActive(){this.hideCurrent&&(this.current&&(this.tmpId=this.current.id),this.resetHide());}resetHide(){console.log(this.tmpId);let t=this.items.length;for(;t--;)t===this.tmpId?(this.items[t].style.height="0px",this.items[t].posy=-1):(this.items[t].style.height=this.itemHeight+"px",this.items[t].posy=(this.itemHeight+1)*(t-1));}mouseup(t){this.isDown=false;}mousedown(t){let s=this.testZone(t);return !!s&&("scroll"===s?(this.isDown=true,this.mousemove(t)):"title"===s?(this.modeTitle(2),this.listOnly||(this.hideActive(),this.isOpen?this.close():this.open())):this.current&&(this.value=this.list[this.current.id],this.isSelectable&&this.selected(),this.send(this.value),this.listOnly||(this.close(),this.setTopItem())),true)}mousemove(t){let s=false,i=this.testZone(t);if(!i)return s;if("title"===i)this.unSelected(),this.modeTitle(1),this.cursor("pointer");else if("scroll"===i){if(this.cursor("s-resize"),this.modeScroll(1),this.isDown){this.modeScroll(2);let s=this.zone.y+this.baseH-2;this.update(t.clientY-s-.5*this.sh);}}else this.modeTitle(0),this.modeScroll(0),this.cursor("pointer");return i!==this.prevName&&(s=true),this.prevName=i,s}wheel(t){return "title"!==this.testZone(t)&&(this.py+=10*t.delta,this.update(this.py),true)}reset(){this.prevName="",this.unSelected(),this.modeTitle(0),this.modeScroll(0);}modeScroll(t){if(t===this.sMode)return;let s=this.scroller.style,i=this.colors;switch(t){case 0:s.background=i.text;break;case 1:case 2:s.background=i.select;}this.sMode=t;}modeTitle(t){if(t===this.tMode)return;let s=this.s,i=this.colors;switch(t){case 0:s[3].color=i.text,s[3].background=i.button;break;case 1:s[3].color=i.textOver,s[3].background=i.overoff;break;case 2:s[3].color=i.textSelect,s[3].background=i.overoff;}this.tMode=t;}clearList(){for(;this.listIn.children.length;)this.listIn.removeChild(this.listIn.lastChild);this.items=[];}setList(t){this.clearList(),this.list=t,this.length=this.list.length;let s,e,h=this.hideCurrent?this.length-1:this.length;this.maxItem=this.full?h:5,this.maxItem=h<this.maxItem?h:this.maxItem,this.maxHeight=this.maxItem*(this.itemHeight+1)+2,this.max=h*(this.itemHeight+1)+2,this.ratio=this.maxHeight/this.max,this.sh=this.maxHeight*this.ratio,this.range=this.maxHeight-this.sh,this.c[2].style.height=this.maxHeight+"px",this.scrollerBack.style.height=this.maxHeight+"px",this.scroller.style.height=this.sh+"px",this.max>this.maxHeight&&(this.ww=this.sb-this.ss,this.scroll=true),this.miniCanvas&&(this.tmpCanvas=document.createElement("canvas"),this.tmpCanvas.width=this.imageSize[0],this.tmpCanvas.height=this.imageSize[1],this.tmpCtx=this.tmpCanvas.getContext("2d"),this.tmpCtx.fillStyle=this.canvasBg,this.tmpCtx.fillRect(0,0,this.imageSize[0],this.imageSize[1]));for(let t=0;t<this.length;t++){if(e=this.list[t],s=this.dom("div",this.css.item+"padding:0px "+(this.m+1)+"px; width:"+this.ww+"px; height:"+this.itemHeight+"px; line-height:"+(this.itemHeight-2)+"px; color:"+this.colors.text+"; background:"+this.colors.back+";"),s.name="item"+t,s.id=t,s.select=false,s.posy=(this.itemHeight+1)*t,this.listIn.appendChild(s),this.items.push(s),e===this.value&&(this.current=s),this.isWithImage||(s.textContent=e),this.miniCanvas){let t=new Image;t.src=this.tmpCanvas.toDataURL(),t.style.cssText="margin-right:4px;",s.appendChild(t),this.tmpImage[e]=t;}this.dragout&&(s.img=this.tmpImage[e],s.style.pointerEvents="auto",s.draggable="true",s.addEventListener("dragstart",this.dragstart||function(){}),s.addEventListener("drag",this.drag||function(){}),s.addEventListener("dragleave",(function(){i$3.fakeUp();})),s.addEventListener("dragend",this.dragend||function(){}.bind(this)));}this.setTopItem(),this.isSelectable&&this.selected();}drawImage(t,s,i,e,h,o){this.tmpCtx.clearRect(0,0,this.imageSize[0],this.imageSize[1]),this.tmpCtx.drawImage(s,i,e,h,o,0,0,this.imageSize[0],this.imageSize[1]),this.tmpImage[t].src=this.tmpCanvas.toDataURL();}addImages(){let t=this.list.length;for(let s=0;s<t;s++)this.items[s].appendChild(this.tmpImage[this.list[s]]);this.setTopItem();}setValue(t){isNaN(t)?this.value=t:this.value=this.list[t],this.setTopItem();}setTopItem(){if(!this.staticTop){if(this.isWithImage){if(!this.preLoadComplete)return;this.c[3].children.length||(this.canvas=document.createElement("canvas"),this.canvas.width=this.imageSize[0],this.canvas.height=this.imageSize[1],this.canvas.style.cssText="margin-right:4px;",this.ctx=this.canvas.getContext("2d"),this.c[3].style.textAlign="left",this.c[3].style.justifyContent="left",this.c[3].appendChild(this.canvas)),this.tmpImage[this.value],this.ctx.drawImage(this.tmpImage[this.value],0,0,this.imageSize[2],this.imageSize[3],0,0,this.imageSize[0],this.imageSize[1]);}else this.c[3].textContent=this.value;this.miniCanvas&&(this.c[3].children.length||(this.canvas=document.createElement("canvas"),this.canvas.width=this.imageSize[0],this.canvas.height=this.imageSize[1],this.canvas.style.cssText="margin-right:4px;",this.ctx=this.canvas.getContext("2d"),this.c[3].style.textAlign="left",this.c[3].style.justifyContent="left",this.c[3].appendChild(this.canvas)),this.ctx.drawImage(this.tmpImage[this.value],0,0));}}update(t){this.scroll&&(t=(t=t<0?0:t)>this.range?this.range:t,this.topList=-Math.floor(t/this.ratio),this.listIn.style.top=this.topList+"px",this.scroller.style.top=Math.floor(t)+"px",this.py=t);}parentHeight(t){null!==this.group?this.group.calc(t):this.isUI&&this.main.calc(t);}open(t){super.open(),this.update(0),this.h=this.maxHeight+this.baseH+5,this.scroll?(this.scroller.style.display="block",this.scrollerBack.style.display="block"):(this.topList=0,this.h=this.baseH+5+this.max,this.scroller.style.display="none",this.scrollerBack.style.display="none"),this.s[0].height=this.h+"px",this.s[2].display="block",this.up?(this.zone.y-=this.h-(this.baseH-10),this.setSvg(this.c[4],"d",this.svgs.g1)):this.setSvg(this.c[4],"d",this.svgs.g2),this.rSizeContent();let s=this.h-this.baseH;this.zone.h=this.h,t||this.parentHeight(s);}close(){super.close(),this.up&&(this.zone.y+=this.h-(this.baseH-10));let t=this.h-this.baseH;this.h=this.baseH,this.s[0].height=this.h+"px",this.s[2].display="none",this.setSvg(this.c[4],"d",this.svgs.g1),this.zone.h=this.h,this.parentHeight(-t);}text(t){this.c[3].textContent=t;}rSizeContent(){let t=this.length;for(;t--;)this.listIn.children[t].style.width=this.ww+"px";}rSize(){super.rSize();let t=this.s,s=this.sb,i=this.sa;void 0!==t[2]&&(t[2].width=s+"px",t[2].left=i+"px",t[3].width=s+"px",t[3].left=i+"px",t[4].left=i+s-15+"px",this.ww=s,this.max>this.maxHeight&&(this.ww=s-this.ss),this.isOpen&&this.rSizeContent());}}let f$1 = class f extends r$1{constructor(t={}){super(t),this.setTypeNumber(t),this.allway=t.allway||false,this.isDown=false,this.value=[0],this.multy=1,this.invmulty=1,this.isSingle=true,this.isAngle=false,this.isVector=false,t.isAngle&&(this.isAngle=true,this.multy=h$2.torad,this.invmulty=h$2.todeg),this.isDrag=t.drag||false,void 0!==t.value&&(isNaN(t.value)?t.value instanceof Array?(this.value=t.value,this.isSingle=false):t.value instanceof Object&&(this.value=[],void 0!==t.value.x&&(this.value[0]=t.value.x),void 0!==t.value.y&&(this.value[1]=t.value.y),void 0!==t.value.z&&(this.value[2]=t.value.z),void 0!==t.value.w&&(this.value[3]=t.value.w),this.isSingle=false,this.isVector=true):this.value=[t.value]),this.lng=this.value.length,this.tmp=[],this.current=-1,this.prev={x:0,y:0,d:0,v:0};let s=this.colors;this.c[2]=this.dom("div",this.css.basic+" background:"+s.select+"; top:4px; width:0px; height:"+(this.h-8)+"px;"),this.cMode=[];let i=this.lng;for(;i--;)this.isAngle&&(this.value[i]=(180*this.value[i]/Math.PI).toFixed(this.precision)),this.c[3+i]=this.dom("div",this.css.txtselect+"top:1px; height:"+(this.h-2)+"px; color:"+s.text+"; background:"+s.back+"; borderColor:"+s.border+"; border-radius:"+this.radius+"px;"),t.center&&(this.c[2+i].style.textAlign="center"),this.c[3+i].textContent=this.value[i],this.c[3+i].style.color=this.colors.text,this.c[3+i].isNum=true,this.cMode[i]=0;this.selectId=3+this.lng,this.c[this.selectId]=this.dom("div",this.css.txtselect+"position:absolute; top:2px; height:"+(this.h-4)+"px; padding:0px 0px; width:0px; color:"+s.textSelect+"; background:"+s.select+"; border:none; border-radius:0px;"),this.cursorId=4+this.lng,this.c[this.cursorId]=this.dom("div",this.css.basic+"top:2px; height:"+(this.h-4)+"px; width:0px; background:"+s.text+";"),this.init();}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";let i=this.lng,e=this.tmp;for(;i--;)if(s.x>e[i][0]&&s.x<e[i][2])return i;return ""}mousedown(t){let s=this.testZone(t);return !this.isDown&&(this.isDown=true,""!==s&&(this.current=s,this.prev={x:t.clientX,y:t.clientY,d:0,v:this.isSingle?parseFloat(this.value):parseFloat(this.value[this.current])},this.setInput(this.c[3+this.current])),this.mousemove(t))}mouseup(t){return !!this.isDown&&(this.isDown=false,this.prev={x:0,y:0,d:0,v:0},this.mousemove(t))}mousemove(t){let s=false,i=0;if(""===this.testZone(t)?this.cursor():this.isDrag?this.cursor(-1!==this.current?"move":"pointer"):this.cursor("text"),!this.isDrag)return this.isDown&&(i=t.clientX-this.zone.x-3),-1!==this.current&&(i-=this.tmp[this.current][0]),this.upInput(i,this.isDown);if(-1!==this.current){this.prev.d+=t.clientX-this.prev.x-(t.clientY-this.prev.y);let i=this.prev.v+this.prev.d*this.step;this.value[this.current]=this.numValue(i),this.c[3+this.current].textContent=this.value[this.current],this.validate(),this.prev.x=t.clientX,this.prev.y=t.clientY,s=true;}return s}reset(){return  false}setValue(t){this.isVector?(void 0!==t.x&&(this.value[0]=t.x),void 0!==t.y&&(this.value[1]=t.y),void 0!==t.z&&(this.value[2]=t.z),void 0!==t.w&&(this.value[3]=t.w)):this.value=this.isSingle?[t]:t,this.update();}sameStr(t){let s=this.value.length;for(;s--;)this.c[3+s].textContent=t;}update(t){let s=this.value.length;for(;s--;)this.value[s]=this.numValue(this.value[s]*this.invmulty),this.c[3+s].textContent=this.value[s];t&&this.send();}send(t){t=t||this.value,this.isSend=true,null!==this.objectLink&&(this.isVector?this.objectLink[this.objectKey].fromArray(t):this.objectLink[this.objectKey]=t),this.callback&&this.callback(t,this.objectKey),this.isSend=false;}select(t,s,i,e){let h=this.s,o=-1!==this.current?this.tmp[this.current][0]+5:0;h[this.cursorId].width="1px",h[this.cursorId].left=o+t+"px",h[this.selectId].left=o+s+"px",h[this.selectId].width=i+"px",this.c[this.selectId].innerHTML=e;}unselect(){let t=this.s;t&&(this.c[this.selectId].innerHTML="",t[this.selectId].width="0px",t[this.cursorId].width="0px");}validate(t){let s=[],i=this.lng;for(this.allway&&(t=true);i--;){if(isNaN(this.c[3+i].textContent))this.c[3+i].textContent=this.value[i];else {let t=this.numValue(this.c[3+i].textContent);this.c[3+i].textContent=t,this.value[i]=t;}s[i]=this.value[i]*this.multy;}t&&this.send(this.isSingle?s[0]:s);}rSize(){super.rSize();let t=this.colors.sx,s=t*(this.lng-1),i=(this.sb-s)/this.lng,e=this.s,h=this.lng;for(;h--;)this.tmp[h]=[this.sa+i*h+t*h,i],this.tmp[h][2]=this.tmp[h][0]+this.tmp[h][1],e[3+h].left=this.tmp[h][0]+"px",e[3+h].width=this.tmp[h][1]+"px";}};let w$2 = class w extends r$1{constructor(t={}){super(t),this.setTypeNumber(t),this.model=void 0!==t.stype?t.stype:2,void 0!==t.mode&&(this.model=t.mode),this.isDown=false,this.isOver=false,this.allway=t.allway||false,this.autoValue=true,void 0!==t.autoValue&&(this.autoValue=false),this.isDeg=t.isDeg||false,this.isCyclic=t.cyclic||false,this.firstImput=false;let s=this.colors;if(this.c[2]=this.dom("div",this.css.txtselect+"border:none; background:none; width:47px; color:"+s.text+";"),this.c[3]=this.dom("div",this.css.basic+" top:0; height:"+this.h+"px;"),this.c[4]=this.dom("div",this.css.basic+"background:"+s.back+"; top:2px; height:"+(this.h-4)+"px;"),this.c[5]=this.dom("div",this.css.basic+"left:4px; top:5px; height:"+(this.h-10)+"px; background:"+s.text+";"),this.c[2].isNum=true,this.c[2].style.height=this.h-2+"px",this.c[2].style.lineHeight=this.h-10+"px",0!==this.model){let t=4,i=4,e=8,h=this.h-6,o=16;2===this.model&&(t=0,i=2,e=4,o=2,h=.5*(this.h-6)),3===this.model&&(this.c[5].style.visible="none"),this.c[4].style.borderRadius=t+"px",this.c[4].style.height=e+"px",this.c[4].style.top=.5*this.h-i+"px",this.c[5].style.borderRadius=.5*t+"px",this.c[5].style.height=i+"px",this.c[5].style.top=.5*this.h-.5*i+"px",this.c[6]=this.dom("div",this.css.basic+"border-radius:"+o+"px; margin-left:"+.5*-h+"px; background:"+s.text+"; left:4px; top:"+.5*(this.h-h)+"px; height:"+h+"px; width:"+h+"px;");}this.init();}testZone(t){let s=this.local;return  -1===s.x&&-1===s.y?"":s.x>=this.txl?"text":s.x>=this.sa?"scroll":""}mouseup(t){this.isDown&&(this.isDown=false);}mousedown(t){let s=this.testZone(t);return !!s&&("scroll"===s&&(this.isDown=true,this.old=this.value,this.mousemove(t)),true)}mousemove(t){let s=false;if("scroll"===this.testZone(t)?(this.mode(1),this.cursor("w-resize")):this.cursor(),this.isDown){let i=(t.clientX-(this.zone.x+this.sa)-3)/this.ww*this.range+this.min-this.old;(i>=this.step||i<=this.step)&&(i=Math.floor(i/this.step),this.value=this.numValue(this.old+i*this.step),this.update(true),this.old=this.value),s=true;}return s}wheel(t){if("scroll"===this.testZone(t)){let s=this.value-this.step*t.delta;return s>this.max?s=this.isCyclic?this.min:this.max:s<this.min&&(s=this.isCyclic?this.max:this.min),this.setValue(s),this.old=s,this.update(true),true}return  false}validate(){let t=this.c[2].textContent;isNaN(t)?this.autoValue&&(this.c[2].textContent=this.value+(this.isDeg?"°":"")):(this.value=this.numValue(t),this.update(true));}reset(){this.isDown=false,this.mode(0);}mode(t){let s=this.s,i=this.colors;switch(t){case 0:s[2].color=i.text,s[4].background=i.back,s[5].background=i.text,0!==this.model&&(s[6].background=i.text);break;case 1:s[2].color=i.textOver,s[4].background=i.back,s[5].background=i.textOver,0!==this.model&&(s[6].background=i.textOver);}}update(t){let s=Math.floor(this.ww*((this.value-this.min)/this.range));3!==this.model&&(this.s[5].width=s+"px"),this.s[6]&&(this.s[6].left=this.sa+s+3+"px"),this.autoValue&&(this.c[2].textContent=this.value+(this.isDeg?"°":"")),t&&this.send();}rSize(){super.rSize();let t=this.sb-this.sc;this.ww=t-6;let s=this.sc;!this.isUI&&this.simple||(s=this.sc+10),this.txl=this.w-s+2;let i=this.s;i[2].width=this.sc-6+"px",i[2].left=this.txl+4+"px",i[3].left=this.sa+"px",i[3].width=t+"px",i[4].left=this.sa+"px",i[4].width=t+"px",i[5].left=this.sa+3+"px",this.update();}};class y extends r$1{constructor(t={}){super(t),this.cmode=0,this.value=void 0!==t.value?t.value:"",this.placeHolder=t.placeHolder||"",this.allway=t.allway||false,this.editable=void 0===t.edit||t.edit,this.isDown=false;let s=this.colors;this.c[2]=this.dom("div",this.css.txtselect+"top:1px; height:"+(this.h-2)+"px; color:"+s.text+"; background:"+s.back+"; borderColor:"+s.border+"; border-radius:"+this.radius+"px;"),this.c[2].textContent=this.value,this.c[3]=this.dom("div",this.css.txtselect+"position:absolute; top:2px; height:"+(this.h-4)+"px; padding:0px 0px; width:0px; color:"+s.textSelect+"; background:"+s.select+"; border:none; border-radius:0px;"),this.c[4]=this.dom("div",this.css.basic+"top:2px; height:"+(this.h-4)+"px; width:0px; background:"+s.text+";"),this.c[5]=this.dom("div",this.css.txtselect+"top:1px; height:"+(this.h-2)+"px; border:none; justify-content: center; font-style: italic; color:"+s.border+";"),""===this.value&&(this.c[5].textContent=this.placeHolder),this.init();}testZone(t){let s=this.local;return  -1===s.x&&-1===s.y?"":s.x>=this.sa?"text":""}mouseup(t){if(this.editable)return !!this.isDown&&(this.isDown=false,this.mousemove(t))}mousedown(t){if(!this.editable)return;let s=this.testZone(t);return !this.isDown&&(this.isDown=true,"text"===s&&this.setInput(this.c[2]),this.mousemove(t))}mousemove(t){if(!this.editable)return;let s=0;return "text"===this.testZone(t)?this.cursor("text"):this.cursor(),this.isDown&&(s=t.clientX-this.zone.x),this.upInput(s-this.sa-3,this.isDown)}update(){this.c[2].textContent=this.value;}reset(){this.cursor();}select(t,s,i,e){let h=this.s,o=this.sa+5;h[4].width="1px",h[4].left=o+s+"px",h[3].left=o+s+"px",h[3].width=i+"px",this.c[3].innerHTML=e;}unselect(){let t=this.s;t&&(t[3].width="0px",this.c[3].innerHTML="t",t[4].width="0px");}validate(t){this.allway&&(t=true),this.value=this.c[2].textContent,""!==this.value?this.c[5].textContent="":this.c[5].textContent=this.placeHolder,t&&this.send();}rSize(){super.rSize();let t=this.s;t[2].left=this.sa+"px",t[2].width=this.sb+"px",t[5].left=this.sa+"px",t[5].width=this.sb+"px";}}class k extends r$1{constructor(t={}){super(t),this.isTitle=true;let s=t.prefix||"",i=t.color||this.colors.text;this.c[2]=this.dom("div",this.css.txt+"justify-content:right; width:60px; line-height:"+(this.h-8)+"px; color:"+i),31===this.h&&(this.s[0].height=this.h+"px",this.s[1].top="8px",this.c[2].style.top="8px");let e=this.s;e[1].justifyContent=t.align||"left",e[1].fontWeight=t.fontWeight||"bold",e[1].color=t.color||this.colors.text,this.c[1].textContent=this.txt.substring(0,1).toUpperCase()+this.txt.substring(1).replace("-"," "),this.c[2].textContent=s,this.init();}text(t){this.c[1].textContent=t;}text2(t){this.c[2].textContent=t;}rSize(){super.rSize(),this.s[1].width=this.w+"px",this.s[2].left=this.w+"px";}setColor(t){this.s[1].color=t,this.s[2].color=t;}}class S extends r$1{constructor(t={}){super(t),this.value=t.value||"",this.isDown=false,this.onActif=t.onActif||function(){};const s=this.colors;this.c[2]=this.dom("div",this.css.txt+this.css.button+" top:1px; background:"+s.button+"; height:"+(this.h-2)+"px; border:"+s.buttonBorder+"; border-radius:15px; width:30px; left:10px;"),this.c[3]=this.dom("div",this.css.txtselect+"height:"+(this.h-4)+"px; background:"+s.inputBg+"; borderColor:"+s.inputBorder+"; border-radius:"+this.radius+"px;"),this.c[3].textContent=this.value;let i=Math.floor(.5*this.h)-7;this.c[4]=this.dom("path",this.css.basic+"position:absolute; width:14px; height:14px; left:5px; top:"+i+"px;",{d:this.svgs.cursor,fill:s.text,stroke:"none"}),this.stat=1,this.isActif=false,this.init();}testZone(t){let s=this.local;return  -1===s.x&&-1===s.y?"":s.x>this.sa&&s.x<this.sa+30?"over":"0"}mouseup(t){return !!this.isDown&&(this.isDown=false,this.mousemove(t))}mousedown(t){return !!this.testZone(t)&&(this.isDown=true,this.mousemove(t))}mousemove(t){let s=false;return "over"===this.testZone(t)?(this.cursor("pointer"),s=this.mode(this.isDown?3:2)):s=this.reset(),s}apply(t){(t=t||"")!==this.value&&(this.value=t,this.c[3].textContent=this.value,this.send()),this.mode(1);}update(){this.mode(3);}mode(t){let s=false,i=this.colors;if(this.stat!==t){switch(1===t&&(this.isActif=false),3===t&&(this.isActif?this.isActif=false:(this.isActif=true,t=4,this.onActif(this))),2===t&&this.isActif&&(t=4),this.stat=t,t){case 1:this.s[2].color=i.text,this.s[2].background=i.button;break;case 2:this.s[2].color=i.textOver,this.s[2].background=i.overoff;break;case 3:this.s[2].color=i.textOver,this.s[2].background=i.action;break;case 4:this.s[2].color=i.textSelect,this.s[2].background=i.action;}s=true;}return s}reset(){return this.cursor(),this.mode(this.isActif?4:1)}text(t){this.c[3].textContent=t;}rSize(){super.rSize();let t=this.s;t[2].left=this.sa+"px",t[3].left=this.sa+40+"px",t[3].width=this.sb-40+"px",t[4].left=this.sa+8+"px";}}let I$2 = class I extends r$1{constructor(t={}){super(t),this.value=t.value||"",this.colorSpace=t.colorSpace||"",this.img=null,this.value.isTexture&&this.value.image&&(this.img=this.value.image),this.isDown=false,this.neverlock=true;const s=this.colors;this.c[2]=this.dom("div",this.css.txt+this.css.button+" top:1px; background:"+s.button+"; height:"+(this.h-2)+"px; border:"+s.buttonBorder+"; border-radius:2px; width:30px; "),this.c[3]=this.dom("div",this.css.txtselect+"height:"+(this.h-4)+"px; background:"+s.back+"; borderColor:"+s.inputBorder+"; border-radius:"+this.radius+"px;"),this.img||(this.c[3].textContent="null");let i=Math.floor(.5*this.h)-7;this.c[4]=this.dom("path",this.css.basic+"position:absolute; width:14px; height:14px; left:5px; top:"+i+"px;",{d:this.svgs.load,fill:s.text,stroke:"none"}),this.stat=1,this.makePreview(),this.init();}testZone(t){let s=this.local;return  -1===s.x&&-1===s.y?"":s.x>this.sa&&s.x<this.sa+30?"over":s.x>this.sa-30&&s.x<this.sa?"delete":"0"}mouseup(t){return !!this.isDown&&(this.isDown=false,this.mousemove(t))}mousedown(t){let s=this.testZone(t);return !!s&&("over"===s&&(this.isDown=true,o$1.load({callback:this.changeBitmap.bind(this),always:true,type:"image"})),this.mousemove(t))}mousemove(t){let s=false;return "over"===this.testZone(t)?(this.cursor("pointer"),s=this.mode(this.isDown?3:2)):s=this.reset(),s}makePreview(){this.img?(this.c[3].style.background="url("+this.img.src+")",this.c[3].style.backgroundSize=this.sb-40+"px "+(this.sb-40)+"px",this.c[3].style.backgroundPosition="center",this.c[3].style.backgroundRepeat="no-repeat"):(this.c[3].style.background=this.colors.back,this.c[3].style.backgroundImage="none");}changeBitmap(t,s,i){t?(this.img=t,this.apply(s)):(this.img=null,this.apply("null")),this.makePreview(),this.threeTexture();}threeTexture(){if(null===this.objectLink)return;let t=this.objectLink[this.objectKey];this.img?null!==t?(t.image=this.img,this.objectLink[this.objectKey]=t.clone(),t.dispose(),this.objectLink[this.objectKey].needsUpdate=true):h$2.texture&&(t=new h$2.texture(this.img),this.colorSpace&&(t.colorSpace=this.colorSpace),this.objectLink[this.objectKey]=t,this.objectLink[this.objectKey].needsUpdate=true):this.objectLink[this.objectKey]=null,this.objectLink.needsUpdate=true;}apply(t){t=t||"";let s=null!==this.objectLink?this.objectKey:this.name;t!==this.value&&(this.value=t,null!==this.img?(this.c[3].textContent="",this.callback&&this.callback(this.value,this.img,s)):(this.c[3].textContent="null",this.callback&&this.callback(null,null,s))),this.mode(1);}update(){this.mode(3);}mode(t,s){let i=false,e=this.colors;if(this.stat!==t){switch(this.stat=t,t){case 1:this.s[2].color=e.text,this.s[2].background=e.button;break;case 2:this.s[2].color=e.textOver,this.s[2].background=e.overoff;break;case 3:this.s[2].color=e.textOver,this.s[2].background=e.over;break;case 4:this.s[2].color=e.textSelect,this.s[2].background=e.select;}i=true;}return i}reset(){return this.cursor(),this.mode(this.isActif?4:1)}text(t){this.c[3].textContent=t;}rSize(){super.rSize();let t=this.s;t[2].left=this.sa+"px",t[3].left=this.sa+40+"px",t[3].width=this.sb-40+"px",t[4].left=this.sa+8+"px";}};let C$3 = class C extends a$1{constructor(t={}){ void 0===t.selectable&&(t.selectable=true),super(t);}};let M$2 = class M extends r$1{constructor(t={}){super(t),this.p=100,this.value=this.txt,this.status=1,this.itype=t.itype||"none",this.val=this.itype,this.graph=this.svgs[this.itype];let s=Math.floor(.5*this.h)-7;this.c[2]=this.dom("path",this.css.basic+"position:absolute; width:14px; height:14px; left:5px; top:"+s+"px;",{d:this.graph,fill:this.colors.text,stroke:"none"}),this.s[1].marginLeft="20px",this.init();}mousemove(t){this.cursor("pointer");}mousedown(t){return this.isUI&&this.main.resetItem(),this.selected(true),this.send(),true}uiout(){this.isSelect?this.mode(3):this.mode(1);}uiover(){this.isSelect?this.mode(4):this.mode(2);}update(){}mode(t){let s=false;if(this.status!==t){this.status=t;let i=this.s,e=this.colors;switch(t){case 1:this.status=1,i[1].color=e.text,i[0].background="none";break;case 2:this.status=2,i[1].color=e.textOver,i[0].background=e.back;break;case 3:this.status=3,i[1].color=e.textSelect,i[0].background=e.select;break;case 4:this.status=4,i[1].color=e.textOver,i[0].background=e.over;}s=true;}return s}reset(){this.cursor();}selected(t){this.isSelect&&this.mode(1),this.isSelect=t||false,this.isSelect&&this.mode(3);}};class L extends r$1{constructor(t={}){if(super(t),this.values=[],t.values)if(t.values instanceof Array)this.values=t.values;else if(t.values instanceof String)this.values=[t.values];else if(t.values instanceof Object){this.refObject=t.values;for(let t in this.refObject)this.values.push(t);}this.lng=this.values.length,this.value=t.value||null;let s=this.colors;this.isSelectable=t.selectable||false,this.spaces=t.spaces||[s.sx,s.sy],this.bsize=t.bsize||[90,this.h],this.bsizeMax=this.bsize[0],this.tmp=[],this.stat=[],this.grid=[2,Math.round(.5*this.lng)],this.h=this.grid[1]*this.bsize[1]+this.grid[1]*this.spaces[1],this.c[1].textContent="",this.c[2]=this.dom("table",this.css.basic+"width:100%; border-spacing: "+(this.spaces[0]-2)+"px "+this.spaces[1]+"px; border:none;");let i,e,h,o,n=0;this.res=-1,this.isDown=false,this.neverlock=true,this.buttons=[],this.stat=[],this.tmpX=[],this.tmpY=[];for(let t=0;t<this.grid[1];t++){h=this.c[2].insertRow(),h.style.cssText="pointer-events:none;";for(let t=0;t<this.grid[0];t++)e=h.insertCell(),e.style.cssText="pointer-events:none;",this.values[n]?(o=false,this.values[n]===this.value&&this.isSelectable&&(o=true),i=document.createElement("div"),i.style.cssText=this.css.txt+this.css.button+"position:static; top:1px; width:"+this.bsize[0]+"px; height:"+(this.bsize[1]-2)+"px; border:"+s.borderSize+"px solid "+s.border+"; left:auto; right:auto; border-radius:"+this.radius+"px;",i.style.background=o?s.select:s.button,i.style.color=o?s.textSelect:s.text,i.innerHTML=this.values[n],e.appendChild(i),this.buttons.push(i),this.stat.push(1)):(i=document.createElement("div"),i.style.cssText=this.css.txt+"position:static; width:"+this.bsize[0]+"px; height:"+this.bsize[1]+"px; text-align:center; left:auto; right:auto; background:none;",e.appendChild(i)),i.style.cssText+=0===t?"float:right;":"float:left;",n++;}this.s[0].border="none",this.init();}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return  -1;s.y+=this.mtop;let i=this.tmpX,e=this.tmpY,h=-1,o=-1,n=-1,r=this.grid[0];for(;r--;)s.x>i[r][0]&&s.x<i[r][1]&&(o=r);for(r=this.grid[1];r--;)s.y>e[r][0]&&s.y<e[r][1]&&(n=r);return  -1!==o&&-1!==n&&(h=o+2*n,h>this.lng-1&&(h=-1)),h}mouseup(t){return !!this.isDown&&(this.isDown=false,-1!==this.res&&(this.value=this.values[this.res],this.send()),this.mousemove(t))}mousedown(t){return !this.isDown&&(this.isDown=true,this.mousemove(t))}mousemove(t){let s=false;return this.res=this.testZone(t),-1!==this.res?(this.cursor("pointer"),s=this.modes(this.isDown?3:2,this.res)):s=this.reset(),s}update(){this.modes(2,this.values.indexOf(this.value));}modes(t=1,s=-1){let i,e,h=this.lng,o=false;for(;h--;)e=t,i=!!this.isSelectable&&this.values[h]===this.value,h===s?i&&2===e&&(e=3):(e=1,i&&(e=4)),this.mode(e,h)&&(o=true);return o}mode(t,s){let i=false,e=this.colors,h=this.buttons,o=s;if(this.stat[s]!==t){switch(this.stat[s]=t,t){case 1:h[o].style.color=e.text,h[o].style.background=e.button;break;case 2:h[o].style.color=e.textOver,h[o].style.background=e.overoff;break;case 3:h[o].style.color=e.textOver,h[o].style.background=e.over;break;case 4:h[o].style.color=e.textSelect,h[o].style.background=e.select;}i=true;}return i}reset(){return this.res=-1,this.cursor(),this.modes()}label(t,s){this.buttons[s].textContent=t;}icon(t,s,i){this.buttons[i].style.padding=(s||0)+"px 0px",this.buttons[i].innerHTML=t;}testW(){let t=false;if(3*this.spaces[0]+2*this.bsizeMax>this.w?(this.bsize[0]=.5*(this.w-3*this.spaces[0]),t=true):this.bsize[0]!==this.bsizeMax&&(this.bsize[0]=this.bsizeMax,t=true),!t)return;let s=this.buttons.length;for(;s--;)this.buttons[s].style.width=this.bsize[0]+"px";}rSize(){let t;super.rSize(),this.testW(),this.tmpX=[],this.tmpY=[];for(let s=0;s<this.grid[0];s++)0===s?(t=.5*this.w-.5*this.spaces[0],this.tmpX.push([t-this.bsize[0],t])):(t=.5*this.w+.5*this.spaces[0],this.tmpX.push([t,t+this.bsize[0]]));t=this.spaces[1];for(let s=0;s<this.grid[1];s++)this.tmpY.push([t,t+this.bsize[1]]),t+=this.bsize[1]+this.spaces[1];}}let z$1 = class z extends r$1{constructor(t={}){super(t),this.autoWidth=false,this.minw=this.w,this.diam=t.diam||this.w,this.pos=new n$2(0,0),this.maxPos=90,this.model=t.stype||0,void 0!==t.mode&&(this.model=t.mode),this.min=void 0===t.min?-1:t.min,this.max=void 0===t.max?1:t.max,this.range=.5*(this.max-this.min),this.cmode=0,this.c[0].style.display="block",this.precision=void 0===t.precision?2:t.precision,this.value=Array.isArray(t.value)&&2==t.value.length?t.value:[0,0],this.h=t.h||this.w+10,this.c[0].style.width=this.w+"px",void 0!==this.c[1]&&(this.c[1].style.width="100%",this.c[1].style.justifyContent="center",this.top=10,this.h+=10);let s=this.colors;this.c[2]=this.dom("div",this.css.txt+"justify-content:center; top:"+(this.h-20)+"px; width:100%; color:"+s.text),this.c[2].textContent=this.value;let i=this.getPad2d();this.setSvg(i,"fill",s.back,0),this.setSvg(i,"fill",s.button,1),this.setSvg(i,"stroke",s.back,2),this.setSvg(i,"stroke",s.back,3),this.setSvg(i,"stroke",s.text,4),this.setSvg(i,"viewBox","0 0 "+this.diam+" "+this.diam),this.setCss(i,{width:this.diam,height:this.diam,left:0,top:this.top}),this.c[3]=i,this.init(),this.setValue();}testZone(t){let s=this.local;return  -1===s.x&&-1===s.y?"":s.y<=this.c[1].offsetHeight?"title":s.y>this.h-this.c[2].offsetHeight?"text":"pad"}mouseup(t){return this.isDown=false,this.mode(0)}mousedown(t){if("pad"===this.testZone(t))return this.isDown=true,this.mousemove(t),this.mode(1)}mousemove(t){if(!this.isDown)return;let s=.5*this.w-(t.clientX-this.zone.x),i=.5*this.diam-(t.clientY-this.zone.y-this.ytop),e=256/this.diam;s=-s*e,i=-i*e,s=h$2.clamp(s,-this.maxPos,this.maxPos),i=h$2.clamp(i,-this.maxPos,this.maxPos),this.setPos([s,i]),this.update(true);}mode(t){if(this.cmode===t)return  false;let s=this.colors;switch(t){case 0:this.s[2].color=s.text,this.setSvg(this.c[3],"fill",s.back,0),this.setSvg(this.c[3],"fill",s.button,1),this.setSvg(this.c[3],"stroke",s.back,2),this.setSvg(this.c[3],"stroke",s.back,3),this.setSvg(this.c[3],"stroke",s.text,4);break;case 1:this.s[2].color=s.textSelect,this.setSvg(this.c[3],"fill",s.backoff,0),this.setSvg(this.c[3],"fill",s.overoff,1),this.setSvg(this.c[3],"stroke",s.backoff,2),this.setSvg(this.c[3],"stroke",s.backoff,3),this.setSvg(this.c[3],"stroke",s.textSelect,4);}return this.cmode=t,true}update(t){this.c[2].textContent=this.value,this.updateSVG(),t&&this.send();}updateSVG(){1==this.model&&(this.setSvg(this.c[3],"y1",this.pos.y,2),this.setSvg(this.c[3],"y2",this.pos.y,2),this.setSvg(this.c[3],"x1",this.pos.x,3),this.setSvg(this.c[3],"x2",this.pos.x,3)),this.setSvg(this.c[3],"cx",this.pos.x,4),this.setSvg(this.c[3],"cy",this.pos.y,4);}setPos(t){this.pos.set(t[0]+128,t[1]+128);let s=1/this.maxPos;this.value[0]=(t[0]*s*this.range).toFixed(this.precision),this.value[1]=(t[1]*s*this.range).toFixed(this.precision);}setValue(t,s=false){ void 0===t&&(t=this.value),this.value[0]=1*Math.min(this.max,Math.max(this.min,t[0])).toFixed(this.precision),this.value[1]=1*Math.min(this.max,Math.max(this.min,t[1])).toFixed(this.precision),this.pos.set(this.value[0]/this.range*this.maxPos+128,this.value[1]/this.range*this.maxPos+128),this.update(s);}};const T=function(){let t,s,e=arguments,h=false,o=null;"string"==typeof e[0]?(t=e[0],s=e[1]||{}):"object"==typeof e[0]&&(h=true,void 0===e[2]&&[].push.call(e,{}),t=e[2].type?e[2].type:O$1(e[0][e[1]],e[2]),s=e[2],s.name=e[1],"list"!==t||s.list?s.value=e[0][e[1]]:s.list=e[0][e[1]]);let n=t.toLowerCase();switch("group"===n&&(s.add=T),n){case "bool":case "boolean":o=new l$1(s);break;case "button":o=new a$1(s);break;case "circular":o=new c$2(s);break;case "color":o=new d$1(s);break;case "fps":o=new u$1(s);break;case "graph":o=new p$2(s);break;case "group":o=new g$2(s);break;case "joystick":o=new x$3(s);break;case "knob":o=new v$1(s);break;case "list":o=new b(s);break;case "numeric":case "number":o=new f$1(s);break;case "slide":o=new w$2(s);break;case "textInput":case "string":o=new y(s);break;case "title":case "text":o=new k(s);break;case "select":o=new S(s);break;case "bitmap":o=new I$2(s);break;case "selector":o=new C$3(s);break;case "empty":case "space":o=new m$2(s);break;case "item":o=new M$2(s);break;case "grid":o=new L(s);break;case "pad2d":case "pad":o=new z$1(s);}if(null!==o)return i$3.needResize=true,h&&o.setReferency(e[0],e[1]),o},O$1=function(t,s){let i="slide";return t.isColor?i="color":t.isTexture?i="bitmap":"boolean"==typeof t?i="bool":"string"==typeof t?i="#"===t.substring(0,1)?"color":"string":"number"==typeof t?i=s.ctype?"color":"slide":"array"==typeof t&&t instanceof Array?"number"==typeof t[0]?i="number":"string"==typeof t[0]&&(i="list"):"object"==typeof t&&t instanceof Object&&(i=void 0!==t.x?"number":"list"),i};class H{constructor(t={}){this.isGui=true,this.name="gui",this.canvas=null,this.screen=null,this.plane=t.plane||null,t.config&&(t.colors=t.config),t.colors?this.setConfig(t.colors):this.colors=h$2.defineColor(t),this.css=h$2.cloneCss(),this.isReset=true,this.tmpAdd=null,this.isCanvas=t.isCanvas||false,this.isCanvasOnly=false,this.callback=void 0===t.callback?null:t.callback,this.forceHeight=t.maxHeight||0,this.lockHeight=t.lockHeight||false,this.isItemMode=void 0!==t.itemMode&&t.itemMode,this.cn="",this.size=h$2.size,void 0!==t.p&&(this.size.p=t.p),void 0!==t.w&&(this.size.w=t.w),void 0!==t.h&&(this.size.h=t.h),void 0!==t.s&&(this.size.s=t.s),this.size.h=this.size.h<11?11:this.size.h,this.local=(new n$2).neg(),this.zone={x:0,y:0,w:this.size.w,h:0},this.mouse=(new n$2).neg(),this.h=0,this.sw=0,this.margin=this.colors.sy,this.marginDiv=h$2.isDivid(this.margin),this.isWithClose=void 0===t.close||t.close,this.bh=this.isWithClose?this.size.h:0,this.autoResize=void 0===t.autoResize||t.autoResize,this.isCenter=t.center||false,this.isBottom=void 0!==t.bottom,this.realTop=0,this.bottomPosition=t.bottom||0,this.cssGui=void 0!==t.css?t.css:this.isCenter?"":"right:10px;",this.isOpen=void 0===t.open||t.open,this.isDown=false,this.isScroll=false,this.uis=[],this.current=-1,this.proto=null,this.isEmpty=true,this.decal=0,this.ratio=1,this.oy=0,this.isNewTarget=false;let s=this.colors,e="border: 2px solid "+s.content+"; ";this.content=h$2.dom("div",this.css.basic+" width:0px; height:auto; top:0px; background:"+s.content+"; "+this.cssGui+e),this.innerContent=h$2.dom("div",this.css.basic+"width:100%; top:0; left:0; height:auto; overflow:hidden;"),this.content.appendChild(this.innerContent),this.useFlex=true;let o=this.useFlex?"display:flex; flex-flow: row wrap;":"";this.inner=h$2.dom("div",this.css.basic+o+"width:100%; left:0; "),this.innerContent.appendChild(this.inner),this.scrollBG=h$2.dom("div",this.css.basic+"right:0; top:0; width:"+(this.size.s-1)+"px; height:10px; display:none; background:"+s.background+";"),this.content.appendChild(this.scrollBG),this.scroll=h$2.dom("div",this.css.basic+"background:"+s.button+"; right:2px; top:0; width:"+(this.size.s-4)+"px; height:10px;"),this.scrollBG.appendChild(this.scroll),this.bottomText=t.bottomText||["open","close"];let r=s.radius;this.bottom=h$2.dom("div",this.css.txt+"width:100%; top:auto; bottom:0; left:0; border-bottom-right-radius:"+r+"px; border-bottom-left-radius:"+r+"px; justify-content:center; height:"+this.bh+"px; line-height:"+(this.bh-5)+"px; color:"+s.text+";"),this.content.appendChild(this.bottom),this.bottom.textContent=this.isOpen?this.bottomText[1]:this.bottomText[0],this.bottom.style.background=s.background,this.parent=void 0!==t.parent?t.parent:null,this.parent=void 0!==t.target?t.target:this.parent,null!==this.parent||this.isCanvas||(this.parent=document.body),null!==this.parent&&this.parent.appendChild(this.content),this.isCanvas&&null===this.parent&&(this.isCanvasOnly=true),this.isCanvasOnly?(this.content.style.left="0px",this.content.style.right="auto",t.transition=0):this.content.style.pointerEvents="auto",this.transition=void 0!==t.transition?t.transition:h$2.transition,this.transition&&setTimeout(this.addTransition.bind(this),1e3),this.setWidth(),this.isCanvas&&this.makeCanvas(),i$3.add(this);}setLeft(t){this.content.style.left=t+"px",i$3.needReZone=true;}setTop(t,s){this.content.style.top=t+"px",void 0!==s&&(this.forceHeight=s),this.calc(),i$3.needReZone=true;}addTransition(){this.transition&&!this.isCanvas&&(this.innerContent.style.transition="height "+this.transition+"s ease-out",this.content.style.transition="height "+this.transition+"s ease-out",this.bottom.style.transition="top "+this.transition+"s ease-out");let t=this.uis.length;for(;t--;)this.uis[t].addTransition();}onDraw(){}makeCanvas(){this.canvas=document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),this.canvas.width=this.zone.w,this.canvas.height=this.forceHeight?this.forceHeight:this.zone.h;}draw(t){if(null===this.canvas)return;let s=this.zone.w,e=this.forceHeight?this.forceHeight:this.zone.h;i$3.toCanvas(this,s,e,t);}getDom(){return this.content}noMouse(){this.mouse.neg();}setMouse(t,s=true){s?this.mouse.set(Math.round(t.x*this.canvas.width),this.canvas.height-Math.round(t.y*this.canvas.height)):this.mouse.set(Math.round(t.x*this.canvas.width),Math.round(t.y*this.canvas.height));}setConfig(t){h$2.setText(),this.colors=h$2.defineColor(t);}setColors(t){for(let s in t)this.colors[s]&&(this.colors[s]=t[s]);}setText(t,s,i,e){h$2.setText(t,s,i,e);}hide(t){this.content.style.visibility=t?"hidden":"visible";}display(t=false){this.content.style.visibility=t?"visible":"hidden";}onChange(t){return this.callback=t||null,this}mode(t){let s=false,e=this.colors;if(t!==this.cn){switch(this.cn=t,t){case "def":i$3.cursor(),this.scroll.style.background=e.button,this.bottom.style.background=e.background,this.bottom.style.color=e.text;break;case "scrollOver":i$3.cursor("ns-resize"),this.scroll.style.background=e.select;break;case "scrollDown":this.scroll.style.background=e.select;break;case "bottomOver":i$3.cursor("pointer"),this.bottom.style.background=e.backgroundOver,this.bottom.style.color=e.textOver;}s=true;}return s}clearTarget(){return  -1!==this.current&&(this.proto.s&&(this.proto.uiout(),this.proto.reset()),this.proto=null,this.current=-1,i$3.cursor(),true)}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";this.isReset=false;let i="",e=this.isScroll?this.zone.w-this.size.s:this.zone.w;return i=s.y>this.zone.h-this.bh&&s.y<this.zone.h?"bottom":s.x>e?"scroll":"content",i}handleEvent(t){let s=t.type,e=false,h=false,o=this.testZone(t);if("mouseup"===s&&this.isDown&&(this.isDown=false),"mousedown"!==s||this.isDown||(this.isDown=true),this.isDown&&this.isNewTarget&&(i$3.clearInput(),this.isNewTarget=false),o){switch(o){case "content":t.clientY=this.isScroll?t.clientY+this.decal:t.clientY,i$3.isMobile&&"mousedown"===s&&this.getNext(t,e),this.proto&&(h=this.proto.handleEvent(t)),"mousemove"===s&&(e=this.mode("def")),"wheel"===s&&!h&&this.isScroll&&(e=this.onWheel(t)),i$3.lock||this.getNext(t,e);break;case "bottom":this.clearTarget(),"mousemove"===s&&(e=this.mode("bottomOver")),"mousedown"===s&&(this.isOpen=!this.isOpen,this.bottom.textContent=this.isOpen?this.bottomText[1]:this.bottomText[0],this.calc(),this.mode("def"),e=true);break;case "scroll":this.clearTarget(),"mousemove"===s&&(e=this.mode("scrollOver")),"mousedown"===s&&(e=this.mode("scrollDown")),"wheel"===s&&(e=this.onWheel(t)),this.isDown&&this.update(t.clientY-this.zone.y-.5*this.sh);}this.isDown&&(e=true),h&&(e=true),"keyup"===s&&(e=true),"keydown"===s&&(e=true),e&&this.draw();}}getNext(t,s){let e=i$3.findTarget(this.uis,t);e!==this.current&&(this.clearTarget(),this.current=e,this.isNewTarget=true),-1!==e&&(this.proto=this.uis[this.current],this.proto.uiover());}onWheel(t){return this.oy+=20*t.delta,this.update(this.oy),true}reset(t){if(this.isReset)return;this.mouse.neg(),this.isDown=false;let s=this.mode("def"),i=this.clearTarget();(s||i)&&this.draw(true),this.isReset=true;}add(){let t=arguments,s=false;"object"==typeof t[1]?(t[1].isUI=true,t[1].main=this,s=!!t[1].ontop&&t[1].ontop):"string"==typeof t[1]&&(void 0===t[2]?[].push.call(t,{isUI:true,main:this}):(t[2].isUI=true,t[2].main=this,s=!!t[2].ontop&&t[2].ontop));let i=T.apply(this,t);if(null!==i)return s?this.uis.unshift(i):this.uis.push(i),this.calc(),this.isEmpty=false,i}remove(t){t.dispose&&t.dispose();}clearOne(t){let s=this.uis.indexOf(t);-1!==s&&(this.inner.removeChild(this.uis[s].c[0]),this.uis.splice(s,1),this.calc());}empty(){let t,s=this.uis.length;for(;s--;)t=this.uis.pop(),this.inner.removeChild(t.c[0]),t.dispose();this.uis=[],this.isEmpty=true,this.calc();}clear(){this.empty();}clear2(){setTimeout(this.empty.bind(this),0);}dispose(){this.clear(),null!==this.parent&&this.parent.removeChild(this.content),i$3.remove(this);}resetItem(){if(!this.isItemMode)return;let t=this.uis.length;for(;t--;)this.uis[t].selected();}setItem(t){if(!this.isItemMode)return;if(t=t||"",this.resetItem(),!t)return void this.update(0);let s=this.uis.length;for(;s--;)this.uis[s].value===t&&(this.uis[s].selected(true),this.isScroll&&this.update(s*(this.uis[s].h+this.margin)*this.ratio));}upScroll(t){this.sw=t?this.size.s:0,this.oy=t?this.oy:0,this.scrollBG.style.display=t?"block":"none",t&&(this.total=this.h,this.maxView=this.maxHeight,this.ratio=this.maxView/this.total,this.sh=this.maxView*this.ratio,this.range=this.maxView-this.sh,this.oy=h$2.clamp(this.oy,0,this.range),this.scrollBG.style.height=this.maxView+"px",this.scroll.style.height=this.sh+"px"),this.setItemWidth(this.zone.w-this.sw),this.update(this.oy);}update(t){t=h$2.clamp(t,0,this.range),this.decal=Math.floor(t/this.ratio),this.inner.style.top=-this.decal+"px",this.scroll.style.top=Math.floor(t)+"px",this.oy=t;}calcUis(){return i$3.calcUis(this.uis,this.zone,this.zone.y)}calc(){clearTimeout(this.tmp),this.tmp=setTimeout(this.setHeight.bind(this),10);}setHeight(){if(this.tmp&&clearTimeout(this.tmp),this.zone.h=this.bh,this.isScroll=false,this.isOpen){this.h=this.calcUis();let t=this.forceHeight?this.forceHeight+this.zone.y:window.innerHeight,s=this.isBottom?this.bottomPosition:this.zone.y;this.maxHeight=t-s-this.bh,this.h-this.maxHeight>1?(this.isScroll=true,this.zone.h=this.maxHeight+this.bh):this.zone.h=this.h+this.bh;}this.upScroll(this.isScroll),this.innerContent.style.height=this.zone.h-this.bh+"px",this.content.style.height=this.zone.h+"px",this.bottom.style.top=this.zone.h-this.bh+"px",this.isBottom&&(this.realTop=window.innerHeight-this.zone.h-this.bottomPosition,this.zone.y=this.realTop,this.content.style.top=this.realTop+"px",this.calcUis()),this.forceHeight&&this.lockHeight&&(this.content.style.height=this.forceHeight+"px"),this.isCanvas&&this.draw(true);}resizeRoot(){i$3.resize(),i$3.initEvents();}rezone(){i$3.needReZone=true;}getRoot(){return i$3}zoneReset(){}setWidth(t){t&&(this.zone.w=t),this.zone.w=Math.floor(this.zone.w),this.content.style.width=this.zone.w+"px",this.isCenter&&(this.content.style.marginLeft=-Math.floor(.5*this.zone.w)+"px"),this.setItemWidth(this.zone.w-this.sw);}setItemWidth(t){let s=this.uis.length;for(;s--;)this.uis[s].setSize(t),this.uis[s].rSize();}}

/* webgl-memory@1.1.2, license MIT */
(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
})((function () {
  /* PixelFormat */
  const ALPHA                          = 0x1906;
  const RGB                            = 0x1907;
  const RGBA                           = 0x1908;
  const LUMINANCE                      = 0x1909;
  const LUMINANCE_ALPHA                = 0x190A;
  const DEPTH_COMPONENT                = 0x1902;
  const DEPTH_STENCIL                  = 0x84F9;

  const R8                           = 0x8229;
  const R8_SNORM                     = 0x8F94;
  const R16F                         = 0x822D;
  const R32F                         = 0x822E;
  const R8UI                         = 0x8232;
  const R8I                          = 0x8231;
  const RG16UI                       = 0x823A;
  const RG16I                        = 0x8239;
  const RG32UI                       = 0x823C;
  const RG32I                        = 0x823B;
  const RG8                          = 0x822B;
  const RG8_SNORM                    = 0x8F95;
  const RG16F                        = 0x822F;
  const RG32F                        = 0x8230;
  const RG8UI                        = 0x8238;
  const RG8I                         = 0x8237;
  const R16UI                        = 0x8234;
  const R16I                         = 0x8233;
  const R32UI                        = 0x8236;
  const R32I                         = 0x8235;
  const RGB8                         = 0x8051;
  const SRGB8                        = 0x8C41;
  const RGB565                       = 0x8D62;
  const RGB8_SNORM                   = 0x8F96;
  const R11F_G11F_B10F               = 0x8C3A;
  const RGB9_E5                      = 0x8C3D;
  const RGB16F                       = 0x881B;
  const RGB32F                       = 0x8815;
  const RGB8UI                       = 0x8D7D;
  const RGB8I                        = 0x8D8F;
  const RGB16UI                      = 0x8D77;
  const RGB16I                       = 0x8D89;
  const RGB32UI                      = 0x8D71;
  const RGB32I                       = 0x8D83;
  const RGBA8                        = 0x8058;
  const SRGB8_ALPHA8                 = 0x8C43;
  const RGBA8_SNORM                  = 0x8F97;
  const RGB5_A1                      = 0x8057;
  const RGBA4                        = 0x8056;
  const RGB10_A2                     = 0x8059;
  const RGBA16F                      = 0x881A;
  const RGBA32F                      = 0x8814;
  const RGBA8UI                      = 0x8D7C;
  const RGBA8I                       = 0x8D8E;
  const RGB10_A2UI                   = 0x906F;
  const RGBA16UI                     = 0x8D76;
  const RGBA16I                      = 0x8D88;
  const RGBA32I                      = 0x8D82;
  const RGBA32UI                     = 0x8D70;

  const DEPTH_COMPONENT16            = 0x81A5;
  const DEPTH_COMPONENT24            = 0x81A6;
  const DEPTH_COMPONENT32F           = 0x8CAC;
  const DEPTH32F_STENCIL8            = 0x8CAD;
  const DEPTH24_STENCIL8             = 0x88F0;
  const STENCIL_INDEX8               = 0x8d48;

  /* DataType */
  // const BYTE                         = 0x1400;
  const UNSIGNED_BYTE                = 0x1401;
  // const SHORT                        = 0x1402;
  const UNSIGNED_SHORT               = 0x1403;
  // const INT                          = 0x1404;
  const UNSIGNED_INT                 = 0x1405;
  const FLOAT                        = 0x1406;
  const UNSIGNED_SHORT_4_4_4_4       = 0x8033;
  const UNSIGNED_SHORT_5_5_5_1       = 0x8034;
  const UNSIGNED_SHORT_5_6_5         = 0x8363;
  const HALF_FLOAT                   = 0x140B;
  const HALF_FLOAT_OES               = 0x8D61;  // Thanks Khronos for making this different >:(

  const SRGB_ALPHA_EXT               = 0x8C42;

  /**
   * @typedef {Object} TextureFormatDetails
   * @property {number} textureFormat format to pass texImage2D and similar functions.
   * @property {boolean} colorRenderable true if you can render to this format of texture.
   * @property {boolean} textureFilterable true if you can filter the texture, false if you can ony use `NEAREST`.
   * @property {number[]} type Array of possible types you can pass to texImage2D and similar function
   * @property {Object.<number,number>} bytesPerElementMap A map of types to bytes per element
   * @private
   */

  let s_textureInternalFormatInfo;
  function getTextureInternalFormatInfo(internalFormat) {
    if (!s_textureInternalFormatInfo) {
      // NOTE: these properties need unique names so we can let Uglify mangle the name.
      const t = {};
      // unsized formats
      t[ALPHA]              = { bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT], };
      t[LUMINANCE]          = { bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT], };
      t[LUMINANCE_ALPHA]    = { bytesPerElement: [2, 4, 4, 8],        type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT], };
      t[RGB]                = { bytesPerElement: [3, 6, 6, 12, 2],    type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_5_6_5], };
      t[RGBA]               = { bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1], };
      t[SRGB_ALPHA_EXT]     = { bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1], };
      t[DEPTH_COMPONENT]    = { bytesPerElement: [2, 4],              type: [UNSIGNED_INT, UNSIGNED_SHORT], };
      t[DEPTH_STENCIL]      = { bytesPerElement: [4],                 };

      // sized formats
      t[R8]                 = { bytesPerElement: [1],  };
      t[R8_SNORM]           = { bytesPerElement: [1],  };
      t[R16F]               = { bytesPerElement: [2],  };
      t[R32F]               = { bytesPerElement: [4],  };
      t[R8UI]               = { bytesPerElement: [1],  };
      t[R8I]                = { bytesPerElement: [1],  };
      t[R16UI]              = { bytesPerElement: [2],  };
      t[R16I]               = { bytesPerElement: [2],  };
      t[R32UI]              = { bytesPerElement: [4],  };
      t[R32I]               = { bytesPerElement: [4],  };
      t[RG8]                = { bytesPerElement: [2],  };
      t[RG8_SNORM]          = { bytesPerElement: [2],  };
      t[RG16F]              = { bytesPerElement: [4],  };
      t[RG32F]              = { bytesPerElement: [8],  };
      t[RG8UI]              = { bytesPerElement: [2],  };
      t[RG8I]               = { bytesPerElement: [2],  };
      t[RG16UI]             = { bytesPerElement: [4],  };
      t[RG16I]              = { bytesPerElement: [4],  };
      t[RG32UI]             = { bytesPerElement: [8],  };
      t[RG32I]              = { bytesPerElement: [8],  };
      t[RGB8]               = { bytesPerElement: [3],  };
      t[SRGB8]              = { bytesPerElement: [3],  };
      t[RGB565]             = { bytesPerElement: [2],  };
      t[RGB8_SNORM]         = { bytesPerElement: [3],  };
      t[R11F_G11F_B10F]     = { bytesPerElement: [4],  };
      t[RGB9_E5]            = { bytesPerElement: [4],  };
      t[RGB16F]             = { bytesPerElement: [6],  };
      t[RGB32F]             = { bytesPerElement: [12], };
      t[RGB8UI]             = { bytesPerElement: [3],  };
      t[RGB8I]              = { bytesPerElement: [3],  };
      t[RGB16UI]            = { bytesPerElement: [6],  };
      t[RGB16I]             = { bytesPerElement: [6],  };
      t[RGB32UI]            = { bytesPerElement: [12], };
      t[RGB32I]             = { bytesPerElement: [12], };
      t[RGBA8]              = { bytesPerElement: [4],  };
      t[SRGB8_ALPHA8]       = { bytesPerElement: [4],  };
      t[RGBA8_SNORM]        = { bytesPerElement: [4],  };
      t[RGB5_A1]            = { bytesPerElement: [2],  };
      t[RGBA4]              = { bytesPerElement: [2],  };
      t[RGB10_A2]           = { bytesPerElement: [4],  };
      t[RGBA16F]            = { bytesPerElement: [8],  };
      t[RGBA32F]            = { bytesPerElement: [16], };
      t[RGBA8UI]            = { bytesPerElement: [4],  };
      t[RGBA8I]             = { bytesPerElement: [4],  };
      t[RGB10_A2UI]         = { bytesPerElement: [4],  };
      t[RGBA16UI]           = { bytesPerElement: [8],  };
      t[RGBA16I]            = { bytesPerElement: [8],  };
      t[RGBA32I]            = { bytesPerElement: [16], };
      t[RGBA32UI]           = { bytesPerElement: [16], };
      // Sized Internal
      t[DEPTH_COMPONENT16]  = { bytesPerElement: [2],  };
      t[DEPTH_COMPONENT24]  = { bytesPerElement: [4],  };
      t[DEPTH_COMPONENT32F] = { bytesPerElement: [4],  };
      t[DEPTH24_STENCIL8]   = { bytesPerElement: [4],  };
      t[DEPTH32F_STENCIL8]  = { bytesPerElement: [4],  };
      t[STENCIL_INDEX8]     = { bytesPerElement: [1],  };

      s_textureInternalFormatInfo = t;
    }
    return s_textureInternalFormatInfo[internalFormat];
  }

  function makeComputeBlockRectSizeFunction(blockWidth, blockHeight, bytesPerBlock) {
    return function(width, height, depth) {
      const blocksAcross = (width + blockWidth - 1) / blockWidth | 0;
      const blocksDown =  (height + blockHeight - 1) / blockHeight | 0;
      return blocksAcross * blocksDown * bytesPerBlock * depth;
    };
  }

  function makeComputePaddedRectSizeFunction(minWidth, minHeight, divisor) {
    return function(width, height, depth) {
      return (Math.max(width, minWidth) * Math.max(height, minHeight) / divisor | 0) * depth;
    };
  }

  // WEBGL_compressed_texture_s3tc
  const COMPRESSED_RGB_S3TC_DXT1_EXT        = 0x83F0;
  const COMPRESSED_RGBA_S3TC_DXT1_EXT       = 0x83F1;
  const COMPRESSED_RGBA_S3TC_DXT3_EXT       = 0x83F2;
  const COMPRESSED_RGBA_S3TC_DXT5_EXT       = 0x83F3;
  // WEBGL_compressed_texture_etc1
  const COMPRESSED_RGB_ETC1_WEBGL           = 0x8D64;
  // WEBGL_compressed_texture_pvrtc
  const COMPRESSED_RGB_PVRTC_4BPPV1_IMG      = 0x8C00;
  const COMPRESSED_RGB_PVRTC_2BPPV1_IMG      = 0x8C01;
  const COMPRESSED_RGBA_PVRTC_4BPPV1_IMG     = 0x8C02;
  const COMPRESSED_RGBA_PVRTC_2BPPV1_IMG     = 0x8C03;
  // WEBGL_compressed_texture_etc
  const COMPRESSED_R11_EAC                        = 0x9270;
  const COMPRESSED_SIGNED_R11_EAC                 = 0x9271;
  const COMPRESSED_RG11_EAC                       = 0x9272;
  const COMPRESSED_SIGNED_RG11_EAC                = 0x9273;
  const COMPRESSED_RGB8_ETC2                      = 0x9274;
  const COMPRESSED_SRGB8_ETC2                     = 0x9275;
  const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2  = 0x9276;
  const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277;
  const COMPRESSED_RGBA8_ETC2_EAC                 = 0x9278;
  const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC          = 0x9279;
  // WEBGL_compressed_texture_astc
  const COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0;
  const COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1;
  const COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2;
  const COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3;
  const COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4;
  const COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5;
  const COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6;
  const COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7;
  const COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8;
  const COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9;
  const COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA;
  const COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB;
  const COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC;
  const COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD;
  // WEBGL_compressed_texture_s3tc_srgb
  const COMPRESSED_SRGB_S3TC_DXT1_EXT        = 0x8C4C;
  const COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT  = 0x8C4D;
  const COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT  = 0x8C4E;
  const COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT  = 0x8C4F;
  // EXT_texture_compression_bptc
  const COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8E8C;
  const COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 0x8E8D;
  const COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 0x8E8E;
  const COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 0x8E8F;
  // EXT_texture_compression_rgtc
  const COMPRESSED_RED_RGTC1_EXT = 0x8DBB;
  const COMPRESSED_SIGNED_RED_RGTC1_EXT = 0x8DBC;
  const COMPRESSED_RED_GREEN_RGTC2_EXT = 0x8DBD;
  const COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 0x8DBE;

  const compressedTextureFunctions = new Map([
    [ COMPRESSED_RGB_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGBA_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGBA_S3TC_DXT3_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_RGBA_S3TC_DXT5_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],

    [ COMPRESSED_RGB_ETC1_WEBGL, makeComputeBlockRectSizeFunction(4, 4, 8) ],

    [ COMPRESSED_RGB_PVRTC_4BPPV1_IMG, makeComputePaddedRectSizeFunction(8, 8, 2) ],
    [ COMPRESSED_RGBA_PVRTC_4BPPV1_IMG, makeComputePaddedRectSizeFunction(8, 8, 2) ],
    [ COMPRESSED_RGB_PVRTC_2BPPV1_IMG, makeComputePaddedRectSizeFunction(16, 8, 4) ],
    [ COMPRESSED_RGBA_PVRTC_2BPPV1_IMG, makeComputePaddedRectSizeFunction(16, 8, 4) ],

    [ COMPRESSED_R11_EAC, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SIGNED_R11_EAC, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGB8_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB8_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],

    [ COMPRESSED_RG11_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SIGNED_RG11_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_RGBA8_ETC2_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],

    [ COMPRESSED_RGBA_ASTC_4x4_KHR, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_RGBA_ASTC_5x4_KHR, makeComputeBlockRectSizeFunction(5, 4, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR, makeComputeBlockRectSizeFunction(5, 4, 16) ],
    [ COMPRESSED_RGBA_ASTC_5x5_KHR, makeComputeBlockRectSizeFunction(5, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR, makeComputeBlockRectSizeFunction(5, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_6x5_KHR, makeComputeBlockRectSizeFunction(6, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR, makeComputeBlockRectSizeFunction(6, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_6x6_KHR, makeComputeBlockRectSizeFunction(6, 6, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR, makeComputeBlockRectSizeFunction(6, 6, 16) ],
    [ COMPRESSED_RGBA_ASTC_8x5_KHR, makeComputeBlockRectSizeFunction(8, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR, makeComputeBlockRectSizeFunction(8, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_8x6_KHR, makeComputeBlockRectSizeFunction(8, 6, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR, makeComputeBlockRectSizeFunction(8, 6, 16) ],
    [ COMPRESSED_RGBA_ASTC_8x8_KHR, makeComputeBlockRectSizeFunction(8, 8, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR, makeComputeBlockRectSizeFunction(8, 8, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x5_KHR, makeComputeBlockRectSizeFunction(10, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR, makeComputeBlockRectSizeFunction(10, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x6_KHR, makeComputeBlockRectSizeFunction(10, 6, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR, makeComputeBlockRectSizeFunction(10, 6, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x8_KHR, makeComputeBlockRectSizeFunction(10, 8, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR, makeComputeBlockRectSizeFunction(10, 8, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x10_KHR, makeComputeBlockRectSizeFunction(10, 10, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, makeComputeBlockRectSizeFunction(10, 10, 16) ],
    [ COMPRESSED_RGBA_ASTC_12x10_KHR, makeComputeBlockRectSizeFunction(12, 10, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR, makeComputeBlockRectSizeFunction(12, 10, 16) ],
    [ COMPRESSED_RGBA_ASTC_12x12_KHR, makeComputeBlockRectSizeFunction(12, 12, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR, makeComputeBlockRectSizeFunction(12, 12, 16) ],

    [ COMPRESSED_SRGB_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],

    [ COMPRESSED_RGBA_BPTC_UNORM_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],

    [ COMPRESSED_RED_RGTC1_EXT, makeComputeBlockRectSizeFunction( 4, 4, 8 ) ],
    [ COMPRESSED_SIGNED_RED_RGTC1_EXT, makeComputeBlockRectSizeFunction( 4, 4, 8 ) ],
    [ COMPRESSED_RED_GREEN_RGTC2_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
  ]);

  /**
   * Gets the number of bytes per element for a given internalFormat / type
   * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
   * @param {number} type The type parameter for texImage2D etc..
   * @return {number} the number of bytes per element for the given internalFormat, type combo
   * @memberOf module:twgl/textures
   */
  function getBytesPerElementForInternalFormat(internalFormat, type) {
    const info = getTextureInternalFormatInfo(internalFormat);
    if (!info) {
      throw "unknown internal format";
    }
    if (info.type) {
      const ndx = info.type.indexOf(type);
      if (ndx < 0) {
        throw new Error(`unsupported type ${type} for internalformat ${internalFormat}`);
      }
      return info.bytesPerElement[ndx];
    }
    return info.bytesPerElement[0];
  }

  function getBytesForMipUncompressed(internalFormat, width, height, depth, type) {
    const bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);
    return width * height * depth * bytesPerElement;
  }

  function getBytesForMip(internalFormat, width, height, depth, type) {
    const fn = compressedTextureFunctions.get(internalFormat);
    return fn ? fn(width, height, depth) : getBytesForMipUncompressed(internalFormat, width, height, depth, type);
  }

  function isTypedArray(v) {
    return v && v.buffer && v.buffer instanceof ArrayBuffer;
  }

  function isBufferSource(v) {
    return isTypedArray(v) || v instanceof ArrayBuffer;
  }

  function getDrawingbufferInfo(gl) {
    return {
      samples: gl.getParameter(gl.SAMPLES) || 1,
      depthBits: gl.getParameter(gl.DEPTH_BITS),
      stencilBits: gl.getParameter(gl.STENCIL_BITS),
      contextAttributes: gl.getContextAttributes(),
    };
  }

  function computeDepthStencilSize(drawingBufferInfo) {
    const {depthBits, stencilBits} = drawingBufferInfo;
    const depthSize = (depthBits + stencilBits + 7) / 8 | 0;
    return depthSize === 3 ? 4 : depthSize;
  }

  function computeDrawingbufferSize(gl, drawingBufferInfo) {
    if (gl.isContextLost()) {
      return 0;
    }
    const {samples} = drawingBufferInfo;
    // this will need to change for hi-color support
    const colorSize = 4;
    const size = gl.drawingBufferWidth * gl.drawingBufferHeight;
    const depthStencilSize = computeDepthStencilSize(drawingBufferInfo);
    return size * colorSize + size * samples * colorSize + size * depthStencilSize;
  }

  // I know this is not a full check
  function isNumber(v) {
    return typeof v === 'number';
  }

  function collectObjects(state, type) {
    const list = [...state.webglObjectToMemory.keys()]
      .filter(obj => obj instanceof type)
      .map((obj) => state.webglObjectToMemory.get(obj));

    return list;
  }

  function getStackTrace() {
    const stack = (new Error()).stack;
    const lines = stack.split('\n');
    // Remove the first two entries, the error message and this function itself, or the webgl-memory itself.
    const userLines = lines.slice(2).filter((l) => !l.includes('webgl-memory.js'));
    return userLines.join('\n');
  }

  /*
  The MIT License (MIT)

  Copyright (c) 2021 Gregg Tavares

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Software, and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */

  //------------ [ from https://github.com/KhronosGroup/WebGLDeveloperTools ]

  /*
  ** Copyright (c) 2012 The Khronos Group Inc.
  **
  ** Permission is hereby granted, free of charge, to any person obtaining a
  ** copy of this software and/or associated documentation files (the
  ** "Materials"), to deal in the Materials without restriction, including
  ** without limitation the rights to use, copy, modify, merge, publish,
  ** distribute, sublicense, and/or sell copies of the Materials, and to
  ** permit persons to whom the Materials are furnished to do so, subject to
  ** the following conditions:
  **
  ** The above copyright notice and this permission notice shall be included
  ** in all copies or substantial portions of the Materials.
  **
  ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
  */


  const augmentedSet = new Set();

  /**
   * Given a WebGL context replaces all the functions with wrapped functions
   * that call gl.getError after every command
   *
   * @param {WebGLRenderingContext|Extension} ctx The webgl context to wrap.
   * @param {string} nameOfClass (eg, webgl, webgl2, OES_texture_float)
   */
  // eslint-disable-next-line consistent-return
  function augmentAPI(ctx, nameOfClass, options = {}) {

    if (augmentedSet.has(ctx)) {
      return ctx;
    }
    augmentedSet.add(ctx);

    const origGLErrorFn = options.origGLErrorFn || ctx.getError;

    function createSharedState(ctx) {
      const drawingBufferInfo = getDrawingbufferInfo(ctx);
      const sharedState = {
        baseContext: ctx,
        config: options,
        apis: {
          // custom extension
          gman_webgl_memory: {
            ctx: {
              getMemoryInfo() {
                const drawingbuffer = computeDrawingbufferSize(ctx, drawingBufferInfo);
                return {
                  memory: {
                    ...memory,
                    drawingbuffer,
                    total: drawingbuffer + memory.buffer + memory.texture + memory.renderbuffer,
                  },
                  resources: {
                    ...resources,
                  },
                };
              },
              getResourcesInfo(type) {
                return collectObjects(sharedState, type);
              },
            },
          },
        },
        resources: {},
        memory: {
          texture: 0,
          buffer: 0,
          renderbuffer: 0,
        },
        bindings: new Map(),
        defaultVertexArray: {},
        webglObjectToMemory: new Map(),
      };

      const unRestorableAPIs = new Set([
        'webgl',
        'webgl2',
        'webgl_lose_context',
      ]);

      function resetSharedState() {
        sharedState.bindings.clear();
        sharedState.webglObjectToMemory.clear();
        sharedState.webglObjectToMemory.set(sharedState.defaultVertexArray, {});
        sharedState.currentVertexArray = sharedState.defaultVertexArray;
        [sharedState.resources, sharedState.memory].forEach(function(obj) {
          for (const prop in obj) {
            obj[prop] = 0;
          }
        });
      }

      function handleContextLost() {
        // Issues:
        //   * all resources are lost.
        //     Solution: handled by resetSharedState
        //   * all functions are no-op
        //     Solutions:
        //        * swap all functions for noop
        //          (not so easy because some functions return values)
        //        * wrap all functions is a isContextLost check forwarder
        //          (slow? and same as above)
        //        * have each function manually check for context lost
        //          (simple but repetitive)
        //   * all extensions are lost
        //      Solution: For these we go through and restore all the functions
        //         on each extension
        resetSharedState();
        sharedState.isContextLost = true;

        // restore all original functions for extensions since
        // user will have to get new extensions.
        for (const [name, {ctx, origFuncs}] of [...Object.entries(sharedState.apis)]) {
          if (!unRestorableAPIs.has(name) && origFuncs) {
            augmentedSet.delete(ctx);
            for (const [funcName, origFn] of Object.entries(origFuncs)) {
              ctx[funcName] = origFn;
            }
            delete apis[name];
          }
        }
      }

      function handleContextRestored() {
        sharedState.isContextLost = false;
      }

      if (ctx.canvas) {
        ctx.canvas.addEventListener('webglcontextlost', handleContextLost);
        ctx.canvas.addEventListener('webglcontextrestored', handleContextRestored);
      }

      resetSharedState();
      return sharedState;
    }

    const sharedState = options.sharedState || createSharedState(ctx);
    options.sharedState = sharedState;

    const {
      apis,
      bindings,
      memory,
      resources,
      webglObjectToMemory,
    } = sharedState;

    const origFuncs = {};

    function noop() {
    }

    function makeCreateWrapper(ctx, typeName, _funcName) {
      const funcName = _funcName || `create${typeName[0].toUpperCase()}${typeName.substr(1)}`;
      if (!ctx[funcName]) {
        return null;
      }
      resources[typeName] = 0;
      return function(ctx, funcName, args, webglObj) {
        if (sharedState.isContextLost) {
          return;
        }
        ++resources[typeName];
        webglObjectToMemory.set(webglObj, {
          size: 0,
          stackCreated: getStackTrace(),
        });
      };
    }

    function makeDeleteWrapper(typeName, fn = noop, _funcName) {
      const funcName = _funcName || `delete${typeName[0].toUpperCase()}${typeName.substr(1)}`;
      if (!ctx[funcName]) {
        return null;
      }
      return function(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [obj] = args;
        const info = webglObjectToMemory.get(obj);
        if (info) {
          --resources[typeName];
          fn(obj, info);
          // TODO: handle resource counts
          webglObjectToMemory.delete(obj);
        }
      };
    }

    function updateRenderbuffer(target, samples, internalFormat, width, height) {
      if (sharedState.isContextLost) {
        return;
      }
      const obj = bindings.get(target);
      if (!obj) {
        throw new Error(`no renderbuffer bound to ${target}`);
      }
      const info = webglObjectToMemory.get(obj);
      if (!info) {
        throw new Error(`unknown renderbuffer ${obj}`);
      }

      const bytesForMip = getBytesForMip(internalFormat, width, height, 1);
      const newSize = bytesForMip * samples;

      memory.renderbuffer -= info.size;
      info.size = newSize;
      info.stackUpdated = getStackTrace();
      memory.renderbuffer += newSize;
    }

    const ELEMENT_ARRAY_BUFFER           = 0x8893;

    const UNSIGNED_BYTE                  = 0x1401;
    const TEXTURE_CUBE_MAP               = 0x8513;
    const TEXTURE_2D_ARRAY               = 0x8C1A;
    const TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
    const TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
    const TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
    const TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
    const TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
    const TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;

    const TEXTURE_BASE_LEVEL             = 0x813C;
    const TEXTURE_MAX_LEVEL              = 0x813D;

    const cubemapTargets = new Set([
      TEXTURE_CUBE_MAP_POSITIVE_X,
      TEXTURE_CUBE_MAP_NEGATIVE_X,
      TEXTURE_CUBE_MAP_POSITIVE_Y,
      TEXTURE_CUBE_MAP_NEGATIVE_Y,
      TEXTURE_CUBE_MAP_POSITIVE_Z,
      TEXTURE_CUBE_MAP_NEGATIVE_Z,
    ]);

    function isCubemapFace(target) {
      return cubemapTargets.has(target);
    }

    function getTextureInfo(target) {
      target = isCubemapFace(target) ? TEXTURE_CUBE_MAP : target;
      const obj = bindings.get(target);
      if (!obj) {
        throw new Error(`no texture bound to ${target}`);
      }
      const info = webglObjectToMemory.get(obj);
      if (!info) {
        throw new Error(`unknown texture ${obj}`);
      }
      return info;
    }

    function updateMipLevel(info, target, level, internalFormat, width, height, depth, type) {
      const oldSize = info.size;
      const newMipSize = getBytesForMip(internalFormat, width, height, depth, type);

      const faceNdx = isCubemapFace(target)
        ? target - TEXTURE_CUBE_MAP_POSITIVE_X
        : 0;

      info.mips = info.mips || [];
      info.mips[level] = info.mips[level] || [];
      const mipFaceInfo = info.mips[level][faceNdx] || {};
      info.size -= mipFaceInfo.size || 0;

      mipFaceInfo.size = newMipSize;
      mipFaceInfo.internalFormat = internalFormat;
      mipFaceInfo.type = type;
      mipFaceInfo.width = width;
      mipFaceInfo.height = height;
      mipFaceInfo.depth = depth;

      info.mips[level][faceNdx] = mipFaceInfo;
      info.size += newMipSize;

      memory.texture -= oldSize;
      memory.texture += info.size;

      info.stackUpdated = getStackTrace();
    }

    function updateTexStorage(target, levels, internalFormat, width, height, depth) {
      const info = getTextureInfo(target);
      const numFaces = target === TEXTURE_CUBE_MAP ? 6 : 1;
      const baseFaceTarget = target === TEXTURE_CUBE_MAP ? TEXTURE_CUBE_MAP_POSITIVE_X : target;
      for (let level = 0; level < levels; ++level) {
        for (let face = 0; face < numFaces; ++face) {
          updateMipLevel(info, baseFaceTarget + face, level, internalFormat, width, height, depth);
        }
        width = Math.ceil(Math.max(width / 2, 1));
        height = Math.ceil(Math.max(height / 2, 1));
        depth = target === TEXTURE_2D_ARRAY ? depth : Math.ceil(Math.max(depth / 2, 1));
      }
    }

    function handleBindVertexArray(gl, funcName, args) {
      if (sharedState.isContextLost) {
        return;
      }
      const [va] = args;
      sharedState.currentVertexArray = va ? va : sharedState.defaultVertexArray;
    }

    function handleBufferBinding(target, obj) {
      if (sharedState.isContextLost) {
        return;
      }
      switch (target) {
        case ELEMENT_ARRAY_BUFFER: {
            const info = webglObjectToMemory.get(sharedState.currentVertexArray);
            info.elementArrayBuffer = obj;
            break;
          }
        default:
          bindings.set(target, obj);
          break;
      }
    }

    const preChecks = {};
    const postChecks = {
      // WebGL1
      //   void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
      //   void bufferData(GLenum target, [AllowShared] BufferSource? srcData, GLenum usage);
      // WebGL2:
      //   void bufferData(GLenum target, [AllowShared] ArrayBufferView srcData, GLenum usage, GLuint srcOffset,
      //                   optional GLuint length = 0);
      bufferData(gl, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, src, /* usage */, /*srcOffset = 0*/, length = undefined] = args;
        let obj;
        switch (target) {
          case ELEMENT_ARRAY_BUFFER:
            {
              const info = webglObjectToMemory.get(sharedState.currentVertexArray);
              obj = info.elementArrayBuffer;
            }
            break;
          default:
            obj = bindings.get(target);
            break;
        }
        if (!obj) {
          throw new Error(`no buffer bound to ${target}`);
        }
        let newSize = 0;
        if (length !== undefined) {
          newSize = length * src.BYTES_PER_ELEMENT;
        } else if (isBufferSource(src)) {
          newSize = src.byteLength;
        } else if (isNumber(src)) {
          newSize = src;
        } else {
          throw new Error(`unsupported bufferData src type ${src}`);
        }

        const info = webglObjectToMemory.get(obj);
        if (!info) {
          throw new Error(`unknown buffer ${obj}`);
        }

        memory.buffer -= info.size;
        info.size = newSize;
        info.stackUpdated = getStackTrace();
        memory.buffer += newSize;
      },

      bindVertexArray: handleBindVertexArray,
      bindVertexArrayOES: handleBindVertexArray,

      bindBuffer(gl, funcName, args) {
        const [target, obj] = args;
        handleBufferBinding(target, obj);
      },

      bindBufferBase(gl, funcName, args) {
        const [target, /*ndx*/, obj] = args;
        handleBufferBinding(target, obj);
      },

      bindBufferRange(gl, funcName, args) {
        const [target, /*ndx*/, obj, /*offset*/, /*size*/] = args;
        handleBufferBinding(target, obj);
      },

      bindRenderbuffer(gl, funcName, args) {
        if (sharedState.isContextLost) {
         return;
        }
        const [target, obj] = args;
        bindings.set(target, obj);
      },

      bindTexture(gl, funcName, args) {
        if (sharedState.isContextLost) {
         return;
        }
        const [target, obj] = args;
        bindings.set(target, obj);
      },

      // void gl.copyTexImage2D(target, level, internalformat, x, y, width, height, border);
      copyTexImage2D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, /*x*/, /*y*/, width, height, /*border*/] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, 1, UNSIGNED_BYTE);
      },

      createBuffer: makeCreateWrapper(ctx, 'buffer'),
      createFramebuffer: makeCreateWrapper(ctx, 'framebuffer'),
      createRenderbuffer: makeCreateWrapper(ctx, 'renderbuffer'),
      createProgram: makeCreateWrapper(ctx, 'program'),
      createQuery: makeCreateWrapper(ctx, 'query'),
      createShader: makeCreateWrapper(ctx, 'shader'),
      createSampler: makeCreateWrapper(ctx, 'sampler'),
      createTexture: makeCreateWrapper(ctx, 'texture'),
      createTransformFeedback: makeCreateWrapper(ctx, 'transformFeedback'),
      createVertexArray: makeCreateWrapper(ctx, 'vertexArray'),
      createVertexArrayOES: makeCreateWrapper(ctx, 'vertexArray', 'createVertexArrayOES'),

      // WebGL 1:
      // void gl.compressedTexImage2D(target, level, internalformat, width, height, border, ArrayBufferView? pixels);
      //
      // Additionally available in WebGL 2:
      // read from buffer bound to gl.PIXEL_UNPACK_BUFFER
      // void gl.compressedTexImage2D(target, level, internalformat, width, height, border, GLsizei imageSize, GLintptr offset);
      // void gl.compressedTexImage2D(target, level, internalformat, width, height, border,
      //                              ArrayBufferView srcData, optional srcOffset, optional srcLengthOverride);
      compressedTexImage2D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, width, height] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, 1, UNSIGNED_BYTE);
      },

      // read from buffer bound to gl.PIXEL_UNPACK_BUFFER
      // void gl.compressedTexImage3D(target, level, internalformat, width, height, depth, border, GLsizei imageSize, GLintptr offset);
      // void gl.compressedTexImage3D(target, level, internalformat, width, height, depth, border,
      //                              ArrayBufferView srcData, optional srcOffset, optional srcLengthOverride);
      compressedTexImage3D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, width, height, depth] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, depth, UNSIGNED_BYTE);
      },

      deleteBuffer: makeDeleteWrapper('buffer', function(obj, info) {
        memory.buffer -= info.size;
      }),
      deleteFramebuffer: makeDeleteWrapper('framebuffer'),
      deleteProgram: makeDeleteWrapper('program'),
      deleteQuery: makeDeleteWrapper('query'),
      deleteRenderbuffer: makeDeleteWrapper('renderbuffer', function(obj, info) {
        memory.renderbuffer -= info.size;
      }),
      deleteSampler: makeDeleteWrapper('sampler'),
      deleteShader: makeDeleteWrapper('shader'),
      deleteSync: makeDeleteWrapper('sync'),
      deleteTexture: makeDeleteWrapper('texture', function(obj, info) {
        memory.texture -= info.size;
      }),
      deleteTransformFeedback: makeDeleteWrapper('transformFeedback'),
      deleteVertexArray: makeDeleteWrapper('vertexArray'),
      deleteVertexArrayOES: makeDeleteWrapper('vertexArray', noop, 'deleteVertexArrayOES'),

      fenceSync: function(ctx) {
        if (sharedState.isContextLost) {
          return undefined;
        }
        if (!ctx.fenceSync) {
          return undefined;
        }
        resources.sync = 0;
        return function(ctx, funcName, args, webglObj) {
          ++resources.sync;

          webglObjectToMemory.set(webglObj, {
            size: 0,
          });
        };
      }(ctx),

      generateMipmap(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target] = args;
        const info = getTextureInfo(target);
        const baseMipNdx = info.parameters ? info.parameters.get(TEXTURE_BASE_LEVEL) || 0 : 0;
        const maxMipNdx = info.parameters ? info.parameters.get(TEXTURE_MAX_LEVEL) || 1024 : 1024;
        const mipInfo = info.mips[baseMipNdx][0];
        let {width, height, depth} = mipInfo;
        const {internalFormat, type} = mipInfo;
        let level = baseMipNdx + 1;

        const numFaces = target === TEXTURE_CUBE_MAP ? 6 : 1;
        const baseFaceTarget = target === TEXTURE_CUBE_MAP ? TEXTURE_CUBE_MAP_POSITIVE_X : target;
        while (level <= maxMipNdx && !(width === 1 && height === 1 && (depth === 1 || target === TEXTURE_2D_ARRAY))) {
          width = Math.ceil(Math.max(width / 2, 1));
          height = Math.ceil(Math.max(height / 2, 1));
          depth = target === TEXTURE_2D_ARRAY ? depth : Math.ceil(Math.max(depth / 2, 1));
          for (let face = 0; face < numFaces; ++face) {
            updateMipLevel(info, baseFaceTarget + face, level, internalFormat, width, height, depth, type);
          }
          ++level;
        }
      },

      getSupportedExtensions(ctx, funcName, args, result) {
        if (sharedState.isContextLost) {
          return;
        }
        result.push('GMAN_webgl_memory');
      },

      // void gl.renderbufferStorage(target, internalFormat, width, height);
      // gl.RGBA4: 4 red bits, 4 green bits, 4 blue bits 4 alpha bits.
      // gl.RGB565: 5 red bits, 6 green bits, 5 blue bits.
      // gl.RGB5_A1: 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.
      // gl.DEPTH_COMPONENT16: 16 depth bits.
      // gl.STENCIL_INDEX8: 8 stencil bits.
      // gl.DEPTH_STENCIL
      renderbufferStorage(ctx, funcName, args) {
        const [target, internalFormat, width, height] = args;
        updateRenderbuffer(target, 1, internalFormat, width, height);
      },

      // void gl.renderbufferStorageMultisample(target, samples, internalFormat, width, height);
      renderbufferStorageMultisample(ctx, funcName, args) {
        const [target, samples, internalFormat, width, height] = args;
        updateRenderbuffer(target, samples, internalFormat, width, height);
      },

      texImage2D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        // WebGL1:
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ArrayBufferView? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, ImageData? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, HTMLImageElement? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, HTMLCanvasElement? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, HTMLVideoElement? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, ImageBitmap? pixels// );

        // WebGL2:
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, GLintptr offset);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, HTMLCanvasElement source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, HTMLImageElement source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, HTMLVideoElement source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ImageBitmap source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ImageData source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ArrayBufferView srcData, srcOffset);
        const [target, level, internalFormat] = args;
        let width;
        let height;
        let type;
        if (args.length === 6) {
          const src = args[5];
          width = src.width;
          height = src.height;
          type = args[4];
        } else {
          width = args[3];
          height = args[4];
          type = args[7];
        }

        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, 1, type);
      },

      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, GLintptr offset);
      //
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, HTMLCanvasElement source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, HTMLImageElement source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, HTMLVideoElement source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ImageBitmap source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ImageData source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ArrayBufferView? srcData);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ArrayBufferView srcData, srcOffset);

      texImage3D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, width, height, depth, /*border*/, /*format*/, type] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, depth, type);
      },

      texParameteri(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, pname, value] = args;
        const info = getTextureInfo(target);
        info.parameters = info.parameters || new Map();
        info.parameters.set(pname, value);
      },

      // void gl.texStorage2D(target, levels, internalformat, width, height);
      texStorage2D(ctx, funcName, args) {
        const [target, levels, internalFormat, width, height] = args;
        updateTexStorage(target, levels, internalFormat, width, height, 1);
      },

      // void gl.texStorage3D(target, levels, internalformat, width, height, depth);
      texStorage3D(ctx, funcName, args) {
        const [target, levels, internalFormat, width, height, depth] = args;
        updateTexStorage(target, levels, internalFormat, width, height, depth);
      },
    };

    const extraWrappers = {
      getExtension(ctx, propertyName) {
        if (sharedState.isContextLost) {
          return;
        }
        const origFn = ctx[propertyName];
        ctx[propertyName] = function(...args) {
          const extensionName = args[0].toLowerCase();
          const api = apis[extensionName];
          if (api) {
            return api.ctx;
          }
          const ext = origFn.call(ctx, ...args);
          if (ext) {
            augmentAPI(ext, extensionName, {...options, origGLErrorFn});
          }
          return ext;
        };
      },
    };

    // Makes a function that calls a WebGL function and then calls getError.
    function makeErrorWrapper(ctx, funcName) {
      const origFn = ctx[funcName];
      const preCheck = preChecks[funcName] || noop;
      const postCheck = postChecks[funcName] || noop;
      if (preCheck === noop && postChecks === noop) {
        return;
      }
      ctx[funcName] = function(...args) {
        preCheck(ctx, funcName, args);
        const result = origFn.call(ctx, ...args);
        postCheck(ctx, funcName, args, result);
        return result;
      };
      const extraWrapperFn = extraWrappers[funcName];
      if (extraWrapperFn) {
        extraWrapperFn(ctx, funcName, origGLErrorFn);
      }
    }

    // Wrap each function
    for (const propertyName in ctx) {
      if (typeof ctx[propertyName] === 'function') {
        origFuncs[propertyName] = ctx[propertyName];
        makeErrorWrapper(ctx, propertyName);
      }
    }

    apis[nameOfClass.toLowerCase()] = { ctx, origFuncs };
  }

  /*
  The MIT License (MIT)

  Copyright (c) 2021 Gregg Tavares

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Software, and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */

  function wrapGetContext(Ctor) {
    const oldFn = Ctor.prototype.getContext;
    Ctor.prototype.getContext = function(type, ...args) {
      const ctx = oldFn.call(this, type, ...args);
      // Using bindTexture to see if it's WebGL. Could check for instanceof WebGLRenderingContext
      // but that might fail if wrapped by debugging extension
      if (ctx && ctx.bindTexture) {
        const config = {};
        augmentAPI(ctx, type, config);
        ctx.getExtension('GMAN_webgl_memory');
      }
      return ctx;
    };
  }

  if (typeof HTMLCanvasElement !== 'undefined') {
    wrapGetContext(HTMLCanvasElement);
  }
  if (typeof OffscreenCanvas !== 'undefined') {
    wrapGetContext(OffscreenCanvas);
  }

}));

class Stats {

    constructor ( renderer ) {

    	this.renderer = renderer;
    	this.memo = this.renderer.getContext().getExtension('GMAN_webgl_memory');
		
    }

    get(){

    	const info = this.memo.getMemoryInfo();
	    const eng = this.renderer.info;

	    info['engine'] = {

	    	geometries : eng.memory.geometries,
			textures : eng.memory.textures,

		    calls : eng.render.calls,
			triangles : eng.render.triangles,
			points : eng.render.points,
			lines : eng.render.lines,
			//frame : eng.render.frame,

	    };

	    // can't remove background geometry !!
	    if( info.engine.geometries === 1 ) info.engine.geometries = 0;

	    return this.format( info )

    }

    format( t ){

    	let txt = t;

        if( t!=='' ){

            for( let j in t.memory ){
                //t.memory[j] = Math.round( t.memory[j]*0.000976563 )

                if( j === 'drawingbuffer' || j === 'total' ) t.memory[j] = Math.round( t.memory[j]*0.000001 ) + ' Mb';
                else t.memory[j] = Math.round( t.memory[j]*0.001 ) + ' Kb';

                //if( j === 'drawingbuffer' || j === 'total' ) t.memory[j] = Math.round( (t.memory[j]*0.000001 )/8) + ' Mo'
                //else t.memory[j] = Math.round( (t.memory[j]*0.001)/8 ) + ' Ko'

                //t.memory[j] = Math.round( t.memory[j] / 1024/ 1024 )
            }

            txt = JSON.stringify(t, null, 2);
            txt = txt.replace(/[",.*+?^${}()|[\]\\]/g, '');

        }

        return txt

    }

}

function e(e,t,n,r){return new(n||(n=Promise))((function(o,a){function i(e){try{d(r.next(e));}catch(e){a(e);}}function c(e){try{d(r.throw(e));}catch(e){a(e);}}function d(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t);}))).then(i,c);}d((r=r.apply(e,[])).next());}))}const t$2=["geforce 320m","geforce 8600","geforce 8600m gt","geforce 8800 gs","geforce 8800 gt","geforce 9400","geforce 9400m g","geforce 9400m","geforce 9600m gt","geforce 9600m","geforce fx go5200","geforce gt 120","geforce gt 130","geforce gt 330m","geforce gtx 285","google swiftshader","intel g41","intel g45","intel gma 4500mhd","intel gma x3100","intel hd 3000","intel q45","legacy","mali-2","mali-3","mali-4","quadro fx 1500","quadro fx 4","quadro fx 5","radeon hd 2400","radeon hd 2600","radeon hd 4670","radeon hd 4850","radeon hd 4870","radeon hd 5670","radeon hd 5750","radeon hd 6290","radeon hd 6300","radeon hd 6310","radeon hd 6320","radeon hd 6490m","radeon hd 6630m","radeon hd 6750m","radeon hd 6770m","radeon hd 6970m","sgx 543","sgx543"];function n$1(e){return e=e.toLowerCase().replace(/.*angle ?\((.+)\)(?: on vulkan [0-9.]+)?$/i,"$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g,"").replace(/(?:vulkan|opengl) \d+\.\d+(?:\.\d+)?(?: \((.*)\))?/,"$1")}const r=16384,o=4,a=35044,i$2=34962,c$1=5121,d=5126,l=6408,s=35632,f=35633,u="undefined"==typeof window,h$1=(()=>{if(u)return;const{userAgent:e,platform:t,maxTouchPoints:n}=window.navigator,r=/(iphone|ipod|ipad)/i.test(e),o="iPad"===t||"MacIntel"===t&&n>0&&!window.MSStream;return {isIpad:o,isMobile:/android/i.test(e)||r||o,isSafari12:/Version\/12.+Safari/.test(e)}})();function g$1(e,t,n){if(!n)return [t];const u=function(e){const t="\n    precision highp float;\n    attribute vec3 aPosition;\n    varying float vvv;\n    void main() {\n      vvv = 0.31622776601683794;\n      gl_Position = vec4(aPosition, 1.0);\n    }\n  ",n="\n    precision highp float;\n    varying float vvv;\n    void main() {\n      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n      enc = fract(enc);\n      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n      gl_FragColor = enc;\n    }\n  ",u=e.createShader(f),h=e.createShader(s),g=e.createProgram();if(!(h&&u&&g))return;e.shaderSource(u,t),e.shaderSource(h,n),e.compileShader(u),e.compileShader(h),e.attachShader(g,u),e.attachShader(g,h),e.linkProgram(g),e.detachShader(g,u),e.detachShader(g,h),e.deleteShader(u),e.deleteShader(h),e.useProgram(g);const p=e.createBuffer();e.bindBuffer(i$2,p),e.bufferData(i$2,new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),a);const m=e.getAttribLocation(g,"aPosition");e.vertexAttribPointer(m,3,d,false,0,0),e.enableVertexAttribArray(m),e.clearColor(1,1,1,1),e.clear(r),e.viewport(0,0,1,1),e.drawArrays(o,0,3);const v=new Uint8Array(4);return e.readPixels(0,0,1,1,l,c$1,v),e.deleteProgram(g),e.deleteBuffer(p),v.join("")}(e),g="801621810",p="8016218135",m="80162181161",v=(null==h$1?void 0:h$1.isIpad)?[["a7",m,12],["a8",p,15],["a8x",p,15],["a9",p,15],["a9x",p,15],["a10",p,15],["a10x",p,15],["a12",g,15],["a12x",g,15],["a12z",g,15],["a14",g,15],["m1",g,15]]:[["a7",m,12],["a8",p,12],["a9",p,15],["a10",p,15],["a11",g,15],["a12",g,15],["a13",g,15],["a14",g,15]];let w;"80162181255"===u?w=v.filter((([,,e])=>e>=14)):(w=v.filter((([,e])=>e===u)),w.length||(w=v));return w.map((([e])=>`apple ${e} gpu`))}let p$1 = class p extends Error{constructor(e){super(e),Object.setPrototypeOf(this,new.target.prototype);}};const m$1=[],v=[];function w$1(e,t){if(e===t)return 0;const n=e;e.length>t.length&&(e=t,t=n);let r=e.length,o=t.length;for(;r>0&&e.charCodeAt(~-r)===t.charCodeAt(~-o);)r--,o--;let a,i=0;for(;i<r&&e.charCodeAt(i)===t.charCodeAt(i);)i++;if(r-=i,o-=i,0===r)return o;let c,d,l=0,s=0,f=0;for(;s<r;)v[s]=e.charCodeAt(i+s),m$1[s]=++s;for(;f<o;)for(a=t.charCodeAt(i+f),c=f++,l=f,s=0;s<r;s++)d=a===v[s]?c:c+1,c=m$1[s],l=m$1[s]=c>l?d>l?l+1:d:d>c?c+1:d;return l}function x$2(e){return null!=e}const A$1=({mobileTiers:r=[0,15,30,60],desktopTiers:o=[0,15,30,60],override:a={},glContext:i,failIfMajorPerformanceCaveat:c=false,benchmarksURL:d="https://unpkg.com/detect-gpu@5.0.15/dist/benchmarks"}={})=>e(void 0,void 0,void 0,(function*(){const l={};if(u)return {tier:0,type:"SSR"};const{isIpad:s=!!(null==h$1?void 0:h$1.isIpad),isMobile:f=!!(null==h$1?void 0:h$1.isMobile),screenSize:m=window.screen,loadBenchmarks:v=(t=>e(void 0,void 0,void 0,(function*(){const e=yield fetch(`${d}/${t}`).then((e=>e.json()));if(parseInt(e.shift().split(".")[0],10)<4)throw new p$1("Detect GPU benchmark data is out of date. Please update to version 4x");return e})))}=a;let{renderer:A}=a;const P=e=>{const t=f?["adreno","apple","mali-t","mali","nvidia","powervr","samsung"]:["intel","apple","amd","radeon","nvidia","geforce"];for(const n of t)if(e.includes(n))return n};const b=(e,t,n,r,o)=>({device:o,fps:r,gpu:n,isMobile:f,tier:e,type:t});let S,y="";if(A)A=n$1(A),S=[A];else {const e=i||function(e,t=false){const n={alpha:false,antialias:false,depth:false,failIfMajorPerformanceCaveat:t,powerPreference:"high-performance",stencil:false};e&&delete n.powerPreference;const r=window.document.createElement("canvas"),o=r.getContext("webgl",n)||r.getContext("experimental-webgl",n);return null!=o?o:void 0}(null==h$1?void 0:h$1.isSafari12,c);if(!e)return b(0,"WEBGL_UNSUPPORTED");const t=e.getExtension("WEBGL_debug_renderer_info");if(t&&(A=e.getParameter(t.UNMASKED_RENDERER_WEBGL)),!A)return b(1,"FALLBACK");y=A,A=n$1(A),S=function(e,t,n){return "apple gpu"===t?g$1(e,t,n):[t]}(e,A,f);}const C=(yield Promise.all(S.map((function(t){var n;return e(this,void 0,void 0,(function*(){const e=P(t);if(!e)return;const r=`${f?"m":"d"}-${e}${s?"-ipad":""}.json`,o=l[r]=null!==(n=l[r])&&void 0!==n?n:v(r);let a;try{a=yield o;}catch(e){if(e instanceof p$1)throw e;return}const i=function(e){var t;const n=(e=e.replace(/\([^)]+\)/,"")).match(/\d+/)||e.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);return null!==(t=null==n?void 0:n.join("").replace(/\W|amd/g,""))&&void 0!==t?t:""}(t);let c=a.filter((([,e])=>e===i));c.length||(c=a.filter((([e])=>e.includes(t))));const d=c.length;if(0===d)return;const u=t.split(/[.,()\[\]/\s]/g).sort().filter(((e,t,n)=>0===t||e!==n[t-1])).join(" ");let h,[g,,,,x]=d>1?c.map((e=>[e,w$1(u,e[2])])).sort((([,e],[,t])=>e-t))[0][0]:c[0],A=Number.MAX_VALUE;const{devicePixelRatio:b}=window,S=m.width*b*m.height*b;for(const e of x){const[t,n]=e,r=t*n,o=Math.abs(S-r);o<A&&(A=o,h=e);}if(!h)return;const[,,y,C]=h;return [A,y,g,C]}))})))).filter(x$2).sort((([e=Number.MAX_VALUE,t],[n=Number.MAX_VALUE,r])=>e===n?t-r:e-n));if(!C.length){const e=t$2.find((e=>A.includes(e)));return e?b(0,"BLOCKLISTED",e):b(1,"FALLBACK",`${A} (${y})`)}const[,E,L,M]=C[0];if(-1===E)return b(0,"BLOCKLISTED",L,E,M);const $=f?r:o;let B=0;for(let e=0;e<$.length;e++)E>=$[e]&&(B=e);return b(B,"BENCHMARK",L,E,M)}));

/**
 * The Ease class provides a collection of easing functions for use with tween.js.
 */
var Easing = Object.freeze({
    Linear: Object.freeze({
        None: function (amount) {
            return amount;
        },
        In: function (amount) {
            return amount;
        },
        Out: function (amount) {
            return amount;
        },
        InOut: function (amount) {
            return amount;
        },
    }),
    Quadratic: Object.freeze({
        In: function (amount) {
            return amount * amount;
        },
        Out: function (amount) {
            return amount * (2 - amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount;
            }
            return -0.5 * (--amount * (amount - 2) - 1);
        },
    }),
    Cubic: Object.freeze({
        In: function (amount) {
            return amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount + 2);
        },
    }),
    Quartic: Object.freeze({
        In: function (amount) {
            return amount * amount * amount * amount;
        },
        Out: function (amount) {
            return 1 - --amount * amount * amount * amount;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount;
            }
            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
        },
    }),
    Quintic: Object.freeze({
        In: function (amount) {
            return amount * amount * amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
        },
    }),
    Sinusoidal: Object.freeze({
        In: function (amount) {
            return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);
        },
        Out: function (amount) {
            return Math.sin((amount * Math.PI) / 2);
        },
        InOut: function (amount) {
            return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));
        },
    }),
    Exponential: Object.freeze({
        In: function (amount) {
            return amount === 0 ? 0 : Math.pow(1024, amount - 1);
        },
        Out: function (amount) {
            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            if ((amount *= 2) < 1) {
                return 0.5 * Math.pow(1024, amount - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
        },
    }),
    Circular: Object.freeze({
        In: function (amount) {
            return 1 - Math.sqrt(1 - amount * amount);
        },
        Out: function (amount) {
            return Math.sqrt(1 - --amount * amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
        },
    }),
    Elastic: Object.freeze({
        In: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        },
        Out: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            amount *= 2;
            if (amount < 1) {
                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
        },
    }),
    Back: Object.freeze({
        In: function (amount) {
            var s = 1.70158;
            return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);
        },
        Out: function (amount) {
            var s = 1.70158;
            return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;
        },
        InOut: function (amount) {
            var s = 1.70158 * 1.525;
            if ((amount *= 2) < 1) {
                return 0.5 * (amount * amount * ((s + 1) * amount - s));
            }
            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
        },
    }),
    Bounce: Object.freeze({
        In: function (amount) {
            return 1 - Easing.Bounce.Out(1 - amount);
        },
        Out: function (amount) {
            if (amount < 1 / 2.75) {
                return 7.5625 * amount * amount;
            }
            else if (amount < 2 / 2.75) {
                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
            }
            else if (amount < 2.5 / 2.75) {
                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
            }
            else {
                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
            }
        },
        InOut: function (amount) {
            if (amount < 0.5) {
                return Easing.Bounce.In(amount * 2) * 0.5;
            }
            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
        },
    }),
    generatePow: function (power) {
        if (power === void 0) { power = 4; }
        power = power < Number.EPSILON ? Number.EPSILON : power;
        power = power > 10000 ? 10000 : power;
        return {
            In: function (amount) {
                return Math.pow(amount, power);
            },
            Out: function (amount) {
                return 1 - Math.pow((1 - amount), power);
            },
            InOut: function (amount) {
                if (amount < 0.5) {
                    return Math.pow((amount * 2), power) / 2;
                }
                return (1 - Math.pow((2 - amount * 2), power)) / 2 + 0.5;
            },
        };
    },
});

var now = function () { return performance.now(); };

/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tween
 */
var Group = /** @class */ (function () {
    function Group() {
        this._tweens = {};
        this._tweensAddedDuringUpdate = {};
    }
    Group.prototype.getAll = function () {
        var _this = this;
        return Object.keys(this._tweens).map(function (tweenId) {
            return _this._tweens[tweenId];
        });
    };
    Group.prototype.removeAll = function () {
        this._tweens = {};
    };
    Group.prototype.add = function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group.prototype.remove = function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group.prototype.update = function (time, preserve) {
        if (time === void 0) { time = now(); }
        if (preserve === void 0) { preserve = false; }
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        // Tweens are updated in "batches". If you add a new tween during an
        // update, then the new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated.
        // However, if the removed tween was added during the current batch,
        // then it will not be updated.
        while (tweenIds.length > 0) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                var autoStart = !preserve;
                if (tween && tween.update(time, autoStart) === false && !preserve) {
                    delete this._tweens[tweenIds[i]];
                }
            }
            tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
        return true;
    };
    return Group;
}());

/**
 *
 */
var Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        }},
};

/**
 * Utils
 */
var Sequence = /** @class */ (function () {
    function Sequence() {
    }
    Sequence.nextId = function () {
        return Sequence._nextId++;
    };
    Sequence._nextId = 0;
    return Sequence;
}());

var mainGroup = new Group();

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var Tween = /** @class */ (function () {
    function Tween(_object, _group) {
        if (_group === void 0) { _group = mainGroup; }
        this._object = _object;
        this._group = _group;
        this._isPaused = false;
        this._pauseStart = 0;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._isDynamic = false;
        this._initialRepeat = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._isPlaying = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = 0;
        this._easingFunction = Easing.Linear.None;
        this._interpolationFunction = Interpolation.Linear;
        // eslint-disable-next-line
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._onEveryStartCallbackFired = false;
        this._id = Sequence.nextId();
        this._isChainStopped = false;
        this._propertiesAreSetUp = false;
        this._goToEnd = false;
    }
    Tween.prototype.getId = function () {
        return this._id;
    };
    Tween.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    Tween.prototype.isPaused = function () {
        return this._isPaused;
    };
    Tween.prototype.getDuration = function () {
        return this._duration;
    };
    Tween.prototype.to = function (target, duration) {
        if (duration === void 0) { duration = 1000; }
        if (this._isPlaying)
            throw new Error('Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.');
        this._valuesEnd = target;
        this._propertiesAreSetUp = false;
        this._duration = duration < 0 ? 0 : duration;
        return this;
    };
    Tween.prototype.duration = function (duration) {
        if (duration === void 0) { duration = 1000; }
        this._duration = duration < 0 ? 0 : duration;
        return this;
    };
    Tween.prototype.dynamic = function (dynamic) {
        if (dynamic === void 0) { dynamic = false; }
        this._isDynamic = dynamic;
        return this;
    };
    Tween.prototype.start = function (time, overrideStartingValues) {
        if (time === void 0) { time = now(); }
        if (overrideStartingValues === void 0) { overrideStartingValues = false; }
        if (this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.add(this);
        this._repeat = this._initialRepeat;
        if (this._reversed) {
            // If we were reversed (f.e. using the yoyo feature) then we need to
            // flip the tween direction back to forward.
            this._reversed = false;
            for (var property in this._valuesStartRepeat) {
                this._swapEndStartRepeatValues(property);
                this._valuesStart[property] = this._valuesStartRepeat[property];
            }
        }
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._onEveryStartCallbackFired = false;
        this._isChainStopped = false;
        this._startTime = time;
        this._startTime += this._delayTime;
        if (!this._propertiesAreSetUp || overrideStartingValues) {
            this._propertiesAreSetUp = true;
            // If dynamic is not enabled, clone the end values instead of using the passed-in end values.
            if (!this._isDynamic) {
                var tmp = {};
                for (var prop in this._valuesEnd)
                    tmp[prop] = this._valuesEnd[prop];
                this._valuesEnd = tmp;
            }
            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);
        }
        return this;
    };
    Tween.prototype.startFromCurrentValues = function (time) {
        return this.start(time, true);
    };
    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {
        for (var property in _valuesEnd) {
            var startValue = _object[property];
            var startValueIsArray = Array.isArray(startValue);
            var propType = startValueIsArray ? 'array' : typeof startValue;
            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
            // If `to()` specifies a property that doesn't exist in the source object,
            // we should not set that property in the object
            if (propType === 'undefined' || propType === 'function') {
                continue;
            }
            // Check if an Array was provided as property value
            if (isInterpolationList) {
                var endValues = _valuesEnd[property];
                if (endValues.length === 0) {
                    continue;
                }
                // Handle an array of relative values.
                // Creates a local copy of the Array with the start value at the front
                var temp = [startValue];
                for (var i = 0, l = endValues.length; i < l; i += 1) {
                    var value = this._handleRelativeValue(startValue, endValues[i]);
                    if (isNaN(value)) {
                        isInterpolationList = false;
                        console.warn('Found invalid interpolation list. Skipping.');
                        break;
                    }
                    temp.push(value);
                }
                if (isInterpolationList) {
                    // if (_valuesStart[property] === undefined) { // handle end values only the first time. NOT NEEDED? setupProperties is now guarded by _propertiesAreSetUp.
                    _valuesEnd[property] = temp;
                    // }
                }
            }
            // handle the deepness of the values
            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                _valuesStart[property] = startValueIsArray ? [] : {};
                var nestedObject = startValue;
                for (var prop in nestedObject) {
                    _valuesStart[property][prop] = nestedObject[prop];
                }
                // TODO? repeat nested values? And yoyo? And array values?
                _valuesStartRepeat[property] = startValueIsArray ? [] : {};
                var endValues = _valuesEnd[property];
                // If dynamic is not enabled, clone the end values instead of using the passed-in end values.
                if (!this._isDynamic) {
                    var tmp = {};
                    for (var prop in endValues)
                        tmp[prop] = endValues[prop];
                    _valuesEnd[property] = endValues = tmp;
                }
                this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);
            }
            else {
                // Save the starting value, but only once unless override is requested.
                if (typeof _valuesStart[property] === 'undefined' || overrideStartingValues) {
                    _valuesStart[property] = startValue;
                }
                if (!startValueIsArray) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                }
                if (isInterpolationList) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                }
                else {
                    _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
            }
        }
    };
    Tween.prototype.stop = function () {
        if (!this._isChainStopped) {
            this._isChainStopped = true;
            this.stopChainedTweens();
        }
        if (!this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback) {
            this._onStopCallback(this._object);
        }
        return this;
    };
    Tween.prototype.end = function () {
        this._goToEnd = true;
        this.update(Infinity);
        return this;
    };
    Tween.prototype.pause = function (time) {
        if (time === void 0) { time = now(); }
        if (this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = true;
        this._pauseStart = time;
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        return this;
    };
    Tween.prototype.resume = function (time) {
        if (time === void 0) { time = now(); }
        if (!this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = false;
        this._startTime += time - this._pauseStart;
        this._pauseStart = 0;
        // eslint-disable-next-line
        this._group && this._group.add(this);
        return this;
    };
    Tween.prototype.stopChainedTweens = function () {
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].stop();
        }
        return this;
    };
    Tween.prototype.group = function (group) {
        if (group === void 0) { group = mainGroup; }
        this._group = group;
        return this;
    };
    Tween.prototype.delay = function (amount) {
        if (amount === void 0) { amount = 0; }
        this._delayTime = amount;
        return this;
    };
    Tween.prototype.repeat = function (times) {
        if (times === void 0) { times = 0; }
        this._initialRepeat = times;
        this._repeat = times;
        return this;
    };
    Tween.prototype.repeatDelay = function (amount) {
        this._repeatDelayTime = amount;
        return this;
    };
    Tween.prototype.yoyo = function (yoyo) {
        if (yoyo === void 0) { yoyo = false; }
        this._yoyo = yoyo;
        return this;
    };
    Tween.prototype.easing = function (easingFunction) {
        if (easingFunction === void 0) { easingFunction = Easing.Linear.None; }
        this._easingFunction = easingFunction;
        return this;
    };
    Tween.prototype.interpolation = function (interpolationFunction) {
        if (interpolationFunction === void 0) { interpolationFunction = Interpolation.Linear; }
        this._interpolationFunction = interpolationFunction;
        return this;
    };
    // eslint-disable-next-line
    Tween.prototype.chain = function () {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tweens[_i] = arguments[_i];
        }
        this._chainedTweens = tweens;
        return this;
    };
    Tween.prototype.onStart = function (callback) {
        this._onStartCallback = callback;
        return this;
    };
    Tween.prototype.onEveryStart = function (callback) {
        this._onEveryStartCallback = callback;
        return this;
    };
    Tween.prototype.onUpdate = function (callback) {
        this._onUpdateCallback = callback;
        return this;
    };
    Tween.prototype.onRepeat = function (callback) {
        this._onRepeatCallback = callback;
        return this;
    };
    Tween.prototype.onComplete = function (callback) {
        this._onCompleteCallback = callback;
        return this;
    };
    Tween.prototype.onStop = function (callback) {
        this._onStopCallback = callback;
        return this;
    };
    /**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */
    Tween.prototype.update = function (time, autoStart) {
        var _a;
        if (time === void 0) { time = now(); }
        if (autoStart === void 0) { autoStart = true; }
        if (this._isPaused)
            return true;
        var endTime = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
            if (time > endTime)
                return false;
            if (autoStart)
                this.start(time, true);
        }
        this._goToEnd = false;
        if (time < this._startTime) {
            return true;
        }
        if (this._onStartCallbackFired === false) {
            if (this._onStartCallback) {
                this._onStartCallback(this._object);
            }
            this._onStartCallbackFired = true;
        }
        if (this._onEveryStartCallbackFired === false) {
            if (this._onEveryStartCallback) {
                this._onEveryStartCallback(this._object);
            }
            this._onEveryStartCallbackFired = true;
        }
        var elapsedTime = time - this._startTime;
        var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);
        var totalTime = this._duration + this._repeat * durationAndDelay;
        var elapsed = this._calculateElapsedPortion(elapsedTime, durationAndDelay, totalTime);
        var value = this._easingFunction(elapsed);
        var status = this._calculateCompletionStatus(elapsedTime, durationAndDelay);
        if (status === 'repeat') {
            // the current update is happening after the instant the tween repeated
            this._processRepetition(elapsedTime, durationAndDelay);
        }
        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
        if (status === 'about-to-repeat') {
            // the current update is happening at the exact instant the tween is going to repeat
            // the values should match the end of the tween, not the beginning,
            // that's why _processRepetition happens after _updateProperties
            this._processRepetition(elapsedTime, durationAndDelay);
        }
        if (this._onUpdateCallback) {
            this._onUpdateCallback(this._object, elapsed);
        }
        if (status === 'repeat' || status === 'about-to-repeat') {
            if (this._onRepeatCallback) {
                this._onRepeatCallback(this._object);
            }
            this._onEveryStartCallbackFired = false;
        }
        else if (status === 'completed') {
            this._isPlaying = false;
            if (this._onCompleteCallback) {
                this._onCompleteCallback(this._object);
            }
            for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                // Make the chained tweens start exactly at the time they should,
                // even if the `update()` method was called way past the duration of the tween
                this._chainedTweens[i].start(this._startTime + this._duration, false);
            }
        }
        return status !== 'completed';
    };
    Tween.prototype._calculateElapsedPortion = function (elapsedTime, durationAndDelay, totalTime) {
        if (this._duration === 0 || elapsedTime > totalTime) {
            return 1;
        }
        var timeIntoCurrentRepeat = elapsedTime % durationAndDelay;
        var portion = Math.min(timeIntoCurrentRepeat / this._duration, 1);
        if (portion === 0 && elapsedTime !== 0 && elapsedTime % this._duration === 0) {
            return 1;
        }
        return portion;
    };
    Tween.prototype._calculateCompletionStatus = function (elapsedTime, durationAndDelay) {
        if (this._duration !== 0 && elapsedTime < this._duration) {
            return 'playing';
        }
        if (this._repeat <= 0) {
            return 'completed';
        }
        if (elapsedTime === this._duration) {
            return 'about-to-repeat';
        }
        return 'repeat';
    };
    Tween.prototype._processRepetition = function (elapsedTime, durationAndDelay) {
        var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);
        if (isFinite(this._repeat)) {
            this._repeat -= completeCount;
        }
        // Reassign starting values, restart by making startTime = now
        for (var property in this._valuesStartRepeat) {
            var valueEnd = this._valuesEnd[property];
            if (!this._yoyo && typeof valueEnd === 'string') {
                this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(valueEnd);
            }
            if (this._yoyo) {
                this._swapEndStartRepeatValues(property);
            }
            this._valuesStart[property] = this._valuesStartRepeat[property];
        }
        if (this._yoyo) {
            this._reversed = !this._reversed;
        }
        this._startTime += durationAndDelay * completeCount;
    };
    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
        for (var property in _valuesEnd) {
            // Don't update properties that do not exist in the source object
            if (_valuesStart[property] === undefined) {
                continue;
            }
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];
            var startIsArray = Array.isArray(_object[property]);
            var endIsArray = Array.isArray(end);
            var isInterpolationList = !startIsArray && endIsArray;
            if (isInterpolationList) {
                _object[property] = this._interpolationFunction(end, value);
            }
            else if (typeof end === 'object' && end) {
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._updateProperties(_object[property], start, end, value);
            }
            else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                end = this._handleRelativeValue(start, end);
                // Protect against non numeric properties.
                if (typeof end === 'number') {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _object[property] = start + (end - start) * value;
                }
            }
        }
    };
    Tween.prototype._handleRelativeValue = function (start, end) {
        if (typeof end !== 'string') {
            return end;
        }
        if (end.charAt(0) === '+' || end.charAt(0) === '-') {
            return start + parseFloat(end);
        }
        return parseFloat(end);
    };
    Tween.prototype._swapEndStartRepeatValues = function (property) {
        var tmp = this._valuesStartRepeat[property];
        var endValue = this._valuesEnd[property];
        if (typeof endValue === 'string') {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
        }
        else {
            this._valuesStartRepeat[property] = this._valuesEnd[property];
        }
        this._valuesEnd[property] = tmp;
    };
    return Tween;
}());

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
Sequence.nextId;
/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tweens.
 */
var TWEEN = mainGroup;
// This is the best way to export things in a way that's compatible with both ES
// Modules and CommonJS, without build hacks, and so as not to break the
// existing API.
// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
TWEEN.getAll.bind(TWEEN);
TWEEN.removeAll.bind(TWEEN);
TWEEN.add.bind(TWEEN);
var remove$1 = TWEEN.remove.bind(TWEEN);
TWEEN.update.bind(TWEEN);

// OrbitControls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };
const _ray = new Ray$1();
const _plane$1 = new Plane();
const TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );

class OrbitControls extends EventDispatcher {

	constructor( object, domElement ) {

		super();

		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new Vector3();

		// Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect
		this.cursor = new Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// Limit camera target within a spherical area around the cursor
		this.minTargetRadius = 0;
		this.maxTargetRadius = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push
		this.zoomToCursor = false;

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Mouse buttons
		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

		// Touch fingers
		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.getSpherical = function () {

			return spherical;

		};
		
		this.getState = function () {

			return state;

		};

		this.getDistance = function () {

			return this.object.position.distanceTo( this.target );

		};

		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.stopListenToKeyEvents = function () {

			this._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = null;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( _changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			const offset = new Vector3();

			// so camera.up is the orbit axis
			const quat = new Quaternion$1().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
			const quatInverse = quat.clone().invert();

			const lastPosition = new Vector3();
			const lastQuaternion = new Quaternion$1();
			const lastTargetPosition = new Vector3();

			const twoPI = 2 * Math.PI;

			return function update( deltaTime = null ) {

				const position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle( deltaTime ) );

				}

				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;

				if ( isFinite( min ) && isFinite( max ) ) {

					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

					if ( min <= max ) {

						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

					} else {

						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
							Math.max( min, spherical.theta ) :
							Math.min( max, spherical.theta );

					}

				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				// Limit the target distance from the cursor to create a sphere around the center of interest
				scope.target.sub( scope.cursor );
				scope.target.clampLength( scope.minTargetRadius, scope.maxTargetRadius );
				scope.target.add( scope.cursor );

				let zoomChanged = false;
				// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
				// we adjust zoom later in these cases
				if ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {

					spherical.radius = clampDistance( spherical.radius );

				} else {

					const prevRadius = spherical.radius;
					spherical.radius = clampDistance( spherical.radius * scale );
					zoomChanged = prevRadius != spherical.radius;

				}

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

				// adjust camera position
				if ( scope.zoomToCursor && performCursorZoom ) {

					let newRadius = null;
					if ( scope.object.isPerspectiveCamera ) {

						// move the camera down the pointer ray
						// this method avoids floating point error
						const prevRadius = offset.length();
						newRadius = clampDistance( prevRadius * scale );

						const radiusDelta = prevRadius - newRadius;
						scope.object.position.addScaledVector( dollyDirection, radiusDelta );
						scope.object.updateMatrixWorld();

						zoomChanged = !! radiusDelta;

					} else if ( scope.object.isOrthographicCamera ) {

						// adjust the ortho camera position based on zoom changes
						const mouseBefore = new Vector3( mouse.x, mouse.y, 0 );
						mouseBefore.unproject( scope.object );

						const prevZoom = scope.object.zoom;
						scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );
						scope.object.updateProjectionMatrix();

						zoomChanged = prevZoom !== scope.object.zoom;

						const mouseAfter = new Vector3( mouse.x, mouse.y, 0 );
						mouseAfter.unproject( scope.object );

						scope.object.position.sub( mouseAfter ).add( mouseBefore );
						scope.object.updateMatrixWorld();

						newRadius = offset.length();

					} else {

						console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
						scope.zoomToCursor = false;

					}

					// handle the placement of the target
					if ( newRadius !== null ) {

						if ( this.screenSpacePanning ) {

							// position the orbit target in front of the new camera position
							scope.target.set( 0, 0, -1 )
								.transformDirection( scope.object.matrix )
								.multiplyScalar( newRadius )
								.add( scope.object.position );

						} else {

							// get the ray and translation plane to compute target
							_ray.origin.copy( scope.object.position );
							_ray.direction.set( 0, 0, -1 ).transformDirection( scope.object.matrix );

							// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
							// extremely large values
							if ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {

								object.lookAt( scope.target );

							} else {

								_plane$1.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );
								_ray.intersectPlane( _plane$1, scope.target );

							}

						}

					}

				} else if ( scope.object.isOrthographicCamera ) {

					const prevZoom = scope.object.zoom;
					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );

					if ( prevZoom !== scope.object.zoom ) {

						scope.object.updateProjectionMatrix();
						zoomChanged = true;

					}

				}

				scale = 1;
				performCursorZoom = false;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||
					lastTargetPosition.distanceToSquared( scope.target ) > EPS ) {

					scope.dispatchEvent( _changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					lastTargetPosition.copy( scope.target );

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerUp );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.removeEventListener( 'pointerup', onPointerUp );

			const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

			document.removeEventListener( 'keydown', interceptControlDown, { capture: true } );

			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
				scope._domElementKeyEvents = null;

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: -1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new Spherical();
		const sphericalDelta = new Spherical();

		let scale = 1;
		const panOffset = new Vector3();

		const rotateStart = new Vector2();
		const rotateEnd = new Vector2();
		const rotateDelta = new Vector2();

		const panStart = new Vector2();
		const panEnd = new Vector2();
		const panDelta = new Vector2();

		const dollyStart = new Vector2();
		const dollyEnd = new Vector2();
		const dollyDelta = new Vector2();

		const dollyDirection = new Vector3();
		const mouse = new Vector2();
		let performCursorZoom = false;

		const pointers = [];
		const pointerPositions = {};

		let controlActive = false;

		function getAutoRotationAngle( deltaTime ) {

			if ( deltaTime !== null ) {

				return ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime;

			} else {

				return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

			}

		}

		function getZoomScale( delta ) {

			const normalizedDelta = Math.abs( delta * 0.01 );
			return Math.pow( 0.95, scope.zoomSpeed * normalizedDelta );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		const panLeft = function () {

			const v = new Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		const panUp = function () {

			const v = new Vector3();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {

			const offset = new Vector3();

			return function pan( deltaX, deltaY ) {

				const element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					const position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale /= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale *= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function updateZoomParameters( x, y ) {

			if ( ! scope.zoomToCursor ) {

				return;

			}

			performCursorZoom = true;

			const rect = scope.domElement.getBoundingClientRect();
			const dx = x - rect.left;
			const dy = y - rect.top;
			const w = rect.width;
			const h = rect.height;

			mouse.x = ( dx / w ) * 2 - 1;
			mouse.y = - ( dy / h ) * 2 + 1;

			dollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize();

		}

		function clampDistance( dist ) {

			return Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			updateZoomParameters( event.clientX, event.clientX );
			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale( dollyDelta.y ) );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale( dollyDelta.y ) );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseWheel( event ) {

			updateZoomParameters( event.clientX, event.clientY );

			if ( event.deltaY < 0 ) {

				dollyIn( getZoomScale( event.deltaY ) );

			} else if ( event.deltaY > 0 ) {

				dollyOut( getZoomScale( event.deltaY ) );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			switch ( event.code ) {

				case scope.keys.UP:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( -2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, - scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.LEFT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

				case scope.keys.RIGHT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( -2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( - scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate( event ) {

			if ( pointers.length === 1 ) {

				rotateStart.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan( event ) {

			if ( pointers.length === 1 ) {

				panStart.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchStartDolly( event );

			if ( scope.enablePan ) handleTouchStartPan( event );

		}

		function handleTouchStartDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchStartDolly( event );

			if ( scope.enableRotate ) handleTouchStartRotate( event );

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

			const centerX = ( event.pageX + position.x ) * 0.5;
			const centerY = ( event.pageY + position.y ) * 0.5;

			updateZoomParameters( centerX, centerY );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.setPointerCapture( event.pointerId );

				scope.domElement.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.addEventListener( 'pointerup', onPointerUp );

			}

			//

			if ( isTrackingPointer( event ) ) return;

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

			removePointer( event );

			switch ( pointers.length ) {

				case 0:

					scope.domElement.releasePointerCapture( event.pointerId );

					scope.domElement.removeEventListener( 'pointermove', onPointerMove );
					scope.domElement.removeEventListener( 'pointerup', onPointerUp );

					scope.dispatchEvent( _endEvent );

					state = STATE.NONE;

					break;

				case 1:

					const pointerId = pointers[ 0 ];
					const position = pointerPositions[ pointerId ];

					// minimal placeholder event - allows state correction on pointer-up
					onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );

					break;

			}

		}

		function onMouseDown( event ) {

			let mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = -1;

			}

			switch ( mouseAction ) {

				case MOUSE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case MOUSE.ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case MOUSE.PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onMouseMove( event ) {

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

			event.preventDefault();

			scope.dispatchEvent( _startEvent );

			handleMouseWheel( customWheelEvent( event ) );

			scope.dispatchEvent( _endEvent );

		}

		function customWheelEvent( event ) {

			const mode = event.deltaMode;

			// minimal wheel event altered to meet delta-zoom demand
			const newEvent = {
				clientX: event.clientX,
				clientY: event.clientY,
				deltaY: event.deltaY,
			};

			switch ( mode ) {

				case 1: // LINE_MODE
					newEvent.deltaY *= 16;
					break;

				case 2: // PAGE_MODE
					newEvent.deltaY *= 100;
					break;

			}

			// detect if event was triggered by pinching
			if ( event.ctrlKey && ! controlActive ) {

				newEvent.deltaY *= 10;

			}

			return newEvent;

		}

		function interceptControlDown( event ) {

			if ( event.key === 'Control' ) {

				controlActive = true;


				const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

				document.addEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );

			}

		}

		function interceptControlUp( event ) {

			if ( event.key === 'Control' ) {

				controlActive = false;


				const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

				document.removeEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );

			}

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate( event );

							state = STATE.TOUCH_ROTATE;

							break;

						case TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan( event );

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan( event );

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate( event );

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event.pointerId );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ] == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function isTrackingPointer( event ) {

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ] == event.pointerId ) return true;

			}

			return false;

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new Vector2();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.pageX, event.pageY );

		}

		function getSecondPointerPosition( event ) {

			const pointerId = ( event.pointerId === pointers[ 0 ] ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerUp );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

		document.addEventListener( 'keydown', interceptControlDown, { passive: true, capture: true } );

		// force an update at start

		this.update();

	}

}

const math$1 = {

	torad: Math.PI / 180,
	todeg: 180 / Math.PI,
	Pi: Math.PI,
	TwoPI: Math.PI*2,
	PI90: Math.PI*0.5,
	PI45: Math.PI*0.25,
	PI270: (Math.PI*0.5)*3,
	inv255: 0.003921569,
	golden: 1.618033,
	epsilon: Math.pow( 2, -52 ),

	randomSign: () => ( Math.random() < 0.5 ? -1 : 1 ),
	randSpread: ( range ) => ( range * ( 0.5 - Math.random() ) ),
	rand: ( low = 0, high = 1 ) => ( low + Math.random() * ( high - low ) ),
	randInt: ( low, high ) => ( low + Math.floor( Math.random() * ( high - low + 1 ) ) ),
	toFixed: ( x, n = 3 ) => ( x.toFixed(n) * 1 ),
	int: ( x ) => ( Math.floor(x) ),
	lerp: ( x, y, t ) => ( ( 1 - t ) * x + t * y ),
	clamp: ( v, min, max ) => ( Math.max( min, Math.min( max, v )) ),
	nearEquals: ( a, b, t ) => ( Math.abs(a - b) <= t ? true : false ),
	lerpAr: ( ar, arx, ary, t ) => {
		let i = ar.length;
		while( i-- ) ar[i] = math$1.lerp( arx[i], ary[i], t );
	},

    unwrapDeg: ( r ) => (r - (Math.floor((r + 180)/360))*360), 
	//unwrapRad: ( r ) => (r - (Math.floor((r + Math.PI)/(2*Math.PI)))*2*Math.PI),
	unwrapRad: ( r ) => ( Math.atan2(Math.sin(r), Math.cos(r)) ),


	scaleArray: ( ar, scale ) => {

		var i = ar.length;
		while( i-- ){ ar[i] *= scale; }		return ar;

	},

	addArray: ( ar, ar2 ) => {

		var r = [];
		var i = ar.length;
		while( i-- ){ r[i] = ar[i] + ar2[i]; }		return r;

	},

	angleDistance:(cur, prv)=> {
		var diff = (cur - prv + 180) % 360 - 180;
		return diff < -180 ? diff + 360 : diff;
	},




	/*map: ( value, in_min, in_max, out_min, out_max ) => ( (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min ),
	
	smoothLerp: ( a, b, c, t, k ) => {

        var f = a - b + (c - b) / (k * t);
        return c - (c - b) / ( k * t ) + f * Math.exp(-k*t);

    },

    smoothLerpV: ( a, b, c, t, k ) => {

    	let x = math.smoothLerp( a.x, b.x, c.x, t, k );
    	let y = math.smoothLerp( a.y, b.y, c.y, t, k );
    	let z = math.smoothLerp( a.z, b.z, c.z, t, k );

    	return { x:x, y:y, z:z }

    },

	minValue: ( ar ) => {

		let v = ar[0];
		for (let i = 1, l=ar.length; i<l; i++){ if( ar[i] < v ) v = ar[i]; }
		return v;

	},

	clamp: function (v, min, max) {

		//return Math.max( min, Math.min( max, value ) );
	    v = v < min ? min : v;
	    v = v > max ? max : v;
	    return v;
	},

	autoSize: ( o ) => {

		let s = o.size === undefined ? [ 1, 1, 1 ] : o.size;
		if ( s.length === 1 ) s[ 1 ] = s[ 0 ];

		let type = o.type === undefined ? 'box' : o.type;
		let radius = o.radius === undefined ? s[0] : o.radius;
		let height = o.height === undefined ? s[1] : o.height;

		if( type === 'sphere' ) s = [ radius, radius, radius ];
		if( type === 'cylinder' || type === 'wheel' || type === 'capsule' ) s = [ radius, height, radius ];
		if( type === 'cone' || type === 'pyramid' ) s = [ radius, height, 0 ];

	    if ( s.length === 2 ) s[ 2 ] = s[ 0 ];
	    return s;

	},

	correctSize: ( s ) => {

		if ( s.length === 1 ) s[ 1 ] = s[ 0 ];
	    if ( s.length === 2 ) s[ 2 ] = s[ 0 ];
	    return s;

	},*/

	tmpE: new Euler(),
	tmpM: new Matrix4(),
	tmpM2: new Matrix4(),
	tmpV: new Vector3(),
	tmpQ: new Quaternion$1(),

	fromTransformToQ: ( p, q, inv ) => {

		inv = inv || false;

		math$1.tmpM.compose( math$1.tmpV.fromArray( p ), math$1.tmpQ.fromArray( q ), { x:1, y:1, z:1 } );
		math$1.tmpM.decompose( math$1.tmpV, math$1.tmpQ, { x:1, y:1, z:1 } );

		//math.tmpQ.fromArray( q )

		if(inv) math$1.tmpQ.invert();

		return math$1.tmpQ.toArray();

	},

	fromTransform: ( p, q, p2, q2, inv ) => {

		inv = inv || false;
		q2 = q2 || [0,0,0,1];

		math$1.tmpM.compose( math$1.tmpV.fromArray( p ), math$1.tmpQ.fromArray( q ), { x:1, y:1, z:1 } );
		math$1.tmpM2.compose( math$1.tmpV.fromArray( p2 ), math$1.tmpQ.fromArray( q2 ), { x:1, y:1, z:1 } );
		if( inv ){
			//math.tmpM.getInverse( math.tmpM );
			math$1.tmpM.invert();
			math$1.tmpM.multiply( math$1.tmpM2 );
		} else {
			math$1.tmpM.multiply( math$1.tmpM2 );
		}

		math$1.tmpM.decompose( math$1.tmpV, math$1.tmpQ, { x:1, y:1, z:1 } );

		return math$1.tmpV.toArray();

	},

	arCopy: ( a, b ) => {

		[...b];

		//for( var i = 0; i< b.length; i++ ) a[i] = b[i];

	},

	axisToQuatArray: ( r, isdeg ) => { // r[0] array in degree

		isdeg = isdeg || false;
		return math$1.tmpQ.setFromAxisAngle( math$1.tmpV.fromArray( r, 1 ), isdeg ? r[0]*math$1.torad : r[0]).normalize().toArray();

	},

	toQuatArray: ( rotation ) => { // rotation array in degree

		return math$1.tmpQ.setFromEuler( math$1.tmpE.fromArray( math$1.vectorad( rotation ) ) ).toArray();

	},

	vectorad: ( r ) => {

		let i = 3, nr = [];
	    while ( i -- ) nr[ i ] = r[ i ] * math$1.torad;
	    nr[3] = r[3];
	    return nr;

	},
/*
	directionVector: ( a, b ) => {

	    var x = b.x-a.x;
	    var y = b.y-a.y;
	    var z = b.z-a.z;
	    var d = math.tmpV.set( x, 0, z ).normalize().toArray();
	    return d;

	},

	distanceVector: ( a, b ) => {

	    var x = b.x-a.x;
	    var y = b.y-a.y;
	    var z = b.z-a.z;
	    var d = Math.sqrt( x*x + y*y + z*z );
	    return d;

	},*/


	//--------------------
	//   COLORS
	//--------------------

	rgbToHex: ( rgb ) => {

	    return '0x' + ( '000000' + ( ( rgb[0] * 255 ) << 16 ^ ( rgb[1] * 255 ) << 8 ^ ( rgb[2] * 255 ) << 0 ).toString( 16 ) ).slice( -6 );

	},

	hexToRgb: ( hex ) => {

	    hex = Math.floor( hex );
	    var r = ( hex >> 16 & 255 ) / 255;
	    var g = ( hex >> 8 & 255 ) / 255;
	    var b = ( hex & 255 ) / 255;
	    return [ r, g, b ];

	},

	htmlToHex: ( v ) => {

	    return v.toUpperCase().replace("#", "0x");

	},

	hexToHtml: ( v ) => {

	    v = v === undefined ? 0x000000 : v;
	    return "#" + ("000000" + v.toString(16)).substr(-6);

	},

	rgbToHtml: ( rgb ) => {

	    return '#' + ( '000000' + ( ( rgb[0] * 255 ) << 16 ^ ( rgb[1] * 255 ) << 8 ^ ( rgb[2] * 255 ) << 0 ).toString( 16 ) ).slice( -6 );

	},


	//--------------------
	//   NOISE
	//--------------------

	perlin: null,

	resetPerlin:()=>{
		if( math$1.perlin !== null ) math$1.perlin = null;
	},

	noise: ( v, o ) => {

	    if( math$1.perlin === null ) math$1.perlin = new SimplexNoise();

	    o = o || {};

	    let level = o.level || [1,0.2,0.05];
	    let frequency  = o.frequency  || [0.016,0.05,0.2];

	    let i, f, c=0, d=0;

	    for(i=0; i<level.length; i++){

	        f = frequency [i];
	        c += level[i] * ( 0.5 + math$1.perlin.noise3d( v.x*f, v.y*f, v.z*f ) * 0.5 );
	        d += level[i];

	    }

	    c/=d;

	    return c;

	},

	/*radArray: (arr) => {
		var ret = [];
		for(var i = 0; i < 3; i++)
			ret[i] = arr[i] * math.torad;

		return ret;
	},

	degArray: (arr) => {
		var ret = [];
		for(var i = 0; i < 3; i++)
			ret[i] = arr[i] * math.todeg;

		return ret;
	},

	angleDistance: (cur, prv) =>{
		var diff = (cur - prv + 180) % 360 - 180;
		return diff < -180 ? diff + 360 : diff;
	}*/

};

class SimplexNoise {

	constructor ( r ) {

		if (r == undefined) r = Math;
		this.grad3 = [[ 1,1,0 ],[ -1,1,0 ],[ 1,-1,0 ],[ -1,-1,0 ],
	        [ 1,0,1 ],[ -1,0,1 ],[ 1,0,-1 ],[ -1,0,-1 ],
	        [ 0,1,1 ],[ 0,-1,1 ],[ 0,1,-1 ],[ 0,-1,-1 ]];

		this.grad4 = [[ 0,1,1,1 ], [ 0,1,1,-1 ], [ 0,1,-1,1 ], [ 0,1,-1,-1 ],
		     [ 0,-1,1,1 ], [ 0,-1,1,-1 ], [ 0,-1,-1,1 ], [ 0,-1,-1,-1 ],
		     [ 1,0,1,1 ], [ 1,0,1,-1 ], [ 1,0,-1,1 ], [ 1,0,-1,-1 ],
		     [ -1,0,1,1 ], [ -1,0,1,-1 ], [ -1,0,-1,1 ], [ -1,0,-1,-1 ],
		     [ 1,1,0,1 ], [ 1,1,0,-1 ], [ 1,-1,0,1 ], [ 1,-1,0,-1 ],
		     [ -1,1,0,1 ], [ -1,1,0,-1 ], [ -1,-1,0,1 ], [ -1,-1,0,-1 ],
		     [ 1,1,1,0 ], [ 1,1,-1,0 ], [ 1,-1,1,0 ], [ 1,-1,-1,0 ],
		     [ -1,1,1,0 ], [ -1,1,-1,0 ], [ -1,-1,1,0 ], [ -1,-1,-1,0 ]];

		this.p = [];
		for (var i = 0; i < 256; i ++) {
			this.p[i] = Math.floor(r.random() * 256);
		}
	  // To remove the need for index wrapping, double the permutation table length
		this.perm = [];
		for (var i = 0; i < 512; i ++) {
			this.perm[i] = this.p[i & 255];
		}

	  // A lookup table to traverse the simplex around a given point in 4D.
	  // Details can be found where this table is used, in the 4D noise method.
		this.simplex = [
	    [ 0,1,2,3 ],[ 0,1,3,2 ],[ 0,0,0,0 ],[ 0,2,3,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,2,3,0 ],
	    [ 0,2,1,3 ],[ 0,0,0,0 ],[ 0,3,1,2 ],[ 0,3,2,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,3,2,0 ],
	    [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],
	    [ 1,2,0,3 ],[ 0,0,0,0 ],[ 1,3,0,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,3,0,1 ],[ 2,3,1,0 ],
	    [ 1,0,2,3 ],[ 1,0,3,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,0,3,1 ],[ 0,0,0,0 ],[ 2,1,3,0 ],
	    [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],
	    [ 2,0,1,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,0,1,2 ],[ 3,0,2,1 ],[ 0,0,0,0 ],[ 3,1,2,0 ],
	    [ 2,1,0,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,1,0,2 ],[ 0,0,0,0 ],[ 3,2,0,1 ],[ 3,2,1,0 ]];
	}

	dot (g, x, y) {
		return g[0] * x + g[1] * y;
	}

	dot3 (g, x, y, z) {
		return g[0] * x + g[1] * y + g[2] * z;
	}

	dot4 (g, x, y, z, w) {
		return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
	}

	noise (xin, yin) {
		var n0, n1, n2; // Noise contributions from the three corners
	  // Skew the input space to determine which simplex cell we're in
		var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
		var s = (xin + yin) * F2; // Hairy factor for 2D
		var i = Math.floor(xin + s);
		var j = Math.floor(yin + s);
		var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
		var t = (i + j) * G2;
		var X0 = i - t; // Unskew the cell origin back to (x,y) space
		var Y0 = j - t;
		var x0 = xin - X0; // The x,y distances from the cell origin
		var y0 = yin - Y0;
	  // For the 2D case, the simplex shape is an equilateral triangle.
	  // Determine which simplex we are in.
		var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
		if (x0 > y0) {i1 = 1; j1 = 0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
		else {i1 = 0; j1 = 1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1)
	  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	  // c = (3-sqrt(3))/6
		var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
		var y1 = y0 - j1 + G2;
		var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
		var y2 = y0 - 1.0 + 2.0 * G2;
	  // Work out the hashed gradient indices of the three simplex corners
		var ii = i & 255;
		var jj = j & 255;
		var gi0 = this.perm[ii + this.perm[jj]] % 12;
		var gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
		var gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
	  // Calculate the contribution from the three corners
		var t0 = 0.5 - x0 * x0 - y0 * y0;
		if (t0 < 0) n0 = 0.0;
		else {
			t0 *= t0;
			n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient
		}
		var t1 = 0.5 - x1 * x1 - y1 * y1;
		if (t1 < 0) n1 = 0.0;
		else {
			t1 *= t1;
			n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
		}
		var t2 = 0.5 - x2 * x2 - y2 * y2;
		if (t2 < 0) n2 = 0.0;
		else {
			t2 *= t2;
			n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
		}
	  // Add contributions from each corner to get the final noise value.
	  // The result is scaled to return values in the interval [-1,1].
		return 70.0 * (n0 + n1 + n2);
	}

	// 3D simplex noise
	noise3d (xin, yin, zin) {
		var n0, n1, n2, n3; // Noise contributions from the four corners
	  // Skew the input space to determine which simplex cell we're in
		var F3 = 1.0 / 3.0;
		var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
		var i = Math.floor(xin + s);
		var j = Math.floor(yin + s);
		var k = Math.floor(zin + s);
		var G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too
		var t = (i + j + k) * G3;
		var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
		var Y0 = j - t;
		var Z0 = k - t;
		var x0 = xin - X0; // The x,y,z distances from the cell origin
		var y0 = yin - Y0;
		var z0 = zin - Z0;
	  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
	  // Determine which simplex we are in.
		var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
		var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
		if (x0 >= y0) {
			if (y0 >= z0)
	      { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // X Y Z order
	      else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } // X Z Y order
			else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } // Z X Y order
		}
		else { // x0<y0
			if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } // Z Y X order
	    else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } // Y Z X order
			else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // Y X Z order
		}
	  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
	  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
	  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
	  // c = 1/6.
		var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
		var y1 = y0 - j1 + G3;
		var z1 = z0 - k1 + G3;
		var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
		var y2 = y0 - j2 + 2.0 * G3;
		var z2 = z0 - k2 + 2.0 * G3;
		var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
		var y3 = y0 - 1.0 + 3.0 * G3;
		var z3 = z0 - 1.0 + 3.0 * G3;
	  // Work out the hashed gradient indices of the four simplex corners
		var ii = i & 255;
		var jj = j & 255;
		var kk = k & 255;
		var gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
		var gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
		var gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
		var gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
	  // Calculate the contribution from the four corners
		var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
		if (t0 < 0) n0 = 0.0;
		else {
			t0 *= t0;
			n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
		}
		var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
		if (t1 < 0) n1 = 0.0;
		else {
			t1 *= t1;
			n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
		}
		var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
		if (t2 < 0) n2 = 0.0;
		else {
			t2 *= t2;
			n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);
		}
		var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
		if (t3 < 0) n3 = 0.0;
		else {
			t3 *= t3;
			n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
		}
	  // Add contributions from each corner to get the final noise value.
	  // The result is scaled to stay just inside [-1,1]
		return 32.0 * (n0 + n1 + n2 + n3);
	}

	// 4D simplex noise
	noise4d ( x, y, z, w ) {
		// For faster and easier lookups
		var grad4 = this.grad4;
		var simplex = this.simplex;
		var perm = this.perm;

	   // The skewing and unskewing factors are hairy again for the 4D case
		var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
		var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
		var n0, n1, n2, n3, n4; // Noise contributions from the five corners
	   // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
		var s = (x + y + z + w) * F4; // Factor for 4D skewing
		var i = Math.floor(x + s);
		var j = Math.floor(y + s);
		var k = Math.floor(z + s);
		var l = Math.floor(w + s);
		var t = (i + j + k + l) * G4; // Factor for 4D unskewing
		var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
		var Y0 = j - t;
		var Z0 = k - t;
		var W0 = l - t;
		var x0 = x - X0;  // The x,y,z,w distances from the cell origin
		var y0 = y - Y0;
		var z0 = z - Z0;
		var w0 = w - W0;

	   // For the 4D case, the simplex is a 4D shape I won't even try to describe.
	   // To find out which of the 24 possible simplices we're in, we need to
	   // determine the magnitude ordering of x0, y0, z0 and w0.
	   // The method below is a good way of finding the ordering of x,y,z,w and
	   // then find the correct traversal order for the simplex we’re in.
	   // First, six pair-wise comparisons are performed between each possible pair
	   // of the four coordinates, and the results are used to add up binary bits
	   // for an integer index.
		var c1 = (x0 > y0) ? 32 : 0;
		var c2 = (x0 > z0) ? 16 : 0;
		var c3 = (y0 > z0) ? 8 : 0;
		var c4 = (x0 > w0) ? 4 : 0;
		var c5 = (y0 > w0) ? 2 : 0;
		var c6 = (z0 > w0) ? 1 : 0;
		var c = c1 + c2 + c3 + c4 + c5 + c6;
		var i1, j1, k1, l1; // The integer offsets for the second simplex corner
		var i2, j2, k2, l2; // The integer offsets for the third simplex corner
		var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
	   // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
	   // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
	   // impossible. Only the 24 indices which have non-zero entries make any sense.
	   // We use a thresholding to set the coordinates in turn from the largest magnitude.
	   // The number 3 in the "simplex" array is at the position of the largest coordinate.
		i1 = simplex[c][0] >= 3 ? 1 : 0;
		j1 = simplex[c][1] >= 3 ? 1 : 0;
		k1 = simplex[c][2] >= 3 ? 1 : 0;
		l1 = simplex[c][3] >= 3 ? 1 : 0;
	   // The number 2 in the "simplex" array is at the second largest coordinate.
		i2 = simplex[c][0] >= 2 ? 1 : 0;
		j2 = simplex[c][1] >= 2 ? 1 : 0;    k2 = simplex[c][2] >= 2 ? 1 : 0;
		l2 = simplex[c][3] >= 2 ? 1 : 0;
	   // The number 1 in the "simplex" array is at the second smallest coordinate.
		i3 = simplex[c][0] >= 1 ? 1 : 0;
		j3 = simplex[c][1] >= 1 ? 1 : 0;
		k3 = simplex[c][2] >= 1 ? 1 : 0;
		l3 = simplex[c][3] >= 1 ? 1 : 0;
	   // The fifth corner has all coordinate offsets = 1, so no need to look that up.
		var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
		var y1 = y0 - j1 + G4;
		var z1 = z0 - k1 + G4;
		var w1 = w0 - l1 + G4;
		var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
		var y2 = y0 - j2 + 2.0 * G4;
		var z2 = z0 - k2 + 2.0 * G4;
		var w2 = w0 - l2 + 2.0 * G4;
		var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
		var y3 = y0 - j3 + 3.0 * G4;
		var z3 = z0 - k3 + 3.0 * G4;
		var w3 = w0 - l3 + 3.0 * G4;
		var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
		var y4 = y0 - 1.0 + 4.0 * G4;
		var z4 = z0 - 1.0 + 4.0 * G4;
		var w4 = w0 - 1.0 + 4.0 * G4;
	   // Work out the hashed gradient indices of the five simplex corners
		var ii = i & 255;
		var jj = j & 255;
		var kk = k & 255;
		var ll = l & 255;
		var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
		var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
		var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
		var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
		var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
	   // Calculate the contribution from the five corners
		var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
		if (t0 < 0) n0 = 0.0;
		else {
			t0 *= t0;
			n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
		}
		var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
		if (t1 < 0) n1 = 0.0;
		else {
			t1 *= t1;
			n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
		}
		var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
		if (t2 < 0) n2 = 0.0;
		else {
			t2 *= t2;
			n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);
		}   var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
		if (t3 < 0) n3 = 0.0;
		else {
			t3 *= t3;
			n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
		}
		var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
		if (t4 < 0) n4 = 0.0;
		else {
			t4 *= t4;
			n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
		}
	   // Sum up and scale the result to cover the range [-1,1]
		return 27.0 * (n0 + n1 + n2 + n3 + n4);
	}

}

/** __
*    _)_|_|_
*   __) |_| | 2022
* @author lo.th / https://github.com/lo-th
*/

const sph = new Spherical();

class Controller extends OrbitControls {

    constructor( object, domElement, group ) {

        super( object, domElement );

    	this.followTarget = null;
        this.camTween = [];

        this.isDecal = false;
        this.isInDecal = false;

        this.tmpS = new Spherical();
        this.tmpP = new Vector3();
        this.tmpQ = new Quaternion$1();

    	this.cam = {

    		stiffness: 0.15,
    		stiffnessTarget: 1,

    	    theta:180,
            phi:20,
            distance:10,
            maxDistance:10,
    	    height:0.6,

    	    v: new Vector3(),
            d: new Vector3(),

            tmp: new Vector3(),
            oldp: new Vector3(),
            oldq: new Quaternion$1(),
            offset: new Vector3(),
            position: new Vector3(),
            decal: new Vector3(),

            multy:1,

            clipper: true,

            forceFree:false,

            simple:false,

            //pov:null,
            

    	};

        this.reverse = false;

    	this.followGroup = group;

        this.tmpMatrix = new Matrix4();
        this.tmpE = new Euler();
        this.tmpV = new Vector3();
        this.tmpV2 = new Vector3();

        this.info = { x:0, y:0, z:0, distance: 0, phi: 0, theta:0, fov: 0, zoom: 0 };

        this.getInfo();

        this.isFree = true;
        this.rayClipper = null;

        this.tmpV1 = new Vector3();

    }


    getSpherical (){

        sph.set(this.getDistance(), this.getPolarAngle(), this.getAzimuthalAngle());
        return sph;

    }

    up ( deltaTime = null ) {

        if( this.enableDamping && this.enabled ) this.update();
        if( this.follow ) this.follow(deltaTime);

    }

    resetAll () {

        this.enableApply = true;
        this.minDistance = 0.001;
        this.maxDistance = 100;
        this.enablePan = true;
        this.enableDamping = true;
        this.dampingFactor = 0.05;
        this.screenSpacePanning = true;
        this.zoomToCursor = true;
        this.stopMoveCam();
        this.resetFov();
        this.resetFollow();
        this.setLimite();
        this.reverse = false;

    }

    upExtra (z){

        this.cam.distance *= z;

    }

    startFollow ( mesh, o ) {

        if(o.d !== undefined) o.distance = o.d;
        if(o.h !== undefined) o.theta = o.h;
        if(o.v !== undefined) o.phi = o.v;

        this.moveCam( o );

        this.reverse = o.reverse || false;

        let cam = this.cam;

        cam.simple = o.simple !== undefined ? o.simple : false;

        cam.stiffness = o.stiffness !== undefined ? o.stiffness : 0.15;
        cam.stiffnessTarget = o.stiffnessTarget !== undefined ? o.stiffnessTarget : 1;

        cam.height = o.height !== undefined ? o.height : 0.6;
        cam.d.set(0,this.cam.height,0);

        cam.theta = o.theta !== undefined ? o.theta : 180;
        cam.phi = o.phi !== undefined ? o.phi : 20;
        cam.distance = o.distance !== undefined ? o.distance : 10;
        cam.maxDistance = cam.distance;
        cam.rotation = o.rotation !== undefined ? o.rotation : true;
        cam.offset.set( 0,0,0 );
        cam.decal.fromArray( o.decal !== undefined ? o.decal : [0,0,0] );
        if( o.dx !== undefined ) cam.decal.x = o.dx;
        if( o.dy !== undefined ) cam.decal.y = o.dy;
        if( o.dz !== undefined ) cam.decal.z = o.dz;
        cam.decalY = o.decalY !== undefined ? o.decalY : 0;
        cam.zoomUp = o.zoomUp || false;
        cam.clipper = o.clipper || false;
        cam.exr = o.exr || 0;


        cam.forceFree = o.forceFree || false;

        if( o.direct ){
            this.enablePan = false;
            this.initFollow( mesh, o );
            return;
        }

        this.enableDamping = o.enableDamping || false;
        if( o.dampingFactor !== undefined ) this.dampingFactor = o.dampingFactor;


        //cam.pov = o.pov || null;


        let start = this.getTargetStart( mesh );

        o.target = start.p;
        o.theta = math$1.unwrapDeg( o.theta + start.r );

        var callback2 = o.callback;

        o.callback = function() {

            if(callback2) callback2();
            this.initFollow( mesh, o );

        }.bind( this );

        //this.moveCam( o );

    }

    getTargetStart ( mesh ){

        mesh.updateMatrix();
        this.tmpMatrix.makeRotationFromQuaternion( mesh.quaternion );
        let cam = this.cam;
        let r = Math.atan2( this.tmpMatrix.elements[8], this.tmpMatrix.elements[10] ) ;
        if( cam.decal.x !== 0 || cam.decal.z !== 0 ) cam.offset.copy( cam.position ).add( cam.decal ).applyAxisAngle( { x:0, y:1, z:0 }, r );
        let p = cam.tmp.copy( mesh.position ).add( cam.offset ).add( cam.d ).toArray();
        
        return { p:p, r:r * math$1.todeg }

    }

    initFollow ( mesh, o ) {

        //console.log('init follow')

        //this.enableDamping = false
        this.zoomToCursor = false;
        this.screenSpacePanning = false;
        this.enableApply = false;

        this.cam.oldp.copy( mesh.position );
        this.cam.oldq.copy( mesh.quaternion );

        //this.object.matrixAutoUpdate = false;

        //this.moveCam( this.cam )

        this.stopMoveCam();

        /*if( this.cam.clipper ){

            this.rayClipper = root.add( { name: 'cameraRayClipper', type:'ray', callback: (o) => { this.onRayClipper(o) }, visible:false, group: "all", filter: [o.clipperFilter || (-1 >>> 0)], isIntern:true } );

        }*/

        this.followTarget = mesh;

    }

    onRayClipper ( o ) {

        if( o.hit ) this.cam.distance = math$1.clamp( o.distance, this.minDistance, this.cam.maxDistance );
        else {
            if( this.cam.distance < this.cam.maxDistance ){
                this.cam.distance += this.cam.maxDistance/16;
            }
        }
        
        this.maxDistance = this.cam.distance;

    }

    setOption ( o ) {

        for(let m in o){
            if(this[m]) this[m] = o[m];
        }

    }

    

    setLimite ( o ){

        o = o || {};

        this.minPolarAngle = o.minV !== undefined ? (90-o.minV) * math$1.torad : 0;
        this.maxPolarAngle = o.maxV !== undefined ? (90-o.maxV) * math$1.torad : Math.PI;

        this.minAzimuthAngle = o.minH !== undefined ? o.minH * math$1.torad : - Infinity;
        this.maxAzimuthAngle = o.maxH !== undefined ? o.maxH * math$1.torad : Infinity;

        this.minDistance = o.minD !== undefined ? o.minD : 0.01;
        this.maxDistance = o.maxD !== undefined ? o.maxD : Infinity;

    }

    resetFov () {

        this.object.fov = 50;
        this.object.zoom = 1;
        this.object.updateProjectionMatrix();

    }

	resetFollow () {

        this.followGroup.position.set(0,0,0);
		this.followTarget = null;
        this.enabled = true;
        //this.object.matrixAutoUpdate = true;


        /*if( this.rayClipper !== null ){ 
            root.remove( 'cameraRayClipper' );
            this.rayClipper = null;
        }*/
	}

    /*upPosition:function () {

        if( !this.followTarget ) return;

        this.tmpP.copy(this.followTarget.position );
        this.tmpQ.copy(this.followTarget.quaternion ) ;

        //this.tmpP.lerp(this.followTarget.position, 0.5 );
        //this.tmpQ.slerp(this.followTarget.quaternion, 0.5 ) ;

    },

    idealOffset () {
        const idealOffset = new Vector3(-0.15, 0.20, -0.30);
        idealOffset.applyQuaternion(this.tmpQ);
        idealOffset.add(this.tmpP);
        return idealOffset;
    }

    ideallLookat () {
        const idealLookat = new THREE.Vector3(0, 0.10, 0.50);
        idealLookat.applyQuaternion(this.tmpQ);
        idealLookat.add(this.tmpP);
        return idealLookat;
    }*/



	follow ( delta ) {

        if( !this.followTarget ) return;



        const cam = this.cam;
        const camera = this.object;
        const target = this.target;
        const sph = this.getSpherical();
        const state = this.getState();

        this.followTarget.updateMatrix();




        this.tmpP.copy( this.followTarget.position );
        this.tmpQ.copy( this.followTarget.quaternion );

        


        let p = this.tmpP;
        let q = this.tmpQ;

        

        
        let phi = ( ( 90 - cam.phi ) * math$1.torad ) ;
        //let theta = ( cam.theta * math.torad )
        let radius = this.getDistance();//cam.distance;


        if( cam.simple ){

            if(radius<2) cam.decalY = (2-radius)*0.5;

            this.tmpV.copy( cam.decal );//.applyAxisAngle( { x:1, y:0, z:0 }, phi - math.PI90 )

            // zoom to head
            if(cam.zoomUp) this.tmpV.y += cam.decalY; 

            this.tmpV.applyAxisAngle( { x:0, y:1, z:0 }, sph.theta);
            //cam.offset.copy( p ).add( this.tmpV ).applyAxisAngle( { x:0, y:1, z:0 }, cam.theta );

            //target.copy( p ).add( this.tmpV )
            //camera.position.setFromSpherical( sph ).add( target );
            //camera.lookAt( target );

            if( this.reverse ){
                camera.position.copy( p ).add( this.tmpV );
                target.setFromSpherical( sph ).add( camera.position );
                camera.lookAt( target );
            } else {
                target.copy( p ).add( this.tmpV );
                camera.position.setFromSpherical( sph ).add( target );
                camera.lookAt( target );
            }
            /*p.add(this.tmpV)
            target.lerp( p, cam.stiffness );
            this.tmpV2.setFromSpherical( sph ).add( target );
            //camera.position.lerp( this.tmpV2, cam.stiffness );
            camera.position.copy(this.tmpV2)*/
            //camera.updateMatrix();

            this.updateFollowGroup();

            return;

        }



        


        //if( this.isDecal || this.isInDecal ){

           // cam.oldp.copy( this.tmpP );
           // cam.oldq.copy( this.tmpQ );

            /*var yy = camera.position.y;
            camera.position.sub( cam.oldp );
            camera.position.y = yy;
            this.target.copy( this.tmpP ).add( cam.d );
            camera.lookAt( this.target ); */

        //}


        this.tmpMatrix.makeRotationFromQuaternion( q );
        let tRotation = Math.atan2( this.tmpMatrix.elements[8], this.tmpMatrix.elements[10] );

        let theta = ( cam.theta * math$1.torad ) + tRotation;

        //theta+=tRotation


        this.isFree = false;
        

        var dist = p.distanceTo( cam.oldp );

        var qx = q.x - cam.oldq.x;
        var qy = q.y - cam.oldq.y;
        var qz = q.z - cam.oldq.z;
        var qw = q.w - cam.oldq.w;
        var qdist = Math.sqrt(qx * qx + qy * qy + qz * qz + qw * qw);

        




        if( this.enabled ){
            if( state === 0 || state === 3 || (dist < 0.01 && qdist < 0.001) ) this.isFree = true;
            else if( !cam.forceFree ) sph.set( radius, phi, theta );
        } else {
            sph.set( radius, phi, theta );
        }



        //if( cam.decal.x !== 0 || cam.decal.z !== 0 ) 
        //cam.offset.copy( cam.position ).add( cam.decal ).applyAxisAngle( { x:0, y:1, z:0 }, tRotation );


        //this.tmpE.set( 0, tRotation, 0, 'XYZ' ) 
        this.tmpV.copy( cam.decal ).applyAxisAngle( { x:1, y:0, z:0 }, phi - math$1.PI90 );
        cam.offset.copy( cam.position ).add( this.tmpV ).applyAxisAngle( { x:0, y:1, z:0 }, tRotation );
       
        cam.v.copy( p ).add( cam.offset ).add( cam.d );
        cam.tmp.setFromSpherical( sph ).add( cam.v );

        //camera.position.copy( cam.tmp );

        if( this.reverse ){

            if( cam.stiffnessTarget !== 1 ) camera.position.lerp( cam.v, cam.stiffnessTarget );
            else camera.position.copy( cam.v );

            if( !this.isDecal ) target.lerp( cam.tmp, cam.stiffness );
            else target.copy( cam.tmp );

        } else {

            if( !this.isDecal ) camera.position.lerp( cam.tmp, cam.stiffness );
            else camera.position.copy( cam.tmp );

            if( cam.stiffnessTarget !== 1 ) target.lerp( cam.v, cam.stiffnessTarget );
            else target.copy( cam.v );

        }
        

       // if( cam.rotation ) camera.lookAt( target );
        camera.lookAt( target );

        this.updateFollowGroup();

        cam.oldp.copy( p );
		cam.oldq.copy( q );


        if( this.isInDecal ){ this.isDecal = false; this.isInDecal = false; }
        if( this.isDecal ) this.isInDecal = true;


        if( !this.cam.clipper ) return;

        this.rayClipper.start.copy( p ).add( cam.offset).add( cam.d );
        this.tmpV1.set(0, 0, -1).applyQuaternion( camera.quaternion ).normalize().multiplyScalar( cam.maxDistance );
        this.rayClipper.end.copy(this.rayClipper.start).sub( this.tmpV1 );

    }


    updateFollowGroup(){

        this.followGroup.position.copy( this.target );

        //this.followGroup.position.set( this.target.x, 0, this.target.z );

    }

    getInfo () {

        this.update();

        const t = this.target;
        const c = this.object;
        /*
        const sph = this.getSpherical();
        let phi = sph.phi;
        let theta = sph.theta;
        let distance = sph.radius;
        */

        let phi = this.getPolarAngle();
        let theta = this.getAzimuthalAngle();
        let distance = this.getDistance();

        this.info.x = t.x;
        this.info.y = t.y;
        this.info.z = t.z;

        this.object.dist = distance;
        this.info.distance = distance;

        this.info.phi = math$1.unwrapDeg(-Math.floor( phi * math$1.todeg ) + 90);
        this.info.theta = math$1.unwrapDeg(Math.floor( theta * math$1.todeg ));

        this.info.fov = c.fov;
        this.info.zoom = c.zoom;

    }

    stopMoveCam (){

        var i = this.camTween.length;
        while(i--){
            remove$1( this.camTween[i] );
            this.camTween[i] = null;
        }

        this.camTween = [];
        this.getInfo();

    }

    moveCam ( data = {} ) {

        if( this.followTarget ) this.resetFollow();

    	var self = this;
        this.getInfo();

        var o = {};

        if( data.phi !== undefined ) o.phi = data.phi;
        if( data.theta !== undefined ) o.theta = data.theta;
        if( data.distance !== undefined ) o.distance = data.distance;

        if( data.v !== undefined ) o.phi = data.v;
        if( data.h !== undefined ) o.theta = data.h;
        if( data.d !== undefined ) o.distance = data.d;

        if( data.fov !== undefined ) o.fov = data.fov;
        if( data.zoom !== undefined ) o.zoom = data.zoom;

        if( data.x !== undefined ) o.x = data.x;
        if( data.y !== undefined ) o.y = data.y;
        if( data.z !== undefined ) o.z = data.z;

        /*if( data.target ){
            //console.log(data.target)
            //o.target = data.target
            o.x = data.target[0];
            o.y = data.target[1];
            o.z = data.target[2];
        }*/

        var shortest = data.shortest !== undefined ? data.shortest : true;
		
		if( o.theta !== undefined && shortest ){ // get shortest distance
			var prvh = this.getAzimuthalAngle() * math$1.todeg;
			o.theta = prvh + math$1.angleDistance(o.theta, prvh);
		}
		
        var time = data.time !== undefined ? data.time : 0;
        var tween = data.tween !== undefined ? data.tween : Easing.Quadratic.Out;//Easing.Linear.None;
        var delay = data.delay !== undefined ? data.delay : 0;

        this.enabled = false;

        var c = [];//[...this.info];
        for( var n in o ) c[n] = this.info[n];

		var callback = data.callback || function(){};

        if( time === 0 ){

            for( var n in o ) c[n] = o[n];
            this.stopMoveCam();
            this.orbit( c );
            this.enabled = true;
            callback();
            return;

        }


        var t = new Tween( c )
            .to( o, time )
            .delay( delay )
            .easing( tween )
            .onUpdate( function( o ) { self.orbit( o ); } )
            .onComplete( function() { self.enabled = true;  callback(); } )
            .start();

        this.camTween.push( t );

    }

    zommer ( p, time, callback ) {

        this.stopMoveCam();

        var cam = this.cam;
        var camera = this.object;
        var o = { 
            zoom:p.zoom, fov:p.fov, distance:p.distance,
            dx: p.dx !== undefined ? p.dx : cam.decal.x, 
            dy: p.dy !== undefined ? p.dy : cam.decal.y, 
            dz: p.dz !== undefined ? p.dz : cam.decal.z, 
            exr: p.exr !== undefined ? p.exr : cam.exr, 
            multy: p.multy !== undefined ? p.multy : cam.multy, 
        };


        var t = new Tween( { zoom:camera.zoom, fov:camera.fov, distance:cam.distance, dx:cam.decal.x, dy:cam.decal.y, dz:cam.decal.z, exr:cam.exr, multy:cam.multy } )
            .to( o, time || 300 )
            .onUpdate( function( o ) { 
                camera.fov = o.fov;
                camera.zoom = o.zoom;
                cam.distance = o.distance;
                cam.decal.x = o.dx; 
                cam.decal.y = o.dy; 
                cam.decal.z = o.dz;
                cam.exr = o.exr;
                cam.multy = o.multy;
                camera.updateProjectionMatrix();
            })
            .onComplete( function( ) {
                if( callback ) callback();
            }
            ).start();

        this.camTween.push( t );

    }

    orbit ( c ) {

        var o = this.info;
        for( var n in c ) o[n] = c[n];

    	var camera = this.object;
        var target = this.target;
        var sph = this.getSpherical();

        var upCam = false;
        if( camera.fov !== o.fov ){ camera.fov = o.fov; upCam = true; }
        if( camera.zoom !== o.zoom ){ camera.zoom = o.zoom; upCam = true; }
        if( upCam ) camera.updateProjectionMatrix();

        sph.set( o.distance, (-o.phi+90) * math$1.torad, o.theta * math$1.torad );
        sph.makeSafe();

        if( this.reverse ){
            //target.set( o.x, o.y, o.z );
            camera.position.set( o.x, o.y, o.z );
            target.setFromSpherical( sph ).add( camera.position );
            camera.lookAt( target );
        } else {
            target.set( o.x, o.y, o.z );
            //camera.position.set( 0,0,0 ).setFromSpherical( sph ).add( target );
            camera.position.setFromSpherical( sph ).add( target );
            camera.lookAt( target );
        }

        //this.updateFollowGroup();

    }

    getDirection () {

        return math$1.tmpV.subVectors( this.target, this.object.position ).normalize().toArray();//math.directionVector( this.object.position, this.target );

    }

}


/*

const sph = new THREE.Spherical();
const target = controlsRef.current.target;
let tmp = {
    distance:controlsRef.current.getDistance(),
    phi:controlsRef.current.getPolarAngle(),
    theta: controlsRef.current.getAzimuthalAngle()
}

gsap.to(tmp, {
  theta: Math.PI*0.5,
  duration: 1.5,
  ease: 'power2.out',
  onStart:()=>{ controlsRef.current.enabled = false; }
  onComplete:()=>{ controlsRef.current.enabled = true; }
  onUpdate: () => {
        sph.set( tmp.distance, tmp.phi, tmp.theta );
        camera.position.setFromSpherical( sph ).add( target )
        camera.lookAt( target )
  }
});
*/

/**
 * @param  {Array<BufferGeometry>} geometries
 * @param  {Boolean} useGroups
 * @return {BufferGeometry}
 */
function mergeGeometries( geometries, useGroups = false ) {

	const isIndexed = geometries[ 0 ].index !== null;

	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
	const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );

	const attributes = {};
	const morphAttributes = {};

	const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;

	const mergedGeometry = new BufferGeometry();

	let offset = 0;

	for ( let i = 0; i < geometries.length; ++ i ) {

		const geometry = geometries[ i ];
		let attributesCount = 0;

		// ensure that all geometries are indexed, or none

		if ( isIndexed !== ( geometry.index !== null ) ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );
			return null;

		}

		// gather attributes, exit early if they're different

		for ( const name in geometry.attributes ) {

			if ( ! attributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );
				return null;

			}

			if ( attributes[ name ] === undefined ) attributes[ name ] = [];

			attributes[ name ].push( geometry.attributes[ name ] );

			attributesCount ++;

		}

		// ensure geometries have the same number of attributes

		if ( attributesCount !== attributesUsed.size ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );
			return null;

		}

		// gather morph attributes, exit early if they're different

		if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );
			return null;

		}

		for ( const name in geometry.morphAttributes ) {

			if ( ! morphAttributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );
				return null;

			}

			if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];

			morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

		}

		if ( useGroups ) {

			let count;

			if ( isIndexed ) {

				count = geometry.index.count;

			} else if ( geometry.attributes.position !== undefined ) {

				count = geometry.attributes.position.count;

			} else {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );
				return null;

			}

			mergedGeometry.addGroup( offset, count, i );

			offset += count;

		}

	}

	// merge indices

	if ( isIndexed ) {

		let indexOffset = 0;
		const mergedIndex = [];

		for ( let i = 0; i < geometries.length; ++ i ) {

			const index = geometries[ i ].index;

			for ( let j = 0; j < index.count; ++ j ) {

				mergedIndex.push( index.getX( j ) + indexOffset );

			}

			indexOffset += geometries[ i ].attributes.position.count;

		}

		mergedGeometry.setIndex( mergedIndex );

	}

	// merge attributes

	for ( const name in attributes ) {

		const mergedAttribute = mergeAttributes( attributes[ name ] );

		if ( ! mergedAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );
			return null;

		}

		mergedGeometry.setAttribute( name, mergedAttribute );

	}

	// merge morph attributes

	for ( const name in morphAttributes ) {

		const numMorphTargets = morphAttributes[ name ][ 0 ].length;

		if ( numMorphTargets === 0 ) break;

		mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
		mergedGeometry.morphAttributes[ name ] = [];

		for ( let i = 0; i < numMorphTargets; ++ i ) {

			const morphAttributesToMerge = [];

			for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {

				morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

			}

			const mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );

			if ( ! mergedMorphAttribute ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );
				return null;

			}

			mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

		}

	}

	return mergedGeometry;

}

/**
 * @param {Array<BufferAttribute>} attributes
 * @return {BufferAttribute}
 */
function mergeAttributes( attributes ) {

	let TypedArray;
	let itemSize;
	let normalized;
	let gpuType = -1;
	let arrayLength = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		const attribute = attributes[ i ];

		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );
			return null;

		}

		if ( itemSize === undefined ) itemSize = attribute.itemSize;
		if ( itemSize !== attribute.itemSize ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );
			return null;

		}

		if ( normalized === undefined ) normalized = attribute.normalized;
		if ( normalized !== attribute.normalized ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );
			return null;

		}

		if ( gpuType === -1 ) gpuType = attribute.gpuType;
		if ( gpuType !== attribute.gpuType ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );
			return null;

		}

		arrayLength += attribute.count * itemSize;

	}

	const array = new TypedArray( arrayLength );
	const result = new BufferAttribute( array, itemSize, normalized );
	let offset = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		const attribute = attributes[ i ];
		if ( attribute.isInterleavedBufferAttribute ) {

			const tupleOffset = offset / itemSize;
			for ( let j = 0, l = attribute.count; j < l; j ++ ) {

				for ( let c = 0; c < itemSize; c ++ ) {

					const value = attribute.getComponent( j, c );
					result.setComponent( j + tupleOffset, c, value );

				}

			}

		} else {

			array.set( attribute.array, offset );

		}

		offset += attribute.count * itemSize;

	}

	if ( gpuType !== undefined ) {

		result.gpuType = gpuType;

	}

	return result;

}

/**
 * @param {BufferGeometry} geometry
 * @param {number} tolerance
 * @return {BufferGeometry}
 */
function mergeVertices( geometry, tolerance = 1e-4 ) {

	tolerance = Math.max( tolerance, Number.EPSILON );

	// Generate an index buffer if the geometry doesn't have one, or optimize it
	// if it's already available.
	const hashToIndex = {};
	const indices = geometry.getIndex();
	const positions = geometry.getAttribute( 'position' );
	const vertexCount = indices ? indices.count : positions.count;

	// next value for triangle indices
	let nextIndex = 0;

	// attributes and new attribute arrays
	const attributeNames = Object.keys( geometry.attributes );
	const tmpAttributes = {};
	const tmpMorphAttributes = {};
	const newIndices = [];
	const getters = [ 'getX', 'getY', 'getZ', 'getW' ];
	const setters = [ 'setX', 'setY', 'setZ', 'setW' ];

	// Initialize the arrays, allocating space conservatively. Extra
	// space will be trimmed in the last step.
	for ( let i = 0, l = attributeNames.length; i < l; i ++ ) {

		const name = attributeNames[ i ];
		const attr = geometry.attributes[ name ];

		tmpAttributes[ name ] = new BufferAttribute(
			new attr.array.constructor( attr.count * attr.itemSize ),
			attr.itemSize,
			attr.normalized
		);

		const morphAttr = geometry.morphAttributes[ name ];
		if ( morphAttr ) {

			tmpMorphAttributes[ name ] = new BufferAttribute(
				new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),
				morphAttr.itemSize,
				morphAttr.normalized
			);

		}

	}

	// convert the error tolerance to an amount of decimal places to truncate to
	const halfTolerance = tolerance * 0.5;
	const exponent = Math.log10( 1 / tolerance );
	const hashMultiplier = Math.pow( 10, exponent );
	const hashAdditive = halfTolerance * hashMultiplier;
	for ( let i = 0; i < vertexCount; i ++ ) {

		const index = indices ? indices.getX( i ) : i;

		// Generate a hash for the vertex attributes at the current index 'i'
		let hash = '';
		for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

			const name = attributeNames[ j ];
			const attribute = geometry.getAttribute( name );
			const itemSize = attribute.itemSize;

			for ( let k = 0; k < itemSize; k ++ ) {

				// double tilde truncates the decimal value
				hash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;

			}

		}

		// Add another reference to the vertex if it's already
		// used by another index
		if ( hash in hashToIndex ) {

			newIndices.push( hashToIndex[ hash ] );

		} else {

			// copy data to the new index in the temporary attributes
			for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

				const name = attributeNames[ j ];
				const attribute = geometry.getAttribute( name );
				const morphAttr = geometry.morphAttributes[ name ];
				const itemSize = attribute.itemSize;
				const newarray = tmpAttributes[ name ];
				const newMorphArrays = tmpMorphAttributes[ name ];

				for ( let k = 0; k < itemSize; k ++ ) {

					const getterFunc = getters[ k ];
					const setterFunc = setters[ k ];
					newarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );

					if ( morphAttr ) {

						for ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {

							newMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );

						}

					}

				}

			}

			hashToIndex[ hash ] = nextIndex;
			newIndices.push( nextIndex );
			nextIndex ++;

		}

	}

	// generate result BufferGeometry
	const result = geometry.clone();
	for ( const name in geometry.attributes ) {

		const tmpAttribute = tmpAttributes[ name ];

		result.setAttribute( name, new BufferAttribute(
			tmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),
			tmpAttribute.itemSize,
			tmpAttribute.normalized,
		) );

		if ( ! ( name in tmpMorphAttributes ) ) continue;

		for ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {

			const tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];

			result.morphAttributes[ name ][ j ] = new BufferAttribute(
				tmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),
				tmpMorphAttribute.itemSize,
				tmpMorphAttribute.normalized,
			);

		}

	}

	// indices

	result.setIndex( newIndices );

	return result;

}

/**
 * @param {BufferGeometry} geometry
 * @param {number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	if ( drawMode === TrianglesDrawMode ) {

		console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );
		return geometry;

	}

	if ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {

		let index = geometry.getIndex();

		// generate index if not present

		if ( index === null ) {

			const indices = [];

			const position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( let i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		}

		//

		const numberOfTriangles = index.count - 2;
		const newIndices = [];

		if ( drawMode === TriangleFanDrawMode ) {

			// gl.TRIANGLE_FAN

			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP

			for ( let i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );

				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

			console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		}

		// build final geometry

		const newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );
		newGeometry.clearGroups();

		return newGeometry;

	} else {

		console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );
		return geometry;

	}

}

class GLTFLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsDispersionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureAVIFExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsEmissiveStrengthExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIridescenceExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsAnisotropyExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsBumpExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshGpuInstancing( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file
			// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'
			// resourcePath = 'https://my-cnd-server.com/assets/models/'
			// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'
			// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'
			const relativeUrl = LoaderUtils.extractUrlBase( url );
			resourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );

		} else {

			resourcePath = LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === -1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== -1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let json;
		const extensions = {};
		const plugins = {};
		const textDecoder = new TextDecoder();

		if ( typeof data === 'string' ) {

			json = JSON.parse( data );

		} else if ( data instanceof ArrayBuffer ) {

			const magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				json = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );

			} else {

				json = JSON.parse( textDecoder.decode( data ) );

			}

		} else {

			json = data;

		}

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );

			if ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );

			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
	KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
	EXT_MATERIALS_BUMP: 'EXT_materials_bump',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_TEXTURE_AVIF: 'EXT_texture_avif',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
	EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new Color( 0xffffff );

		if ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new DirectionalLight( color );
				lightNode.target.position.set( 0, 0, -1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, -1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		assignExtrasToUserData( lightNode, lightDef );

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	getDependency( type, index ) {

		if ( type !== 'light' ) return;

		return this._loadLight( index );

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */
class GLTFMaterialsEmissiveStrengthExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;

		if ( emissiveStrength !== undefined ) {

			materialParams.emissiveIntensity = emissiveStrength;

		}

		return Promise.resolve();

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Materials dispersion Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion
 */
class GLTFMaterialsDispersionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;

		return Promise.resolve();

	}

}

/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */
class GLTFMaterialsIridescenceExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.iridescenceFactor !== undefined ) {

			materialParams.iridescence = extension.iridescenceFactor;

		}

		if ( extension.iridescenceTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );

		}

		if ( extension.iridescenceIor !== undefined ) {

			materialParams.iridescenceIOR = extension.iridescenceIor;

		}

		if ( materialParams.iridescenceThicknessRange === undefined ) {

			materialParams.iridescenceThicknessRange = [ 100, 400 ];

		}

		if ( extension.iridescenceThicknessMinimum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;

		}

		if ( extension.iridescenceThicknessMaximum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;

		}

		if ( extension.iridescenceThicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new Color( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			const colorFactor = extension.sheenColorFactor;
			materialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || Infinity;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );

		}

		return Promise.all( pending );

	}

}


/**
 * Materials bump Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump
 */
class GLTFMaterialsBumpExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_MATERIALS_BUMP;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;

		if ( extension.bumpTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials anisotropy Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy
 */
class GLTFMaterialsAnisotropyExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.anisotropyStrength !== undefined ) {

			materialParams.anisotropy = extension.anisotropyStrength;

		}

		if ( extension.anisotropyRotation !== undefined ) {

			materialParams.anisotropyRotation = extension.anisotropyRotation;

		}

		if ( extension.anisotropyTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * AVIF Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif
 */
class GLTFTextureAVIFExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image.
				image.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';
				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return buffer.then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const source = new Uint8Array( res, byteOffset, byteLength );

				if ( decoder.decodeGltfBufferAsync ) {

					return decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {

						return res.buffer;

					} );

				} else {

					// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync
					return decoder.ready.then( function () {

						const result = new ArrayBuffer( count * stride );
						decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
						return result;

					} );

				}

			} );

		} else {

			return null;

		}

	}

}

/**
 * GPU Instancing Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
 *
 */
class GLTFMeshGpuInstancing {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
		this.parser = parser;

	}

	createNodeMesh( nodeIndex ) {

		const json = this.parser.json;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||
			nodeDef.mesh === undefined ) {

			return null;

		}

		const meshDef = json.meshes[ nodeDef.mesh ];

		// No Points or Lines + Instancing support yet

		for ( const primitive of meshDef.primitives ) {

			if ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&
				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
				 primitive.mode !== undefined ) {

				return null;

			}

		}

		const extensionDef = nodeDef.extensions[ this.name ];
		const attributesDef = extensionDef.attributes;

		// @TODO: Can we support InstancedMesh + SkinnedMesh?

		const pending = [];
		const attributes = {};

		for ( const key in attributesDef ) {

			pending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {

				attributes[ key ] = accessor;
				return attributes[ key ];

			} ) );

		}

		if ( pending.length < 1 ) {

			return null;

		}

		pending.push( this.parser.createNodeMesh( nodeIndex ) );

		return Promise.all( pending ).then( results => {

			const nodeObject = results.pop();
			const meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];
			const count = results[ 0 ].count; // All attribute counts should be same
			const instancedMeshes = [];

			for ( const mesh of meshes ) {

				// Temporal variables
				const m = new Matrix4();
				const p = new Vector3();
				const q = new Quaternion$1();
				const s = new Vector3( 1, 1, 1 );

				const instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );

				for ( let i = 0; i < count; i ++ ) {

					if ( attributes.TRANSLATION ) {

						p.fromBufferAttribute( attributes.TRANSLATION, i );

					}

					if ( attributes.ROTATION ) {

						q.fromBufferAttribute( attributes.ROTATION, i );

					}

					if ( attributes.SCALE ) {

						s.fromBufferAttribute( attributes.SCALE, i );

					}

					instancedMesh.setMatrixAt( i, m.compose( p, q, s ) );

				}

				// Add instance attributes to the geometry, excluding TRS.
				for ( const attributeName in attributes ) {

					if ( attributeName === '_COLOR_0' ) {

						const attr = attributes[ attributeName ];
						instancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );

					} else if ( attributeName !== 'TRANSLATION' &&
						 attributeName !== 'ROTATION' &&
						 attributeName !== 'SCALE' ) {

						mesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );

					}

				}

				// Just in case
				Object3D.prototype.copy.call( instancedMesh, mesh );

				this.parser.assignFinalMaterial( instancedMesh );

				instancedMeshes.push( instancedMesh );

			}

			if ( nodeObject.isGroup ) {

				nodeObject.clear();

				nodeObject.add( ... instancedMeshes );

				return nodeObject;

			}

			return instancedMeshes[ 0 ];

		} );

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
		const textDecoder = new TextDecoder();

		this.header = {
			magic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = textDecoder.decode( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType.name;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve, reject ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )
			&& transform.offset === undefined
			&& transform.rotation === undefined
			&& transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.texCoord !== undefined ) {

			texture.channel = transform.texCoord;

		}

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer;
		const values = this.sampleValues;
		const stride = this.valueSize;

		const stride2 = stride * 2;
		const stride3 = stride * 3;

		const td = t1 - t0;

		const p = ( t - t0 ) / td;
		const pp = p * p;
		const ppp = pp * p;

		const offset1 = i1 * stride3;
		const offset0 = offset1 - stride3;

		const s2 = -2 * ppp + 3 * pp;
		const s3 = ppp - pp;
		const s0 = 1 - s2;
		const s1 = s3 - pp + p;

		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for ( let i = 0; i !== stride; i ++ ) {

			const p0 = values[ offset0 + i + stride ]; // splineVertex_k
			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	}

}

const _q$1 = new Quaternion$1();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q$1.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: NearestFilter,
	9729: LinearFilter,
	9984: NearestMipmapNearestFilter,
	9985: LinearMipmapNearestFilter,
	9986: NearestMipmapLinearFilter,
	9987: LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: ClampToEdgeWrapping,
	33648: MirroredRepeatWrapping,
	10497: RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv1',
	TEXCOORD_2: 'uv2',
	TEXCOORD_3: 'uv3',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: InterpolateLinear,
	STEP: InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 *
 * @param {Object<String, Material>} cache
 * @return {Material}
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	let geometryKey;

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	if ( primitiveDef.targets !== undefined ) {

		for ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {

			geometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );

		}

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';
	if ( uri.search( /\.ktx2($|\?)/i ) > 0 || uri.search( /^data\:image\/ktx2/ ) === 0 ) return 'image/ktx2';

	return 'image/png';

}

const _identityMatrix$1 = new Matrix4();

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Node cache
		this.nodeCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.

		let isSafari = false;
		let safariVersion = -1;
		let isFirefox = false;
		let firefoxVersion = -1;

		if ( typeof navigator !== 'undefined' ) {

			const userAgent = navigator.userAgent;

			isSafari = /^((?!chrome|android).)*safari/i.test( userAgent ) === true;
			const safariMatch = userAgent.match( /Version\/(\d+)/ );
			safariVersion = isSafari && safariMatch ? parseInt( safariMatch[ 1 ], 10 ) : -1;

			isFirefox = userAgent.indexOf( 'Firefox' ) > -1;
			firefoxVersion = isFirefox ? userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : -1;

		}

		if ( typeof createImageBitmap === 'undefined' || ( isSafari && safariVersion < 17 ) || ( isFirefox && firefoxVersion < 98 ) ) {

			this.textureLoader = new TextureLoader( this.options.manager );

		} else {

			this.textureLoader = new ImageBitmapLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();
		this.nodeCache = {};

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			return Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				for ( const scene of result.scenes ) {

					scene.updateMatrixWorld();

				}

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 *
	 * @param {Object} cache
	 * @param {Object3D} index
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/**
	 * Returns a reference to a shared resource, cloning it if necessary.
	 *
	 * @param {Object} cache
	 * @param {number} index
	 * @param {Object} object
	 * @return {Object}
	 */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadNode && ext.loadNode( index );

					} );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadAnimation && ext.loadAnimation( index );

					} );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					dependency = this._invokeOne( function ( ext ) {

						return ext != this && ext.getDependency && ext.getDependency( type, index );

					} );

					if ( ! dependency ) {

						throw new Error( 'Unknown type: ' + type );

					}

					break;

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
			const normalized = accessorDef.normalized === true;

			const array = new TypedArray( accessorDef.count * itemSize );
			return Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				// Ignore normalized since we copy from sparse
				bufferAttribute.normalized = false;

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

				bufferAttribute.normalized = normalized;

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture|null>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			texture.name = textureDef.name || sourceDef.name || '';

			if ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {

				texture.name = sourceDef.uri;

			}

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;
			texture.generateMipmaps = ! texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			assignExtrasToUserData( texture, sourceDef );

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 *
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @param {string} colorSpace
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef, colorSpace ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			if ( ! texture ) return null;

			if ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {

				texture = texture.clone();
				texture.channel = mapDef.texCoord;

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			if ( colorSpace !== undefined ) {

				texture.colorSpace = colorSpace;

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new PointsMaterial();
				Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new LineBasicMaterial();
				Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );
				lineMaterial.map = material.map;

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= -1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= -1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

			const emissiveFactor = materialDef.emissiveFactor;
			materialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );

		}

		return Promise.all( pending ).then( function () {

			const material = new materialType( materialParams );

			if ( materialDef.name ) material.name = materialDef.name;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/**
	 * When Object3D instances are targeted by animation, they need unique names.
	 *
	 * @param {string} originalName
	 * @return {string}
	 */
	createUniqueName( originalName ) {

		const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

		if ( sanitizedName in this.nodeNamesUsed ) {

			return sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );

		} else {

			this.nodeNamesUsed[ sanitizedName ] = 0;

			return sanitizedName;

		}

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new SkinnedMesh( geometry, material )
						: new Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true ) {

						// normalize skin weights to fix malformed assets (see #15319)
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new Line$1( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );

				return meshes[ 0 ];

			}

			const group = new Group$1();

			if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Skeleton>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const pending = [];

		for ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {

			pending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );

		}

		if ( skinDef.inverseBindMatrices !== undefined ) {

			pending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );

		} else {

			pending.push( null );

		}

		return Promise.all( pending ).then( function ( results ) {

			const inverseBindMatrices = results.pop();
			const jointNodes = results;

			// Note that bones (joint nodes) may or may not be in the
			// scene graph at this time.

			const bones = [];
			const boneInverses = [];

			for ( let i = 0, il = jointNodes.length; i < il; i ++ ) {

				const jointNode = jointNodes[ i ];

				if ( jointNode ) {

					bones.push( jointNode );

					const mat = new Matrix4();

					if ( inverseBindMatrices !== null ) {

						mat.fromArray( inverseBindMatrices.array, i * 16 );

					}

					boneInverses.push( mat );

				} else {

					console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[ i ] );

				}

			}

			return new Skeleton( bones, boneInverses );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;
		const parser = this;

		const animationDef = json.animations[ animationIndex ];
		const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node;
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			if ( target.node === undefined ) continue;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				if ( node.updateMatrix ) {

					node.updateMatrix();

				}

				const createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );

				if ( createdTracks ) {

					for ( let k = 0; k < createdTracks.length; k ++ ) {

						tracks.push( createdTracks[ k ] );

					}

				}

			}

			return new AnimationClip( animationName, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		const nodePending = parser._loadNodeShallow( nodeIndex );

		const childPending = [];
		const childrenDef = nodeDef.children || [];

		for ( let i = 0, il = childrenDef.length; i < il; i ++ ) {

			childPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );

		}

		const skeletonPending = nodeDef.skin === undefined
			? Promise.resolve( null )
			: parser.getDependency( 'skin', nodeDef.skin );

		return Promise.all( [
			nodePending,
			Promise.all( childPending ),
			skeletonPending
		] ).then( function ( results ) {

			const node = results[ 0 ];
			const children = results[ 1 ];
			const skeleton = results[ 2 ];

			if ( skeleton !== null ) {

				// This full traverse should be fine because
				// child glTF nodes have not been added to this node yet.
				node.traverse( function ( mesh ) {

					if ( ! mesh.isSkinnedMesh ) return;

					mesh.bind( skeleton, _identityMatrix$1 );

				} );

			}

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				node.add( children[ i ] );

			}

			return node;

		} );

	}

	// ._loadNodeShallow() parses a single node.
	// skin and child nodes are created and added in .loadNode() (no '_' prefix).
	_loadNodeShallow( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		// This method is called from .loadNode() and .loadSkin().
		// Cache a node to avoid duplication.

		if ( this.nodeCache[ nodeIndex ] !== undefined ) {

			return this.nodeCache[ nodeIndex ];

		}

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		const pending = [];

		const meshPromise = parser._invokeOne( function ( ext ) {

			return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

		} );

		if ( meshPromise ) {

			pending.push( meshPromise );

		}

		if ( nodeDef.camera !== undefined ) {

			pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

				return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

			} ) );

		}

		parser._invokeAll( function ( ext ) {

			return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

		} ).forEach( function ( promise ) {

			pending.push( promise );

		} );

		this.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new Bone();

			} else if ( objects.length > 1 ) {

				node = new Group$1();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

		return this.nodeCache[ nodeIndex ];

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new Group$1();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( parser.getDependency( 'node', nodeIds[ i ] ) );

		}

		return Promise.all( pending ).then( function ( nodes ) {

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				scene.add( nodes[ i ] );

			}

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof Material || key instanceof Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

	_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {

		const tracks = [];

		const targetName = node.name ? node.name : node.uuid;
		const targetNames = [];

		if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

			node.traverse( function ( object ) {

				if ( object.morphTargetInfluences ) {

					targetNames.push( object.name ? object.name : object.uuid );

				}

			} );

		} else {

			targetNames.push( targetName );

		}

		let TypedKeyframeTrack;

		switch ( PATH_PROPERTIES[ target.path ] ) {

			case PATH_PROPERTIES.weights:

				TypedKeyframeTrack = NumberKeyframeTrack;
				break;

			case PATH_PROPERTIES.rotation:

				TypedKeyframeTrack = QuaternionKeyframeTrack;
				break;

			case PATH_PROPERTIES.position:
			case PATH_PROPERTIES.scale:

				TypedKeyframeTrack = VectorKeyframeTrack;
				break;

			default:

				switch ( outputAccessor.itemSize ) {

					case 1:
						TypedKeyframeTrack = NumberKeyframeTrack;
						break;
					case 2:
					case 3:
					default:
						TypedKeyframeTrack = VectorKeyframeTrack;
						break;

				}

				break;

		}

		const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;


		const outputArray = this._getArrayFromAccessor( outputAccessor );

		for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

			const track = new TypedKeyframeTrack(
				targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
				inputAccessor.array,
				outputArray,
				interpolation
			);

			// Override interpolation with custom factory method.
			if ( sampler.interpolation === 'CUBICSPLINE' ) {

				this._createCubicSplineTrackInterpolant( track );

			}

			tracks.push( track );

		}

		return tracks;

	}

	_getArrayFromAccessor( accessor ) {

		let outputArray = accessor.array;

		if ( accessor.normalized ) {

			const scale = getNormalizedComponentScale( outputArray.constructor );
			const scaled = new Float32Array( outputArray.length );

			for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

				scaled[ j ] = outputArray[ j ] * scale;

			}

			outputArray = scaled;

		}

		return outputArray;

	}

	_createCubicSplineTrackInterpolant( track ) {

		track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

			// A CUBICSPLINE keyframe in glTF has three output values for each input value,
			// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
			// must be divided by three to get the interpolant's sampleSize argument.

			const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

			return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

		};

		// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
		track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

	}

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new Vector3();
		const vector = new Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	if ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {

		console.warn( `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.` );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

const _taskCache$1 = new WeakMap();

class DRACOLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.decoderPath = '';
		this.decoderConfig = {};
		this.decoderBinary = null;
		this.decoderPending = null;

		this.workerLimit = 4;
		this.workerPool = [];
		this.workerNextTaskID = 1;
		this.workerSourceURL = '';

		this.defaultAttributeIDs = {
			position: 'POSITION',
			normal: 'NORMAL',
			color: 'COLOR',
			uv: 'TEX_COORD'
		};
		this.defaultAttributeTypes = {
			position: 'Float32Array',
			normal: 'Float32Array',
			color: 'Float32Array',
			uv: 'Float32Array'
		};

	}

	setDecoderPath( path ) {

		this.decoderPath = path;

		return this;

	}

	setDecoderConfig( config ) {

		this.decoderConfig = config;

		return this;

	}

	setWorkerLimit( workerLimit ) {

		this.workerLimit = workerLimit;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			this.parse( buffer, onLoad, onError );

		}, onProgress, onError );

	}

	parse( buffer, onLoad, onError ) {

		this.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace ).catch( onError );

	}

	decodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace ) {

		const taskConfig = {
			attributeIDs: attributeIDs || this.defaultAttributeIDs,
			attributeTypes: attributeTypes || this.defaultAttributeTypes,
			useUniqueIDs: !! attributeIDs,
			vertexColorSpace: vertexColorSpace,
		};

		return this.decodeGeometry( buffer, taskConfig ).then( callback );

	}

	decodeGeometry( buffer, taskConfig ) {

		const taskKey = JSON.stringify( taskConfig );

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( _taskCache$1.has( buffer ) ) {

			const cachedTask = _taskCache$1.get( buffer );

			if ( cachedTask.key === taskKey ) {

				return cachedTask.promise;

			} else if ( buffer.byteLength === 0 ) {

				// Technically, it would be possible to wait for the previous task to complete,
				// transfer the buffer back, and decode again with the second configuration. That
				// is complex, and I don't know of any reason to decode a Draco buffer twice in
				// different ways, so this is left unimplemented.
				throw new Error(

					'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
					'settings. Buffer has already been transferred.'

				);

			}

		}

		//

		let worker;
		const taskID = this.workerNextTaskID ++;
		const taskCost = buffer.byteLength;

		// Obtain a worker and assign a task, and construct a geometry instance
		// when the task completes.
		const geometryPending = this._getWorker( taskID, taskCost )
			.then( ( _worker ) => {

				worker = _worker;

				return new Promise( ( resolve, reject ) => {

					worker._callbacks[ taskID ] = { resolve, reject };

					worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );

					// this.debug();

				} );

			} )
			.then( ( message ) => this._createGeometry( message.geometry ) );

		// Remove task from the task list.
		// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
		geometryPending
			.catch( () => true )
			.then( () => {

				if ( worker && taskID ) {

					this._releaseTask( worker, taskID );

					// this.debug();

				}

			} );

		// Cache the task result.
		_taskCache$1.set( buffer, {

			key: taskKey,
			promise: geometryPending

		} );

		return geometryPending;

	}

	_createGeometry( geometryData ) {

		const geometry = new BufferGeometry();

		if ( geometryData.index ) {

			geometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );

		}

		for ( let i = 0; i < geometryData.attributes.length; i ++ ) {

			const result = geometryData.attributes[ i ];
			const name = result.name;
			const array = result.array;
			const itemSize = result.itemSize;

			const attribute = new BufferAttribute( array, itemSize );

			if ( name === 'color' ) {

				this._assignVertexColorSpace( attribute, result.vertexColorSpace );

				attribute.normalized = ( array instanceof Float32Array ) === false;

			}

			geometry.setAttribute( name, attribute );

		}

		return geometry;

	}

	_assignVertexColorSpace( attribute, inputColorSpace ) {

		// While .drc files do not specify colorspace, the only 'official' tooling
		// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc
		// file is passed into .load() or .parse(). GLTFLoader uses internal APIs
		// to decode geometry, and vertex colors are already Linear-sRGB in there.

		if ( inputColorSpace !== SRGBColorSpace ) return;

		const _color = new Color();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			_color.fromBufferAttribute( attribute, i ).convertSRGBToLinear();
			attribute.setXYZ( i, _color.r, _color.g, _color.b );

		}

	}

	_loadLibrary( url, responseType ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.decoderPath );
		loader.setResponseType( responseType );
		loader.setWithCredentials( this.withCredentials );

		return new Promise( ( resolve, reject ) => {

			loader.load( url, resolve, undefined, reject );

		} );

	}

	preload() {

		this._initDecoder();

		return this;

	}

	_initDecoder() {

		if ( this.decoderPending ) return this.decoderPending;

		const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
		const librariesPending = [];

		if ( useJS ) {

			librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );

		} else {

			librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );
			//librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );

		}

		this.decoderPending = Promise.all( librariesPending )
			.then( ( libraries ) => {

				const jsContent = libraries[ 0 ];

				const fn = DRACOWorker.toString();

				const body = [
					'/* draco decoder */',
					jsContent,
					'',
					'/* worker */',
					fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
				].join( '\n' );

				this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

			} );

		return this.decoderPending;

	}

	_getWorker( taskID, taskCost ) {

		return this._initDecoder().then( () => {

			if ( this.workerPool.length < this.workerLimit ) {

				const worker = new Worker( this.workerSourceURL );

				worker._callbacks = {};
				worker._taskCosts = {};
				worker._taskLoad = 0;

				worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );

				worker.onmessage = function ( e ) {

					const message = e.data;

					switch ( message.type ) {

						case 'decode':
							worker._callbacks[ message.id ].resolve( message );
							break;

						case 'error':
							worker._callbacks[ message.id ].reject( message );
							break;

						default:
							console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );

					}

				};

				this.workerPool.push( worker );

			} else {

				this.workerPool.sort( function ( a, b ) {

					return a._taskLoad > b._taskLoad ? -1 : 1;

				} );

			}

			const worker = this.workerPool[ this.workerPool.length - 1 ];
			worker._taskCosts[ taskID ] = taskCost;
			worker._taskLoad += taskCost;
			return worker;

		} );

	}

	_releaseTask( worker, taskID ) {

		worker._taskLoad -= worker._taskCosts[ taskID ];
		delete worker._callbacks[ taskID ];
		delete worker._taskCosts[ taskID ];

	}

	debug() {

		console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

	}

	dispose() {

		for ( let i = 0; i < this.workerPool.length; ++ i ) {

			this.workerPool[ i ].terminate();

		}

		this.workerPool.length = 0;

		if ( this.workerSourceURL !== '' ) {

			URL.revokeObjectURL( this.workerSourceURL );

		}

		return this;

	}

}

/* WEB WORKER */

function DRACOWorker() {

	let decoderConfig;
	let decoderPending;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				const buffer = message.buffer;
				const taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					const draco = module.draco;
					const decoder = new draco.Decoder();

					try {

						const geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );

						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, array, taskConfig ) {

		const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType( array );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		const geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( const attributeName in attributeIDs ) {

			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and `.drc` files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === -1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			const attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );

			if ( attributeName === 'color' ) {

				attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;

			}

			geometry.attributes.push( attributeResult );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType( draco, attributeType );

		const ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

}

/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/

var durl = function (c) { return URL.createObjectURL(new Blob([c], { type: 'text/javascript' })); };
try {
    URL.revokeObjectURL(durl(''));
}
catch (e) {
    // We're in Deno or a very old browser
    durl = function (c) { return 'data:application/javascript;charset=UTF-8,' + encodeURI(c); };
}

// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
// fixed length extra bits
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
// fixed distance extra bits
// see fleb note
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
// code length index map
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
// get base, reverse index map from extra bits
var freb = function (eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new u32(b[30]);
    for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = ((j - b[i]) << 5) | i;
        }
    }
    return [b, r];
};
var _a$1 = freb(fleb, 2), fl = _a$1[0], revfl = _a$1[1];
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b[0];
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for (var i$1 = 0; i$1 < 32768; ++i$1) {
    // reverse table algorithm from SO
    var x$1 = ((i$1 & 0xAAAA) >>> 1) | ((i$1 & 0x5555) << 1);
    x$1 = ((x$1 & 0xCCCC) >>> 2) | ((x$1 & 0x3333) << 2);
    x$1 = ((x$1 & 0xF0F0) >>> 4) | ((x$1 & 0x0F0F) << 4);
    rev[i$1] = (((x$1 & 0xFF00) >>> 8) | ((x$1 & 0x00FF) << 8)) >>> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = (function (cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for (; i < s; ++i)
        ++l[cd[i] - 1];
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for (i = 0; i < mb; ++i) {
        le[i] = (le[i - 1] + l[i - 1]) << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = (i << 4) | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >>> rvb] = sv;
                }
            }
        }
    }
    else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
            }
        }
    }
    return co;
});
// fixed length tree
var flt = new u8(288);
for (var i$1 = 0; i$1 < 144; ++i$1)
    flt[i$1] = 8;
for (var i$1 = 144; i$1 < 256; ++i$1)
    flt[i$1] = 9;
for (var i$1 = 256; i$1 < 280; ++i$1)
    flt[i$1] = 7;
for (var i$1 = 280; i$1 < 288; ++i$1)
    flt[i$1] = 8;
// fixed distance tree
var fdt = new u8(32);
for (var i$1 = 0; i$1 < 32; ++i$1)
    fdt[i$1] = 5;
// fixed length map
var flrm = /*#__PURE__*/ hMap(flt, 9, 1);
// fixed distance map
var fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
// find max of array
var max = function (a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
        if (a[i] > m)
            m = a[i];
    }
    return m;
};
// read d, starting at bit p and mask with m
var bits = function (d, p, m) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
};
// read d, starting at bit p continuing for at least 16 bits
var bits16 = function (d, p) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
};
// get end of byte
var shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function (v, s, e) {
    if (e == null || e > v.length)
        e = v.length;
    // can't use .constructor in case user-supplied
    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
    n.set(v.subarray(s, e));
    return n;
};
// expands raw DEFLATE data
var inflt = function (dat, buf, st) {
    // source length
    var sl = dat.length;
    if (!sl || (st && !st.l && sl < 5))
        return buf || new u8(0);
    // have to estimate size
    var noBuf = !buf || st;
    // no state
    var noSt = !st || st.i;
    if (!st)
        st = {};
    // Assumes roughly 33% compression ratio average
    if (!buf)
        buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function (l) {
        var bl = buf.length;
        // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            var nbuf = new u8(Math.max(bl * 2, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    };
    //  last chunk         bitpos           bytes
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            st.f = final = bits(dat, pos, 1);
            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                if (t > sl) {
                    if (noSt)
                        throw 'unexpected EOF';
                    break;
                }
                // ensure size
                if (noBuf)
                    cbuf(bt + l);
                // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt);
                // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t * 8;
                continue;
            }
            else if (type == 1)
                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                // length+distance tree
                var ldt = new u8(tl);
                // code length tree
                var clt = new u8(19);
                for (var i = 0; i < hcLen; ++i) {
                    // use index map to get real code
                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
                }
                pos += hcLen * 3;
                // code lengths bits
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                // code lengths map
                var clm = hMap(clt, clb, 1);
                for (var i = 0; i < tl;) {
                    var r = clm[bits(dat, pos, clbmsk)];
                    // bits read
                    pos += r & 15;
                    // symbol
                    var s = r >>> 4;
                    // code length to copy
                    if (s < 16) {
                        ldt[i++] = s;
                    }
                    else {
                        //  copy   count
                        var c = 0, n = 0;
                        if (s == 16)
                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                        else if (s == 17)
                            n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s == 18)
                            n = 11 + bits(dat, pos, 127), pos += 7;
                        while (n--)
                            ldt[i++] = c;
                    }
                }
                //    length tree                 distance tree
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                // max length bits
                lbt = max(lt);
                // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            }
            else
                throw 'invalid block type';
            if (pos > tbts) {
                if (noSt)
                    throw 'unexpected EOF';
                break;
            }
        }
        // Make sure the buffer can hold this + the largest possible addition
        // Maximum chunk size (practically, theoretically infinite) is 2^17;
        if (noBuf)
            cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (;; lpos = pos) {
            // bits read, code
            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
            pos += c & 15;
            if (pos > tbts) {
                if (noSt)
                    throw 'unexpected EOF';
                break;
            }
            if (!c)
                throw 'invalid length/literal';
            if (sym < 256)
                buf[bt++] = sym;
            else if (sym == 256) {
                lpos = pos, lm = null;
                break;
            }
            else {
                var add = sym - 254;
                // no extra bits needed if less
                if (sym > 264) {
                    // index
                    var i = sym - 257, b = fleb[i];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                    pos += b;
                }
                // dist
                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                if (!d)
                    throw 'invalid distance';
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                    var b = fdeb[dsym];
                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
                }
                if (pos > tbts) {
                    if (noSt)
                        throw 'unexpected EOF';
                    break;
                }
                if (noBuf)
                    cbuf(bt + 131072);
                var end = bt + add;
                for (; bt < end; bt += 4) {
                    buf[bt] = buf[bt - dt];
                    buf[bt + 1] = buf[bt + 1 - dt];
                    buf[bt + 2] = buf[bt + 2 - dt];
                    buf[bt + 3] = buf[bt + 3 - dt];
                }
                bt = end;
            }
        }
        st.l = lm, st.p = lpos, st.b = bt;
        if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
};
// empty
var et = /*#__PURE__*/ new u8(0);
// zlib valid
var zlv = function (d) {
    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
        throw 'invalid zlib data';
    if (d[1] & 32)
        throw 'invalid zlib data: preset dictionaries not supported';
};
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */
function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
}
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et, { stream: true });
    tds = 1;
}
catch (e) { }

/**
 * NURBS utils
 *
 * See NURBSCurve and NURBSSurface.
 **/


/**************************************************************
 *	NURBS Utils
 **************************************************************/

/*
Finds knot vector span.

p : degree
u : parametric value
U : knot vector

returns the span
*/
function findSpan( p, u, U ) {

	const n = U.length - p - 1;

	if ( u >= U[ n ] ) {

		return n - 1;

	}

	if ( u <= U[ p ] ) {

		return p;

	}

	let low = p;
	let high = n;
	let mid = Math.floor( ( low + high ) / 2 );

	while ( u < U[ mid ] || u >= U[ mid + 1 ] ) {

		if ( u < U[ mid ] ) {

			high = mid;

		} else {

			low = mid;

		}

		mid = Math.floor( ( low + high ) / 2 );

	}

	return mid;

}


/*
Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2

span : span in which u lies
u    : parametric point
p    : degree
U    : knot vector

returns array[p+1] with basis functions values.
*/
function calcBasisFunctions( span, u, p, U ) {

	const N = [];
	const left = [];
	const right = [];
	N[ 0 ] = 1.0;

	for ( let j = 1; j <= p; ++ j ) {

		left[ j ] = u - U[ span + 1 - j ];
		right[ j ] = U[ span + j ] - u;

		let saved = 0.0;

		for ( let r = 0; r < j; ++ r ) {

			const rv = right[ r + 1 ];
			const lv = left[ j - r ];
			const temp = N[ r ] / ( rv + lv );
			N[ r ] = saved + rv * temp;
			saved = lv * temp;

		}

		N[ j ] = saved;

	}

	return N;

}


/*
Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

p : degree of B-Spline
U : knot vector
P : control points (x, y, z, w)
u : parametric point

returns point for given u
*/
function calcBSplinePoint( p, U, P, u ) {

	const span = findSpan( p, u, U );
	const N = calcBasisFunctions( span, u, p, U );
	const C = new Vector4( 0, 0, 0, 0 );

	for ( let j = 0; j <= p; ++ j ) {

		const point = P[ span - p + j ];
		const Nj = N[ j ];
		const wNj = point.w * Nj;
		C.x += point.x * wNj;
		C.y += point.y * wNj;
		C.z += point.z * wNj;
		C.w += point.w * Nj;

	}

	return C;

}


/*
Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

span : span in which u lies
u    : parametric point
p    : degree
n    : number of derivatives to calculate
U    : knot vector

returns array[n+1][p+1] with basis functions derivatives
*/
function calcBasisFunctionDerivatives( span, u, p, n, U ) {

	const zeroArr = [];
	for ( let i = 0; i <= p; ++ i )
		zeroArr[ i ] = 0.0;

	const ders = [];

	for ( let i = 0; i <= n; ++ i )
		ders[ i ] = zeroArr.slice( 0 );

	const ndu = [];

	for ( let i = 0; i <= p; ++ i )
		ndu[ i ] = zeroArr.slice( 0 );

	ndu[ 0 ][ 0 ] = 1.0;

	const left = zeroArr.slice( 0 );
	const right = zeroArr.slice( 0 );

	for ( let j = 1; j <= p; ++ j ) {

		left[ j ] = u - U[ span + 1 - j ];
		right[ j ] = U[ span + j ] - u;

		let saved = 0.0;

		for ( let r = 0; r < j; ++ r ) {

			const rv = right[ r + 1 ];
			const lv = left[ j - r ];
			ndu[ j ][ r ] = rv + lv;

			const temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];
			ndu[ r ][ j ] = saved + rv * temp;
			saved = lv * temp;

		}

		ndu[ j ][ j ] = saved;

	}

	for ( let j = 0; j <= p; ++ j ) {

		ders[ 0 ][ j ] = ndu[ j ][ p ];

	}

	for ( let r = 0; r <= p; ++ r ) {

		let s1 = 0;
		let s2 = 1;

		const a = [];
		for ( let i = 0; i <= p; ++ i ) {

			a[ i ] = zeroArr.slice( 0 );

		}

		a[ 0 ][ 0 ] = 1.0;

		for ( let k = 1; k <= n; ++ k ) {

			let d = 0.0;
			const rk = r - k;
			const pk = p - k;

			if ( r >= k ) {

				a[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];
				d = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];

			}

			const j1 = ( rk >= -1 ) ? 1 : - rk;
			const j2 = ( r - 1 <= pk ) ? k - 1 : p - r;

			for ( let j = j1; j <= j2; ++ j ) {

				a[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];
				d += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];

			}

			if ( r <= pk ) {

				a[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];
				d += a[ s2 ][ k ] * ndu[ r ][ pk ];

			}

			ders[ k ][ r ] = d;

			const j = s1;
			s1 = s2;
			s2 = j;

		}

	}

	let r = p;

	for ( let k = 1; k <= n; ++ k ) {

		for ( let j = 0; j <= p; ++ j ) {

			ders[ k ][ j ] *= r;

		}

		r *= p - k;

	}

	return ders;

}


/*
	Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

	p  : degree
	U  : knot vector
	P  : control points
	u  : Parametric points
	nd : number of derivatives

	returns array[d+1] with derivatives
	*/
function calcBSplineDerivatives( p, U, P, u, nd ) {

	const du = nd < p ? nd : p;
	const CK = [];
	const span = findSpan( p, u, U );
	const nders = calcBasisFunctionDerivatives( span, u, p, du, U );
	const Pw = [];

	for ( let i = 0; i < P.length; ++ i ) {

		const point = P[ i ].clone();
		const w = point.w;

		point.x *= w;
		point.y *= w;
		point.z *= w;

		Pw[ i ] = point;

	}

	for ( let k = 0; k <= du; ++ k ) {

		const point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );

		for ( let j = 1; j <= p; ++ j ) {

			point.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );

		}

		CK[ k ] = point;

	}

	for ( let k = du + 1; k <= nd + 1; ++ k ) {

		CK[ k ] = new Vector4( 0, 0, 0 );

	}

	return CK;

}


/*
Calculate "K over I"

returns k!/(i!(k-i)!)
*/
function calcKoverI( k, i ) {

	let nom = 1;

	for ( let j = 2; j <= k; ++ j ) {

		nom *= j;

	}

	let denom = 1;

	for ( let j = 2; j <= i; ++ j ) {

		denom *= j;

	}

	for ( let j = 2; j <= k - i; ++ j ) {

		denom *= j;

	}

	return nom / denom;

}


/*
Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

Pders : result of function calcBSplineDerivatives

returns array with derivatives for rational curve.
*/
function calcRationalCurveDerivatives( Pders ) {

	const nd = Pders.length;
	const Aders = [];
	const wders = [];

	for ( let i = 0; i < nd; ++ i ) {

		const point = Pders[ i ];
		Aders[ i ] = new Vector3( point.x, point.y, point.z );
		wders[ i ] = point.w;

	}

	const CK = [];

	for ( let k = 0; k < nd; ++ k ) {

		const v = Aders[ k ].clone();

		for ( let i = 1; i <= k; ++ i ) {

			v.sub( CK[ k - i ].clone().multiplyScalar( calcKoverI( k, i ) * wders[ i ] ) );

		}

		CK[ k ] = v.divideScalar( wders[ 0 ] );

	}

	return CK;

}


/*
Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

p  : degree
U  : knot vector
P  : control points in homogeneous space
u  : parametric points
nd : number of derivatives

returns array with derivatives.
*/
function calcNURBSDerivatives( p, U, P, u, nd ) {

	const Pders = calcBSplineDerivatives( p, U, P, u, nd );
	return calcRationalCurveDerivatives( Pders );

}

/**
 * NURBS curve object
 *
 * Derives from Curve, overriding getPoint and getTangent.
 *
 * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.
 *
 **/

class NURBSCurve extends Curve {

	constructor(
		degree,
		knots /* array of reals */,
		controlPoints /* array of Vector(2|3|4) */,
		startKnot /* index in knots */,
		endKnot /* index in knots */
	) {

		super();

		this.degree = degree;
		this.knots = knots;
		this.controlPoints = [];
		// Used by periodic NURBS to remove hidden spans
		this.startKnot = startKnot || 0;
		this.endKnot = endKnot || ( this.knots.length - 1 );

		for ( let i = 0; i < controlPoints.length; ++ i ) {

			// ensure Vector4 for control points
			const point = controlPoints[ i ];
			this.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );

		}

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u

		// following results in (wx, wy, wz, w) homogeneous point
		const hpoint = calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );

		if ( hpoint.w !== 1.0 ) {

			// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)
			hpoint.divideScalar( hpoint.w );

		}

		return point.set( hpoint.x, hpoint.y, hpoint.z );

	}

	getTangent( t, optionalTarget = new Vector3() ) {

		const tangent = optionalTarget;

		const u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );
		const ders = calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );
		tangent.copy( ders[ 1 ] ).normalize();

		return tangent;

	}

}

/**
 * Loader loads FBX file and generates Group representing FBX scene.
 * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format
 * Versions lower than this may load but will probably have errors
 *
 * Needs Support:
 *  Morph normals / blend shape normals
 *
 * FBX format references:
 * 	https://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)
 *
 * Binary format specification:
 *	https://code.blender.org/2013/08/fbx-binary-file-format-specification/
 */


let fbxTree;
let connections;
let sceneGraph;

class FBXLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;

		const loader = new FileLoader( this.manager );
		loader.setPath( scope.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		loader.load( url, function ( buffer ) {

			try {

				onLoad( scope.parse( buffer, path ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( FBXBuffer, path ) {

		if ( isFbxFormatBinary( FBXBuffer ) ) {

			fbxTree = new BinaryParser().parse( FBXBuffer );

		} else {

			const FBXText = convertArrayBufferToString( FBXBuffer );

			if ( ! isFbxFormatASCII( FBXText ) ) {

				throw new Error( 'THREE.FBXLoader: Unknown format.' );

			}

			if ( getFbxVersion( FBXText ) < 7000 ) {

				throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );

			}

			fbxTree = new TextParser().parse( FBXText );

		}

		// console.log( fbxTree );

		const textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

		return new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );

	}

}

// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group
class FBXTreeParser {

	constructor( textureLoader, manager ) {

		this.textureLoader = textureLoader;
		this.manager = manager;

	}

	parse() {

		connections = this.parseConnections();

		const images = this.parseImages();
		const textures = this.parseTextures( images );
		const materials = this.parseMaterials( textures );
		const deformers = this.parseDeformers();
		const geometryMap = new GeometryParser().parse( deformers );

		this.parseScene( deformers, geometryMap, materials );

		return sceneGraph;

	}

	// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
	// and details the connection type
	parseConnections() {

		const connectionMap = new Map();

		if ( 'Connections' in fbxTree ) {

			const rawConnections = fbxTree.Connections.connections;

			rawConnections.forEach( function ( rawConnection ) {

				const fromID = rawConnection[ 0 ];
				const toID = rawConnection[ 1 ];
				const relationship = rawConnection[ 2 ];

				if ( ! connectionMap.has( fromID ) ) {

					connectionMap.set( fromID, {
						parents: [],
						children: []
					} );

				}

				const parentRelationship = { ID: toID, relationship: relationship };
				connectionMap.get( fromID ).parents.push( parentRelationship );

				if ( ! connectionMap.has( toID ) ) {

					connectionMap.set( toID, {
						parents: [],
						children: []
					} );

				}

				const childRelationship = { ID: fromID, relationship: relationship };
				connectionMap.get( toID ).children.push( childRelationship );

			} );

		}

		return connectionMap;

	}

	// Parse FBXTree.Objects.Video for embedded image data
	// These images are connected to textures in FBXTree.Objects.Textures
	// via FBXTree.Connections.
	parseImages() {

		const images = {};
		const blobs = {};

		if ( 'Video' in fbxTree.Objects ) {

			const videoNodes = fbxTree.Objects.Video;

			for ( const nodeID in videoNodes ) {

				const videoNode = videoNodes[ nodeID ];

				const id = parseInt( nodeID );

				images[ id ] = videoNode.RelativeFilename || videoNode.Filename;

				// raw image data is in videoNode.Content
				if ( 'Content' in videoNode ) {

					const arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );
					const base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );

					if ( arrayBufferContent || base64Content ) {

						const image = this.parseImage( videoNodes[ nodeID ] );

						blobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;

					}

				}

			}

		}

		for ( const id in images ) {

			const filename = images[ id ];

			if ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];
			else images[ id ] = images[ id ].split( '\\' ).pop();

		}

		return images;

	}

	// Parse embedded image data in FBXTree.Video.Content
	parseImage( videoNode ) {

		const content = videoNode.Content;
		const fileName = videoNode.RelativeFilename || videoNode.Filename;
		const extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();

		let type;

		switch ( extension ) {

			case 'bmp':

				type = 'image/bmp';
				break;

			case 'jpg':
			case 'jpeg':

				type = 'image/jpeg';
				break;

			case 'png':

				type = 'image/png';
				break;

			case 'tif':

				type = 'image/tiff';
				break;

			case 'tga':

				if ( this.manager.getHandler( '.tga' ) === null ) {

					console.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );

				}

				type = 'image/tga';
				break;

			default:

				console.warn( 'FBXLoader: Image type "' + extension + '" is not supported.' );
				return;

		}

		if ( typeof content === 'string' ) { // ASCII format

			return 'data:' + type + ';base64,' + content;

		} else { // Binary Format

			const array = new Uint8Array( content );
			return window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );

		}

	}

	// Parse nodes in FBXTree.Objects.Texture
	// These contain details such as UV scaling, cropping, rotation etc and are connected
	// to images in FBXTree.Objects.Video
	parseTextures( images ) {

		const textureMap = new Map();

		if ( 'Texture' in fbxTree.Objects ) {

			const textureNodes = fbxTree.Objects.Texture;
			for ( const nodeID in textureNodes ) {

				const texture = this.parseTexture( textureNodes[ nodeID ], images );
				textureMap.set( parseInt( nodeID ), texture );

			}

		}

		return textureMap;

	}

	// Parse individual node in FBXTree.Objects.Texture
	parseTexture( textureNode, images ) {

		const texture = this.loadTexture( textureNode, images );

		texture.ID = textureNode.id;

		texture.name = textureNode.attrName;

		const wrapModeU = textureNode.WrapModeU;
		const wrapModeV = textureNode.WrapModeV;

		const valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
		const valueV = wrapModeV !== undefined ? wrapModeV.value : 0;

		// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
		// 0: repeat(default), 1: clamp

		texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
		texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;

		if ( 'Scaling' in textureNode ) {

			const values = textureNode.Scaling.value;

			texture.repeat.x = values[ 0 ];
			texture.repeat.y = values[ 1 ];

		}

		if ( 'Translation' in textureNode ) {

			const values = textureNode.Translation.value;

			texture.offset.x = values[ 0 ];
			texture.offset.y = values[ 1 ];

		}

		return texture;

	}

	// load a texture specified as a blob or data URI, or via an external URL using TextureLoader
	loadTexture( textureNode, images ) {

		const nonNativeExtensions = new Set( [ 'tga', 'tif', 'tiff', 'exr', 'dds', 'hdr', 'ktx2' ] );

		const extension = textureNode.FileName.split( '.' ).pop().toLowerCase();

		const loader = nonNativeExtensions.has( extension ) ? this.manager.getHandler( `.${extension}` ) : this.textureLoader;

		if ( ! loader ) {

			console.warn(
				`FBXLoader: ${extension.toUpperCase()} loader not found, creating placeholder texture for`,
				textureNode.RelativeFilename
			);
			return new Texture();

		}

		const loaderPath = loader.path;

		if ( ! loaderPath ) {

			loader.setPath( this.textureLoader.path );

		}

		const children = connections.get( textureNode.id ).children;

		let fileName;

		if ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {

			fileName = images[ children[ 0 ].ID ];

			if ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {

				loader.setPath( undefined );

			}

		}

		const texture = loader.load( fileName );

		// revert to initial path
		loader.setPath( loaderPath );

		return texture;

	}

	// Parse nodes in FBXTree.Objects.Material
	parseMaterials( textureMap ) {

		const materialMap = new Map();

		if ( 'Material' in fbxTree.Objects ) {

			const materialNodes = fbxTree.Objects.Material;

			for ( const nodeID in materialNodes ) {

				const material = this.parseMaterial( materialNodes[ nodeID ], textureMap );

				if ( material !== null ) materialMap.set( parseInt( nodeID ), material );

			}

		}

		return materialMap;

	}

	// Parse single node in FBXTree.Objects.Material
	// Materials are connected to texture maps in FBXTree.Objects.Textures
	// FBX format currently only supports Lambert and Phong shading models
	parseMaterial( materialNode, textureMap ) {

		const ID = materialNode.id;
		const name = materialNode.attrName;
		let type = materialNode.ShadingModel;

		// Case where FBX wraps shading model in property object.
		if ( typeof type === 'object' ) {

			type = type.value;

		}

		// Ignore unused materials which don't have any connections.
		if ( ! connections.has( ID ) ) return null;

		const parameters = this.parseParameters( materialNode, textureMap, ID );

		let material;

		switch ( type.toLowerCase() ) {

			case 'phong':
				material = new MeshPhongMaterial();
				break;
			case 'lambert':
				material = new MeshLambertMaterial();
				break;
			default:
				console.warn( 'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type );
				material = new MeshPhongMaterial();
				break;

		}

		material.setValues( parameters );
		material.name = name;

		return material;

	}

	// Parse FBX material and return parameters suitable for a three.js material
	// Also parse the texture map and return any textures associated with the material
	parseParameters( materialNode, textureMap, ID ) {

		const parameters = {};

		if ( materialNode.BumpFactor ) {

			parameters.bumpScale = materialNode.BumpFactor.value;

		}

		if ( materialNode.Diffuse ) {

			parameters.color = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.Diffuse.value ), SRGBColorSpace );

		} else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {

			// The blender exporter exports diffuse here instead of in materialNode.Diffuse
			parameters.color = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.DiffuseColor.value ), SRGBColorSpace );

		}

		if ( materialNode.DisplacementFactor ) {

			parameters.displacementScale = materialNode.DisplacementFactor.value;

		}

		if ( materialNode.Emissive ) {

			parameters.emissive = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.Emissive.value ), SRGBColorSpace );

		} else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {

			// The blender exporter exports emissive color here instead of in materialNode.Emissive
			parameters.emissive = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.EmissiveColor.value ), SRGBColorSpace );

		}

		if ( materialNode.EmissiveFactor ) {

			parameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );

		}

		// the transparency handling is implemented based on Blender/Unity's approach: https://github.com/sobotka/blender-addons/blob/7d80f2f97161fc8e353a657b179b9aa1f8e5280b/io_scene_fbx/import_fbx.py#L1444-L1459

		parameters.opacity = 1 - ( materialNode.TransparencyFactor ? parseFloat( materialNode.TransparencyFactor.value ) : 0 );

		if ( parameters.opacity === 1 || parameters.opacity === 0 ) {

			parameters.opacity = ( materialNode.Opacity ? parseFloat( materialNode.Opacity.value ) : null );

			if ( parameters.opacity === null ) {

				parameters.opacity = 1 - ( materialNode.TransparentColor ? parseFloat( materialNode.TransparentColor.value[ 0 ] ) : 0 );

			}

		}

		if ( parameters.opacity < 1.0 ) {

			parameters.transparent = true;

		}

		if ( materialNode.ReflectionFactor ) {

			parameters.reflectivity = materialNode.ReflectionFactor.value;

		}

		if ( materialNode.Shininess ) {

			parameters.shininess = materialNode.Shininess.value;

		}

		if ( materialNode.Specular ) {

			parameters.specular = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.Specular.value ), SRGBColorSpace );

		} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {

			// The blender exporter exports specular color here instead of in materialNode.Specular
			parameters.specular = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.SpecularColor.value ), SRGBColorSpace );

		}

		const scope = this;
		connections.get( ID ).children.forEach( function ( child ) {

			const type = child.relationship;

			switch ( type ) {

				case 'Bump':
					parameters.bumpMap = scope.getTexture( textureMap, child.ID );
					break;

				case 'Maya|TEX_ao_map':
					parameters.aoMap = scope.getTexture( textureMap, child.ID );
					break;

				case 'DiffuseColor':
				case 'Maya|TEX_color_map':
					parameters.map = scope.getTexture( textureMap, child.ID );
					if ( parameters.map !== undefined ) {

						parameters.map.colorSpace = SRGBColorSpace;

					}

					break;

				case 'DisplacementColor':
					parameters.displacementMap = scope.getTexture( textureMap, child.ID );
					break;

				case 'EmissiveColor':
					parameters.emissiveMap = scope.getTexture( textureMap, child.ID );
					if ( parameters.emissiveMap !== undefined ) {

						parameters.emissiveMap.colorSpace = SRGBColorSpace;

					}

					break;

				case 'NormalMap':
				case 'Maya|TEX_normal_map':
					parameters.normalMap = scope.getTexture( textureMap, child.ID );
					break;

				case 'ReflectionColor':
					parameters.envMap = scope.getTexture( textureMap, child.ID );
					if ( parameters.envMap !== undefined ) {

						parameters.envMap.mapping = EquirectangularReflectionMapping;
						parameters.envMap.colorSpace = SRGBColorSpace;

					}

					break;

				case 'SpecularColor':
					parameters.specularMap = scope.getTexture( textureMap, child.ID );
					if ( parameters.specularMap !== undefined ) {

						parameters.specularMap.colorSpace = SRGBColorSpace;

					}

					break;

				case 'TransparentColor':
				case 'TransparencyFactor':
					parameters.alphaMap = scope.getTexture( textureMap, child.ID );
					parameters.transparent = true;
					break;

				case 'AmbientColor':
				case 'ShininessExponent': // AKA glossiness map
				case 'SpecularFactor': // AKA specularLevel
				case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor
				default:
					console.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );
					break;

			}

		} );

		return parameters;

	}

	// get a texture from the textureMap for use by a material.
	getTexture( textureMap, id ) {

		// if the texture is a layered texture, just use the first layer and issue a warning
		if ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {

			console.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );
			id = connections.get( id ).children[ 0 ].ID;

		}

		return textureMap.get( id );

	}

	// Parse nodes in FBXTree.Objects.Deformer
	// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
	// Generates map of Skeleton-like objects for use later when generating and binding skeletons.
	parseDeformers() {

		const skeletons = {};
		const morphTargets = {};

		if ( 'Deformer' in fbxTree.Objects ) {

			const DeformerNodes = fbxTree.Objects.Deformer;

			for ( const nodeID in DeformerNodes ) {

				const deformerNode = DeformerNodes[ nodeID ];

				const relationships = connections.get( parseInt( nodeID ) );

				if ( deformerNode.attrType === 'Skin' ) {

					const skeleton = this.parseSkeleton( relationships, DeformerNodes );
					skeleton.ID = nodeID;

					if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );
					skeleton.geometryID = relationships.parents[ 0 ].ID;

					skeletons[ nodeID ] = skeleton;

				} else if ( deformerNode.attrType === 'BlendShape' ) {

					const morphTarget = {
						id: nodeID,
					};

					morphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );
					morphTarget.id = nodeID;

					if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );

					morphTargets[ nodeID ] = morphTarget;

				}

			}

		}

		return {

			skeletons: skeletons,
			morphTargets: morphTargets,

		};

	}

	// Parse single nodes in FBXTree.Objects.Deformer
	// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
	// Each skin node represents a skeleton and each cluster node represents a bone
	parseSkeleton( relationships, deformerNodes ) {

		const rawBones = [];

		relationships.children.forEach( function ( child ) {

			const boneNode = deformerNodes[ child.ID ];

			if ( boneNode.attrType !== 'Cluster' ) return;

			const rawBone = {

				ID: child.ID,
				indices: [],
				weights: [],
				transformLink: new Matrix4().fromArray( boneNode.TransformLink.a ),
				// transform: new Matrix4().fromArray( boneNode.Transform.a ),
				// linkMode: boneNode.Mode,

			};

			if ( 'Indexes' in boneNode ) {

				rawBone.indices = boneNode.Indexes.a;
				rawBone.weights = boneNode.Weights.a;

			}

			rawBones.push( rawBone );

		} );

		return {

			rawBones: rawBones,
			bones: []

		};

	}

	// The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
	parseMorphTargets( relationships, deformerNodes ) {

		const rawMorphTargets = [];

		for ( let i = 0; i < relationships.children.length; i ++ ) {

			const child = relationships.children[ i ];

			const morphTargetNode = deformerNodes[ child.ID ];

			const rawMorphTarget = {

				name: morphTargetNode.attrName,
				initialWeight: morphTargetNode.DeformPercent,
				id: morphTargetNode.id,
				fullWeights: morphTargetNode.FullWeights.a

			};

			if ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;

			rawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {

				return child.relationship === undefined;

			} )[ 0 ].ID;

			rawMorphTargets.push( rawMorphTarget );

		}

		return rawMorphTargets;

	}

	// create the main Group() to be returned by the loader
	parseScene( deformers, geometryMap, materialMap ) {

		sceneGraph = new Group$1();

		const modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );

		const modelNodes = fbxTree.Objects.Model;

		const scope = this;
		modelMap.forEach( function ( model ) {

			const modelNode = modelNodes[ model.ID ];
			scope.setLookAtProperties( model, modelNode );

			const parentConnections = connections.get( model.ID ).parents;

			parentConnections.forEach( function ( connection ) {

				const parent = modelMap.get( connection.ID );
				if ( parent !== undefined ) parent.add( model );

			} );

			if ( model.parent === null ) {

				sceneGraph.add( model );

			}


		} );

		this.bindSkeleton( deformers.skeletons, geometryMap, modelMap );

		this.addGlobalSceneSettings();

		sceneGraph.traverse( function ( node ) {

			if ( node.userData.transformData ) {

				if ( node.parent ) {

					node.userData.transformData.parentMatrix = node.parent.matrix;
					node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;

				}

				const transform = generateTransform( node.userData.transformData );

				node.applyMatrix4( transform );
				node.updateWorldMatrix();

			}

		} );

		const animations = new AnimationParser().parse();

		// if all the models where already combined in a single group, just return that
		if ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {

			sceneGraph.children[ 0 ].animations = animations;
			sceneGraph = sceneGraph.children[ 0 ];

		}

		sceneGraph.animations = animations;

	}

	// parse nodes in FBXTree.Objects.Model
	parseModels( skeletons, geometryMap, materialMap ) {

		const modelMap = new Map();
		const modelNodes = fbxTree.Objects.Model;

		for ( const nodeID in modelNodes ) {

			const id = parseInt( nodeID );
			const node = modelNodes[ nodeID ];
			const relationships = connections.get( id );

			let model = this.buildSkeleton( relationships, skeletons, id, node.attrName );

			if ( ! model ) {

				switch ( node.attrType ) {

					case 'Camera':
						model = this.createCamera( relationships );
						break;
					case 'Light':
						model = this.createLight( relationships );
						break;
					case 'Mesh':
						model = this.createMesh( relationships, geometryMap, materialMap );
						break;
					case 'NurbsCurve':
						model = this.createCurve( relationships, geometryMap );
						break;
					case 'LimbNode':
					case 'Root':
						model = new Bone();
						break;
					case 'Null':
					default:
						model = new Group$1();
						break;

				}

				model.name = node.attrName ? PropertyBinding.sanitizeNodeName( node.attrName ) : '';
				model.userData.originalName = node.attrName;

				model.ID = id;

			}

			this.getTransformData( model, node );
			modelMap.set( id, model );

		}

		return modelMap;

	}

	buildSkeleton( relationships, skeletons, id, name ) {

		let bone = null;

		relationships.parents.forEach( function ( parent ) {

			for ( const ID in skeletons ) {

				const skeleton = skeletons[ ID ];

				skeleton.rawBones.forEach( function ( rawBone, i ) {

					if ( rawBone.ID === parent.ID ) {

						const subBone = bone;
						bone = new Bone();

						bone.matrixWorld.copy( rawBone.transformLink );

						// set name and id here - otherwise in cases where "subBone" is created it will not have a name / id

						bone.name = name ? PropertyBinding.sanitizeNodeName( name ) : '';
						bone.userData.originalName = name;
						bone.ID = id;

						skeleton.bones[ i ] = bone;

						// In cases where a bone is shared between multiple meshes
						// duplicate the bone here and and it as a child of the first bone
						if ( subBone !== null ) {

							bone.add( subBone );

						}

					}

				} );

			}

		} );

		return bone;

	}

	// create a PerspectiveCamera or OrthographicCamera
	createCamera( relationships ) {

		let model;
		let cameraAttribute;

		relationships.children.forEach( function ( child ) {

			const attr = fbxTree.Objects.NodeAttribute[ child.ID ];

			if ( attr !== undefined ) {

				cameraAttribute = attr;

			}

		} );

		if ( cameraAttribute === undefined ) {

			model = new Object3D();

		} else {

			let type = 0;
			if ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {

				type = 1;

			}

			let nearClippingPlane = 1;
			if ( cameraAttribute.NearPlane !== undefined ) {

				nearClippingPlane = cameraAttribute.NearPlane.value / 1000;

			}

			let farClippingPlane = 1000;
			if ( cameraAttribute.FarPlane !== undefined ) {

				farClippingPlane = cameraAttribute.FarPlane.value / 1000;

			}


			let width = window.innerWidth;
			let height = window.innerHeight;

			if ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {

				width = cameraAttribute.AspectWidth.value;
				height = cameraAttribute.AspectHeight.value;

			}

			const aspect = width / height;

			let fov = 45;
			if ( cameraAttribute.FieldOfView !== undefined ) {

				fov = cameraAttribute.FieldOfView.value;

			}

			const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;

			switch ( type ) {

				case 0: // Perspective
					model = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );
					if ( focalLength !== null ) model.setFocalLength( focalLength );
					break;

				case 1: // Orthographic
					console.warn( 'THREE.FBXLoader: Orthographic cameras not supported yet.' );
					model = new Object3D();
					break;

				default:
					console.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );
					model = new Object3D();
					break;

			}

		}

		return model;

	}

	// Create a DirectionalLight, PointLight or SpotLight
	createLight( relationships ) {

		let model;
		let lightAttribute;

		relationships.children.forEach( function ( child ) {

			const attr = fbxTree.Objects.NodeAttribute[ child.ID ];

			if ( attr !== undefined ) {

				lightAttribute = attr;

			}

		} );

		if ( lightAttribute === undefined ) {

			model = new Object3D();

		} else {

			let type;

			// LightType can be undefined for Point lights
			if ( lightAttribute.LightType === undefined ) {

				type = 0;

			} else {

				type = lightAttribute.LightType.value;

			}

			let color = 0xffffff;

			if ( lightAttribute.Color !== undefined ) {

				color = ColorManagement.toWorkingColorSpace( new Color().fromArray( lightAttribute.Color.value ), SRGBColorSpace );

			}

			let intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;

			// light disabled
			if ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {

				intensity = 0;

			}

			let distance = 0;
			if ( lightAttribute.FarAttenuationEnd !== undefined ) {

				if ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {

					distance = 0;

				} else {

					distance = lightAttribute.FarAttenuationEnd.value;

				}

			}

			// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
			const decay = 1;

			switch ( type ) {

				case 0: // Point
					model = new PointLight( color, intensity, distance, decay );
					break;

				case 1: // Directional
					model = new DirectionalLight( color, intensity );
					break;

				case 2: // Spot
					let angle = Math.PI / 3;

					if ( lightAttribute.InnerAngle !== undefined ) {

						angle = MathUtils.degToRad( lightAttribute.InnerAngle.value );

					}

					let penumbra = 0;
					if ( lightAttribute.OuterAngle !== undefined ) {

						// TODO: this is not correct - FBX calculates outer and inner angle in degrees
						// with OuterAngle > InnerAngle && OuterAngle <= Math.PI
						// while three.js uses a penumbra between (0, 1) to attenuate the inner angle
						penumbra = MathUtils.degToRad( lightAttribute.OuterAngle.value );
						penumbra = Math.max( penumbra, 1 );

					}

					model = new SpotLight( color, intensity, distance, angle, penumbra, decay );
					break;

				default:
					console.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );
					model = new PointLight( color, intensity );
					break;

			}

			if ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {

				model.castShadow = true;

			}

		}

		return model;

	}

	createMesh( relationships, geometryMap, materialMap ) {

		let model;
		let geometry = null;
		let material = null;
		const materials = [];

		// get geometry and materials(s) from connections
		relationships.children.forEach( function ( child ) {

			if ( geometryMap.has( child.ID ) ) {

				geometry = geometryMap.get( child.ID );

			}

			if ( materialMap.has( child.ID ) ) {

				materials.push( materialMap.get( child.ID ) );

			}

		} );

		if ( materials.length > 1 ) {

			material = materials;

		} else if ( materials.length > 0 ) {

			material = materials[ 0 ];

		} else {

			material = new MeshPhongMaterial( {
				name: Loader.DEFAULT_MATERIAL_NAME,
				color: 0xcccccc
			} );
			materials.push( material );

		}

		if ( 'color' in geometry.attributes ) {

			materials.forEach( function ( material ) {

				material.vertexColors = true;

			} );

		}

		if ( geometry.FBX_Deformer ) {

			model = new SkinnedMesh( geometry, material );
			model.normalizeSkinWeights();

		} else {

			model = new Mesh( geometry, material );

		}

		return model;

	}

	createCurve( relationships, geometryMap ) {

		const geometry = relationships.children.reduce( function ( geo, child ) {

			if ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );

			return geo;

		}, null );

		// FBX does not list materials for Nurbs lines, so we'll just put our own in here.
		const material = new LineBasicMaterial( {
			name: Loader.DEFAULT_MATERIAL_NAME,
			color: 0x3300ff,
			linewidth: 1
		} );
		return new Line$1( geometry, material );

	}

	// parse the model node for transform data
	getTransformData( model, modelNode ) {

		const transformData = {};

		if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );

		if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );
		else transformData.eulerOrder = getEulerOrder( 0 );

		if ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;

		if ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;
		if ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;
		if ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;

		if ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;

		if ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;
		if ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;

		if ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;
		if ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;

		model.userData.transformData = transformData;

	}

	setLookAtProperties( model, modelNode ) {

		if ( 'LookAtProperty' in modelNode ) {

			const children = connections.get( model.ID ).children;

			children.forEach( function ( child ) {

				if ( child.relationship === 'LookAtProperty' ) {

					const lookAtTarget = fbxTree.Objects.Model[ child.ID ];

					if ( 'Lcl_Translation' in lookAtTarget ) {

						const pos = lookAtTarget.Lcl_Translation.value;

						// DirectionalLight, SpotLight
						if ( model.target !== undefined ) {

							model.target.position.fromArray( pos );
							sceneGraph.add( model.target );

						} else { // Cameras and other Object3Ds

							model.lookAt( new Vector3().fromArray( pos ) );

						}

					}

				}

			} );

		}

	}

	bindSkeleton( skeletons, geometryMap, modelMap ) {

		const bindMatrices = this.parsePoseNodes();

		for ( const ID in skeletons ) {

			const skeleton = skeletons[ ID ];

			const parents = connections.get( parseInt( skeleton.ID ) ).parents;

			parents.forEach( function ( parent ) {

				if ( geometryMap.has( parent.ID ) ) {

					const geoID = parent.ID;
					const geoRelationships = connections.get( geoID );

					geoRelationships.parents.forEach( function ( geoConnParent ) {

						if ( modelMap.has( geoConnParent.ID ) ) {

							const model = modelMap.get( geoConnParent.ID );

							model.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );

						}

					} );

				}

			} );

		}

	}

	parsePoseNodes() {

		const bindMatrices = {};

		if ( 'Pose' in fbxTree.Objects ) {

			const BindPoseNode = fbxTree.Objects.Pose;

			for ( const nodeID in BindPoseNode ) {

				if ( BindPoseNode[ nodeID ].attrType === 'BindPose' && BindPoseNode[ nodeID ].NbPoseNodes > 0 ) {

					const poseNodes = BindPoseNode[ nodeID ].PoseNode;

					if ( Array.isArray( poseNodes ) ) {

						poseNodes.forEach( function ( poseNode ) {

							bindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a );

						} );

					} else {

						bindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a );

					}

				}

			}

		}

		return bindMatrices;

	}

	addGlobalSceneSettings() {

		if ( 'GlobalSettings' in fbxTree ) {

			if ( 'AmbientColor' in fbxTree.GlobalSettings ) {

				// Parse ambient color - if it's not set to black (default), create an ambient light

				const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
				const r = ambientColor[ 0 ];
				const g = ambientColor[ 1 ];
				const b = ambientColor[ 2 ];

				if ( r !== 0 || g !== 0 || b !== 0 ) {

					const color = new Color().setRGB( r, g, b, SRGBColorSpace );
					sceneGraph.add( new AmbientLight( color, 1 ) );

				}

			}

			if ( 'UnitScaleFactor' in fbxTree.GlobalSettings ) {

				sceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;

			}

		}

	}

}

// parse Geometry data from FBXTree and return map of BufferGeometries
class GeometryParser {

	constructor() {

		this.negativeMaterialIndices = false;

	}

	// Parse nodes in FBXTree.Objects.Geometry
	parse( deformers ) {

		const geometryMap = new Map();

		if ( 'Geometry' in fbxTree.Objects ) {

			const geoNodes = fbxTree.Objects.Geometry;

			for ( const nodeID in geoNodes ) {

				const relationships = connections.get( parseInt( nodeID ) );
				const geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );

				geometryMap.set( parseInt( nodeID ), geo );

			}

		}

		// report warnings

		if ( this.negativeMaterialIndices === true ) {

			console.warn( 'THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.' );

		}

		return geometryMap;

	}

	// Parse single node in FBXTree.Objects.Geometry
	parseGeometry( relationships, geoNode, deformers ) {

		switch ( geoNode.attrType ) {

			case 'Mesh':
				return this.parseMeshGeometry( relationships, geoNode, deformers );

			case 'NurbsCurve':
				return this.parseNurbsGeometry( geoNode );

		}

	}

	// Parse single node mesh geometry in FBXTree.Objects.Geometry
	parseMeshGeometry( relationships, geoNode, deformers ) {

		const skeletons = deformers.skeletons;
		const morphTargets = [];

		const modelNodes = relationships.parents.map( function ( parent ) {

			return fbxTree.Objects.Model[ parent.ID ];

		} );

		// don't create geometry if it is not associated with any models
		if ( modelNodes.length === 0 ) return;

		const skeleton = relationships.children.reduce( function ( skeleton, child ) {

			if ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];

			return skeleton;

		}, null );

		relationships.children.forEach( function ( child ) {

			if ( deformers.morphTargets[ child.ID ] !== undefined ) {

				morphTargets.push( deformers.morphTargets[ child.ID ] );

			}

		} );

		// Assume one model and get the preRotation from that
		// if there is more than one model associated with the geometry this may cause problems
		const modelNode = modelNodes[ 0 ];

		const transformData = {};

		if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );
		if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );

		if ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;
		if ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;
		if ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;

		const transform = generateTransform( transformData );

		return this.genGeometry( geoNode, skeleton, morphTargets, transform );

	}

	// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
	genGeometry( geoNode, skeleton, morphTargets, preTransform ) {

		const geo = new BufferGeometry();
		if ( geoNode.attrName ) geo.name = geoNode.attrName;

		const geoInfo = this.parseGeoNode( geoNode, skeleton );
		const buffers = this.genBuffers( geoInfo );

		const positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 );

		positionAttribute.applyMatrix4( preTransform );

		geo.setAttribute( 'position', positionAttribute );

		if ( buffers.colors.length > 0 ) {

			geo.setAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) );

		}

		if ( skeleton ) {

			geo.setAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) );

			geo.setAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) );

			// used later to bind the skeleton to the model
			geo.FBX_Deformer = skeleton;

		}

		if ( buffers.normal.length > 0 ) {

			const normalMatrix = new Matrix3$1().getNormalMatrix( preTransform );

			const normalAttribute = new Float32BufferAttribute( buffers.normal, 3 );
			normalAttribute.applyNormalMatrix( normalMatrix );

			geo.setAttribute( 'normal', normalAttribute );

		}

		buffers.uvs.forEach( function ( uvBuffer, i ) {

			const name = i === 0 ? 'uv' : `uv${ i }`;

			geo.setAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) );

		} );

		if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

			// Convert the material indices of each vertex into rendering groups on the geometry.
			let prevMaterialIndex = buffers.materialIndex[ 0 ];
			let startIndex = 0;

			buffers.materialIndex.forEach( function ( currentIndex, i ) {

				if ( currentIndex !== prevMaterialIndex ) {

					geo.addGroup( startIndex, i - startIndex, prevMaterialIndex );

					prevMaterialIndex = currentIndex;
					startIndex = i;

				}

			} );

			// the loop above doesn't add the last group, do that here.
			if ( geo.groups.length > 0 ) {

				const lastGroup = geo.groups[ geo.groups.length - 1 ];
				const lastIndex = lastGroup.start + lastGroup.count;

				if ( lastIndex !== buffers.materialIndex.length ) {

					geo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );

				}

			}

			// case where there are multiple materials but the whole geometry is only
			// using one of them
			if ( geo.groups.length === 0 ) {

				geo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );

			}

		}

		this.addMorphTargets( geo, geoNode, morphTargets, preTransform );

		return geo;

	}

	parseGeoNode( geoNode, skeleton ) {

		const geoInfo = {};

		geoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];
		geoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];

		if ( geoNode.LayerElementColor ) {

			geoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );

		}

		if ( geoNode.LayerElementMaterial ) {

			geoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );

		}

		if ( geoNode.LayerElementNormal ) {

			geoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );

		}

		if ( geoNode.LayerElementUV ) {

			geoInfo.uv = [];

			let i = 0;
			while ( geoNode.LayerElementUV[ i ] ) {

				if ( geoNode.LayerElementUV[ i ].UV ) {

					geoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );

				}

				i ++;

			}

		}

		geoInfo.weightTable = {};

		if ( skeleton !== null ) {

			geoInfo.skeleton = skeleton;

			skeleton.rawBones.forEach( function ( rawBone, i ) {

				// loop over the bone's vertex indices and weights
				rawBone.indices.forEach( function ( index, j ) {

					if ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];

					geoInfo.weightTable[ index ].push( {

						id: i,
						weight: rawBone.weights[ j ],

					} );

				} );

			} );

		}

		return geoInfo;

	}

	genBuffers( geoInfo ) {

		const buffers = {
			vertex: [],
			normal: [],
			colors: [],
			uvs: [],
			materialIndex: [],
			vertexWeights: [],
			weightsIndices: [],
		};

		let polygonIndex = 0;
		let faceLength = 0;
		let displayedWeightsWarning = false;

		// these will hold data for a single face
		let facePositionIndexes = [];
		let faceNormals = [];
		let faceColors = [];
		let faceUVs = [];
		let faceWeights = [];
		let faceWeightIndices = [];

		const scope = this;
		geoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {

			let materialIndex;
			let endOfFace = false;

			// Face index and vertex index arrays are combined in a single array
			// A cube with quad faces looks like this:
			// PolygonVertexIndex: *24 {
			//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
			//  }
			// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
			// to find index of last vertex bit shift the index: ^ - 1
			if ( vertexIndex < 0 ) {

				vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1
				endOfFace = true;

			}

			let weightIndices = [];
			let weights = [];

			facePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );

			if ( geoInfo.color ) {

				const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );

				faceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );

			}

			if ( geoInfo.skeleton ) {

				if ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {

					geoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {

						weights.push( wt.weight );
						weightIndices.push( wt.id );

					} );


				}

				if ( weights.length > 4 ) {

					if ( ! displayedWeightsWarning ) {

						console.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );
						displayedWeightsWarning = true;

					}

					const wIndex = [ 0, 0, 0, 0 ];
					const Weight = [ 0, 0, 0, 0 ];

					weights.forEach( function ( weight, weightIndex ) {

						let currentWeight = weight;
						let currentIndex = weightIndices[ weightIndex ];

						Weight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {

							if ( currentWeight > comparedWeight ) {

								comparedWeightArray[ comparedWeightIndex ] = currentWeight;
								currentWeight = comparedWeight;

								const tmp = wIndex[ comparedWeightIndex ];
								wIndex[ comparedWeightIndex ] = currentIndex;
								currentIndex = tmp;

							}

						} );

					} );

					weightIndices = wIndex;
					weights = Weight;

				}

				// if the weight array is shorter than 4 pad with 0s
				while ( weights.length < 4 ) {

					weights.push( 0 );
					weightIndices.push( 0 );

				}

				for ( let i = 0; i < 4; ++ i ) {

					faceWeights.push( weights[ i ] );
					faceWeightIndices.push( weightIndices[ i ] );

				}

			}

			if ( geoInfo.normal ) {

				const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );

				faceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );

			}

			if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

				materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];

				if ( materialIndex < 0 ) {

					scope.negativeMaterialIndices = true;
					materialIndex = 0; // fallback

				}

			}

			if ( geoInfo.uv ) {

				geoInfo.uv.forEach( function ( uv, i ) {

					const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );

					if ( faceUVs[ i ] === undefined ) {

						faceUVs[ i ] = [];

					}

					faceUVs[ i ].push( data[ 0 ] );
					faceUVs[ i ].push( data[ 1 ] );

				} );

			}

			faceLength ++;

			if ( endOfFace ) {

				scope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );

				polygonIndex ++;
				faceLength = 0;

				// reset arrays for the next face
				facePositionIndexes = [];
				faceNormals = [];
				faceColors = [];
				faceUVs = [];
				faceWeights = [];
				faceWeightIndices = [];

			}

		} );

		return buffers;

	}

	// See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
	getNormalNewell( vertices ) {

		const normal = new Vector3( 0.0, 0.0, 0.0 );

		for ( let i = 0; i < vertices.length; i ++ ) {

			const current = vertices[ i ];
			const next = vertices[ ( i + 1 ) % vertices.length ];

			normal.x += ( current.y - next.y ) * ( current.z + next.z );
			normal.y += ( current.z - next.z ) * ( current.x + next.x );
			normal.z += ( current.x - next.x ) * ( current.y + next.y );

		}

		normal.normalize();

		return normal;

	}

	getNormalTangentAndBitangent( vertices ) {

		const normalVector = this.getNormalNewell( vertices );
		// Avoid up being equal or almost equal to normalVector
		const up = Math.abs( normalVector.z ) > 0.5 ? new Vector3( 0.0, 1.0, 0.0 ) : new Vector3( 0.0, 0.0, 1.0 );
		const tangent = up.cross( normalVector ).normalize();
		const bitangent = normalVector.clone().cross( tangent ).normalize();

		return {
			normal: normalVector,
			tangent: tangent,
			bitangent: bitangent
		};

	}

	flattenVertex( vertex, normalTangent, normalBitangent ) {

		return new Vector2(
			vertex.dot( normalTangent ),
			vertex.dot( normalBitangent )
		);

	}

	// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
	genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {

		let triangles;

		if ( faceLength > 3 ) {

			// Triangulate n-gon using earcut

			const vertices = [];
			// in morphing scenario vertexPositions represent morphPositions
			// while baseVertexPositions represent the original geometry's positions
			const positions = geoInfo.baseVertexPositions || geoInfo.vertexPositions;
			for ( let i = 0; i < facePositionIndexes.length; i += 3 ) {

				vertices.push(
					new Vector3(
						positions[ facePositionIndexes[ i ] ],
						positions[ facePositionIndexes[ i + 1 ] ],
						positions[ facePositionIndexes[ i + 2 ] ]
					)
				);

			}

			const { tangent, bitangent } = this.getNormalTangentAndBitangent( vertices );
			const triangulationInput = [];

			for ( const vertex of vertices ) {

				triangulationInput.push( this.flattenVertex( vertex, tangent, bitangent ) );

			}

			// When vertices is an array of [0,0,0] elements (which is the case for vertices not participating in morph)
			// the triangulationInput will be an array of [0,0] elements
			// resulting in an array of 0 triangles being returned from ShapeUtils.triangulateShape
			// leading to not pushing into buffers.vertex the redundant vertices (the vertices that are not morphed).
			// That's why, in order to support morphing scenario, "positions" is looking first for baseVertexPositions,
			// so that we don't end up with an array of 0 triangles for the faces not participating in morph.
			triangles = ShapeUtils.triangulateShape( triangulationInput, [] );

		} else {

			// Regular triangle, skip earcut triangulation step
			triangles = [[ 0, 1, 2 ]];

		}

		for ( const [ i0, i1, i2 ] of triangles ) {

			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 + 1 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 + 2 ] ] );

			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 + 1 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 + 2 ] ] );

			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 + 1 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 + 2 ] ] );

			if ( geoInfo.skeleton ) {

				buffers.vertexWeights.push( faceWeights[ i0 * 4 ] );
				buffers.vertexWeights.push( faceWeights[ i0 * 4 + 1 ] );
				buffers.vertexWeights.push( faceWeights[ i0 * 4 + 2 ] );
				buffers.vertexWeights.push( faceWeights[ i0 * 4 + 3 ] );

				buffers.vertexWeights.push( faceWeights[ i1 * 4 ] );
				buffers.vertexWeights.push( faceWeights[ i1 * 4 + 1 ] );
				buffers.vertexWeights.push( faceWeights[ i1 * 4 + 2 ] );
				buffers.vertexWeights.push( faceWeights[ i1 * 4 + 3 ] );

				buffers.vertexWeights.push( faceWeights[ i2 * 4 ] );
				buffers.vertexWeights.push( faceWeights[ i2 * 4 + 1 ] );
				buffers.vertexWeights.push( faceWeights[ i2 * 4 + 2 ] );
				buffers.vertexWeights.push( faceWeights[ i2 * 4 + 3 ] );

				buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 1 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 2 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 3 ] );

				buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 1 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 2 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 3 ] );

				buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 1 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 2 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 3 ] );

			}

			if ( geoInfo.color ) {

				buffers.colors.push( faceColors[ i0 * 3 ] );
				buffers.colors.push( faceColors[ i0 * 3 + 1 ] );
				buffers.colors.push( faceColors[ i0 * 3 + 2 ] );

				buffers.colors.push( faceColors[ i1 * 3 ] );
				buffers.colors.push( faceColors[ i1 * 3 + 1 ] );
				buffers.colors.push( faceColors[ i1 * 3 + 2 ] );

				buffers.colors.push( faceColors[ i2 * 3 ] );
				buffers.colors.push( faceColors[ i2 * 3 + 1 ] );
				buffers.colors.push( faceColors[ i2 * 3 + 2 ] );

			}

			if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

				buffers.materialIndex.push( materialIndex );
				buffers.materialIndex.push( materialIndex );
				buffers.materialIndex.push( materialIndex );

			}

			if ( geoInfo.normal ) {

				buffers.normal.push( faceNormals[ i0 * 3 ] );
				buffers.normal.push( faceNormals[ i0 * 3 + 1 ] );
				buffers.normal.push( faceNormals[ i0 * 3 + 2 ] );

				buffers.normal.push( faceNormals[ i1 * 3 ] );
				buffers.normal.push( faceNormals[ i1 * 3 + 1 ] );
				buffers.normal.push( faceNormals[ i1 * 3 + 2 ] );

				buffers.normal.push( faceNormals[ i2 * 3 ] );
				buffers.normal.push( faceNormals[ i2 * 3 + 1 ] );
				buffers.normal.push( faceNormals[ i2 * 3 + 2 ] );

			}

			if ( geoInfo.uv ) {

				geoInfo.uv.forEach( function ( uv, j ) {

					if ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];

					buffers.uvs[ j ].push( faceUVs[ j ][ i0 * 2 ] );
					buffers.uvs[ j ].push( faceUVs[ j ][ i0 * 2 + 1 ] );

					buffers.uvs[ j ].push( faceUVs[ j ][ i1 * 2 ] );
					buffers.uvs[ j ].push( faceUVs[ j ][ i1 * 2 + 1 ] );

					buffers.uvs[ j ].push( faceUVs[ j ][ i2 * 2 ] );
					buffers.uvs[ j ].push( faceUVs[ j ][ i2 * 2 + 1 ] );

				} );

			}

		}

	}

	addMorphTargets( parentGeo, parentGeoNode, morphTargets, preTransform ) {

		if ( morphTargets.length === 0 ) return;

		parentGeo.morphTargetsRelative = true;

		parentGeo.morphAttributes.position = [];
		// parentGeo.morphAttributes.normal = []; // not implemented

		const scope = this;
		morphTargets.forEach( function ( morphTarget ) {

			morphTarget.rawTargets.forEach( function ( rawTarget ) {

				const morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];

				if ( morphGeoNode !== undefined ) {

					scope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );

				}

			} );

		} );

	}

	// a morph geometry node is similar to a standard  node, and the node is also contained
	// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
	// and a special attribute Index defining which vertices of the original geometry are affected
	// Normal and position attributes only have data for the vertices that are affected by the morph
	genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {

		const basePositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a : [];
		const baseIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];

		const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];
		const morphIndices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];

		const length = parentGeo.attributes.position.count * 3;
		const morphPositions = new Float32Array( length );

		for ( let i = 0; i < morphIndices.length; i ++ ) {

			const morphIndex = morphIndices[ i ] * 3;

			morphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];
			morphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];
			morphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];

		}

		// TODO: add morph normal support
		const morphGeoInfo = {
			vertexIndices: baseIndices,
			vertexPositions: morphPositions,
			baseVertexPositions: basePositions
		};

		const morphBuffers = this.genBuffers( morphGeoInfo );

		const positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 );
		positionAttribute.name = name || morphGeoNode.attrName;

		positionAttribute.applyMatrix4( preTransform );

		parentGeo.morphAttributes.position.push( positionAttribute );

	}

	// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
	parseNormals( NormalNode ) {

		const mappingType = NormalNode.MappingInformationType;
		const referenceType = NormalNode.ReferenceInformationType;
		const buffer = NormalNode.Normals.a;
		let indexBuffer = [];
		if ( referenceType === 'IndexToDirect' ) {

			if ( 'NormalIndex' in NormalNode ) {

				indexBuffer = NormalNode.NormalIndex.a;

			} else if ( 'NormalsIndex' in NormalNode ) {

				indexBuffer = NormalNode.NormalsIndex.a;

			}

		}

		return {
			dataSize: 3,
			buffer: buffer,
			indices: indexBuffer,
			mappingType: mappingType,
			referenceType: referenceType
		};

	}

	// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
	parseUVs( UVNode ) {

		const mappingType = UVNode.MappingInformationType;
		const referenceType = UVNode.ReferenceInformationType;
		const buffer = UVNode.UV.a;
		let indexBuffer = [];
		if ( referenceType === 'IndexToDirect' ) {

			indexBuffer = UVNode.UVIndex.a;

		}

		return {
			dataSize: 2,
			buffer: buffer,
			indices: indexBuffer,
			mappingType: mappingType,
			referenceType: referenceType
		};

	}

	// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
	parseVertexColors( ColorNode ) {

		const mappingType = ColorNode.MappingInformationType;
		const referenceType = ColorNode.ReferenceInformationType;
		const buffer = ColorNode.Colors.a;
		let indexBuffer = [];
		if ( referenceType === 'IndexToDirect' ) {

			indexBuffer = ColorNode.ColorIndex.a;

		}

		for ( let i = 0, c = new Color(); i < buffer.length; i += 4 ) {

			c.fromArray( buffer, i );
			ColorManagement.toWorkingColorSpace( c, SRGBColorSpace );
			c.toArray( buffer, i );

		}

		return {
			dataSize: 4,
			buffer: buffer,
			indices: indexBuffer,
			mappingType: mappingType,
			referenceType: referenceType
		};

	}

	// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
	parseMaterialIndices( MaterialNode ) {

		const mappingType = MaterialNode.MappingInformationType;
		const referenceType = MaterialNode.ReferenceInformationType;

		if ( mappingType === 'NoMappingInformation' ) {

			return {
				dataSize: 1,
				buffer: [ 0 ],
				indices: [ 0 ],
				mappingType: 'AllSame',
				referenceType: referenceType
			};

		}

		const materialIndexBuffer = MaterialNode.Materials.a;

		// Since materials are stored as indices, there's a bit of a mismatch between FBX and what
		// we expect.So we create an intermediate buffer that points to the index in the buffer,
		// for conforming with the other functions we've written for other data.
		const materialIndices = [];

		for ( let i = 0; i < materialIndexBuffer.length; ++ i ) {

			materialIndices.push( i );

		}

		return {
			dataSize: 1,
			buffer: materialIndexBuffer,
			indices: materialIndices,
			mappingType: mappingType,
			referenceType: referenceType
		};

	}

	// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
	parseNurbsGeometry( geoNode ) {

		const order = parseInt( geoNode.Order );

		if ( isNaN( order ) ) {

			console.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );
			return new BufferGeometry();

		}

		const degree = order - 1;

		const knots = geoNode.KnotVector.a;
		const controlPoints = [];
		const pointsValues = geoNode.Points.a;

		for ( let i = 0, l = pointsValues.length; i < l; i += 4 ) {

			controlPoints.push( new Vector4().fromArray( pointsValues, i ) );

		}

		let startKnot, endKnot;

		if ( geoNode.Form === 'Closed' ) {

			controlPoints.push( controlPoints[ 0 ] );

		} else if ( geoNode.Form === 'Periodic' ) {

			startKnot = degree;
			endKnot = knots.length - 1 - startKnot;

			for ( let i = 0; i < degree; ++ i ) {

				controlPoints.push( controlPoints[ i ] );

			}

		}

		const curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );
		const points = curve.getPoints( controlPoints.length * 12 );

		return new BufferGeometry().setFromPoints( points );

	}

}

// parse animation data from FBXTree
class AnimationParser {

	// take raw animation clips and turn them into three.js animation clips
	parse() {

		const animationClips = [];

		const rawClips = this.parseClips();

		if ( rawClips !== undefined ) {

			for ( const key in rawClips ) {

				const rawClip = rawClips[ key ];

				const clip = this.addClip( rawClip );

				animationClips.push( clip );

			}

		}

		return animationClips;

	}

	parseClips() {

		// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
		// if this is undefined we can safely assume there are no animations
		if ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;

		const curveNodesMap = this.parseAnimationCurveNodes();

		this.parseAnimationCurves( curveNodesMap );

		const layersMap = this.parseAnimationLayers( curveNodesMap );
		const rawClips = this.parseAnimStacks( layersMap );

		return rawClips;

	}

	// parse nodes in FBXTree.Objects.AnimationCurveNode
	// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
	// and is referenced by an AnimationLayer
	parseAnimationCurveNodes() {

		const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;

		const curveNodesMap = new Map();

		for ( const nodeID in rawCurveNodes ) {

			const rawCurveNode = rawCurveNodes[ nodeID ];

			if ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {

				const curveNode = {

					id: rawCurveNode.id,
					attr: rawCurveNode.attrName,
					curves: {},

				};

				curveNodesMap.set( curveNode.id, curveNode );

			}

		}

		return curveNodesMap;

	}

	// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
	// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
	// axis ( e.g. times and values of x rotation)
	parseAnimationCurves( curveNodesMap ) {

		const rawCurves = fbxTree.Objects.AnimationCurve;

		// TODO: Many values are identical up to roundoff error, but won't be optimised
		// e.g. position times: [0, 0.4, 0. 8]
		// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]
		// clearly, this should be optimised to
		// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]
		// this shows up in nearly every FBX file, and generally time array is length > 100

		for ( const nodeID in rawCurves ) {

			const animationCurve = {

				id: rawCurves[ nodeID ].id,
				times: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),
				values: rawCurves[ nodeID ].KeyValueFloat.a,

			};

			const relationships = connections.get( animationCurve.id );

			if ( relationships !== undefined ) {

				const animationCurveID = relationships.parents[ 0 ].ID;
				const animationCurveRelationship = relationships.parents[ 0 ].relationship;

				if ( animationCurveRelationship.match( /X/ ) ) {

					curveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;

				} else if ( animationCurveRelationship.match( /Y/ ) ) {

					curveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;

				} else if ( animationCurveRelationship.match( /Z/ ) ) {

					curveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;

				} else if ( animationCurveRelationship.match( /DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {

					curveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;

				}

			}

		}

	}

	// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
	// to various AnimationCurveNodes and is referenced by an AnimationStack node
	// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
	parseAnimationLayers( curveNodesMap ) {

		const rawLayers = fbxTree.Objects.AnimationLayer;

		const layersMap = new Map();

		for ( const nodeID in rawLayers ) {

			const layerCurveNodes = [];

			const connection = connections.get( parseInt( nodeID ) );

			if ( connection !== undefined ) {

				// all the animationCurveNodes used in the layer
				const children = connection.children;

				children.forEach( function ( child, i ) {

					if ( curveNodesMap.has( child.ID ) ) {

						const curveNode = curveNodesMap.get( child.ID );

						// check that the curves are defined for at least one axis, otherwise ignore the curveNode
						if ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {

							if ( layerCurveNodes[ i ] === undefined ) {

								const modelID = connections.get( child.ID ).parents.filter( function ( parent ) {

									return parent.relationship !== undefined;

								} )[ 0 ].ID;

								if ( modelID !== undefined ) {

									const rawModel = fbxTree.Objects.Model[ modelID.toString() ];

									if ( rawModel === undefined ) {

										console.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );
										return;

									}

									const node = {

										modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',
										ID: rawModel.id,
										initialPosition: [ 0, 0, 0 ],
										initialRotation: [ 0, 0, 0 ],
										initialScale: [ 1, 1, 1 ],

									};

									sceneGraph.traverse( function ( child ) {

										if ( child.ID === rawModel.id ) {

											node.transform = child.matrix;

											if ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;

										}

									} );

									if ( ! node.transform ) node.transform = new Matrix4();

									// if the animated model is pre rotated, we'll have to apply the pre rotations to every
									// animation value as well
									if ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;
									if ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;

									layerCurveNodes[ i ] = node;

								}

							}

							if ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;

						} else if ( curveNode.curves.morph !== undefined ) {

							if ( layerCurveNodes[ i ] === undefined ) {

								const deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {

									return parent.relationship !== undefined;

								} )[ 0 ].ID;

								const morpherID = connections.get( deformerID ).parents[ 0 ].ID;
								const geoID = connections.get( morpherID ).parents[ 0 ].ID;

								// assuming geometry is not used in more than one model
								const modelID = connections.get( geoID ).parents[ 0 ].ID;

								const rawModel = fbxTree.Objects.Model[ modelID ];

								const node = {

									modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',
									morphName: fbxTree.Objects.Deformer[ deformerID ].attrName,

								};

								layerCurveNodes[ i ] = node;

							}

							layerCurveNodes[ i ][ curveNode.attr ] = curveNode;

						}

					}

				} );

				layersMap.set( parseInt( nodeID ), layerCurveNodes );

			}

		}

		return layersMap;

	}

	// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
	// hierarchy. Each Stack node will be used to create a AnimationClip
	parseAnimStacks( layersMap ) {

		const rawStacks = fbxTree.Objects.AnimationStack;

		// connect the stacks (clips) up to the layers
		const rawClips = {};

		for ( const nodeID in rawStacks ) {

			const children = connections.get( parseInt( nodeID ) ).children;

			if ( children.length > 1 ) {

				// it seems like stacks will always be associated with a single layer. But just in case there are files
				// where there are multiple layers per stack, we'll display a warning
				console.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );

			}

			const layer = layersMap.get( children[ 0 ].ID );

			rawClips[ nodeID ] = {

				name: rawStacks[ nodeID ].attrName,
				layer: layer,

			};

		}

		return rawClips;

	}

	addClip( rawClip ) {

		let tracks = [];

		const scope = this;
		rawClip.layer.forEach( function ( rawTracks ) {

			tracks = tracks.concat( scope.generateTracks( rawTracks ) );

		} );

		return new AnimationClip( rawClip.name, -1, tracks );

	}

	generateTracks( rawTracks ) {

		const tracks = [];

		let initialPosition = new Vector3();
		let initialScale = new Vector3();

		if ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, new Quaternion$1(), initialScale );

		initialPosition = initialPosition.toArray();
		initialScale = initialScale.toArray();

		if ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {

			const positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );
			if ( positionTrack !== undefined ) tracks.push( positionTrack );

		}

		if ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {

			const rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );
			if ( rotationTrack !== undefined ) tracks.push( rotationTrack );

		}

		if ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {

			const scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );
			if ( scaleTrack !== undefined ) tracks.push( scaleTrack );

		}

		if ( rawTracks.DeformPercent !== undefined ) {

			const morphTrack = this.generateMorphTrack( rawTracks );
			if ( morphTrack !== undefined ) tracks.push( morphTrack );

		}

		return tracks;

	}

	generateVectorTrack( modelName, curves, initialValue, type ) {

		const times = this.getTimesForAllAxes( curves );
		const values = this.getKeyframeTrackValues( times, curves, initialValue );

		return new VectorKeyframeTrack( modelName + '.' + type, times, values );

	}

	generateRotationTrack( modelName, curves, preRotation, postRotation, eulerOrder ) {

		let times;
		let values;

		if ( curves.x !== undefined && curves.y !== undefined && curves.z !== undefined ) {

			const result = this.interpolateRotations( curves.x, curves.y, curves.z, eulerOrder );

			times = result[ 0 ];
			values = result[ 1 ];

		}

		// For Maya models using "Joint Orient", Euler order only applies to rotation, not pre/post-rotations
		const defaultEulerOrder = getEulerOrder( 0 );

		if ( preRotation !== undefined ) {

			preRotation = preRotation.map( MathUtils.degToRad );
			preRotation.push( defaultEulerOrder );

			preRotation = new Euler().fromArray( preRotation );
			preRotation = new Quaternion$1().setFromEuler( preRotation );

		}

		if ( postRotation !== undefined ) {

			postRotation = postRotation.map( MathUtils.degToRad );
			postRotation.push( defaultEulerOrder );

			postRotation = new Euler().fromArray( postRotation );
			postRotation = new Quaternion$1().setFromEuler( postRotation ).invert();

		}

		const quaternion = new Quaternion$1();
		const euler = new Euler();

		const quaternionValues = [];

		if ( ! values || ! times ) return new QuaternionKeyframeTrack( modelName + '.quaternion', [ 0 ], [ 0 ] );

		for ( let i = 0; i < values.length; i += 3 ) {

			euler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );
			quaternion.setFromEuler( euler );

			if ( preRotation !== undefined ) quaternion.premultiply( preRotation );
			if ( postRotation !== undefined ) quaternion.multiply( postRotation );

			// Check unroll
			if ( i > 2 ) {

				const prevQuat = new Quaternion$1().fromArray(
					quaternionValues,
					( ( i - 3 ) / 3 ) * 4
				);

				if ( prevQuat.dot( quaternion ) < 0 ) {

					quaternion.set( - quaternion.x, - quaternion.y, - quaternion.z, - quaternion.w );

				}

			}

			quaternion.toArray( quaternionValues, ( i / 3 ) * 4 );

		}

		return new QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );

	}

	generateMorphTrack( rawTracks ) {

		const curves = rawTracks.DeformPercent.curves.morph;
		const values = curves.values.map( function ( val ) {

			return val / 100;

		} );

		const morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];

		return new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );

	}

	// For all animated objects, times are defined separately for each axis
	// Here we'll combine the times into one sorted array without duplicates
	getTimesForAllAxes( curves ) {

		let times = [];

		// first join together the times for each axis, if defined
		if ( curves.x !== undefined ) times = times.concat( curves.x.times );
		if ( curves.y !== undefined ) times = times.concat( curves.y.times );
		if ( curves.z !== undefined ) times = times.concat( curves.z.times );

		// then sort them
		times = times.sort( function ( a, b ) {

			return a - b;

		} );

		// and remove duplicates
		if ( times.length > 1 ) {

			let targetIndex = 1;
			let lastValue = times[ 0 ];
			for ( let i = 1; i < times.length; i ++ ) {

				const currentValue = times[ i ];
				if ( currentValue !== lastValue ) {

					times[ targetIndex ] = currentValue;
					lastValue = currentValue;
					targetIndex ++;

				}

			}

			times = times.slice( 0, targetIndex );

		}

		return times;

	}

	getKeyframeTrackValues( times, curves, initialValue ) {

		const prevValue = initialValue;

		const values = [];

		let xIndex = -1;
		let yIndex = -1;
		let zIndex = -1;

		times.forEach( function ( time ) {

			if ( curves.x ) xIndex = curves.x.times.indexOf( time );
			if ( curves.y ) yIndex = curves.y.times.indexOf( time );
			if ( curves.z ) zIndex = curves.z.times.indexOf( time );

			// if there is an x value defined for this frame, use that
			if ( xIndex !== -1 ) {

				const xValue = curves.x.values[ xIndex ];
				values.push( xValue );
				prevValue[ 0 ] = xValue;

			} else {

				// otherwise use the x value from the previous frame
				values.push( prevValue[ 0 ] );

			}

			if ( yIndex !== -1 ) {

				const yValue = curves.y.values[ yIndex ];
				values.push( yValue );
				prevValue[ 1 ] = yValue;

			} else {

				values.push( prevValue[ 1 ] );

			}

			if ( zIndex !== -1 ) {

				const zValue = curves.z.values[ zIndex ];
				values.push( zValue );
				prevValue[ 2 ] = zValue;

			} else {

				values.push( prevValue[ 2 ] );

			}

		} );

		return values;

	}

	// Rotations are defined as Euler angles which can have values  of any size
	// These will be converted to quaternions which don't support values greater than
	// PI, so we'll interpolate large rotations
	interpolateRotations( curvex, curvey, curvez, eulerOrder ) {

		const times = [];
		const values = [];

		// Add first frame
		times.push( curvex.times[ 0 ] );
		values.push( MathUtils.degToRad( curvex.values[ 0 ] ) );
		values.push( MathUtils.degToRad( curvey.values[ 0 ] ) );
		values.push( MathUtils.degToRad( curvez.values[ 0 ] ) );

		for ( let i = 1; i < curvex.values.length; i ++ ) {

			const initialValue = [
				curvex.values[ i - 1 ],
				curvey.values[ i - 1 ],
				curvez.values[ i - 1 ],
			];

			if ( isNaN( initialValue[ 0 ] ) || isNaN( initialValue[ 1 ] ) || isNaN( initialValue[ 2 ] ) ) {

				continue;

			}

			const initialValueRad = initialValue.map( MathUtils.degToRad );

			const currentValue = [
				curvex.values[ i ],
				curvey.values[ i ],
				curvez.values[ i ],
			];

			if ( isNaN( currentValue[ 0 ] ) || isNaN( currentValue[ 1 ] ) || isNaN( currentValue[ 2 ] ) ) {

				continue;

			}

			const currentValueRad = currentValue.map( MathUtils.degToRad );

			const valuesSpan = [
				currentValue[ 0 ] - initialValue[ 0 ],
				currentValue[ 1 ] - initialValue[ 1 ],
				currentValue[ 2 ] - initialValue[ 2 ],
			];

			const absoluteSpan = [
				Math.abs( valuesSpan[ 0 ] ),
				Math.abs( valuesSpan[ 1 ] ),
				Math.abs( valuesSpan[ 2 ] ),
			];

			if ( absoluteSpan[ 0 ] >= 180 || absoluteSpan[ 1 ] >= 180 || absoluteSpan[ 2 ] >= 180 ) {

				const maxAbsSpan = Math.max( ...absoluteSpan );

				const numSubIntervals = maxAbsSpan / 180;

				const E1 = new Euler( ...initialValueRad, eulerOrder );
				const E2 = new Euler( ...currentValueRad, eulerOrder );

				const Q1 = new Quaternion$1().setFromEuler( E1 );
				const Q2 = new Quaternion$1().setFromEuler( E2 );

				// Check unroll
				if ( Q1.dot( Q2 ) ) {

					Q2.set( - Q2.x, - Q2.y, - Q2.z, - Q2.w );

				}

				// Interpolate
				const initialTime = curvex.times[ i - 1 ];
				const timeSpan = curvex.times[ i ] - initialTime;

				const Q = new Quaternion$1();
				const E = new Euler();
				for ( let t = 0; t < 1; t += 1 / numSubIntervals ) {

					Q.copy( Q1.clone().slerp( Q2.clone(), t ) );

					times.push( initialTime + t * timeSpan );
					E.setFromQuaternion( Q, eulerOrder );

					values.push( E.x );
					values.push( E.y );
					values.push( E.z );

				}

			} else {

				times.push( curvex.times[ i ] );
				values.push( MathUtils.degToRad( curvex.values[ i ] ) );
				values.push( MathUtils.degToRad( curvey.values[ i ] ) );
				values.push( MathUtils.degToRad( curvez.values[ i ] ) );

			}

		}

		return [ times, values ];

	}

}

// parse an FBX file in ASCII format
class TextParser {

	getPrevNode() {

		return this.nodeStack[ this.currentIndent - 2 ];

	}

	getCurrentNode() {

		return this.nodeStack[ this.currentIndent - 1 ];

	}

	getCurrentProp() {

		return this.currentProp;

	}

	pushStack( node ) {

		this.nodeStack.push( node );
		this.currentIndent += 1;

	}

	popStack() {

		this.nodeStack.pop();
		this.currentIndent -= 1;

	}

	setCurrentProp( val, name ) {

		this.currentProp = val;
		this.currentPropName = name;

	}

	parse( text ) {

		this.currentIndent = 0;

		this.allNodes = new FBXTree();
		this.nodeStack = [];
		this.currentProp = [];
		this.currentPropName = '';

		const scope = this;

		const split = text.split( /[\r\n]+/ );

		split.forEach( function ( line, i ) {

			const matchComment = line.match( /^[\s\t]*;/ );
			const matchEmpty = line.match( /^[\s\t]*$/ );

			if ( matchComment || matchEmpty ) return;

			const matchBeginning = line.match( '^\\t{' + scope.currentIndent + '}(\\w+):(.*){', '' );
			const matchProperty = line.match( '^\\t{' + ( scope.currentIndent ) + '}(\\w+):[\\s\\t\\r\\n](.*)' );
			const matchEnd = line.match( '^\\t{' + ( scope.currentIndent - 1 ) + '}}' );

			if ( matchBeginning ) {

				scope.parseNodeBegin( line, matchBeginning );

			} else if ( matchProperty ) {

				scope.parseNodeProperty( line, matchProperty, split[ ++ i ] );

			} else if ( matchEnd ) {

				scope.popStack();

			} else if ( line.match( /^[^\s\t}]/ ) ) {

				// large arrays are split over multiple lines terminated with a ',' character
				// if this is encountered the line needs to be joined to the previous line
				scope.parseNodePropertyContinued( line );

			}

		} );

		return this.allNodes;

	}

	parseNodeBegin( line, property ) {

		const nodeName = property[ 1 ].trim().replace( /^"/, '' ).replace( /"$/, '' );

		const nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {

			return attr.trim().replace( /^"/, '' ).replace( /"$/, '' );

		} );

		const node = { name: nodeName };
		const attrs = this.parseNodeAttr( nodeAttrs );

		const currentNode = this.getCurrentNode();

		// a top node
		if ( this.currentIndent === 0 ) {

			this.allNodes.add( nodeName, node );

		} else { // a subnode

			// if the subnode already exists, append it
			if ( nodeName in currentNode ) {

				// special case Pose needs PoseNodes as an array
				if ( nodeName === 'PoseNode' ) {

					currentNode.PoseNode.push( node );

				} else if ( currentNode[ nodeName ].id !== undefined ) {

					currentNode[ nodeName ] = {};
					currentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];

				}

				if ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;

			} else if ( typeof attrs.id === 'number' ) {

				currentNode[ nodeName ] = {};
				currentNode[ nodeName ][ attrs.id ] = node;

			} else if ( nodeName !== 'Properties70' ) {

				if ( nodeName === 'PoseNode' )	currentNode[ nodeName ] = [ node ];
				else currentNode[ nodeName ] = node;

			}

		}

		if ( typeof attrs.id === 'number' ) node.id = attrs.id;
		if ( attrs.name !== '' ) node.attrName = attrs.name;
		if ( attrs.type !== '' ) node.attrType = attrs.type;

		this.pushStack( node );

	}

	parseNodeAttr( attrs ) {

		let id = attrs[ 0 ];

		if ( attrs[ 0 ] !== '' ) {

			id = parseInt( attrs[ 0 ] );

			if ( isNaN( id ) ) {

				id = attrs[ 0 ];

			}

		}

		let name = '', type = '';

		if ( attrs.length > 1 ) {

			name = attrs[ 1 ].replace( /^(\w+)::/, '' );
			type = attrs[ 2 ];

		}

		return { id: id, name: name, type: type };

	}

	parseNodeProperty( line, property, contentLine ) {

		let propName = property[ 1 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();
		let propValue = property[ 2 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();

		// for special case: base64 image data follows "Content: ," line
		//	Content: ,
		//	 "/9j/4RDaRXhpZgAATU0A..."
		if ( propName === 'Content' && propValue === ',' ) {

			propValue = contentLine.replace( /"/g, '' ).replace( /,$/, '' ).trim();

		}

		const currentNode = this.getCurrentNode();
		const parentName = currentNode.name;

		if ( parentName === 'Properties70' ) {

			this.parseNodeSpecialProperty( line, propName, propValue );
			return;

		}

		// Connections
		if ( propName === 'C' ) {

			const connProps = propValue.split( ',' ).slice( 1 );
			const from = parseInt( connProps[ 0 ] );
			const to = parseInt( connProps[ 1 ] );

			let rest = propValue.split( ',' ).slice( 3 );

			rest = rest.map( function ( elem ) {

				return elem.trim().replace( /^"/, '' );

			} );

			propName = 'connections';
			propValue = [ from, to ];
			append( propValue, rest );

			if ( currentNode[ propName ] === undefined ) {

				currentNode[ propName ] = [];

			}

		}

		// Node
		if ( propName === 'Node' ) currentNode.id = propValue;

		// connections
		if ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {

			currentNode[ propName ].push( propValue );

		} else {

			if ( propName !== 'a' ) currentNode[ propName ] = propValue;
			else currentNode.a = propValue;

		}

		this.setCurrentProp( currentNode, propName );

		// convert string to array, unless it ends in ',' in which case more will be added to it
		if ( propName === 'a' && propValue.slice( -1 ) !== ',' ) {

			currentNode.a = parseNumberArray( propValue );

		}

	}

	parseNodePropertyContinued( line ) {

		const currentNode = this.getCurrentNode();

		currentNode.a += line;

		// if the line doesn't end in ',' we have reached the end of the property value
		// so convert the string to an array
		if ( line.slice( -1 ) !== ',' ) {

			currentNode.a = parseNumberArray( currentNode.a );

		}

	}

	// parse "Property70"
	parseNodeSpecialProperty( line, propName, propValue ) {

		// split this
		// P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
		// into array like below
		// ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
		const props = propValue.split( '",' ).map( function ( prop ) {

			return prop.trim().replace( /^\"/, '' ).replace( /\s/, '_' );

		} );

		const innerPropName = props[ 0 ];
		const innerPropType1 = props[ 1 ];
		const innerPropType2 = props[ 2 ];
		const innerPropFlag = props[ 3 ];
		let innerPropValue = props[ 4 ];

		// cast values where needed, otherwise leave as strings
		switch ( innerPropType1 ) {

			case 'int':
			case 'enum':
			case 'bool':
			case 'ULongLong':
			case 'double':
			case 'Number':
			case 'FieldOfView':
				innerPropValue = parseFloat( innerPropValue );
				break;

			case 'Color':
			case 'ColorRGB':
			case 'Vector3D':
			case 'Lcl_Translation':
			case 'Lcl_Rotation':
			case 'Lcl_Scaling':
				innerPropValue = parseNumberArray( innerPropValue );
				break;

		}

		// CAUTION: these props must append to parent's parent
		this.getPrevNode()[ innerPropName ] = {

			'type': innerPropType1,
			'type2': innerPropType2,
			'flag': innerPropFlag,
			'value': innerPropValue

		};

		this.setCurrentProp( this.getPrevNode(), innerPropName );

	}

}

// Parse an FBX file in Binary format
class BinaryParser {

	parse( buffer ) {

		const reader = new BinaryReader( buffer );
		reader.skip( 23 ); // skip magic 23 bytes

		const version = reader.getUint32();

		if ( version < 6400 ) {

			throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );

		}

		const allNodes = new FBXTree();

		while ( ! this.endOfContent( reader ) ) {

			const node = this.parseNode( reader, version );
			if ( node !== null ) allNodes.add( node.name, node );

		}

		return allNodes;

	}

	// Check if reader has reached the end of content.
	endOfContent( reader ) {

		// footer size: 160bytes + 16-byte alignment padding
		// - 16bytes: magic
		// - padding til 16-byte alignment (at least 1byte?)
		//	(seems like some exporters embed fixed 15 or 16bytes?)
		// - 4bytes: magic
		// - 4bytes: version
		// - 120bytes: zero
		// - 16bytes: magic
		if ( reader.size() % 16 === 0 ) {

			return ( ( reader.getOffset() + 160 + 16 ) & -16 ) >= reader.size();

		} else {

			return reader.getOffset() + 160 + 16 >= reader.size();

		}

	}

	// recursively parse nodes until the end of the file is reached
	parseNode( reader, version ) {

		const node = {};

		// The first three data sizes depends on version.
		const endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();
		const numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();

		( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used

		const nameLen = reader.getUint8();
		const name = reader.getString( nameLen );

		// Regards this node as NULL-record if endOffset is zero
		if ( endOffset === 0 ) return null;

		const propertyList = [];

		for ( let i = 0; i < numProperties; i ++ ) {

			propertyList.push( this.parseProperty( reader ) );

		}

		// Regards the first three elements in propertyList as id, attrName, and attrType
		const id = propertyList.length > 0 ? propertyList[ 0 ] : '';
		const attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';
		const attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';

		// check if this node represents just a single property
		// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
		node.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;

		while ( endOffset > reader.getOffset() ) {

			const subNode = this.parseNode( reader, version );

			if ( subNode !== null ) this.parseSubNode( name, node, subNode );

		}

		node.propertyList = propertyList; // raw property list used by parent

		if ( typeof id === 'number' ) node.id = id;
		if ( attrName !== '' ) node.attrName = attrName;
		if ( attrType !== '' ) node.attrType = attrType;
		if ( name !== '' ) node.name = name;

		return node;

	}

	parseSubNode( name, node, subNode ) {

		// special case: child node is single property
		if ( subNode.singleProperty === true ) {

			const value = subNode.propertyList[ 0 ];

			if ( Array.isArray( value ) ) {

				node[ subNode.name ] = subNode;

				subNode.a = value;

			} else {

				node[ subNode.name ] = value;

			}

		} else if ( name === 'Connections' && subNode.name === 'C' ) {

			const array = [];

			subNode.propertyList.forEach( function ( property, i ) {

				// first Connection is FBX type (OO, OP, etc.). We'll discard these
				if ( i !== 0 ) array.push( property );

			} );

			if ( node.connections === undefined ) {

				node.connections = [];

			}

			node.connections.push( array );

		} else if ( subNode.name === 'Properties70' ) {

			const keys = Object.keys( subNode );

			keys.forEach( function ( key ) {

				node[ key ] = subNode[ key ];

			} );

		} else if ( name === 'Properties70' && subNode.name === 'P' ) {

			let innerPropName = subNode.propertyList[ 0 ];
			let innerPropType1 = subNode.propertyList[ 1 ];
			const innerPropType2 = subNode.propertyList[ 2 ];
			const innerPropFlag = subNode.propertyList[ 3 ];
			let innerPropValue;

			if ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );
			if ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );

			if ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {

				innerPropValue = [
					subNode.propertyList[ 4 ],
					subNode.propertyList[ 5 ],
					subNode.propertyList[ 6 ]
				];

			} else {

				innerPropValue = subNode.propertyList[ 4 ];

			}

			// this will be copied to parent, see above
			node[ innerPropName ] = {

				'type': innerPropType1,
				'type2': innerPropType2,
				'flag': innerPropFlag,
				'value': innerPropValue

			};

		} else if ( node[ subNode.name ] === undefined ) {

			if ( typeof subNode.id === 'number' ) {

				node[ subNode.name ] = {};
				node[ subNode.name ][ subNode.id ] = subNode;

			} else {

				node[ subNode.name ] = subNode;

			}

		} else {

			if ( subNode.name === 'PoseNode' ) {

				if ( ! Array.isArray( node[ subNode.name ] ) ) {

					node[ subNode.name ] = [ node[ subNode.name ] ];

				}

				node[ subNode.name ].push( subNode );

			} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {

				node[ subNode.name ][ subNode.id ] = subNode;

			}

		}

	}

	parseProperty( reader ) {

		const type = reader.getString( 1 );
		let length;

		switch ( type ) {

			case 'C':
				return reader.getBoolean();

			case 'D':
				return reader.getFloat64();

			case 'F':
				return reader.getFloat32();

			case 'I':
				return reader.getInt32();

			case 'L':
				return reader.getInt64();

			case 'R':
				length = reader.getUint32();
				return reader.getArrayBuffer( length );

			case 'S':
				length = reader.getUint32();
				return reader.getString( length );

			case 'Y':
				return reader.getInt16();

			case 'b':
			case 'c':
			case 'd':
			case 'f':
			case 'i':
			case 'l':

				const arrayLength = reader.getUint32();
				const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed
				const compressedLength = reader.getUint32();

				if ( encoding === 0 ) {

					switch ( type ) {

						case 'b':
						case 'c':
							return reader.getBooleanArray( arrayLength );

						case 'd':
							return reader.getFloat64Array( arrayLength );

						case 'f':
							return reader.getFloat32Array( arrayLength );

						case 'i':
							return reader.getInt32Array( arrayLength );

						case 'l':
							return reader.getInt64Array( arrayLength );

					}

				}

				const data = unzlibSync( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) );
				const reader2 = new BinaryReader( data.buffer );

				switch ( type ) {

					case 'b':
					case 'c':
						return reader2.getBooleanArray( arrayLength );

					case 'd':
						return reader2.getFloat64Array( arrayLength );

					case 'f':
						return reader2.getFloat32Array( arrayLength );

					case 'i':
						return reader2.getInt32Array( arrayLength );

					case 'l':
						return reader2.getInt64Array( arrayLength );

				}

				break; // cannot happen but is required by the DeepScan

			default:
				throw new Error( 'THREE.FBXLoader: Unknown property type ' + type );

		}

	}

}

class BinaryReader {

	constructor( buffer, littleEndian ) {

		this.dv = new DataView( buffer );
		this.offset = 0;
		this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;
		this._textDecoder = new TextDecoder();

	}

	getOffset() {

		return this.offset;

	}

	size() {

		return this.dv.buffer.byteLength;

	}

	skip( length ) {

		this.offset += length;

	}

	// seems like true/false representation depends on exporter.
	// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
	// then sees LSB.
	getBoolean() {

		return ( this.getUint8() & 1 ) === 1;

	}

	getBooleanArray( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getBoolean() );

		}

		return a;

	}

	getUint8() {

		const value = this.dv.getUint8( this.offset );
		this.offset += 1;
		return value;

	}

	getInt16() {

		const value = this.dv.getInt16( this.offset, this.littleEndian );
		this.offset += 2;
		return value;

	}

	getInt32() {

		const value = this.dv.getInt32( this.offset, this.littleEndian );
		this.offset += 4;
		return value;

	}

	getInt32Array( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getInt32() );

		}

		return a;

	}

	getUint32() {

		const value = this.dv.getUint32( this.offset, this.littleEndian );
		this.offset += 4;
		return value;

	}

	// JavaScript doesn't support 64-bit integer so calculate this here
	// 1 << 32 will return 1 so using multiply operation instead here.
	// There's a possibility that this method returns wrong value if the value
	// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
	// TODO: safely handle 64-bit integer
	getInt64() {

		let low, high;

		if ( this.littleEndian ) {

			low = this.getUint32();
			high = this.getUint32();

		} else {

			high = this.getUint32();
			low = this.getUint32();

		}

		// calculate negative value
		if ( high & 0x80000000 ) {

			high = ~ high & 0xFFFFFFFF;
			low = ~ low & 0xFFFFFFFF;

			if ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;

			low = ( low + 1 ) & 0xFFFFFFFF;

			return - ( high * 0x100000000 + low );

		}

		return high * 0x100000000 + low;

	}

	getInt64Array( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getInt64() );

		}

		return a;

	}

	// Note: see getInt64() comment
	getUint64() {

		let low, high;

		if ( this.littleEndian ) {

			low = this.getUint32();
			high = this.getUint32();

		} else {

			high = this.getUint32();
			low = this.getUint32();

		}

		return high * 0x100000000 + low;

	}

	getFloat32() {

		const value = this.dv.getFloat32( this.offset, this.littleEndian );
		this.offset += 4;
		return value;

	}

	getFloat32Array( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getFloat32() );

		}

		return a;

	}

	getFloat64() {

		const value = this.dv.getFloat64( this.offset, this.littleEndian );
		this.offset += 8;
		return value;

	}

	getFloat64Array( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getFloat64() );

		}

		return a;

	}

	getArrayBuffer( size ) {

		const value = this.dv.buffer.slice( this.offset, this.offset + size );
		this.offset += size;
		return value;

	}

	getString( size ) {

		const start = this.offset;
		let a = new Uint8Array( this.dv.buffer, start, size );

		this.skip( size );

		const nullByte = a.indexOf( 0 );
		if ( nullByte >= 0 ) a = new Uint8Array( this.dv.buffer, start, nullByte );

		return this._textDecoder.decode( a );

	}

}

// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
// and BinaryParser( FBX Binary format)
class FBXTree {

	add( key, val ) {

		this[ key ] = val;

	}

}

// ************** UTILITY FUNCTIONS **************

function isFbxFormatBinary( buffer ) {

	const CORRECT = 'Kaydara\u0020FBX\u0020Binary\u0020\u0020\0';

	return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );

}

function isFbxFormatASCII( text ) {

	const CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\' ];

	let cursor = 0;

	function read( offset ) {

		const result = text[ offset - 1 ];
		text = text.slice( cursor + offset );
		cursor ++;
		return result;

	}

	for ( let i = 0; i < CORRECT.length; ++ i ) {

		const num = read( 1 );
		if ( num === CORRECT[ i ] ) {

			return false;

		}

	}

	return true;

}

function getFbxVersion( text ) {

	const versionRegExp = /FBXVersion: (\d+)/;
	const match = text.match( versionRegExp );

	if ( match ) {

		const version = parseInt( match[ 1 ] );
		return version;

	}

	throw new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );

}

// Converts FBX ticks into real time seconds.
function convertFBXTimeToSeconds( time ) {

	return time / 46186158000;

}

const dataArray = [];

// extracts the data from the correct position in the FBX array based on indexing type
function getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

	let index;

	switch ( infoObject.mappingType ) {

		case 'ByPolygonVertex' :
			index = polygonVertexIndex;
			break;
		case 'ByPolygon' :
			index = polygonIndex;
			break;
		case 'ByVertice' :
			index = vertexIndex;
			break;
		case 'AllSame' :
			index = infoObject.indices[ 0 ];
			break;
		default :
			console.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );

	}

	if ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];

	const from = index * infoObject.dataSize;
	const to = from + infoObject.dataSize;

	return slice$1( dataArray, infoObject.buffer, from, to );

}

const tempEuler = new Euler();
const tempVec = new Vector3();

// generate transformation from FBX transform data
// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e
function generateTransform( transformData ) {

	const lTranslationM = new Matrix4();
	const lPreRotationM = new Matrix4();
	const lRotationM = new Matrix4();
	const lPostRotationM = new Matrix4();

	const lScalingM = new Matrix4();
	const lScalingPivotM = new Matrix4();
	const lScalingOffsetM = new Matrix4();
	const lRotationOffsetM = new Matrix4();
	const lRotationPivotM = new Matrix4();

	const lParentGX = new Matrix4();
	const lParentLX = new Matrix4();
	const lGlobalT = new Matrix4();

	const inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;

	if ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );

	// For Maya models using "Joint Orient", Euler order only applies to rotation, not pre/post-rotations
	const defaultEulerOrder = getEulerOrder( 0 );

	if ( transformData.preRotation ) {

		const array = transformData.preRotation.map( MathUtils.degToRad );
		array.push( defaultEulerOrder );
		lPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

	}

	if ( transformData.rotation ) {

		const array = transformData.rotation.map( MathUtils.degToRad );
		array.push( transformData.eulerOrder || defaultEulerOrder );
		lRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

	}

	if ( transformData.postRotation ) {

		const array = transformData.postRotation.map( MathUtils.degToRad );
		array.push( defaultEulerOrder );
		lPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );
		lPostRotationM.invert();

	}

	if ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );

	// Pivots and offsets
	if ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );
	if ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );
	if ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );
	if ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );

	// parent transform
	if ( transformData.parentMatrixWorld ) {

		lParentLX.copy( transformData.parentMatrix );
		lParentGX.copy( transformData.parentMatrixWorld );

	}

	const lLRM = lPreRotationM.clone().multiply( lRotationM ).multiply( lPostRotationM );
	// Global Rotation
	const lParentGRM = new Matrix4();
	lParentGRM.extractRotation( lParentGX );

	// Global Shear*Scaling
	const lParentTM = new Matrix4();
	lParentTM.copyPosition( lParentGX );

	const lParentGRSM = lParentTM.clone().invert().multiply( lParentGX );
	const lParentGSM = lParentGRM.clone().invert().multiply( lParentGRSM );
	const lLSM = lScalingM;

	const lGlobalRS = new Matrix4();

	if ( inheritType === 0 ) {

		lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );

	} else if ( inheritType === 1 ) {

		lGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );

	} else {

		const lParentLSM = new Matrix4().scale( new Vector3().setFromMatrixScale( lParentLX ) );
		const lParentLSM_inv = lParentLSM.clone().invert();
		const lParentGSM_noLocal = lParentGSM.clone().multiply( lParentLSM_inv );

		lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );

	}

	const lRotationPivotM_inv = lRotationPivotM.clone().invert();
	const lScalingPivotM_inv = lScalingPivotM.clone().invert();
	// Calculate the local transform matrix
	let lTransform = lTranslationM.clone().multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );

	const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition( lTransform );

	const lGlobalTranslation = lParentGX.clone().multiply( lLocalTWithAllPivotAndOffsetInfo );
	lGlobalT.copyPosition( lGlobalTranslation );

	lTransform = lGlobalT.clone().multiply( lGlobalRS );

	// from global to local
	lTransform.premultiply( lParentGX.invert() );

	return lTransform;

}

// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html
function getEulerOrder( order ) {

	order = order || 0;

	const enums = [
		'ZYX', // -> XYZ extrinsic
		'YZX', // -> XZY extrinsic
		'XZY', // -> YZX extrinsic
		'ZXY', // -> YXZ extrinsic
		'YXZ', // -> ZXY extrinsic
		'XYZ', // -> ZYX extrinsic
		//'SphericXYZ', // not possible to support
	];

	if ( order === 6 ) {

		console.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );
		return enums[ 0 ];

	}

	return enums[ order ];

}

// Parses comma separated list of numbers and returns them an array.
// Used internally by the TextParser
function parseNumberArray( value ) {

	const array = value.split( ',' ).map( function ( val ) {

		return parseFloat( val );

	} );

	return array;

}

function convertArrayBufferToString( buffer, from, to ) {

	if ( from === undefined ) from = 0;
	if ( to === undefined ) to = buffer.byteLength;

	return new TextDecoder().decode( new Uint8Array( buffer, from, to ) );

}

function append( a, b ) {

	for ( let i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {

		a[ j ] = b[ i ];

	}

}

function slice$1( a, b, from, to ) {

	for ( let i = from, j = 0; i < to; i ++, j ++ ) {

		a[ j ] = b[ i ];

	}

	return a;

}

// This file is part of meshoptimizer library and is distributed under the terms of MIT License.
// Copyright (C) 2016-2022, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
var MeshoptDecoder = (function() {

	// Built with clang version 14.0.4
	// Built from meshoptimizer 0.18
	var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
	var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";

	var detector = new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]);
	var wasmpack = new Uint8Array([32,0,65,2,1,106,34,33,3,128,11,4,13,64,6,253,10,7,15,116,127,5,8,12,40,16,19,54,20,9,27,255,113,17,42,67,24,23,146,148,18,14,22,45,70,69,56,114,101,21,25,63,75,136,108,28,118,29,73,115]);

	if (typeof WebAssembly !== 'object') {
		return {
			supported: false,
		};
	}

	var wasm = WebAssembly.validate(detector) ? wasm_simd : wasm_base;

	var instance;

	var ready =
		WebAssembly.instantiate(unpack(wasm), {})
		.then(function(result) {
			instance = result.instance;
			instance.exports.__wasm_call_ctors();
		});

	function unpack(data) {
		var result = new Uint8Array(data.length);
		for (var i = 0; i < data.length; ++i) {
			var ch = data.charCodeAt(i);
			result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
		}
		var write = 0;
		for (var i = 0; i < data.length; ++i) {
			result[write++] = (result[i] < 60) ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
		}
		return result.buffer.slice(0, write);
	}

	function decode(fun, target, count, size, source, filter) {
		var sbrk = instance.exports.sbrk;
		var count4 = (count + 3) & -4;
		var tp = sbrk(count4 * size);
		var sp = sbrk(source.length);
		var heap = new Uint8Array(instance.exports.memory.buffer);
		heap.set(source, sp);
		var res = fun(tp, count, size, sp, source.length);
		if (res == 0 && filter) {
			filter(tp, count4, size);
		}
		target.set(heap.subarray(tp, tp + count * size));
		sbrk(tp - sbrk(0));
		if (res != 0) {
			throw new Error("Malformed buffer data: " + res);
		}
	}

	var filters = {
		NONE: "",
		OCTAHEDRAL: "meshopt_decodeFilterOct",
		QUATERNION: "meshopt_decodeFilterQuat",
		EXPONENTIAL: "meshopt_decodeFilterExp",
	};

	var decoders = {
		ATTRIBUTES: "meshopt_decodeVertexBuffer",
		TRIANGLES: "meshopt_decodeIndexBuffer",
		INDICES: "meshopt_decodeIndexSequence",
	};

	var workers = [];
	var requestId = 0;

	function createWorker(url) {
		var worker = {
			object: new Worker(url),
			pending: 0,
			requests: {}
		};

		worker.object.onmessage = function(event) {
			var data = event.data;

			worker.pending -= data.count;
			worker.requests[data.id][data.action](data.value);

			delete worker.requests[data.id];
		};

		return worker;
	}

	function initWorkers(count) {
		var source =
			"var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(unpack(wasm)) + "]), {})" +
			".then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });" +
			"self.onmessage = workerProcess;" +
			decode.toString() + workerProcess.toString();

		var blob = new Blob([source], {type: 'text/javascript'});
		var url = URL.createObjectURL(blob);

		for (var i = 0; i < count; ++i) {
			workers[i] = createWorker(url);
		}

		URL.revokeObjectURL(url);
	}

	function decodeWorker(count, size, source, mode, filter) {
		var worker = workers[0];

		for (var i = 1; i < workers.length; ++i) {
			if (workers[i].pending < worker.pending) {
				worker = workers[i];
			}
		}

		return new Promise(function (resolve, reject) {
			var data = new Uint8Array(source);
			var id = requestId++;

			worker.pending += count;
			worker.requests[id] = { resolve: resolve, reject: reject };
			worker.object.postMessage({ id: id, count: count, size: size, source: data, mode: mode, filter: filter }, [ data.buffer ]);
		});
	}

	function workerProcess(event) {
		ready.then(function() {
			var data = event.data;
			try {
				var target = new Uint8Array(data.count * data.size);
				decode(instance.exports[data.mode], target, data.count, data.size, data.source, instance.exports[data.filter]);
				self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [ target.buffer ]);
			} catch (error) {
				self.postMessage({ id: data.id, count: data.count, action: "reject", value: error });
			}
		});
	}

	return {
		ready: ready,
		supported: true,
		useWorkers: function(count) {
			initWorkers(count);
		},
		decodeVertexBuffer: function(target, count, size, source, filter) {
			decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);
		},
		decodeIndexBuffer: function(target, count, size, source) {
			decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);
		},
		decodeIndexSequence: function(target, count, size, source) {
			decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);
		},
		decodeGltfBuffer: function(target, count, size, source, mode, filter) {
			decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
		},
		decodeGltfBufferAsync: function(count, size, source, mode, filter) {
			if (workers.length > 0) {
				return decodeWorker(count, size, source, decoders[mode], filters[filter]);
			}

			return ready.then(function() {
				var target = new Uint8Array(count * size);
				decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
				return target;
			});
		}
	};
})();

// o object_name | g group_name
const _object_pattern = /^[og]\s*(.+)?/;
// mtllib file_reference
const _material_library_pattern = /^mtllib /;
// usemtl material_name
const _material_use_pattern = /^usemtl /;
// usemap map_name
const _map_use_pattern = /^usemap /;
const _face_vertex_data_separator_pattern = /\s+/;

const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();

const _ab = new Vector3();
const _cb = new Vector3();

const _color$1 = new Color();

function ParserState() {

	const state = {
		objects: [],
		object: {},

		vertices: [],
		normals: [],
		colors: [],
		uvs: [],

		materials: {},
		materialLibraries: [],

		startObject: function ( name, fromDeclaration ) {

			// If the current object (initial from reset) is not from a g/o declaration in the parsed
			// file. We need to use it for the first parsed g/o to keep things in sync.
			if ( this.object && this.object.fromDeclaration === false ) {

				this.object.name = name;
				this.object.fromDeclaration = ( fromDeclaration !== false );
				return;

			}

			const previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

			this.object = {
				name: name || '',
				fromDeclaration: ( fromDeclaration !== false ),

				geometry: {
					vertices: [],
					normals: [],
					colors: [],
					uvs: [],
					hasUVIndices: false
				},
				materials: [],
				smooth: true,

				startMaterial: function ( name, libraries ) {

					const previous = this._finalize( false );

					// New usemtl declaration overwrites an inherited material, except if faces were declared
					// after the material, then it must be preserved for proper MultiMaterial continuation.
					if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

						this.materials.splice( previous.index, 1 );

					}

					const material = {
						index: this.materials.length,
						name: name || '',
						mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
						smooth: ( previous !== undefined ? previous.smooth : this.smooth ),
						groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),
						groupEnd: -1,
						groupCount: -1,
						inherited: false,

						clone: function ( index ) {

							const cloned = {
								index: ( typeof index === 'number' ? index : this.index ),
								name: this.name,
								mtllib: this.mtllib,
								smooth: this.smooth,
								groupStart: 0,
								groupEnd: -1,
								groupCount: -1,
								inherited: false
							};
							cloned.clone = this.clone.bind( cloned );
							return cloned;

						}
					};

					this.materials.push( material );

					return material;

				},

				currentMaterial: function () {

					if ( this.materials.length > 0 ) {

						return this.materials[ this.materials.length - 1 ];

					}

					return undefined;

				},

				_finalize: function ( end ) {

					const lastMultiMaterial = this.currentMaterial();
					if ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {

						lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
						lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
						lastMultiMaterial.inherited = false;

					}

					// Ignore objects tail materials if no face declarations followed them before a new o/g started.
					if ( end && this.materials.length > 1 ) {

						for ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {

							if ( this.materials[ mi ].groupCount <= 0 ) {

								this.materials.splice( mi, 1 );

							}

						}

					}

					// Guarantee at least one empty material, this makes the creation later more straight forward.
					if ( end && this.materials.length === 0 ) {

						this.materials.push( {
							name: '',
							smooth: this.smooth
						} );

					}

					return lastMultiMaterial;

				}
			};

			// Inherit previous objects material.
			// Spec tells us that a declared material must be set to all objects until a new material is declared.
			// If a usemtl declaration is encountered while this new object is being parsed, it will
			// overwrite the inherited material. Exception being that there was already face declarations
			// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

			if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

				const declared = previousMaterial.clone( 0 );
				declared.inherited = true;
				this.object.materials.push( declared );

			}

			this.objects.push( this.object );

		},

		finalize: function () {

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

		},

		parseVertexIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseNormalIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseUVIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

		},

		addVertex: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addVertexPoint: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addVertexLine: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addNormal: function ( a, b, c ) {

			const src = this.normals;
			const dst = this.object.geometry.normals;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addFaceNormal: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.normals;

			_vA.fromArray( src, a );
			_vB.fromArray( src, b );
			_vC.fromArray( src, c );

			_cb.subVectors( _vC, _vB );
			_ab.subVectors( _vA, _vB );
			_cb.cross( _ab );

			_cb.normalize();

			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );

		},

		addColor: function ( a, b, c ) {

			const src = this.colors;
			const dst = this.object.geometry.colors;

			if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addUV: function ( a, b, c ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ] );

		},

		addDefaultUV: function () {

			const dst = this.object.geometry.uvs;

			dst.push( 0, 0 );
			dst.push( 0, 0 );
			dst.push( 0, 0 );

		},

		addUVLine: function ( a ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );

		},

		addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

			const vLen = this.vertices.length;

			let ia = this.parseVertexIndex( a, vLen );
			let ib = this.parseVertexIndex( b, vLen );
			let ic = this.parseVertexIndex( c, vLen );

			this.addVertex( ia, ib, ic );
			this.addColor( ia, ib, ic );

			// normals

			if ( na !== undefined && na !== '' ) {

				const nLen = this.normals.length;

				ia = this.parseNormalIndex( na, nLen );
				ib = this.parseNormalIndex( nb, nLen );
				ic = this.parseNormalIndex( nc, nLen );

				this.addNormal( ia, ib, ic );

			} else {

				this.addFaceNormal( ia, ib, ic );

			}

			// uvs

			if ( ua !== undefined && ua !== '' ) {

				const uvLen = this.uvs.length;

				ia = this.parseUVIndex( ua, uvLen );
				ib = this.parseUVIndex( ub, uvLen );
				ic = this.parseUVIndex( uc, uvLen );

				this.addUV( ia, ib, ic );

				this.object.geometry.hasUVIndices = true;

			} else {

				// add placeholder values (for inconsistent face definitions)

				this.addDefaultUV();

			}

		},

		addPointGeometry: function ( vertices ) {

			this.object.geometry.type = 'Points';

			const vLen = this.vertices.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				const index = this.parseVertexIndex( vertices[ vi ], vLen );

				this.addVertexPoint( index );
				this.addColor( index );

			}

		},

		addLineGeometry: function ( vertices, uvs ) {

			this.object.geometry.type = 'Line';

			const vLen = this.vertices.length;
			const uvLen = this.uvs.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

			}

			for ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

				this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

			}

		}

	};

	state.startObject( '', false );

	return state;

}

//

class OBJLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.materials = null;

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	setMaterials( materials ) {

		this.materials = materials;

		return this;

	}

	parse( text ) {

		const state = new ParserState();

		if ( text.indexOf( '\r\n' ) !== -1 ) {

			// This is faster than String.split with regex that splits on both
			text = text.replace( /\r\n/g, '\n' );

		}

		if ( text.indexOf( '\\\n' ) !== -1 ) {

			// join lines separated by a line continuation character (\)
			text = text.replace( /\\\n/g, '' );

		}

		const lines = text.split( '\n' );
		let result = [];

		for ( let i = 0, l = lines.length; i < l; i ++ ) {

			const line = lines[ i ].trimStart();

			if ( line.length === 0 ) continue;

			const lineFirstChar = line.charAt( 0 );

			// @todo invoke passed in handler if any
			if ( lineFirstChar === '#' ) continue; // skip comments

			if ( lineFirstChar === 'v' ) {

				const data = line.split( _face_vertex_data_separator_pattern );

				switch ( data[ 0 ] ) {

					case 'v':
						state.vertices.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						if ( data.length >= 7 ) {

							_color$1.setRGB(
								parseFloat( data[ 4 ] ),
								parseFloat( data[ 5 ] ),
								parseFloat( data[ 6 ] ),
								SRGBColorSpace
							);

							state.colors.push( _color$1.r, _color$1.g, _color$1.b );

						} else {

							// if no colors are defined, add placeholders so color and vertex indices match

							state.colors.push( undefined, undefined, undefined );

						}

						break;
					case 'vn':
						state.normals.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						break;
					case 'vt':
						state.uvs.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] )
						);
						break;

				}

			} else if ( lineFirstChar === 'f' ) {

				const lineData = line.slice( 1 ).trim();
				const vertexData = lineData.split( _face_vertex_data_separator_pattern );
				const faceVertices = [];

				// Parse the face vertex data into an easy to work with format

				for ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {

					const vertex = vertexData[ j ];

					if ( vertex.length > 0 ) {

						const vertexParts = vertex.split( '/' );
						faceVertices.push( vertexParts );

					}

				}

				// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

				const v1 = faceVertices[ 0 ];

				for ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

					const v2 = faceVertices[ j ];
					const v3 = faceVertices[ j + 1 ];

					state.addFace(
						v1[ 0 ], v2[ 0 ], v3[ 0 ],
						v1[ 1 ], v2[ 1 ], v3[ 1 ],
						v1[ 2 ], v2[ 2 ], v3[ 2 ]
					);

				}

			} else if ( lineFirstChar === 'l' ) {

				const lineParts = line.substring( 1 ).trim().split( ' ' );
				let lineVertices = [];
				const lineUVs = [];

				if ( line.indexOf( '/' ) === -1 ) {

					lineVertices = lineParts;

				} else {

					for ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {

						const parts = lineParts[ li ].split( '/' );

						if ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );
						if ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );

					}

				}

				state.addLineGeometry( lineVertices, lineUVs );

			} else if ( lineFirstChar === 'p' ) {

				const lineData = line.slice( 1 ).trim();
				const pointData = lineData.split( ' ' );

				state.addPointGeometry( pointData );

			} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {

				// o object_name
				// or
				// g group_name

				// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
				// let name = result[ 0 ].slice( 1 ).trim();
				const name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );

				state.startObject( name );

			} else if ( _material_use_pattern.test( line ) ) {

				// material

				state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

			} else if ( _material_library_pattern.test( line ) ) {

				// mtl file

				state.materialLibraries.push( line.substring( 7 ).trim() );

			} else if ( _map_use_pattern.test( line ) ) {

				// the line is parsed but ignored since the loader assumes textures are defined MTL files
				// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)

				console.warn( 'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.' );

			} else if ( lineFirstChar === 's' ) {

				result = line.split( ' ' );

				// smooth shading

				// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
				// but does not define a usemtl for each face set.
				// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
				// This requires some care to not create extra material on each smooth value for "normal" obj files.
				// where explicit usemtl defines geometry groups.
				// Example asset: examples/models/obj/cerberus/Cerberus.obj

				/*
					 * http://paulbourke.net/dataformats/obj/
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */
				if ( result.length > 1 ) {

					const value = result[ 1 ].trim().toLowerCase();
					state.object.smooth = ( value !== '0' && value !== 'off' );

				} else {

					// ZBrush can produce "s" lines #11707
					state.object.smooth = true;

				}

				const material = state.object.currentMaterial();
				if ( material ) material.smooth = state.object.smooth;

			} else {

				// Handle null terminated files without exception
				if ( line === '\0' ) continue;

				console.warn( 'THREE.OBJLoader: Unexpected line: "' + line + '"' );

			}

		}

		state.finalize();

		const container = new Group$1();
		container.materialLibraries = [].concat( state.materialLibraries );

		const hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );

		if ( hasPrimitives === true ) {

			for ( let i = 0, l = state.objects.length; i < l; i ++ ) {

				const object = state.objects[ i ];
				const geometry = object.geometry;
				const materials = object.materials;
				const isLine = ( geometry.type === 'Line' );
				const isPoints = ( geometry.type === 'Points' );
				let hasVertexColors = false;

				// Skip o/g line declarations that did not follow with any faces
				if ( geometry.vertices.length === 0 ) continue;

				const buffergeometry = new BufferGeometry();

				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) );

				if ( geometry.normals.length > 0 ) {

					buffergeometry.setAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) );

				}

				if ( geometry.colors.length > 0 ) {

					hasVertexColors = true;
					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) );

				}

				if ( geometry.hasUVIndices === true ) {

					buffergeometry.setAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) );

				}

				// Create materials

				const createdMaterials = [];

				for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

					const sourceMaterial = materials[ mi ];
					const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
					let material = state.materials[ materialHash ];

					if ( this.materials !== null ) {

						material = this.materials.create( sourceMaterial.name );

						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) {

							const materialLine = new LineBasicMaterial();
							Material.prototype.copy.call( materialLine, material );
							materialLine.color.copy( material.color );
							material = materialLine;

						} else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) {

							const materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } );
							Material.prototype.copy.call( materialPoints, material );
							materialPoints.color.copy( material.color );
							materialPoints.map = material.map;
							material = materialPoints;

						}

					}

					if ( material === undefined ) {

						if ( isLine ) {

							material = new LineBasicMaterial();

						} else if ( isPoints ) {

							material = new PointsMaterial( { size: 1, sizeAttenuation: false } );

						} else {

							material = new MeshPhongMaterial();

						}

						material.name = sourceMaterial.name;
						material.flatShading = sourceMaterial.smooth ? false : true;
						material.vertexColors = hasVertexColors;

						state.materials[ materialHash ] = material;

					}

					createdMaterials.push( material );

				}

				// Create mesh

				let mesh;

				if ( createdMaterials.length > 1 ) {

					for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

						const sourceMaterial = materials[ mi ];
						buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

					}

					if ( isLine ) {

						mesh = new LineSegments( buffergeometry, createdMaterials );

					} else if ( isPoints ) {

						mesh = new Points( buffergeometry, createdMaterials );

					} else {

						mesh = new Mesh( buffergeometry, createdMaterials );

					}

				} else {

					if ( isLine ) {

						mesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] );

					} else if ( isPoints ) {

						mesh = new Points( buffergeometry, createdMaterials[ 0 ] );

					} else {

						mesh = new Mesh( buffergeometry, createdMaterials[ 0 ] );

					}

				}

				mesh.name = object.name;

				container.add( mesh );

			}

		} else {

			// if there is only the default parser state object with no geometry data, interpret data as point cloud

			if ( state.vertices.length > 0 ) {

				const material = new PointsMaterial( { size: 1, sizeAttenuation: false } );

				const buffergeometry = new BufferGeometry();

				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( state.vertices, 3 ) );

				if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {

					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( state.colors, 3 ) );
					material.vertexColors = true;

				}

				const points = new Points( buffergeometry, material );
				container.add( points );

			}

		}

		return container;

	}

}

/**
 * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.
 *
 * Supports both binary and ASCII encoded files, with automatic detection of type.
 *
 * The loader returns a non-indexed buffer geometry.
 *
 * Limitations:
 *  Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
 *  There is perhaps some question as to how valid it is to always assume little-endian-ness.
 *  ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *  const loader = new STLLoader();
 *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {
 *    scene.add( new THREE.Mesh( geometry ) );
 *  });
 *
 * For binary STLs geometry might contain colors for vertices. To use it:
 *  // use the same code to load STL as above
 *  if (geometry.hasColors) {
 *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });
 *  } else { .... }
 *  const mesh = new THREE.Mesh( geometry, material );
 *
 * For ASCII STLs containing multiple solids, each solid is assigned to a different group.
 * Groups can be used to assign a different color by defining an array of materials with the same length of
 * geometry.groups and passing it to the Mesh constructor:
 *
 * const mesh = new THREE.Mesh( geometry, material );
 *
 * For example:
 *
 *  const materials = [];
 *  const nGeometryGroups = geometry.groups.length;
 *
 *  const colorMap = ...; // Some logic to index colors.
 *
 *  for (let i = 0; i < nGeometryGroups; i++) {
 *
 *		const material = new THREE.MeshPhongMaterial({
 *			color: colorMap[i],
 *			wireframe: false
 *		});
 *
 *  }
 *
 *  materials.push(material);
 *  const mesh = new THREE.Mesh(geometry, materials);
 */


class STLLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( data ) {

		function isBinary( data ) {

			const reader = new DataView( data );
			const face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );
			const n_faces = reader.getUint32( 80, true );
			const expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );

			if ( expect === reader.byteLength ) {

				return true;

			}

			// An ASCII STL data must begin with 'solid ' as the first six bytes.
			// However, ASCII STLs lacking the SPACE after the 'd' are known to be
			// plentiful.  So, check the first 5 bytes for 'solid'.

			// Several encodings, such as UTF-8, precede the text with up to 5 bytes:
			// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding
			// Search for "solid" to start anywhere after those prefixes.

			// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'

			const solid = [ 115, 111, 108, 105, 100 ];

			for ( let off = 0; off < 5; off ++ ) {

				// If "solid" text is matched to the current offset, declare it to be an ASCII STL.

				if ( matchDataViewAt( solid, reader, off ) ) return false;

			}

			// Couldn't find "solid" text at the beginning; it is binary STL.

			return true;

		}

		function matchDataViewAt( query, reader, offset ) {

			// Check if each byte in query matches the corresponding byte from the current offset

			for ( let i = 0, il = query.length; i < il; i ++ ) {

				if ( query[ i ] !== reader.getUint8( offset + i ) ) return false;

			}

			return true;

		}

		function parseBinary( data ) {

			const reader = new DataView( data );
			const faces = reader.getUint32( 80, true );

			let r, g, b, hasColors = false, colors;
			let defaultR, defaultG, defaultB, alpha;

			// process STL header
			// check for default color in header ("COLOR=rgba" sequence).

			for ( let index = 0; index < 80 - 10; index ++ ) {

				if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&
					( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&
					( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {

					hasColors = true;
					colors = new Float32Array( faces * 3 * 3 );

					defaultR = reader.getUint8( index + 6 ) / 255;
					defaultG = reader.getUint8( index + 7 ) / 255;
					defaultB = reader.getUint8( index + 8 ) / 255;
					alpha = reader.getUint8( index + 9 ) / 255;

				}

			}

			const dataOffset = 84;
			const faceLength = 12 * 4 + 2;

			const geometry = new BufferGeometry();

			const vertices = new Float32Array( faces * 3 * 3 );
			const normals = new Float32Array( faces * 3 * 3 );

			const color = new Color();

			for ( let face = 0; face < faces; face ++ ) {

				const start = dataOffset + face * faceLength;
				const normalX = reader.getFloat32( start, true );
				const normalY = reader.getFloat32( start + 4, true );
				const normalZ = reader.getFloat32( start + 8, true );

				if ( hasColors ) {

					const packedColor = reader.getUint16( start + 48, true );

					if ( ( packedColor & 0x8000 ) === 0 ) {

						// facet has its own unique color

						r = ( packedColor & 0x1F ) / 31;
						g = ( ( packedColor >> 5 ) & 0x1F ) / 31;
						b = ( ( packedColor >> 10 ) & 0x1F ) / 31;

					} else {

						r = defaultR;
						g = defaultG;
						b = defaultB;

					}

				}

				for ( let i = 1; i <= 3; i ++ ) {

					const vertexstart = start + i * 12;
					const componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );

					vertices[ componentIdx ] = reader.getFloat32( vertexstart, true );
					vertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );
					vertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );

					normals[ componentIdx ] = normalX;
					normals[ componentIdx + 1 ] = normalY;
					normals[ componentIdx + 2 ] = normalZ;

					if ( hasColors ) {

						color.setRGB( r, g, b, SRGBColorSpace );

						colors[ componentIdx ] = color.r;
						colors[ componentIdx + 1 ] = color.g;
						colors[ componentIdx + 2 ] = color.b;

					}

				}

			}

			geometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );

			if ( hasColors ) {

				geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );
				geometry.hasColors = true;
				geometry.alpha = alpha;

			}

			return geometry;

		}

		function parseASCII( data ) {

			const geometry = new BufferGeometry();
			const patternSolid = /solid([\s\S]*?)endsolid/g;
			const patternFace = /facet([\s\S]*?)endfacet/g;
			const patternName = /solid\s(.+)/;
			let faceCounter = 0;

			const patternFloat = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source;
			const patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );
			const patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );

			const vertices = [];
			const normals = [];
			const groupNames = [];

			const normal = new Vector3();

			let result;

			let groupCount = 0;
			let startVertex = 0;
			let endVertex = 0;

			while ( ( result = patternSolid.exec( data ) ) !== null ) {

				startVertex = endVertex;

				const solid = result[ 0 ];

				const name = ( result = patternName.exec( solid ) ) !== null ? result[ 1 ] : '';
				groupNames.push( name );

				while ( ( result = patternFace.exec( solid ) ) !== null ) {

					let vertexCountPerFace = 0;
					let normalCountPerFace = 0;

					const text = result[ 0 ];

					while ( ( result = patternNormal.exec( text ) ) !== null ) {

						normal.x = parseFloat( result[ 1 ] );
						normal.y = parseFloat( result[ 2 ] );
						normal.z = parseFloat( result[ 3 ] );
						normalCountPerFace ++;

					}

					while ( ( result = patternVertex.exec( text ) ) !== null ) {

						vertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );
						normals.push( normal.x, normal.y, normal.z );
						vertexCountPerFace ++;
						endVertex ++;

					}

					// every face have to own ONE valid normal

					if ( normalCountPerFace !== 1 ) {

						console.error( 'THREE.STLLoader: Something isn\'t right with the normal of face number ' + faceCounter );

					}

					// each face have to own THREE valid vertices

					if ( vertexCountPerFace !== 3 ) {

						console.error( 'THREE.STLLoader: Something isn\'t right with the vertices of face number ' + faceCounter );

					}

					faceCounter ++;

				}

				const start = startVertex;
				const count = endVertex - startVertex;

				geometry.userData.groupNames = groupNames;

				geometry.addGroup( start, count, groupCount );
				groupCount ++;

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

			return geometry;

		}

		function ensureString( buffer ) {

			if ( typeof buffer !== 'string' ) {

				return new TextDecoder().decode( buffer );

			}

			return buffer;

		}

		function ensureBinary( buffer ) {

			if ( typeof buffer === 'string' ) {

				const array_buffer = new Uint8Array( buffer.length );
				for ( let i = 0; i < buffer.length; i ++ ) {

					array_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian

				}

				return array_buffer.buffer || array_buffer;

			} else {

				return buffer;

			}

		}

		// start

		const binData = ensureBinary( data );

		return isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );

	}

}

// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

class RGBELoader extends DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = HalfFloatType;

	}

	// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

	parse( buffer ) {

		const
			/* default error routine.  change this to change error handling */
			rgbe_read_error = 1,
			rgbe_write_error = 2,
			rgbe_format_error = 3,
			rgbe_memory_error = 4,
			rgbe_error = function ( rgbe_error_code, msg ) {

				switch ( rgbe_error_code ) {

					case rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );
					case rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );
					case rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );
					default:
					case rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );

				}

			},

			/* offsets to red, green, and blue components in a data (float) pixel */
			//RGBE_DATA_RED = 0,
			//RGBE_DATA_GREEN = 1,
			//RGBE_DATA_BLUE = 2,

			/* number of floats per pixel, use 4 since stored in rgba image format */
			//RGBE_DATA_SIZE = 4,

			/* flags indicating which fields in an rgbe_header_info are valid */
			RGBE_VALID_PROGRAMTYPE = 1,
			RGBE_VALID_FORMAT = 2,
			RGBE_VALID_DIMENSIONS = 4,

			NEWLINE = '\n',

			fgets = function ( buffer, lineLimit, consume ) {

				const chunkSize = 128;

				lineLimit = ! lineLimit ? 1024 : lineLimit;
				let p = buffer.pos,
					i = -1, len = 0, s = '',
					chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

					s += chunk; len += chunk.length;
					p += chunkSize;
					chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				}

				if ( -1 < i ) {

					/*for (i=l-1; i>=0; i--) {
						byteCode = m.charCodeAt(i);
						if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
						else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
						if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
					}*/
					buffer.pos += len + i + 1;
					return s + chunk.slice( 0, i );

				}

				return false;

			},

			/* minimal header reading.  modify if you want to parse more information */
			RGBE_ReadHeader = function ( buffer ) {


				// regexes to parse header info fields
				const magic_token_re = /^#\?(\S+)/,
					gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

					// RGBE format header struct
					header = {

						valid: 0, /* indicate which fields are valid */

						string: '', /* the actual header string */

						comments: '', /* comments found in header */

						programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

						format: '', /* RGBE format, default 32-bit_rle_rgbe */

						gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

						exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

						width: 0, height: 0 /* image dimensions, width/height */

					};

				let line, match;

				if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

					rgbe_error( rgbe_read_error, 'no header found' );

				}

				/* if you want to require the magic token then uncomment the next line */
				if ( ! ( match = line.match( magic_token_re ) ) ) {

					rgbe_error( rgbe_format_error, 'bad initial token' );

				}

				header.valid |= RGBE_VALID_PROGRAMTYPE;
				header.programtype = match[ 1 ];
				header.string += line + '\n';

				while ( true ) {

					line = fgets( buffer );
					if ( false === line ) break;
					header.string += line + '\n';

					if ( '#' === line.charAt( 0 ) ) {

						header.comments += line + '\n';
						continue; // comment line

					}

					if ( match = line.match( gamma_re ) ) {

						header.gamma = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( exposure_re ) ) {

						header.exposure = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( format_re ) ) {

						header.valid |= RGBE_VALID_FORMAT;
						header.format = match[ 1 ];//'32-bit_rle_rgbe';

					}

					if ( match = line.match( dimensions_re ) ) {

						header.valid |= RGBE_VALID_DIMENSIONS;
						header.height = parseInt( match[ 1 ], 10 );
						header.width = parseInt( match[ 2 ], 10 );

					}

					if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;

				}

				if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

					rgbe_error( rgbe_format_error, 'missing format specifier' );

				}

				if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

					rgbe_error( rgbe_format_error, 'missing image size specifier' );

				}

				return header;

			},

			RGBE_ReadPixels_RLE = function ( buffer, w, h ) {

				const scanline_width = w;

				if (
					// run length encoding is not allowed so read flat
					( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
					// this file is not run length encoded
					( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
				) {

					// return the flat buffer
					return new Uint8Array( buffer );

				}

				if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

					rgbe_error( rgbe_format_error, 'wrong scanline width' );

				}

				const data_rgba = new Uint8Array( 4 * w * h );

				if ( ! data_rgba.length ) {

					rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );

				}

				let offset = 0, pos = 0;

				const ptr_end = 4 * scanline_width;
				const rgbeStart = new Uint8Array( 4 );
				const scanline_buffer = new Uint8Array( ptr_end );
				let num_scanlines = h;

				// read in each successive scanline
				while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

					if ( pos + 4 > buffer.byteLength ) {

						rgbe_error( rgbe_read_error );

					}

					rgbeStart[ 0 ] = buffer[ pos ++ ];
					rgbeStart[ 1 ] = buffer[ pos ++ ];
					rgbeStart[ 2 ] = buffer[ pos ++ ];
					rgbeStart[ 3 ] = buffer[ pos ++ ];

					if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

						rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );

					}

					// read each of the four channels for the scanline into the buffer
					// first red, then green, then blue, then exponent
					let ptr = 0, count;

					while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

						count = buffer[ pos ++ ];
						const isEncodedRun = count > 128;
						if ( isEncodedRun ) count -= 128;

						if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

							rgbe_error( rgbe_format_error, 'bad scanline data' );

						}

						if ( isEncodedRun ) {

							// a (encoded) run of the same value
							const byteValue = buffer[ pos ++ ];
							for ( let i = 0; i < count; i ++ ) {

								scanline_buffer[ ptr ++ ] = byteValue;

							}
							//ptr += count;

						} else {

							// a literal-run
							scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
							ptr += count; pos += count;

						}

					}


					// now convert data from buffer into rgba
					// first red, then green, then blue, then exponent (alpha)
					const l = scanline_width; //scanline_buffer.byteLength;
					for ( let i = 0; i < l; i ++ ) {

						let off = 0;
						data_rgba[ offset ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
						offset += 4;

					}

					num_scanlines --;

				}

				return data_rgba;

			};

		const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
			destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
			destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;
			destArray[ destOffset + 3 ] = 1;

		};

		const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			// clamping to 65504, the maximum representable value in float16
			destArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );
			destArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );
			destArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );
			destArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );

		};

		const byteArray = new Uint8Array( buffer );
		byteArray.pos = 0;
		const rgbe_header_info = RGBE_ReadHeader( byteArray );

		const w = rgbe_header_info.width,
			h = rgbe_header_info.height,
			image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );


		let data, type;
		let numElements;

		switch ( this.type ) {

			case FloatType:

				numElements = image_rgba_data.length / 4;
				const floatArray = new Float32Array( numElements * 4 );

				for ( let j = 0; j < numElements; j ++ ) {

					RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );

				}

				data = floatArray;
				type = FloatType;
				break;

			case HalfFloatType:

				numElements = image_rgba_data.length / 4;
				const halfArray = new Uint16Array( numElements * 4 );

				for ( let j = 0; j < numElements; j ++ ) {

					RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );

				}

				data = halfArray;
				type = HalfFloatType;
				break;

			default:

				throw new Error( 'THREE.RGBELoader: unsupported type: ', this.type );

		}

		return {
			width: w, height: h,
			data: data,
			header: rgbe_header_info.string,
			gamma: rgbe_header_info.gamma,
			exposure: rgbe_header_info.exposure,
			type: type
		};

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			switch ( texture.type ) {

				case FloatType:
				case HalfFloatType:

					texture.colorSpace = LinearSRGBColorSpace;
					texture.minFilter = LinearFilter;
					texture.magFilter = LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;

					//texture.gamma = texData.gamma;
					//texture.exposure = texData.exposure;
					//texture.userData = texData;


					break;

			}

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}

/**
 * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.
 * Supports reading as UnsignedByte, HalfFloat and Float type data texture.
 *
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation, so I have preserved their copyright notices.
 */

// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */

// // TinyEXR contains some OpenEXR code, which is licensed under ------------

// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////

// // End of OpenEXR license -------------------------------------------------

class EXRLoader extends DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = HalfFloatType;

	}

	parse( buffer ) {

		const USHORT_RANGE = ( 1 << 16 );
		const BITMAP_SIZE = ( USHORT_RANGE >> 3 );

		const HUF_ENCBITS = 16; // literal (value) bit length
		const HUF_DECBITS = 14; // decoding bit size (>= 8)

		const HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size
		const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size
		const HUF_DECMASK = HUF_DECSIZE - 1;

		const NBITS = 16;
		const A_OFFSET = 1 << ( NBITS - 1 );
		const MOD_MASK = ( 1 << NBITS ) - 1;

		const SHORT_ZEROCODE_RUN = 59;
		const LONG_ZEROCODE_RUN = 63;
		const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;

		const ULONG_SIZE = 8;
		const FLOAT32_SIZE = 4;
		const INT32_SIZE = 4;
		const INT16_SIZE = 2;
		const INT8_SIZE = 1;

		const STATIC_HUFFMAN = 0;
		const DEFLATE = 1;

		const UNKNOWN = 0;
		const LOSSY_DCT = 1;
		const RLE = 2;

		const logBase = Math.pow( 2.7182818, 2.2 );

		function reverseLutFromBitmap( bitmap, lut ) {

			let k = 0;

			for ( let i = 0; i < USHORT_RANGE; ++ i ) {

				if ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {

					lut[ k ++ ] = i;

				}

			}

			const n = k - 1;

			while ( k < USHORT_RANGE ) lut[ k ++ ] = 0;

			return n;

		}

		function hufClearDecTable( hdec ) {

			for ( let i = 0; i < HUF_DECSIZE; i ++ ) {

				hdec[ i ] = {};
				hdec[ i ].len = 0;
				hdec[ i ].lit = 0;
				hdec[ i ].p = null;

			}

		}

		const getBitsReturn = { l: 0, c: 0, lc: 0 };

		function getBits( nBits, c, lc, uInt8Array, inOffset ) {

			while ( lc < nBits ) {

				c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
				lc += 8;

			}

			lc -= nBits;

			getBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );
			getBitsReturn.c = c;
			getBitsReturn.lc = lc;

		}

		const hufTableBuffer = new Array( 59 );

		function hufCanonicalCodeTable( hcode ) {

			for ( let i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;
			for ( let i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;

			let c = 0;

			for ( let i = 58; i > 0; -- i ) {

				const nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );
				hufTableBuffer[ i ] = c;
				c = nc;

			}

			for ( let i = 0; i < HUF_ENCSIZE; ++ i ) {

				const l = hcode[ i ];
				if ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );

			}

		}

		function hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {

			const p = inOffset;
			let c = 0;
			let lc = 0;

			for ( ; im <= iM; im ++ ) {

				if ( p.value - inOffset.value > ni ) return false;

				getBits( 6, c, lc, uInt8Array, p );

				const l = getBitsReturn.l;
				c = getBitsReturn.c;
				lc = getBitsReturn.lc;

				hcode[ im ] = l;

				if ( l == LONG_ZEROCODE_RUN ) {

					if ( p.value - inOffset.value > ni ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					getBits( 8, c, lc, uInt8Array, p );

					let zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
					c = getBitsReturn.c;
					lc = getBitsReturn.lc;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				} else if ( l >= SHORT_ZEROCODE_RUN ) {

					let zerun = l - SHORT_ZEROCODE_RUN + 2;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				}

			}

			hufCanonicalCodeTable( hcode );

		}

		function hufLength( code ) {

			return code & 63;

		}

		function hufCode( code ) {

			return code >> 6;

		}

		function hufBuildDecTable( hcode, im, iM, hdecod ) {

			for ( ; im <= iM; im ++ ) {

				const c = hufCode( hcode[ im ] );
				const l = hufLength( hcode[ im ] );

				if ( c >> l ) {

					throw new Error( 'Invalid table entry' );

				}

				if ( l > HUF_DECBITS ) {

					const pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];

					if ( pl.len ) {

						throw new Error( 'Invalid table entry' );

					}

					pl.lit ++;

					if ( pl.p ) {

						const p = pl.p;
						pl.p = new Array( pl.lit );

						for ( let i = 0; i < pl.lit - 1; ++ i ) {

							pl.p[ i ] = p[ i ];

						}

					} else {

						pl.p = new Array( 1 );

					}

					pl.p[ pl.lit - 1 ] = im;

				} else if ( l ) {

					let plOffset = 0;

					for ( let i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {

						const pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];

						if ( pl.len || pl.p ) {

							throw new Error( 'Invalid table entry' );

						}

						pl.len = l;
						pl.lit = im;

						plOffset ++;

					}

				}

			}

			return true;

		}

		const getCharReturn = { c: 0, lc: 0 };

		function getChar( c, lc, uInt8Array, inOffset ) {

			c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
			lc += 8;

			getCharReturn.c = c;
			getCharReturn.lc = lc;

		}

		const getCodeReturn = { c: 0, lc: 0 };

		function getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {

			if ( po == rlc ) {

				if ( lc < 8 ) {

					getChar( c, lc, uInt8Array, inOffset );
					c = getCharReturn.c;
					lc = getCharReturn.lc;

				}

				lc -= 8;

				let cs = ( c >> lc );
				cs = new Uint8Array( [ cs ] )[ 0 ];

				if ( outBufferOffset.value + cs > outBufferEndOffset ) {

					return false;

				}

				const s = outBuffer[ outBufferOffset.value - 1 ];

				while ( cs -- > 0 ) {

					outBuffer[ outBufferOffset.value ++ ] = s;

				}

			} else if ( outBufferOffset.value < outBufferEndOffset ) {

				outBuffer[ outBufferOffset.value ++ ] = po;

			} else {

				return false;

			}

			getCodeReturn.c = c;
			getCodeReturn.lc = lc;

		}

		function UInt16( value ) {

			return ( value & 0xFFFF );

		}

		function Int16( value ) {

			const ref = UInt16( value );
			return ( ref > 0x7FFF ) ? ref - 0x10000 : ref;

		}

		const wdec14Return = { a: 0, b: 0 };

		function wdec14( l, h ) {

			const ls = Int16( l );
			const hs = Int16( h );

			const hi = hs;
			const ai = ls + ( hi & 1 ) + ( hi >> 1 );

			const as = ai;
			const bs = ai - hi;

			wdec14Return.a = as;
			wdec14Return.b = bs;

		}

		function wdec16( l, h ) {

			const m = UInt16( l );
			const d = UInt16( h );

			const bb = ( m - ( d >> 1 ) ) & MOD_MASK;
			const aa = ( d + bb - A_OFFSET ) & MOD_MASK;

			wdec14Return.a = aa;
			wdec14Return.b = bb;

		}

		function wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {

			const w14 = mx < ( 1 << 14 );
			const n = ( nx > ny ) ? ny : nx;
			let p = 1;
			let p2;
			let py;

			while ( p <= n ) p <<= 1;

			p >>= 1;
			p2 = p;
			p >>= 1;

			while ( p >= 1 ) {

				py = 0;
				const ey = py + oy * ( ny - p2 );
				const oy1 = oy * p;
				const oy2 = oy * p2;
				const ox1 = ox * p;
				const ox2 = ox * p2;
				let i00, i01, i10, i11;

				for ( ; py <= ey; py += oy2 ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px <= ex; px += ox2 ) {

						const p01 = px + ox1;
						const p10 = px + oy1;
						const p11 = p10 + ox1;

						if ( w14 ) {

							wdec14( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec14( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec14( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec14( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;

						} else {

							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec16( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec16( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec16( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;


						}

					}

					if ( nx & p ) {

						const p10 = px + oy1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p10 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

						i00 = wdec14Return.a;
						buffer[ p10 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				if ( ny & p ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px <= ex; px += ox2 ) {

						const p01 = px + ox1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p01 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p01 + j ] );

						i00 = wdec14Return.a;
						buffer[ p01 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				p2 = p;
				p >>= 1;

			}

			return py;

		}

		function hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {

			let c = 0;
			let lc = 0;
			const outBufferEndOffset = no;
			const inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );

			while ( inOffset.value < inOffsetEnd ) {

				getChar( c, lc, uInt8Array, inOffset );

				c = getCharReturn.c;
				lc = getCharReturn.lc;

				while ( lc >= HUF_DECBITS ) {

					const index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;
					const pl = decodingTable[ index ];

					if ( pl.len ) {

						lc -= pl.len;

						getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

						c = getCodeReturn.c;
						lc = getCodeReturn.lc;

					} else {

						if ( ! pl.p ) {

							throw new Error( 'hufDecode issues' );

						}

						let j;

						for ( j = 0; j < pl.lit; j ++ ) {

							const l = hufLength( encodingTable[ pl.p[ j ] ] );

							while ( lc < l && inOffset.value < inOffsetEnd ) {

								getChar( c, lc, uInt8Array, inOffset );

								c = getCharReturn.c;
								lc = getCharReturn.lc;

							}

							if ( lc >= l ) {

								if ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {

									lc -= l;

									getCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

									c = getCodeReturn.c;
									lc = getCodeReturn.lc;

									break;

								}

							}

						}

						if ( j == pl.lit ) {

							throw new Error( 'hufDecode issues' );

						}

					}

				}

			}

			const i = ( 8 - ni ) & 7;

			c >>= i;
			lc -= i;

			while ( lc > 0 ) {

				const pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];

				if ( pl.len ) {

					lc -= pl.len;

					getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

					c = getCodeReturn.c;
					lc = getCodeReturn.lc;

				} else {

					throw new Error( 'hufDecode issues' );

				}

			}

			return true;

		}

		function hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {

			const outOffset = { value: 0 };
			const initialInOffset = inOffset.value;

			const im = parseUint32( inDataView, inOffset );
			const iM = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			const nBits = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			if ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {

				throw new Error( 'Something wrong with HUF_ENCSIZE' );

			}

			const freq = new Array( HUF_ENCSIZE );
			const hdec = new Array( HUF_DECSIZE );

			hufClearDecTable( hdec );

			const ni = nCompressed - ( inOffset.value - initialInOffset );

			hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );

			if ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {

				throw new Error( 'Something wrong with hufUncompress' );

			}

			hufBuildDecTable( freq, im, iM, hdec );

			hufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );

		}

		function applyLut( lut, data, nData ) {

			for ( let i = 0; i < nData; ++ i ) {

				data[ i ] = lut[ data[ i ] ];

			}

		}

		function predictor( source ) {

			for ( let t = 1; t < source.length; t ++ ) {

				const d = source[ t - 1 ] + source[ t ] - 128;
				source[ t ] = d;

			}

		}

		function interleaveScalar( source, out ) {

			let t1 = 0;
			let t2 = Math.floor( ( source.length + 1 ) / 2 );
			let s = 0;
			const stop = source.length - 1;

			while ( true ) {

				if ( s > stop ) break;
				out[ s ++ ] = source[ t1 ++ ];

				if ( s > stop ) break;
				out[ s ++ ] = source[ t2 ++ ];

			}

		}

		function decodeRunLength( source ) {

			let size = source.byteLength;
			const out = new Array();
			let p = 0;

			const reader = new DataView( source );

			while ( size > 0 ) {

				const l = reader.getInt8( p ++ );

				if ( l < 0 ) {

					const count = - l;
					size -= count + 1;

					for ( let i = 0; i < count; i ++ ) {

						out.push( reader.getUint8( p ++ ) );

					}


				} else {

					const count = l;
					size -= 2;

					const value = reader.getUint8( p ++ );

					for ( let i = 0; i < count + 1; i ++ ) {

						out.push( value );

					}

				}

			}

			return out;

		}

		function lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {

			let dataView = new DataView( outBuffer.buffer );

			const width = channelData[ cscSet.idx[ 0 ] ].width;
			const height = channelData[ cscSet.idx[ 0 ] ].height;

			const numComp = 3;

			const numFullBlocksX = Math.floor( width / 8.0 );
			const numBlocksX = Math.ceil( width / 8.0 );
			const numBlocksY = Math.ceil( height / 8.0 );
			const leftoverX = width - ( numBlocksX - 1 ) * 8;
			const leftoverY = height - ( numBlocksY - 1 ) * 8;

			const currAcComp = { value: 0 };
			const currDcComp = new Array( numComp );
			const dctData = new Array( numComp );
			const halfZigBlock = new Array( numComp );
			const rowBlock = new Array( numComp );
			const rowOffsets = new Array( numComp );

			for ( let comp = 0; comp < numComp; ++ comp ) {

				rowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];
				currDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;
				dctData[ comp ] = new Float32Array( 64 );
				halfZigBlock[ comp ] = new Uint16Array( 64 );
				rowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );

			}

			for ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {

				let maxY = 8;

				if ( blocky == numBlocksY - 1 )
					maxY = leftoverY;

				let maxX = 8;

				for ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {

					if ( blockx == numBlocksX - 1 )
						maxX = leftoverX;

					for ( let comp = 0; comp < numComp; ++ comp ) {

						halfZigBlock[ comp ].fill( 0 );

						// set block DC component
						halfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];
						// set block AC components
						unRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );

						// UnZigZag block to float
						unZigZag( halfZigBlock[ comp ], dctData[ comp ] );
						// decode float dct
						dctInverse( dctData[ comp ] );

					}

					{

						csc709Inverse( dctData );

					}

					for ( let comp = 0; comp < numComp; ++ comp ) {

						convertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );

					}

				} // blockx

				let offset = 0;

				for ( let comp = 0; comp < numComp; ++ comp ) {

					const type = channelData[ cscSet.idx[ comp ] ].type;

					for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {

						offset = rowOffsets[ comp ][ y ];

						for ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {

							const src = blockx * 64 + ( ( y & 0x7 ) * 8 );

							dataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );
							dataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );
							dataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );
							dataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );

							dataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );
							dataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );
							dataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );
							dataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );

							offset += 8 * INT16_SIZE * type;

						}

					}

					// handle partial X blocks
					if ( numFullBlocksX != numBlocksX ) {

						for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {

							const offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;
							const src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );

							for ( let x = 0; x < maxX; ++ x ) {

								dataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );

							}

						}

					}

				} // comp

			} // blocky

			const halfRow = new Uint16Array( width );
			dataView = new DataView( outBuffer.buffer );

			// convert channels back to float, if needed
			for ( let comp = 0; comp < numComp; ++ comp ) {

				channelData[ cscSet.idx[ comp ] ].decoded = true;
				const type = channelData[ cscSet.idx[ comp ] ].type;

				if ( channelData[ comp ].type != 2 ) continue;

				for ( let y = 0; y < height; ++ y ) {

					const offset = rowOffsets[ comp ][ y ];

					for ( let x = 0; x < width; ++ x ) {

						halfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );

					}

					for ( let x = 0; x < width; ++ x ) {

						dataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );

					}

				}

			}

		}

		function unRleAC( currAcComp, acBuffer, halfZigBlock ) {

			let acValue;
			let dctComp = 1;

			while ( dctComp < 64 ) {

				acValue = acBuffer[ currAcComp.value ];

				if ( acValue == 0xff00 ) {

					dctComp = 64;

				} else if ( acValue >> 8 == 0xff ) {

					dctComp += acValue & 0xff;

				} else {

					halfZigBlock[ dctComp ] = acValue;
					dctComp ++;

				}

				currAcComp.value ++;

			}

		}

		function unZigZag( src, dst ) {

			dst[ 0 ] = decodeFloat16( src[ 0 ] );
			dst[ 1 ] = decodeFloat16( src[ 1 ] );
			dst[ 2 ] = decodeFloat16( src[ 5 ] );
			dst[ 3 ] = decodeFloat16( src[ 6 ] );
			dst[ 4 ] = decodeFloat16( src[ 14 ] );
			dst[ 5 ] = decodeFloat16( src[ 15 ] );
			dst[ 6 ] = decodeFloat16( src[ 27 ] );
			dst[ 7 ] = decodeFloat16( src[ 28 ] );
			dst[ 8 ] = decodeFloat16( src[ 2 ] );
			dst[ 9 ] = decodeFloat16( src[ 4 ] );

			dst[ 10 ] = decodeFloat16( src[ 7 ] );
			dst[ 11 ] = decodeFloat16( src[ 13 ] );
			dst[ 12 ] = decodeFloat16( src[ 16 ] );
			dst[ 13 ] = decodeFloat16( src[ 26 ] );
			dst[ 14 ] = decodeFloat16( src[ 29 ] );
			dst[ 15 ] = decodeFloat16( src[ 42 ] );
			dst[ 16 ] = decodeFloat16( src[ 3 ] );
			dst[ 17 ] = decodeFloat16( src[ 8 ] );
			dst[ 18 ] = decodeFloat16( src[ 12 ] );
			dst[ 19 ] = decodeFloat16( src[ 17 ] );

			dst[ 20 ] = decodeFloat16( src[ 25 ] );
			dst[ 21 ] = decodeFloat16( src[ 30 ] );
			dst[ 22 ] = decodeFloat16( src[ 41 ] );
			dst[ 23 ] = decodeFloat16( src[ 43 ] );
			dst[ 24 ] = decodeFloat16( src[ 9 ] );
			dst[ 25 ] = decodeFloat16( src[ 11 ] );
			dst[ 26 ] = decodeFloat16( src[ 18 ] );
			dst[ 27 ] = decodeFloat16( src[ 24 ] );
			dst[ 28 ] = decodeFloat16( src[ 31 ] );
			dst[ 29 ] = decodeFloat16( src[ 40 ] );

			dst[ 30 ] = decodeFloat16( src[ 44 ] );
			dst[ 31 ] = decodeFloat16( src[ 53 ] );
			dst[ 32 ] = decodeFloat16( src[ 10 ] );
			dst[ 33 ] = decodeFloat16( src[ 19 ] );
			dst[ 34 ] = decodeFloat16( src[ 23 ] );
			dst[ 35 ] = decodeFloat16( src[ 32 ] );
			dst[ 36 ] = decodeFloat16( src[ 39 ] );
			dst[ 37 ] = decodeFloat16( src[ 45 ] );
			dst[ 38 ] = decodeFloat16( src[ 52 ] );
			dst[ 39 ] = decodeFloat16( src[ 54 ] );

			dst[ 40 ] = decodeFloat16( src[ 20 ] );
			dst[ 41 ] = decodeFloat16( src[ 22 ] );
			dst[ 42 ] = decodeFloat16( src[ 33 ] );
			dst[ 43 ] = decodeFloat16( src[ 38 ] );
			dst[ 44 ] = decodeFloat16( src[ 46 ] );
			dst[ 45 ] = decodeFloat16( src[ 51 ] );
			dst[ 46 ] = decodeFloat16( src[ 55 ] );
			dst[ 47 ] = decodeFloat16( src[ 60 ] );
			dst[ 48 ] = decodeFloat16( src[ 21 ] );
			dst[ 49 ] = decodeFloat16( src[ 34 ] );

			dst[ 50 ] = decodeFloat16( src[ 37 ] );
			dst[ 51 ] = decodeFloat16( src[ 47 ] );
			dst[ 52 ] = decodeFloat16( src[ 50 ] );
			dst[ 53 ] = decodeFloat16( src[ 56 ] );
			dst[ 54 ] = decodeFloat16( src[ 59 ] );
			dst[ 55 ] = decodeFloat16( src[ 61 ] );
			dst[ 56 ] = decodeFloat16( src[ 35 ] );
			dst[ 57 ] = decodeFloat16( src[ 36 ] );
			dst[ 58 ] = decodeFloat16( src[ 48 ] );
			dst[ 59 ] = decodeFloat16( src[ 49 ] );

			dst[ 60 ] = decodeFloat16( src[ 57 ] );
			dst[ 61 ] = decodeFloat16( src[ 58 ] );
			dst[ 62 ] = decodeFloat16( src[ 62 ] );
			dst[ 63 ] = decodeFloat16( src[ 63 ] );

		}

		function dctInverse( data ) {

			const a = 0.5 * Math.cos( 3.14159 / 4.0 );
			const b = 0.5 * Math.cos( 3.14159 / 16.0 );
			const c = 0.5 * Math.cos( 3.14159 / 8.0 );
			const d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );
			const e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );
			const f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );
			const g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );

			const alpha = new Array( 4 );
			const beta = new Array( 4 );
			const theta = new Array( 4 );
			const gamma = new Array( 4 );

			for ( let row = 0; row < 8; ++ row ) {

				const rowPtr = row * 8;

				alpha[ 0 ] = c * data[ rowPtr + 2 ];
				alpha[ 1 ] = f * data[ rowPtr + 2 ];
				alpha[ 2 ] = c * data[ rowPtr + 6 ];
				alpha[ 3 ] = f * data[ rowPtr + 6 ];

				beta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];
				beta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];
				beta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];
				beta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];

				theta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );
				theta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );
				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];
				data[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];
				data[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];
				data[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];

				data[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];
				data[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];
				data[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];
				data[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];

			}

			for ( let column = 0; column < 8; ++ column ) {

				alpha[ 0 ] = c * data[ 16 + column ];
				alpha[ 1 ] = f * data[ 16 + column ];
				alpha[ 2 ] = c * data[ 48 + column ];
				alpha[ 3 ] = f * data[ 48 + column ];

				beta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];
				beta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];
				beta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];
				beta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];

				theta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );
				theta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );

				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];
				data[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];
				data[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];
				data[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];

				data[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];
				data[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];
				data[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];
				data[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];

			}

		}

		function csc709Inverse( data ) {

			for ( let i = 0; i < 64; ++ i ) {

				const y = data[ 0 ][ i ];
				const cb = data[ 1 ][ i ];
				const cr = data[ 2 ][ i ];

				data[ 0 ][ i ] = y + 1.5747 * cr;
				data[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;
				data[ 2 ][ i ] = y + 1.8556 * cb;

			}

		}

		function convertToHalf( src, dst, idx ) {

			for ( let i = 0; i < 64; ++ i ) {

				dst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) );

			}

		}

		function toLinear( float ) {

			if ( float <= 1 ) {

				return Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );

			} else {

				return Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );

			}

		}

		function uncompressRAW( info ) {

			return new DataView( info.array.buffer, info.offset.value, info.size );

		}

		function uncompressRLE( info ) {

			const compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = new Uint8Array( decodeRunLength( compressed ) );
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressZIP( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = unzlibSync( compressed );
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPIZ( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };

			const outBuffer = new Uint16Array( info.columns * info.lines * ( info.inputChannels.length * info.type ) );
			const bitmap = new Uint8Array( BITMAP_SIZE );

			// Setup channel info
			let outBufferEnd = 0;
			const pizChannelData = new Array( info.inputChannels.length );
			for ( let i = 0, il = info.inputChannels.length; i < il; i ++ ) {

				pizChannelData[ i ] = {};
				pizChannelData[ i ][ 'start' ] = outBufferEnd;
				pizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];
				pizChannelData[ i ][ 'nx' ] = info.columns;
				pizChannelData[ i ][ 'ny' ] = info.lines;
				pizChannelData[ i ][ 'size' ] = info.type;

				outBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;

			}

			// Read range compression data

			const minNonZero = parseUint16( inDataView, inOffset );
			const maxNonZero = parseUint16( inDataView, inOffset );

			if ( maxNonZero >= BITMAP_SIZE ) {

				throw new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );

			}

			if ( minNonZero <= maxNonZero ) {

				for ( let i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {

					bitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );

				}

			}

			// Reverse LUT
			const lut = new Uint16Array( USHORT_RANGE );
			const maxValue = reverseLutFromBitmap( bitmap, lut );

			const length = parseUint32( inDataView, inOffset );

			// Huffman decoding
			hufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );

			// Wavelet decoding
			for ( let i = 0; i < info.inputChannels.length; ++ i ) {

				const cd = pizChannelData[ i ];

				for ( let j = 0; j < pizChannelData[ i ].size; ++ j ) {

					wav2Decode(
						outBuffer,
						cd.start + j,
						cd.nx,
						cd.size,
						cd.ny,
						cd.nx * cd.size,
						maxValue
					);

				}

			}

			// Expand the pixel data to their original range
			applyLut( lut, outBuffer, outBufferEnd );

			// Rearrange the pixel data into the format expected by the caller.
			let tmpOffset = 0;
			const tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );
			for ( let y = 0; y < info.lines; y ++ ) {

				for ( let c = 0; c < info.inputChannels.length; c ++ ) {

					const cd = pizChannelData[ c ];

					const n = cd.nx * cd.size;
					const cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );

					tmpBuffer.set( cp, tmpOffset );
					tmpOffset += n * INT16_SIZE;
					cd.end += n;

				}

			}

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPXR( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = unzlibSync( compressed );

			const byteSize = info.inputChannels.length * info.lines * info.columns * info.totalBytes;
			const tmpBuffer = new ArrayBuffer( byteSize );
			const viewer = new DataView( tmpBuffer );

			let tmpBufferEnd = 0;
			let writePtr = 0;
			const ptr = new Array( 4 );

			for ( let y = 0; y < info.lines; y ++ ) {

				for ( let c = 0; c < info.inputChannels.length; c ++ ) {

					let pixel = 0;

					const type = info.inputChannels[ c ].pixelType;
					switch ( type ) {

						case 1:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.columns;
							tmpBufferEnd = ptr[ 1 ] + info.columns;

							for ( let j = 0; j < info.columns; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 8 ) | rawBuffer[ ptr[ 1 ] ++ ];

								pixel += diff;

								viewer.setUint16( writePtr, pixel, true );
								writePtr += 2;

							}

							break;

						case 2:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.columns;
							ptr[ 2 ] = ptr[ 1 ] + info.columns;
							tmpBufferEnd = ptr[ 2 ] + info.columns;

							for ( let j = 0; j < info.columns; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] << 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] << 8 );

								pixel += diff;

								viewer.setUint32( writePtr, pixel, true );
								writePtr += 4;

							}

							break;

					}

				}

			}

			return viewer;

		}

		function uncompressDWA( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };
			const outBuffer = new Uint8Array( info.columns * info.lines * ( info.inputChannels.length * info.type * INT16_SIZE ) );

			// Read compression header information
			const dwaHeader = {

				version: parseInt64( inDataView, inOffset ),
				unknownUncompressedSize: parseInt64( inDataView, inOffset ),
				unknownCompressedSize: parseInt64( inDataView, inOffset ),
				acCompressedSize: parseInt64( inDataView, inOffset ),
				dcCompressedSize: parseInt64( inDataView, inOffset ),
				rleCompressedSize: parseInt64( inDataView, inOffset ),
				rleUncompressedSize: parseInt64( inDataView, inOffset ),
				rleRawSize: parseInt64( inDataView, inOffset ),
				totalAcUncompressedCount: parseInt64( inDataView, inOffset ),
				totalDcUncompressedCount: parseInt64( inDataView, inOffset ),
				acCompression: parseInt64( inDataView, inOffset )

			};

			if ( dwaHeader.version < 2 )
				throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );

			// Read channel ruleset information
			const channelRules = new Array();
			let ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;

			while ( ruleSize > 0 ) {

				const name = parseNullTerminatedString( inDataView.buffer, inOffset );
				const value = parseUint8( inDataView, inOffset );
				const compression = ( value >> 2 ) & 3;
				const csc = ( value >> 4 ) - 1;
				const index = new Int8Array( [ csc ] )[ 0 ];
				const type = parseUint8( inDataView, inOffset );

				channelRules.push( {
					name: name,
					index: index,
					type: type,
					compression: compression,
				} );

				ruleSize -= name.length + 3;

			}

			// Classify channels
			const channels = EXRHeader.channels;
			const channelData = new Array( info.inputChannels.length );

			for ( let i = 0; i < info.inputChannels.length; ++ i ) {

				const cd = channelData[ i ] = {};
				const channel = channels[ i ];

				cd.name = channel.name;
				cd.compression = UNKNOWN;
				cd.decoded = false;
				cd.type = channel.pixelType;
				cd.pLinear = channel.pLinear;
				cd.width = info.columns;
				cd.height = info.lines;

			}

			const cscSet = {
				idx: new Array( 3 )
			};

			for ( let offset = 0; offset < info.inputChannels.length; ++ offset ) {

				const cd = channelData[ offset ];

				for ( let i = 0; i < channelRules.length; ++ i ) {

					const rule = channelRules[ i ];

					if ( cd.name == rule.name ) {

						cd.compression = rule.compression;

						if ( rule.index >= 0 ) {

							cscSet.idx[ rule.index ] = offset;

						}

						cd.offset = offset;

					}

				}

			}

			let acBuffer, dcBuffer, rleBuffer;

			// Read DCT - AC component data
			if ( dwaHeader.acCompressedSize > 0 ) {

				switch ( dwaHeader.acCompression ) {

					case STATIC_HUFFMAN:

						acBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );
						hufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );
						break;

					case DEFLATE:

						const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );
						const data = unzlibSync( compressed );
						acBuffer = new Uint16Array( data.buffer );
						inOffset.value += dwaHeader.totalAcUncompressedCount;
						break;

				}


			}

			// Read DCT - DC component data
			if ( dwaHeader.dcCompressedSize > 0 ) {

				const zlibInfo = {
					array: info.array,
					offset: inOffset,
					size: dwaHeader.dcCompressedSize
				};
				dcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );
				inOffset.value += dwaHeader.dcCompressedSize;

			}

			// Read RLE compressed data
			if ( dwaHeader.rleRawSize > 0 ) {

				const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );
				const data = unzlibSync( compressed );
				rleBuffer = decodeRunLength( data.buffer );

				inOffset.value += dwaHeader.rleCompressedSize;

			}

			// Prepare outbuffer data offset
			let outBufferEnd = 0;
			const rowOffsets = new Array( channelData.length );
			for ( let i = 0; i < rowOffsets.length; ++ i ) {

				rowOffsets[ i ] = new Array();

			}

			for ( let y = 0; y < info.lines; ++ y ) {

				for ( let chan = 0; chan < channelData.length; ++ chan ) {

					rowOffsets[ chan ].push( outBufferEnd );
					outBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;

				}

			}

			// Lossy DCT decode RGB channels
			lossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );

			// Decode other channels
			for ( let i = 0; i < channelData.length; ++ i ) {

				const cd = channelData[ i ];

				if ( cd.decoded ) continue;

				switch ( cd.compression ) {

					case RLE:

						let row = 0;
						let rleOffset = 0;

						for ( let y = 0; y < info.lines; ++ y ) {

							let rowOffsetBytes = rowOffsets[ i ][ row ];

							for ( let x = 0; x < cd.width; ++ x ) {

								for ( let byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {

									outBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];

								}

								rleOffset ++;

							}

							row ++;

						}

						break;

					case LOSSY_DCT: // skip

					default:
						throw new Error( 'EXRLoader.parse: unsupported channel compression' );

				}

			}

			return new DataView( outBuffer.buffer );

		}

		function parseNullTerminatedString( buffer, offset ) {

			const uintBuffer = new Uint8Array( buffer );
			let endOffset = 0;

			while ( uintBuffer[ offset.value + endOffset ] != 0 ) {

				endOffset += 1;

			}

			const stringValue = new TextDecoder().decode(
				uintBuffer.slice( offset.value, offset.value + endOffset )
			);

			offset.value = offset.value + endOffset + 1;

			return stringValue;

		}

		function parseFixedLengthString( buffer, offset, size ) {

			const stringValue = new TextDecoder().decode(
				new Uint8Array( buffer ).slice( offset.value, offset.value + size )
			);

			offset.value = offset.value + size;

			return stringValue;

		}

		function parseRational( dataView, offset ) {

			const x = parseInt32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseTimecode( dataView, offset ) {

			const x = parseUint32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseInt32( dataView, offset ) {

			const Int32 = dataView.getInt32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Int32;

		}

		function parseUint32( dataView, offset ) {

			const Uint32 = dataView.getUint32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Uint32;

		}

		function parseUint8Array( uInt8Array, offset ) {

			const Uint8 = uInt8Array[ offset.value ];

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		function parseUint8( dataView, offset ) {

			const Uint8 = dataView.getUint8( offset.value );

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		const parseInt64 = function ( dataView, offset ) {

			let int;

			if ( 'getBigInt64' in DataView.prototype ) {

				int = Number( dataView.getBigInt64( offset.value, true ) );

			} else {

				int = dataView.getUint32( offset.value + 4, true ) + Number( dataView.getUint32( offset.value, true ) << 32 );

			}

			offset.value += ULONG_SIZE;

			return int;

		};

		function parseFloat32( dataView, offset ) {

			const float = dataView.getFloat32( offset.value, true );

			offset.value += FLOAT32_SIZE;

			return float;

		}

		function decodeFloat32( dataView, offset ) {

			return DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );

		}

		// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript
		function decodeFloat16( binary ) {

			const exponent = ( binary & 0x7C00 ) >> 10,
				fraction = binary & 0x03FF;

			return ( binary >> 15 ? -1 : 1 ) * (
				exponent ?
					(
						exponent === 0x1F ?
							fraction ? NaN : Infinity :
							Math.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )
					) :
					6.103515625e-5 * ( fraction / 0x400 )
			);

		}

		function parseUint16( dataView, offset ) {

			const Uint16 = dataView.getUint16( offset.value, true );

			offset.value += INT16_SIZE;

			return Uint16;

		}

		function parseFloat16( buffer, offset ) {

			return decodeFloat16( parseUint16( buffer, offset ) );

		}

		function parseChlist( dataView, buffer, offset, size ) {

			const startOffset = offset.value;
			const channels = [];

			while ( offset.value < ( startOffset + size - 1 ) ) {

				const name = parseNullTerminatedString( buffer, offset );
				const pixelType = parseInt32( dataView, offset );
				const pLinear = parseUint8( dataView, offset );
				offset.value += 3; // reserved, three chars
				const xSampling = parseInt32( dataView, offset );
				const ySampling = parseInt32( dataView, offset );

				channels.push( {
					name: name,
					pixelType: pixelType,
					pLinear: pLinear,
					xSampling: xSampling,
					ySampling: ySampling
				} );

			}

			offset.value += 1;

			return channels;

		}

		function parseChromaticities( dataView, offset ) {

			const redX = parseFloat32( dataView, offset );
			const redY = parseFloat32( dataView, offset );
			const greenX = parseFloat32( dataView, offset );
			const greenY = parseFloat32( dataView, offset );
			const blueX = parseFloat32( dataView, offset );
			const blueY = parseFloat32( dataView, offset );
			const whiteX = parseFloat32( dataView, offset );
			const whiteY = parseFloat32( dataView, offset );

			return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };

		}

		function parseCompression( dataView, offset ) {

			const compressionCodes = [
				'NO_COMPRESSION',
				'RLE_COMPRESSION',
				'ZIPS_COMPRESSION',
				'ZIP_COMPRESSION',
				'PIZ_COMPRESSION',
				'PXR24_COMPRESSION',
				'B44_COMPRESSION',
				'B44A_COMPRESSION',
				'DWAA_COMPRESSION',
				'DWAB_COMPRESSION'
			];

			const compression = parseUint8( dataView, offset );

			return compressionCodes[ compression ];

		}

		function parseBox2i( dataView, offset ) {

			const xMin = parseInt32( dataView, offset );
			const yMin = parseInt32( dataView, offset );
			const xMax = parseInt32( dataView, offset );
			const yMax = parseInt32( dataView, offset );

			return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };

		}

		function parseLineOrder( dataView, offset ) {

			const lineOrders = [
				'INCREASING_Y',
				'DECREASING_Y',
				'RANDOM_Y',
			];

			const lineOrder = parseUint8( dataView, offset );

			return lineOrders[ lineOrder ];

		}

		function parseEnvmap( dataView, offset ) {

			const envmaps = [
				'ENVMAP_LATLONG',
				'ENVMAP_CUBE'
			];

			const envmap = parseUint8( dataView, offset );

			return envmaps[ envmap ];

		}

		function parseTiledesc( dataView, offset ) {

			const levelModes = [
				'ONE_LEVEL',
				'MIPMAP_LEVELS',
				'RIPMAP_LEVELS',
			];

			const roundingModes = [
				'ROUND_DOWN',
				'ROUND_UP',
			];

			const xSize = parseUint32( dataView, offset );
			const ySize = parseUint32( dataView, offset );
			const modes = parseUint8( dataView, offset );

			return {
				xSize: xSize,
				ySize: ySize,
				levelMode: levelModes[ modes & 0xf ],
				roundingMode: roundingModes[ modes >> 4 ]
			};

		}

		function parseV2f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );

			return [ x, y ];

		}

		function parseV3f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );
			const z = parseFloat32( dataView, offset );

			return [ x, y, z ];

		}

		function parseValue( dataView, buffer, offset, type, size ) {

			if ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {

				return parseFixedLengthString( buffer, offset, size );

			} else if ( type === 'chlist' ) {

				return parseChlist( dataView, buffer, offset, size );

			} else if ( type === 'chromaticities' ) {

				return parseChromaticities( dataView, offset );

			} else if ( type === 'compression' ) {

				return parseCompression( dataView, offset );

			} else if ( type === 'box2i' ) {

				return parseBox2i( dataView, offset );

			} else if ( type === 'envmap' ) {

				return parseEnvmap( dataView, offset );

			} else if ( type === 'tiledesc' ) {

				return parseTiledesc( dataView, offset );

			} else if ( type === 'lineOrder' ) {

				return parseLineOrder( dataView, offset );

			} else if ( type === 'float' ) {

				return parseFloat32( dataView, offset );

			} else if ( type === 'v2f' ) {

				return parseV2f( dataView, offset );

			} else if ( type === 'v3f' ) {

				return parseV3f( dataView, offset );

			} else if ( type === 'int' ) {

				return parseInt32( dataView, offset );

			} else if ( type === 'rational' ) {

				return parseRational( dataView, offset );

			} else if ( type === 'timecode' ) {

				return parseTimecode( dataView, offset );

			} else if ( type === 'preview' ) {

				offset.value += size;
				return 'skipped';

			} else {

				offset.value += size;
				return undefined;

			}

		}

		function roundLog2( x, mode ) {

			const log2 = Math.log2( x );
			return mode == 'ROUND_DOWN' ? Math.floor( log2 ) : Math.ceil( log2 );

		}

		function calculateTileLevels( tiledesc, w, h ) {

			let num = 0;

			switch ( tiledesc.levelMode ) {

				case 'ONE_LEVEL':
					num = 1;
					break;

				case 'MIPMAP_LEVELS':
					num = roundLog2( Math.max( w, h ), tiledesc.roundingMode ) + 1;
					break;

				case 'RIPMAP_LEVELS':
					throw new Error( 'THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.' );

			}

			return num;

		}

		function calculateTiles( count, dataSize, size, roundingMode ) {

			const tiles = new Array( count );

			for ( let i = 0; i < count; i ++ ) {

				const b = ( 1 << i );
				let s = ( dataSize / b ) | 0;

				if ( roundingMode == 'ROUND_UP' && s * b < dataSize ) s += 1;

				const l = Math.max( s, 1 );

				tiles[ i ] = ( ( l + size - 1 ) / size ) | 0;

			}

			return tiles;

		}

		function parseTiles() {

			const EXRDecoder = this;
			const offset = EXRDecoder.offset;
			const tmpOffset = { value: 0 };

			for ( let tile = 0; tile < EXRDecoder.tileCount; tile ++ ) {

				const tileX = parseInt32( EXRDecoder.viewer, offset );
				const tileY = parseInt32( EXRDecoder.viewer, offset );
				offset.value += 8; // skip levels - only parsing top-level
				EXRDecoder.size = parseUint32( EXRDecoder.viewer, offset );

				const startX = tileX * EXRDecoder.blockWidth;
				const startY = tileY * EXRDecoder.blockHeight;
				EXRDecoder.columns = ( startX + EXRDecoder.blockWidth > EXRDecoder.width ) ? EXRDecoder.width - startX : EXRDecoder.blockWidth;
				EXRDecoder.lines = ( startY + EXRDecoder.blockHeight > EXRDecoder.height ) ? EXRDecoder.height - startY : EXRDecoder.blockHeight;

				const bytesBlockLine = EXRDecoder.columns * EXRDecoder.totalBytes;
				const isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesBlockLine;
				const viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );

				offset.value += EXRDecoder.size;

				for ( let line = 0; line < EXRDecoder.lines; line ++ ) {

					const lineOffset = line * EXRDecoder.columns * EXRDecoder.totalBytes;

					for ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {

						const name = EXRHeader.channels[ channelID ].name;
						const lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;
						const cOff = EXRDecoder.decodeChannels[ name ];

						if ( cOff === undefined ) continue;

						tmpOffset.value = lineOffset + lOff;
						const outLineOffset = ( EXRDecoder.height - ( 1 + startY + line ) ) * EXRDecoder.outLineWidth;

						for ( let x = 0; x < EXRDecoder.columns; x ++ ) {

							const outIndex = outLineOffset + ( x + startX ) * EXRDecoder.outputChannels + cOff;
							EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );

						}

					}

				}

			}

		}

		function parseScanline() {

			const EXRDecoder = this;
			const offset = EXRDecoder.offset;
			const tmpOffset = { value: 0 };

			for ( let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.blockHeight; scanlineBlockIdx ++ ) {

				const line = parseInt32( EXRDecoder.viewer, offset ) - EXRHeader.dataWindow.yMin; // line_no
				EXRDecoder.size = parseUint32( EXRDecoder.viewer, offset ); // data_len
				EXRDecoder.lines = ( ( line + EXRDecoder.blockHeight > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.blockHeight );

				const bytesPerLine = EXRDecoder.columns * EXRDecoder.totalBytes;
				const isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesPerLine;
				const viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );

				offset.value += EXRDecoder.size;

				for ( let line_y = 0; line_y < EXRDecoder.blockHeight; line_y ++ ) {

					const scan_y = scanlineBlockIdx * EXRDecoder.blockHeight;
					const true_y = line_y + EXRDecoder.scanOrder( scan_y );
					if ( true_y >= EXRDecoder.height ) continue;

					const lineOffset = line_y * bytesPerLine;
					const outLineOffset = ( EXRDecoder.height - 1 - true_y ) * EXRDecoder.outLineWidth;

					for ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {

						const name = EXRHeader.channels[ channelID ].name;
						const lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;
						const cOff = EXRDecoder.decodeChannels[ name ];

						if ( cOff === undefined ) continue;

						tmpOffset.value = lineOffset + lOff;

						for ( let x = 0; x < EXRDecoder.columns; x ++ ) {

							const outIndex = outLineOffset + x * EXRDecoder.outputChannels + cOff;
							EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );

						}

					}

				}

			}

		}

		function parseHeader( dataView, buffer, offset ) {

			const EXRHeader = {};

			if ( dataView.getUint32( 0, true ) != 20000630 ) { // magic

				throw new Error( 'THREE.EXRLoader: Provided file doesn\'t appear to be in OpenEXR format.' );

			}

			EXRHeader.version = dataView.getUint8( 4 );

			const spec = dataView.getUint8( 5 ); // fullMask

			EXRHeader.spec = {
				singleTile: !! ( spec & 2 ),
				longName: !! ( spec & 4 ),
				deepFormat: !! ( spec & 8 ),
				multiPart: !! ( spec & 16 ),
			};

			// start of header

			offset.value = 8; // start at 8 - after pre-amble

			let keepReading = true;

			while ( keepReading ) {

				const attributeName = parseNullTerminatedString( buffer, offset );

				if ( attributeName == 0 ) {

					keepReading = false;

				} else {

					const attributeType = parseNullTerminatedString( buffer, offset );
					const attributeSize = parseUint32( dataView, offset );
					const attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );

					if ( attributeValue === undefined ) {

						console.warn( `THREE.EXRLoader: Skipped unknown header attribute type \'${attributeType}\'.` );

					} else {

						EXRHeader[ attributeName ] = attributeValue;

					}

				}

			}

			if ( ( spec & -7 ) != 0 ) { // unsupported deep-image, multi-part

				console.error( 'THREE.EXRHeader:', EXRHeader );
				throw new Error( 'THREE.EXRLoader: Provided file is currently unsupported.' );

			}

			return EXRHeader;

		}

		function setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {

			const EXRDecoder = {
				size: 0,
				viewer: dataView,
				array: uInt8Array,
				offset: offset,
				width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,
				height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,
				inputChannels: EXRHeader.channels,
				channelByteOffsets: {},
				scanOrder: null,
				totalBytes: null,
				columns: null,
				lines: null,
				type: null,
				uncompress: null,
				getter: null,
				format: null,
				colorSpace: LinearSRGBColorSpace,
			};

			switch ( EXRHeader.compression ) {

				case 'NO_COMPRESSION':
					EXRDecoder.blockHeight = 1;
					EXRDecoder.uncompress = uncompressRAW;
					break;

				case 'RLE_COMPRESSION':
					EXRDecoder.blockHeight = 1;
					EXRDecoder.uncompress = uncompressRLE;
					break;

				case 'ZIPS_COMPRESSION':
					EXRDecoder.blockHeight = 1;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'ZIP_COMPRESSION':
					EXRDecoder.blockHeight = 16;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'PIZ_COMPRESSION':
					EXRDecoder.blockHeight = 32;
					EXRDecoder.uncompress = uncompressPIZ;
					break;

				case 'PXR24_COMPRESSION':
					EXRDecoder.blockHeight = 16;
					EXRDecoder.uncompress = uncompressPXR;
					break;

				case 'DWAA_COMPRESSION':
					EXRDecoder.blockHeight = 32;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				case 'DWAB_COMPRESSION':
					EXRDecoder.blockHeight = 256;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				default:
					throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );

			}

			const channels = {};
			for ( const channel of EXRHeader.channels ) {

				switch ( channel.name ) {

					case 'Y':
					case 'R':
					case 'G':
					case 'B':
					case 'A':
						channels[ channel.name ] = true;
						EXRDecoder.type = channel.pixelType;

				}

			}

			// RGB images will be converted to RGBA format, preventing software emulation in select devices.
			let fillAlpha = false;

			if ( channels.R && channels.G && channels.B ) {

				fillAlpha = ! channels.A;
				EXRDecoder.outputChannels = 4;
				EXRDecoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };

			} else if ( channels.Y ) {

				EXRDecoder.outputChannels = 1;
				EXRDecoder.decodeChannels = { Y: 0 };

			} else {

				throw new Error( 'EXRLoader.parse: file contains unsupported data channels.' );

			}

			if ( EXRDecoder.type == 1 ) {

				// half
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat16;
						break;

					case HalfFloatType:
						EXRDecoder.getter = parseUint16;
						break;

				}

			} else if ( EXRDecoder.type == 2 ) {

				// float
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat32;
						break;

					case HalfFloatType:
						EXRDecoder.getter = decodeFloat32;

				}

			} else {

				throw new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );

			}

			EXRDecoder.columns = EXRDecoder.width;
			const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;

			switch ( outputType ) {

				case FloatType:
					EXRDecoder.byteArray = new Float32Array( size );

					// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten
					if ( fillAlpha )
						EXRDecoder.byteArray.fill( 1, 0, size );

					break;

				case HalfFloatType:
					EXRDecoder.byteArray = new Uint16Array( size );

					if ( fillAlpha )
						EXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1

					break;

				default:
					console.error( 'THREE.EXRLoader: unsupported type: ', outputType );
					break;

			}

			let byteOffset = 0;
			for ( const channel of EXRHeader.channels ) {

				if ( EXRDecoder.decodeChannels[ channel.name ] !== undefined ) {

					EXRDecoder.channelByteOffsets[ channel.name ] = byteOffset;

				}

				byteOffset += channel.pixelType * 2;

			}

			EXRDecoder.totalBytes = byteOffset;
			EXRDecoder.outLineWidth = EXRDecoder.width * EXRDecoder.outputChannels;

			if ( EXRHeader.lineOrder === 'INCREASING_Y' ) {

				EXRDecoder.scanOrder = ( y ) => y;

			} else {

				EXRDecoder.scanOrder = ( y ) => EXRDecoder.height - 1 - y;

			}

			if ( EXRDecoder.outputChannels == 4 ) {

				EXRDecoder.format = RGBAFormat;
				EXRDecoder.colorSpace = LinearSRGBColorSpace;

			} else {

				EXRDecoder.format = RedFormat;
				EXRDecoder.colorSpace = NoColorSpace;

			}

			if ( EXRHeader.spec.singleTile ) {

				EXRDecoder.blockHeight = EXRHeader.tiles.ySize;
				EXRDecoder.blockWidth = EXRHeader.tiles.xSize;

				const numXLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );
				// const numYLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );

				const numXTiles = calculateTiles( numXLevels, EXRDecoder.width, EXRHeader.tiles.xSize, EXRHeader.tiles.roundingMode );
				const numYTiles = calculateTiles( numXLevels, EXRDecoder.height, EXRHeader.tiles.ySize, EXRHeader.tiles.roundingMode );

				EXRDecoder.tileCount = numXTiles[ 0 ] * numYTiles[ 0 ];

				for ( let l = 0; l < numXLevels; l ++ )
					for ( let y = 0; y < numYTiles[ l ]; y ++ )
						for ( let x = 0; x < numXTiles[ l ]; x ++ )
							parseInt64( dataView, offset ); // tileOffset

				EXRDecoder.decode = parseTiles.bind( EXRDecoder );

			} else {

				EXRDecoder.blockWidth = EXRDecoder.width;
				const blockCount = Math.ceil( EXRDecoder.height / EXRDecoder.blockHeight );

				for ( let i = 0; i < blockCount; i ++ )
					parseInt64( dataView, offset ); // scanlineOffset

				EXRDecoder.decode = parseScanline.bind( EXRDecoder );

			}

			return EXRDecoder;

		}

		// start parsing file [START]
		const offset = { value: 0 };
		const bufferDataView = new DataView( buffer );
		const uInt8Array = new Uint8Array( buffer );

		// get header information and validate format.
		const EXRHeader = parseHeader( bufferDataView, buffer, offset );

		// get input compression information and prepare decoding.
		const EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );

		// parse input data
		EXRDecoder.decode();

		return {
			header: EXRHeader,
			width: EXRDecoder.width,
			height: EXRDecoder.height,
			data: EXRDecoder.byteArray,
			format: EXRDecoder.format,
			colorSpace: EXRDecoder.colorSpace,
			type: this.type,
		};

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			texture.colorSpace = texData.colorSpace;
			texture.minFilter = LinearFilter;
			texture.magFilter = LinearFilter;
			texture.generateMipmaps = false;
			texture.flipY = false;

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}

/**
 * @author Deepkolos / https://github.com/deepkolos
 */

class WorkerPool {

	constructor( pool = 4 ) {

		this.pool = pool;
		this.queue = [];
		this.workers = [];
		this.workersResolve = [];
		this.workerStatus = 0;

	}

	_initWorker( workerId ) {

		if ( ! this.workers[ workerId ] ) {

			const worker = this.workerCreator();
			worker.addEventListener( 'message', this._onMessage.bind( this, workerId ) );
			this.workers[ workerId ] = worker;

		}

	}

	_getIdleWorker() {

		for ( let i = 0; i < this.pool; i ++ )
			if ( ! ( this.workerStatus & ( 1 << i ) ) ) return i;

		return -1;

	}

	_onMessage( workerId, msg ) {

		const resolve = this.workersResolve[ workerId ];
		resolve && resolve( msg );

		if ( this.queue.length ) {

			const { resolve, msg, transfer } = this.queue.shift();
			this.workersResolve[ workerId ] = resolve;
			this.workers[ workerId ].postMessage( msg, transfer );

		} else {

			this.workerStatus ^= 1 << workerId;

		}

	}

	setWorkerCreator( workerCreator ) {

		this.workerCreator = workerCreator;

	}

	setWorkerLimit( pool ) {

		this.pool = pool;

	}

	postMessage( msg, transfer ) {

		return new Promise( ( resolve ) => {

			const workerId = this._getIdleWorker();

			if ( workerId !== -1 ) {

				this._initWorker( workerId );
				this.workerStatus |= 1 << workerId;
				this.workersResolve[ workerId ] = resolve;
				this.workers[ workerId ].postMessage( msg, transfer );

			} else {

				this.queue.push( { resolve, msg, transfer } );

			}

		} );

	}

	dispose() {

		this.workers.forEach( ( worker ) => worker.terminate() );
		this.workersResolve.length = 0;
		this.workers.length = 0;
		this.queue.length = 0;
		this.workerStatus = 0;

	}

}

const t$1=0,n=2,p=1,x=2,E$1=0,F$1=1,X=10,nt=0,ct=9,gt=15,yt=16,dt=22,Ot=37,Ft=43,$t=76,se=83,pe=97,xe=100,de=103,Ae=109,Sn=165,In=166,_i=1000066e3;class Si{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=0,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:0,descriptorBlockSize:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],this.keyValue={},this.globalData=null;}}class Ii{constructor(t,e,n,i){this._dataView=new DataView(t.buffer,t.byteOffset+e,n),this._littleEndian=i,this._offset=0;}_nextUint8(){const t=this._dataView.getUint8(this._offset);return this._offset+=1,t}_nextUint16(){const t=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,t}_nextUint32(){const t=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,t}_nextUint64(){const t=this._dataView.getUint32(this._offset,this._littleEndian)+2**32*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,t}_nextInt32(){const t=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,t}_skip(t){return this._offset+=t,this}_scan(t,e=0){const n=this._offset;let i=0;for(;this._dataView.getUint8(this._offset)!==e&&i<t;)i++,this._offset++;return i<t&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+n,i)}}const Ti=[171,75,84,88,32,50,48,187,13,10,26,10];function Ei(t){return "undefined"!=typeof TextDecoder?(new TextDecoder).decode(t):Buffer.from(t).toString("utf8")}function Pi(t){const e=new Uint8Array(t.buffer,t.byteOffset,Ti.length);if(e[0]!==Ti[0]||e[1]!==Ti[1]||e[2]!==Ti[2]||e[3]!==Ti[3]||e[4]!==Ti[4]||e[5]!==Ti[5]||e[6]!==Ti[6]||e[7]!==Ti[7]||e[8]!==Ti[8]||e[9]!==Ti[9]||e[10]!==Ti[10]||e[11]!==Ti[11])throw new Error("Missing KTX 2.0 identifier.");const n=new Si,i=17*Uint32Array.BYTES_PER_ELEMENT,s=new Ii(t,Ti.length,i,true);n.vkFormat=s._nextUint32(),n.typeSize=s._nextUint32(),n.pixelWidth=s._nextUint32(),n.pixelHeight=s._nextUint32(),n.pixelDepth=s._nextUint32(),n.layerCount=s._nextUint32(),n.faceCount=s._nextUint32();const a=s._nextUint32();n.supercompressionScheme=s._nextUint32();const r=s._nextUint32(),o=s._nextUint32(),l=s._nextUint32(),f=s._nextUint32(),U=s._nextUint64(),c=s._nextUint64(),h=new Ii(t,Ti.length+i,3*a*8,true);for(let e=0;e<a;e++)n.levels.push({levelData:new Uint8Array(t.buffer,t.byteOffset+h._nextUint64(),h._nextUint64()),uncompressedByteLength:h._nextUint64()});const _=new Ii(t,r,o,true),p={vendorId:_._skip(4)._nextUint16(),descriptorType:_._nextUint16(),versionNumber:_._nextUint16(),descriptorBlockSize:_._nextUint16(),colorModel:_._nextUint8(),colorPrimaries:_._nextUint8(),transferFunction:_._nextUint8(),flags:_._nextUint8(),texelBlockDimension:[_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8()],bytesPlane:[_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8()],samples:[]},g=(p.descriptorBlockSize/4-6)/4;for(let t=0;t<g;t++){const e={bitOffset:_._nextUint16(),bitLength:_._nextUint8(),channelType:_._nextUint8(),samplePosition:[_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8()],sampleLower:-Infinity,sampleUpper:Infinity};64&e.channelType?(e.sampleLower=_._nextInt32(),e.sampleUpper=_._nextInt32()):(e.sampleLower=_._nextUint32(),e.sampleUpper=_._nextUint32()),p.samples[t]=e;}n.dataFormatDescriptor.length=0,n.dataFormatDescriptor.push(p);const y=new Ii(t,l,f,true);for(;y._offset<f;){const t=y._nextUint32(),e=y._scan(t),i=Ei(e),s=y._scan(t-e.byteLength);n.keyValue[i]=i.match(/^ktx/i)?Ei(s):s,y._offset%4&&y._skip(4-y._offset%4);}if(c<=0)return n;const x=new Ii(t,U,c,true),u=x._nextUint16(),b=x._nextUint16(),d=x._nextUint32(),m=x._nextUint32(),w=x._nextUint32(),D=x._nextUint32(),B=[];for(let t=0;t<a;t++)B.push({imageFlags:x._nextUint32(),rgbSliceByteOffset:x._nextUint32(),rgbSliceByteLength:x._nextUint32(),alphaSliceByteOffset:x._nextUint32(),alphaSliceByteLength:x._nextUint32()});const L=U+x._offset,A=L+d,k=A+m,v=k+w,S=new Uint8Array(t.buffer,t.byteOffset+L,d),I=new Uint8Array(t.buffer,t.byteOffset+A,m),O=new Uint8Array(t.buffer,t.byteOffset+k,w),T=new Uint8Array(t.buffer,t.byteOffset+v,D);return n.globalData={endpointCount:u,selectorCount:b,imageDescs:B,endpointsData:S,selectorsData:I,tablesData:O,extendedData:T},n}

let A,I$1,B$1;const g={env:{emscripten_notify_memory_growth:function(A){B$1=new Uint8Array(I$1.exports.memory.buffer);}}};class Q{init(){return A||(A="undefined"!=typeof fetch?fetch("data:application/wasm;base64,"+C$2).then(A=>A.arrayBuffer()).then(A=>WebAssembly.instantiate(A,g)).then(this._init):WebAssembly.instantiate(Buffer.from(C$2,"base64"),g).then(this._init),A)}_init(A){I$1=A.instance,g.env.emscripten_notify_memory_growth(0);}decode(A,g=0){if(!I$1)throw new Error("ZSTDDecoder: Await .init() before decoding.");const Q=A.byteLength,C=I$1.exports.malloc(Q);B$1.set(A,C),g=g||Number(I$1.exports.ZSTD_findDecompressedSize(C,Q));const E=I$1.exports.malloc(g),i=I$1.exports.ZSTD_decompress(E,g,C,Q),D=B$1.slice(E,E+i);return I$1.exports.free(C),I$1.exports.free(E),D}}const C$2="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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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";

const DisplayP3ColorSpace = 'display-p3';
const LinearDisplayP3ColorSpace = 'display-p3-linear';

/**
 * Loader for KTX 2.0 GPU Texture containers.
 *
 * KTX 2.0 is a container format for various GPU texture formats. The loader
 * supports Basis Universal GPU textures, which can be quickly transcoded to
 * a wide variety of GPU texture compression formats, as well as some
 * uncompressed DataTexture and Data3DTexture formats.
 *
 * References:
 * - KTX: http://github.khronos.org/KTX-Specification/
 * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor
 * - BasisU HDR: https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Texture-Specification-v1.0
 */


const _taskCache = new WeakMap();

let _activeLoaders = 0;

let _zstd;

class KTX2Loader extends Loader {

	constructor( manager ) {

		super( manager );

		this.transcoderPath = '';
		this.transcoderBinary = null;
		this.transcoderPending = null;

		this.workerPool = new WorkerPool();
		this.workerSourceURL = '';
		this.workerConfig = null;

		if ( typeof MSC_TRANSCODER !== 'undefined' ) {

			console.warn(

				'THREE.KTX2Loader: Please update to latest "basis_transcoder".'
				+ ' "msc_basis_transcoder" is no longer supported in three.js r125+.'

			);

		}

	}

	setTranscoderPath( path ) {

		this.transcoderPath = path;

		return this;

	}

	setWorkerLimit( num ) {

		this.workerPool.setWorkerLimit( num );

		return this;

	}

	async detectSupportAsync( renderer ) {

		this.workerConfig = {
			astcSupported: await renderer.hasFeatureAsync( 'texture-compression-astc' ),
			astcHDRSupported: false, // https://github.com/gpuweb/gpuweb/issues/3856
			etc1Supported: await renderer.hasFeatureAsync( 'texture-compression-etc1' ),
			etc2Supported: await renderer.hasFeatureAsync( 'texture-compression-etc2' ),
			dxtSupported: await renderer.hasFeatureAsync( 'texture-compression-bc' ),
			bptcSupported: await renderer.hasFeatureAsync( 'texture-compression-bptc' ),
			pvrtcSupported: await renderer.hasFeatureAsync( 'texture-compression-pvrtc' )
		};

		return this;

	}

	detectSupport( renderer ) {

		if ( renderer.isWebGPURenderer === true ) {

			this.workerConfig = {
				astcSupported: renderer.hasFeature( 'texture-compression-astc' ),
				astcHDRSupported: false, // https://github.com/gpuweb/gpuweb/issues/3856
				etc1Supported: renderer.hasFeature( 'texture-compression-etc1' ),
				etc2Supported: renderer.hasFeature( 'texture-compression-etc2' ),
				dxtSupported: renderer.hasFeature( 'texture-compression-bc' ),
				bptcSupported: renderer.hasFeature( 'texture-compression-bptc' ),
				pvrtcSupported: renderer.hasFeature( 'texture-compression-pvrtc' )
			};

		} else {

			this.workerConfig = {
				astcSupported: renderer.extensions.has( 'WEBGL_compressed_texture_astc' ),
				astcHDRSupported: renderer.extensions.has( 'WEBGL_compressed_texture_astc' )
					&& renderer.extensions.get( 'WEBGL_compressed_texture_astc' ).getSupportedProfiles().includes( 'hdr' ),
				etc1Supported: renderer.extensions.has( 'WEBGL_compressed_texture_etc1' ),
				etc2Supported: renderer.extensions.has( 'WEBGL_compressed_texture_etc' ),
				dxtSupported: renderer.extensions.has( 'WEBGL_compressed_texture_s3tc' ),
				bptcSupported: renderer.extensions.has( 'EXT_texture_compression_bptc' ),
				pvrtcSupported: renderer.extensions.has( 'WEBGL_compressed_texture_pvrtc' )
					|| renderer.extensions.has( 'WEBKIT_WEBGL_compressed_texture_pvrtc' )
			};

		}

		return this;

	}

	init() {

		if ( ! this.transcoderPending ) {

			// Load transcoder wrapper.
			const jsLoader = new FileLoader( this.manager );
			jsLoader.setPath( this.transcoderPath );
			jsLoader.setWithCredentials( this.withCredentials );
			const jsContent = jsLoader.loadAsync( 'basis_transcoder.js' );

			// Load transcoder WASM binary.
			const binaryLoader = new FileLoader( this.manager );
			binaryLoader.setPath( this.transcoderPath );
			binaryLoader.setResponseType( 'arraybuffer' );
			binaryLoader.setWithCredentials( this.withCredentials );
			const binaryContent = binaryLoader.loadAsync( 'basis_transcoder.wasm' );

			this.transcoderPending = Promise.all( [ jsContent, binaryContent ] )
				.then( ( [ jsContent, binaryContent ] ) => {

					const fn = KTX2Loader.BasisWorker.toString();

					const body = [
						'/* constants */',
						'let _EngineFormat = ' + JSON.stringify( KTX2Loader.EngineFormat ),
						'let _EngineType = ' + JSON.stringify( KTX2Loader.EngineType ),
						'let _TranscoderFormat = ' + JSON.stringify( KTX2Loader.TranscoderFormat ),
						'let _BasisFormat = ' + JSON.stringify( KTX2Loader.BasisFormat ),
						'/* basis_transcoder.js */',
						jsContent,
						'/* worker */',
						fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
					].join( '\n' );

					this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );
					this.transcoderBinary = binaryContent;

					this.workerPool.setWorkerCreator( () => {

						const worker = new Worker( this.workerSourceURL );
						const transcoderBinary = this.transcoderBinary.slice( 0 );

						worker.postMessage( { type: 'init', config: this.workerConfig, transcoderBinary }, [ transcoderBinary ] );

						return worker;

					} );

				} );

			if ( _activeLoaders > 0 ) {

				// Each instance loads a transcoder and allocates workers, increasing network and memory cost.

				console.warn(

					'THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.'
					+ ' Use a single KTX2Loader instance, or call .dispose() on old instances.'

				);

			}

			_activeLoaders ++;

		}

		return this.transcoderPending;

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.workerConfig === null ) {

			throw new Error( 'THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.' );

		}

		const loader = new FileLoader( this.manager );

		loader.setResponseType( 'arraybuffer' );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			this.parse( buffer, onLoad, onError );

		}, onProgress, onError );

	}

	parse( buffer, onLoad, onError ) {

		if ( this.workerConfig === null ) {

			throw new Error( 'THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.' );

		}

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( _taskCache.has( buffer ) ) {

			const cachedTask = _taskCache.get( buffer );

			return cachedTask.promise.then( onLoad ).catch( onError );

		}

		this._createTexture( buffer )
			.then( ( texture ) => onLoad ? onLoad( texture ) : null )
			.catch( onError );

	}

	_createTextureFrom( transcodeResult, container ) {

		const { type: messageType, error, data: { faces, width, height, format, type, dfdFlags } } = transcodeResult;

		if ( messageType === 'error' ) return Promise.reject( error );

		let texture;

		if ( container.faceCount === 6 ) {

			texture = new CompressedCubeTexture( faces, format, type );

		} else {

			const mipmaps = faces[ 0 ].mipmaps;

			texture = container.layerCount > 1
				? new CompressedArrayTexture( mipmaps, width, height, container.layerCount, format, type )
				: new CompressedTexture( mipmaps, width, height, format, type );

		}

		texture.minFilter = faces[ 0 ].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
		texture.magFilter = LinearFilter;
		texture.generateMipmaps = false;

		texture.needsUpdate = true;
		texture.colorSpace = parseColorSpace( container );
		texture.premultiplyAlpha = !! ( dfdFlags & p );

		return texture;

	}

	/**
	 * @param {ArrayBuffer} buffer
	 * @param {?Object} config
	 * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
	 */
	async _createTexture( buffer, config = {} ) {

		const container = Pi( new Uint8Array( buffer ) );

		// Basis UASTC HDR is a subset of ASTC, which can be transcoded efficiently
		// to BC6H. To detect whether a KTX2 file uses Basis UASTC HDR, or default
		// ASTC, inspect the DFD color model.
		//
		// Source: https://github.com/BinomialLLC/basis_universal/issues/381
		const isBasisHDR = container.vkFormat === _i
			&& container.dataFormatDescriptor[ 0 ].colorModel === 0xA7;

		// If the device supports ASTC, Basis UASTC HDR requires no transcoder.
		const needsTranscoder = container.vkFormat === nt
			|| isBasisHDR && ! this.workerConfig.astcHDRSupported;

		if ( ! needsTranscoder ) {

			return createRawTexture( container );

		}

		//
		const taskConfig = config;
		const texturePending = this.init().then( () => {

			return this.workerPool.postMessage( { type: 'transcode', buffer, taskConfig: taskConfig }, [ buffer ] );

		} ).then( ( e ) => this._createTextureFrom( e.data, container ) );

		// Cache the task result.
		_taskCache.set( buffer, { promise: texturePending } );

		return texturePending;

	}

	dispose() {

		this.workerPool.dispose();
		if ( this.workerSourceURL ) URL.revokeObjectURL( this.workerSourceURL );

		_activeLoaders --;

		return this;

	}

}


/* CONSTANTS */

KTX2Loader.BasisFormat = {
	ETC1S: 0,
	UASTC: 1,
	UASTC_HDR: 2,
};

// Source: https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture_test/index.html
KTX2Loader.TranscoderFormat = {
	ETC1: 0,
	ETC2: 1,
	BC1: 2,
	BC3: 3,
	BC4: 4,
	BC5: 5,
	BC7_M6_OPAQUE_ONLY: 6,
	BC7_M5: 7,
	PVRTC1_4_RGB: 8,
	PVRTC1_4_RGBA: 9,
	ASTC_4x4: 10,
	ATC_RGB: 11,
	ATC_RGBA_INTERPOLATED_ALPHA: 12,
	RGBA32: 13,
	RGB565: 14,
	BGR565: 15,
	RGBA4444: 16,
	BC6H: 22,
	RGB_HALF: 24,
	RGBA_HALF: 25,
};

KTX2Loader.EngineFormat = {
	RGBAFormat: RGBAFormat,
	RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
	RGB_BPTC_UNSIGNED_Format: RGB_BPTC_UNSIGNED_Format,
	RGBA_BPTC_Format: RGBA_BPTC_Format,
	RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,
	RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
	RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
	RGB_ETC1_Format: RGB_ETC1_Format,
	RGB_ETC2_Format: RGB_ETC2_Format,
	RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
	RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,
};

KTX2Loader.EngineType = {
	UnsignedByteType: UnsignedByteType,
	HalfFloatType: HalfFloatType,
	FloatType: FloatType,
};

/* WEB WORKER */

KTX2Loader.BasisWorker = function () {

	let config;
	let transcoderPending;
	let BasisModule;

	const EngineFormat = _EngineFormat; // eslint-disable-line no-undef
	const EngineType = _EngineType; // eslint-disable-line no-undef
	const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef
	const BasisFormat = _BasisFormat; // eslint-disable-line no-undef

	self.addEventListener( 'message', function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				config = message.config;
				init( message.transcoderBinary );
				break;

			case 'transcode':
				transcoderPending.then( () => {

					try {

						const { faces, buffers, width, height, hasAlpha, format, type, dfdFlags } = transcode( message.buffer );

						self.postMessage( { type: 'transcode', id: message.id, data: { faces, width, height, hasAlpha, format, type, dfdFlags } }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					}

				} );
				break;

		}

	} );

	function init( wasmBinary ) {

		transcoderPending = new Promise( ( resolve ) => {

			BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
			BASIS( BasisModule ); // eslint-disable-line no-undef

		} ).then( () => {

			BasisModule.initializeBasis();

			if ( BasisModule.KTX2File === undefined ) {

				console.warn( 'THREE.KTX2Loader: Please update Basis Universal transcoder.' );

			}

		} );

	}

	function transcode( buffer ) {

		const ktx2File = new BasisModule.KTX2File( new Uint8Array( buffer ) );

		function cleanup() {

			ktx2File.close();
			ktx2File.delete();

		}

		if ( ! ktx2File.isValid() ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader:	Invalid or unsupported .ktx2 file' );

		}

		let basisFormat;

		if ( ktx2File.isUASTC() ) {

			basisFormat = BasisFormat.UASTC;

		} else if ( ktx2File.isETC1S() ) {

			basisFormat = BasisFormat.ETC1S;

		} else if ( ktx2File.isHDR() ) {

			basisFormat = BasisFormat.UASTC_HDR;

		} else {

			throw new Error( 'THREE.KTX2Loader: Unknown Basis encoding' );

		}

		const width = ktx2File.getWidth();
		const height = ktx2File.getHeight();
		const layerCount = ktx2File.getLayers() || 1;
		const levelCount = ktx2File.getLevels();
		const faceCount = ktx2File.getFaces();
		const hasAlpha = ktx2File.getHasAlpha();
		const dfdFlags = ktx2File.getDFDFlags();

		const { transcoderFormat, engineFormat, engineType } = getTranscoderFormat( basisFormat, width, height, hasAlpha );

		if ( ! width || ! height || ! levelCount ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader:	Invalid texture' );

		}

		if ( ! ktx2File.startTranscoding() ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader: .startTranscoding failed' );

		}

		const faces = [];
		const buffers = [];

		for ( let face = 0; face < faceCount; face ++ ) {

			const mipmaps = [];

			for ( let mip = 0; mip < levelCount; mip ++ ) {

				const layerMips = [];

				let mipWidth, mipHeight;

				for ( let layer = 0; layer < layerCount; layer ++ ) {

					const levelInfo = ktx2File.getImageLevelInfo( mip, layer, face );

					if ( face === 0 && mip === 0 && layer === 0 && ( levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0 ) ) {

						console.warn( 'THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.' );

					}

					if ( levelCount > 1 ) {

						mipWidth = levelInfo.origWidth;
						mipHeight = levelInfo.origHeight;

					} else {

						// Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with
						// mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.
						// See mrdoob/three.js#25908.
						mipWidth = levelInfo.width;
						mipHeight = levelInfo.height;

					}

					let dst = new Uint8Array( ktx2File.getImageTranscodedSizeInBytes( mip, layer, 0, transcoderFormat ) );
					const status = ktx2File.transcodeImage( dst, mip, layer, face, transcoderFormat, 0, -1, -1 );

					if ( engineType === EngineType.HalfFloatType ) {

						dst = new Uint16Array( dst.buffer, dst.byteOffset, dst.byteLength / Uint16Array.BYTES_PER_ELEMENT );

					}

					if ( ! status ) {

						cleanup();
						throw new Error( 'THREE.KTX2Loader: .transcodeImage failed.' );

					}

					layerMips.push( dst );

				}

				const mipData = concat( layerMips );

				mipmaps.push( { data: mipData, width: mipWidth, height: mipHeight } );
				buffers.push( mipData.buffer );

			}

			faces.push( { mipmaps, width, height, format: engineFormat, type: engineType } );

		}

		cleanup();

		return { faces, buffers, width, height, hasAlpha, dfdFlags, format: engineFormat, type: engineType };

	}

	//

	// Optimal choice of a transcoder target format depends on the Basis format (ETC1S, UASTC, or
	// UASTC HDR), device capabilities, and texture dimensions. The list below ranks the formats
	// separately for each format. Currently, priority is assigned based on:
	//
	//   high quality > low quality > uncompressed
	//
	// Prioritization may be revisited, or exposed for configuration, in the future.
	//
	// Reference: https://github.com/KhronosGroup/3D-Formats-Guidelines/blob/main/KTXDeveloperGuide.md
	const FORMAT_OPTIONS = [
		{
			if: 'astcSupported',
			basisFormat: [ BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4 ],
			engineFormat: [ EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: Infinity,
			priorityUASTC: 1,
			needsPowerOfTwo: false,
		},
		{
			if: 'bptcSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5 ],
			engineFormat: [ EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 3,
			priorityUASTC: 2,
			needsPowerOfTwo: false,
		},
		{
			if: 'dxtSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.BC1, TranscoderFormat.BC3 ],
			engineFormat: [ EngineFormat.RGBA_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 4,
			priorityUASTC: 5,
			needsPowerOfTwo: false,
		},
		{
			if: 'etc2Supported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.ETC1, TranscoderFormat.ETC2 ],
			engineFormat: [ EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 1,
			priorityUASTC: 3,
			needsPowerOfTwo: false,
		},
		{
			if: 'etc1Supported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.ETC1 ],
			engineFormat: [ EngineFormat.RGB_ETC1_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 2,
			priorityUASTC: 4,
			needsPowerOfTwo: false,
		},
		{
			if: 'pvrtcSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA ],
			engineFormat: [ EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format ],
			engineType: [ EngineType.UnsignedByteType ],
			priorityETC1S: 5,
			priorityUASTC: 6,
			needsPowerOfTwo: true,
		},
		{
			if: 'bptcSupported',
			basisFormat: [ BasisFormat.UASTC_HDR ],
			transcoderFormat: [ TranscoderFormat.BC6H ],
			engineFormat: [ EngineFormat.RGB_BPTC_UNSIGNED_Format ],
			engineType: [ EngineType.HalfFloatType ],
			priorityHDR: 1,
			needsPowerOfTwo: false,
		},

		// Uncompressed fallbacks.

		{
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC ],
			transcoderFormat: [ TranscoderFormat.RGBA32, TranscoderFormat.RGBA32 ],
			engineFormat: [ EngineFormat.RGBAFormat, EngineFormat.RGBAFormat ],
			engineType: [ EngineType.UnsignedByteType, EngineType.UnsignedByteType ],
			priorityETC1S: 100,
			priorityUASTC: 100,
			needsPowerOfTwo: false,
		},
		{
			basisFormat: [ BasisFormat.UASTC_HDR ],
			transcoderFormat: [ TranscoderFormat.RGBA_HALF ],
			engineFormat: [ EngineFormat.RGBAFormat ],
			engineType: [ EngineType.HalfFloatType ],
			priorityHDR: 100,
			needsPowerOfTwo: false,
		}
	];

	const OPTIONS = {
		// TODO: For ETC1S we intentionally sort by _UASTC_ priority, preserving
		// a historical accident shown to avoid performance pitfalls for Linux with
		// Firefox & AMD GPU (RadeonSI). Further work needed.
		// See https://github.com/mrdoob/three.js/pull/29730.
		[ BasisFormat.ETC1S ]: FORMAT_OPTIONS
			.filter( ( opt ) => opt.basisFormat.includes( BasisFormat.ETC1S ) )
			.sort( ( a, b ) => a.priorityUASTC - b.priorityUASTC ),

		[ BasisFormat.UASTC ]: FORMAT_OPTIONS
			.filter( ( opt ) => opt.basisFormat.includes( BasisFormat.UASTC ) )
			.sort( ( a, b ) => a.priorityUASTC - b.priorityUASTC ),

		[ BasisFormat.UASTC_HDR ]: FORMAT_OPTIONS
			.filter( ( opt ) => opt.basisFormat.includes( BasisFormat.UASTC_HDR ) )
			.sort( ( a, b ) => a.priorityHDR - b.priorityHDR ),
	};

	function getTranscoderFormat( basisFormat, width, height, hasAlpha ) {

		const options = OPTIONS[ basisFormat ];

		for ( let i = 0; i < options.length; i ++ ) {

			const opt = options[ i ];

			if ( opt.if && ! config[ opt.if ] ) continue;
			if ( ! opt.basisFormat.includes( basisFormat ) ) continue;
			if ( hasAlpha && opt.transcoderFormat.length < 2 ) continue;
			if ( opt.needsPowerOfTwo && ! ( isPowerOfTwo( width ) && isPowerOfTwo( height ) ) ) continue;

			const transcoderFormat = opt.transcoderFormat[ hasAlpha ? 1 : 0 ];
			const engineFormat = opt.engineFormat[ hasAlpha ? 1 : 0 ];
			const engineType = opt.engineType[ 0 ];

			return { transcoderFormat, engineFormat, engineType };

		}

		throw new Error( 'THREE.KTX2Loader: Failed to identify transcoding target.' );

	}

	function isPowerOfTwo( value ) {

		if ( value <= 2 ) return true;

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

	/**
	 * Concatenates N byte arrays.
	 *
	 * @param {Uint8Array[]} arrays
	 * @return {Uint8Array}
	 */
	function concat( arrays ) {

		if ( arrays.length === 1 ) return arrays[ 0 ];

		let totalByteLength = 0;

		for ( let i = 0; i < arrays.length; i ++ ) {

			const array = arrays[ i ];
			totalByteLength += array.byteLength;

		}

		const result = new Uint8Array( totalByteLength );

		let byteOffset = 0;

		for ( let i = 0; i < arrays.length; i ++ ) {

			const array = arrays[ i ];
			result.set( array, byteOffset );

			byteOffset += array.byteLength;

		}

		return result;

	}

};

// Parsing for non-Basis textures. These textures may have supercompression
// like Zstd, but they do not require transcoding.

const UNCOMPRESSED_FORMATS = new Set( [ RGBAFormat, RGFormat, RedFormat ] );

const FORMAT_MAP = {

	[ Ae ]: RGBAFormat,
	[ pe ]: RGBAFormat,
	[ Ot ]: RGBAFormat,
	[ Ft ]: RGBAFormat,

	[ de ]: RGFormat,
	[ se ]: RGFormat,
	[ yt ]: RGFormat,
	[ dt ]: RGFormat,

	[ xe ]: RedFormat,
	[ $t ]: RedFormat,
	[ gt ]: RedFormat,
	[ ct ]: RedFormat,

	[ _i ]: RGBA_ASTC_4x4_Format,
	[ In ]: RGBA_ASTC_6x6_Format,
	[ Sn ]: RGBA_ASTC_6x6_Format,

};

const TYPE_MAP = {

	[ Ae ]: FloatType,
	[ pe ]: HalfFloatType,
	[ Ot ]: UnsignedByteType,
	[ Ft ]: UnsignedByteType,

	[ de ]: FloatType,
	[ se ]: HalfFloatType,
	[ yt ]: UnsignedByteType,
	[ dt ]: UnsignedByteType,

	[ xe ]: FloatType,
	[ $t ]: HalfFloatType,
	[ gt ]: UnsignedByteType,
	[ ct ]: UnsignedByteType,

	[ _i ]: HalfFloatType,
	[ In ]: UnsignedByteType,
	[ Sn ]: UnsignedByteType,

};

async function createRawTexture( container ) {

	const { vkFormat } = container;

	if ( FORMAT_MAP[ vkFormat ] === undefined ) {

		throw new Error( 'THREE.KTX2Loader: Unsupported vkFormat.' );

	}

	//

	let zstd;

	if ( container.supercompressionScheme === n ) {

		if ( ! _zstd ) {

			_zstd = new Promise( async ( resolve ) => {

				const zstd = new Q();
				await zstd.init();
				resolve( zstd );

			} );

		}

		zstd = await _zstd;

	}

	//

	const mipmaps = [];


	for ( let levelIndex = 0; levelIndex < container.levels.length; levelIndex ++ ) {

		const levelWidth = Math.max( 1, container.pixelWidth >> levelIndex );
		const levelHeight = Math.max( 1, container.pixelHeight >> levelIndex );
		const levelDepth = container.pixelDepth ? Math.max( 1, container.pixelDepth >> levelIndex ) : 0;

		const level = container.levels[ levelIndex ];

		let levelData;

		if ( container.supercompressionScheme === t$1 ) {

			levelData = level.levelData;

		} else if ( container.supercompressionScheme === n ) {

			levelData = zstd.decode( level.levelData, level.uncompressedByteLength );

		} else {

			throw new Error( 'THREE.KTX2Loader: Unsupported supercompressionScheme.' );

		}

		let data;

		if ( TYPE_MAP[ vkFormat ] === FloatType ) {

			data = new Float32Array(

				levelData.buffer,
				levelData.byteOffset,
				levelData.byteLength / Float32Array.BYTES_PER_ELEMENT

			);

		} else if ( TYPE_MAP[ vkFormat ] === HalfFloatType ) {

			data = new Uint16Array(

				levelData.buffer,
				levelData.byteOffset,
				levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT

			);

		} else {

			data = levelData;

		}

		mipmaps.push( {

			data: data,
			width: levelWidth,
			height: levelHeight,
			depth: levelDepth,

		} );

	}

	let texture;

	if ( UNCOMPRESSED_FORMATS.has( FORMAT_MAP[ vkFormat ] ) ) {

		texture = container.pixelDepth === 0
			? new DataTexture( mipmaps[ 0 ].data, container.pixelWidth, container.pixelHeight )
			: new Data3DTexture( mipmaps[ 0 ].data, container.pixelWidth, container.pixelHeight, container.pixelDepth );

	} else {

		if ( container.pixelDepth > 0 ) throw new Error( 'THREE.KTX2Loader: Unsupported pixelDepth.' );

		texture = new CompressedTexture( mipmaps, container.pixelWidth, container.pixelHeight );

		texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
		texture.magFilter = LinearFilter;

	}

	texture.mipmaps = mipmaps;

	texture.type = TYPE_MAP[ vkFormat ];
	texture.format = FORMAT_MAP[ vkFormat ];
	texture.colorSpace = parseColorSpace( container );
	texture.needsUpdate = true;

	//

	return Promise.resolve( texture );

}

function parseColorSpace( container ) {

	const dfd = container.dataFormatDescriptor[ 0 ];

	if ( dfd.colorPrimaries === F$1 ) {

		return dfd.transferFunction === x ? SRGBColorSpace : LinearSRGBColorSpace;

	} else if ( dfd.colorPrimaries === X ) {

		return dfd.transferFunction === x ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;

	} else if ( dfd.colorPrimaries === E$1 ) {

		return NoColorSpace;

	} else {

		console.warn( `THREE.KTX2Loader: Unsupported color primaries, "${ dfd.colorPrimaries }"` );
		return NoColorSpace;

	}

}

var lzma = function(){var pp, n0 = 0x10000000000000000, n1 = 4294967295, n2 = 2147483647, n3 = 2147483648;
function r(e,r){pp({action:nr,cbn:r,result:e});}function o(e){var r=[];return r[e-1]=void 0,r}function n(e,r){return i(e[0]+r[0],e[1]+r[1])}
function t(e,r){var o,n;return e[0]==r[0]&&e[1]==r[1]?0:(o=0>e[1],n=0>r[1],o&&!n?-1:!o&&n?1:d(e,r)[1]<0?-1:1)}
function i(e,r){var o,n;for(r%=n0,e%=n0,o=r%ir,n=Math.floor(e/ir)*ir,r=r-o+n,e=e-n+o;0>e;)e+=ir,r-=ir;for(;e>n1;)e-=ir,r+=ir;for(r%=n0;r>0x7fffffff00000000;)r-=n0;for(;-18446744073709552e3>r;)r+=n0;return [e,r]}
function u(e){return e>=0?[e,0]:[e+ir,-4294967296]}function s(e){return e[0]>=n3?~~Math.max(Math.min(e[0]-ir,n2),-2147483648):~~Math.max(Math.min(e[0],n2),-2147483648)}function d(e,r){return i(e[0]-r[0],e[1]-r[1])}
function c(e,r){return e.ab=r,e.cb=0,e.O=r.length,e}function m(e){return e.cb>=e.O?-1:255&e.ab[e.cb++]}function a(e){return e.ab=o(32),e.O=0,e}function _(e){var r=e.ab;return r.length=e.O,r}
function f(e,r,o,n){p(r,o,e.ab,e.O,n),e.O+=n;}function p(e,r,o,n,t){for(var i=0;t>i;++i)o[n+i]=e[r+i];}
function D(e,r,o){var n,t,i,s,d="",c=[];for(t=0;5>t;++t){if(i=m(r),-1==i)throw Error("truncated input");c[t]=i<<24>>24;}if(n=N({}),!z(n,c))throw Error("corrupted input");
for(t=0;64>t;t+=8){if(i=m(r),-1==i)throw Error("truncated input");i=i.toString(16),1==i.length&&(i="0"+i),d=i+""+d;}/^0+$|^f+$/i.test(d)?e.N=ur:(s=parseInt(d,16),e.N=s>n1?ur:u(s)),e.Q=B(n,r,o,e.N);}
function l(e,r){return e.S=a({}),D(e,c({},r),e.S),e}function g(e,r,o){var n=e.D-r-1;for(0>n&&(n+=e.c);0!=o;--o)n>=e.c&&(n=0),e.x[e.D++]=e.x[n++],e.D>=e.c&&w(e);}
function v(e,r){(null==e.x||e.c!=r)&&(e.x=o(r)),e.c=r,e.D=0,e.w=0;}function w(e){var r=e.D-e.w;r&&(f(e.V,e.x,e.w,r),e.D>=e.c&&(e.D=0),e.w=e.D);}
function R(e,r){var o=e.D-r-1;return 0>o&&(o+=e.c),e.x[o]}function h(e,r){e.x[e.D++]=r,e.D>=e.c&&w(e);}function P(e){w(e),e.V=null;}function C(e){return e-=2,4>e?e:3}
function S(e){return 4>e?0:10>e?e-3:e-6}function M(e,r){return e.h=r,e.bb=null,e.X=1,e}function L(e){if(!e.X)throw Error("bad state");if(e.bb)throw Error("No encoding");return y(e),e.X}
function y(e){var r=I(e.h);if(-1==r)throw Error("corrupted input");e.$=ur,e.Z=e.h.d,(r||t(e.h.U,sr)>=0&&t(e.h.d,e.h.U)>=0)&&(w(e.h.b),P(e.h.b),e.h.a.K=null,e.X=0);}
function B(e,r,o,n){return e.a.K=r,P(e.b),e.b.V=o,b(e),e.f=0,e.l=0,e.T=0,e.R=0,e._=0,e.U=n,e.d=sr,e.I=0,M({},e)}
function I(e){ var r,o,i,d,c,m;if(m=s(e.d)&e.P,Q(e.a,e.q,(e.f<<4)+m)){if(Q(e.a,e.E,e.f))i=0,
Q(e.a,e.s,e.f)?(Q(e.a,e.u,e.f)?(Q(e.a,e.r,e.f)?(o=e._,e._=e.R):o=e.R,e.R=e.T):o=e.T,e.T=e.l,e.l=o):Q(e.a,e.n,(e.f<<4)+m)||(e.f=7>e.f?9:11,i=1),
i||(i=x(e.o,e.a,m)+2,e.f=7>e.f?8:11);else if(e._=e.R,e.R=e.T,e.T=e.l,i=2+x(e.C,e.a,m),e.f=7>e.f?7:10,c=q(e.j[C(i)],e.a),c>=4){if(d=(c>>1)-1,e.l=(2|1&c)<<d,14>c)e.l+=J(e.J,e.l-c-1,e.a,d);
else if(e.l+=U(e.a,d-4)<<4,e.l+=F(e.t,e.a),0>e.l)return  -1==e.l?1:-1}else e.l=c;if(t(u(e.l),e.d)>=0||e.l>=e.m)return  -1;
g(e.b,e.l,i),e.d=n(e.d,u(i)),e.I=R(e.b,0);}else r=Z(e.k,s(e.d),e.I),e.I=7>e.f?T(r,e.a):$(r,e.a,R(e.b,e.l)),h(e.b,e.I),e.f=S(e.f),e.d=n(e.d,dr);return 0}
function N(e){e.b={},e.a={},e.q=o(192),e.E=o(12),e.s=o(12),e.u=o(12),e.r=o(12),e.n=o(192),e.j=o(4),e.J=o(114),e.t=K({},4),e.C=G({}),e.o=G({}),e.k={};for(var r=0;4>r;++r)e.j[r]=K({},6);return e}
function b(e){e.b.w=0,e.b.D=0,X(e.q),X(e.n),X(e.E),X(e.s),X(e.u),X(e.r),X(e.J),H(e.k);for(var r=0;4>r;++r)X(e.j[r].B);A(e.C),A(e.o),X(e.t.B),V(e.a);}
function z(e,r){var o,n,t,i,u,s,d;if(5>r.length)return 0;for(d=255&r[0],t=d%9,s=~~(d/9),i=s%5,u=~~(s/5),o=0,n=0;4>n;++n)o+=(255&r[1+n])<<8*n;return o>99999999||!W(e,t,i,u)?0:O(e,o)}
function O(e,r){return 0>r?0:(e.z!=r&&(e.z=r,e.m=Math.max(e.z,1),v(e.b,Math.max(e.m,4096))),1)}
function W(e,r,o,n){if(r>8||o>4||n>4)return 0;E(e.k,o,r);var t=1<<n;return k(e.C,t),k(e.o,t),e.P=t-1,1}function k(e,r){for(;r>e.e;++e.e)e.G[e.e]=K({},3),e.H[e.e]=K({},3);}
function x(e,r,o){if(!Q(r,e.M,0))return q(e.G[o],r);var n=8;return n+=Q(r,e.M,1)?8+q(e.L,r):q(e.H[o],r)}function G(e){return e.M=o(2),e.G=o(16),e.H=o(16),e.L=K({},8),e.e=0,e}
function A(e){X(e.M);for(var r=0;e.e>r;++r)X(e.G[r].B),X(e.H[r].B);X(e.L.B);}
function E(e,r,n){var t,i;if(null==e.F||e.g!=n||e.y!=r)for(e.y=r,e.Y=(1<<r)-1,e.g=n,i=1<<e.g+e.y,e.F=o(i),t=0;i>t;++t)e.F[t]=j({});}
function Z(e,r,o){return e.F[((r&e.Y)<<e.g)+((255&o)>>>8-e.g)]}function H(e){var r,o;for(o=1<<e.g+e.y,r=0;o>r;++r)X(e.F[r].v);}
function T(e,r){var o=1;do o=o<<1|Q(r,e.v,o);while(256>o);return o<<24>>24}
function $(e,r,o){var n,t,i=1;do if(t=o>>7&1,o<<=1,n=Q(r,e.v,(1+t<<8)+i),i=i<<1|n,t!=n){for(;256>i;)i=i<<1|Q(r,e.v,i);break}while(256>i);return i<<24>>24}
function j(e){return e.v=o(768),e}function K(e,r){return e.A=r,e.B=o(1<<r),e}function q(e,r){var o,n=1;for(o=e.A;0!=o;--o)n=(n<<1)+Q(r,e.B,n);return n-(1<<e.A)}
function F(e,r){var o,n,t=1,i=0;for(n=0;e.A>n;++n)o=Q(r,e.B,t),t<<=1,t+=o,i|=o<<n;return i}function J(e,r,o,n){var t,i,u=1,s=0;for(i=0;n>i;++i)t=Q(o,e,r+u),u<<=1,u+=t,s|=t<<i;return s}
function Q(e,r,o){var n,t=r[o];return n=(e.i>>>11)*t,(-2147483648^n)>(-2147483648^e.p)?(e.i=n,r[o]=t+(2048-t>>>5)<<16>>16,-16777216&e.i||(e.p=e.p<<8|m(e.K),e.i<<=8),0):(e.i-=n,e.p-=n,r[o]=t-(t>>>5)<<16>>16,
-16777216&e.i||(e.p=e.p<<8|m(e.K),e.i<<=8),1)}
function U(e,r){var o,n,t=0;for(o=r;0!=o;--o)e.i>>>=1,n=e.p-e.i>>>31,e.p-=e.i&n-1,t=t<<1|1-n,-16777216&e.i||(e.p=e.p<<8|m(e.K),e.i<<=8);return t}
function V(e){e.p=0,e.i=-1;for(var r=0;5>r;++r)e.p=e.p<<8|m(e.K);}function X(e){for(var r=e.length-1;r>=0;--r)e[r]=1024;}
function Y(e){ for(var r,o,n,t=0,i=0,u=e.length,s=[],d=[];u>t;++t,++i){
if(r=255&e[t],128&r)if(192==(224&r)){if(t+1>=u)return e;if(o=255&e[++t],128!=(192&o))return e;d[i]=(31&r)<<6|63&o;}else {if(224!=(240&r))return e;if(t+2>=u)return e;
if(o=255&e[++t],128!=(192&o))return e;if(n=255&e[++t],128!=(192&n))return e;d[i]=(15&r)<<12|(63&o)<<6|63&n;}else {if(!r)return e;
d[i]=r;}16383==i&&(s.push(String.fromCharCode.apply(String,d)),i=-1);}return i>0&&(d.length=i,s.push(String.fromCharCode.apply(String,d))),s.join("")}
function er(e){return e[1]+e[0]}
function rr(e,o,n){function t(){try{for(var e,r=0,u=(new Date).getTime();L(c.d.Q);)if(++r%1e3==0&&(new Date).getTime()-u>200)return s&&(i=er(c.d.Q.h.d)/d,n(i)),tr(t,0),0;
n(1),e=Y(_(c.d.S)),tr(o.bind(null,e),0);}catch(m){o(null,m);}} var i,u,s,d,c={},m=void 0===o&&void 0===n;
if("function"!=typeof o&&(u=o,o=n=0),n=n||function(e){return void 0!==u?r(s?e:-1,u):void 0},
o=o||function(e,r){return void 0!==u?pp({action:or,cbn:u,result:e,error:r}):void 0},m){for(c.d=l({},e);L(c.d.Q););return Y(_(c.d.S))}
try{c.d=l({},e),d=er(c.d.N),s=d>-1,n(0);}catch(a){return o(null,a)}tr(t,0);}
var or=2,nr=3,tr="function"==typeof setImmediate?setImmediate:setTimeout,ir=4294967296,ur=[n1,-4294967296],sr=[0,0],dr=[1,0];
return {decompress:rr}
}();

const LZMA = {

    decompress:( r, callback ) => {
        lzma.decompress( new Uint8Array( r ), callback );
    },
};
/*
  var action_compress   = 1, action_decompress = 2, action_progress   = 3

  export class LZMA {

    constructor( lzma_path ) {
   // export class LZMA = function (lzma_path) {
        
            
            this.callback_obj = {}
            
            ///NOTE: Node.js needs something like "./" or "../" at the beginning.
            this.lzma_worker = new Worker(lzma_path || "./lzma_worker-min.js");
        
        this.lzma_worker.onmessage = function onmessage(e) {
            if (e.data.action === action_progress) {
                if (this.callback_obj[e.data.cbn] && typeof this.callback_obj[e.data.cbn].on_progress === "function") {
                    this.callback_obj[e.data.cbn].on_progress(e.data.result);
                }
            } else {
                if (this.callback_obj[e.data.cbn] && typeof this.callback_obj[e.data.cbn].on_finish === "function") {
                    this.callback_obj[e.data.cbn].on_finish(e.data.result, e.data.error);
                    
                    /// Since the (de)compression is complete, the callbacks are no longer needed.
                    delete this.callback_obj[e.data.cbn];
                }
            }
        }.bind(this)
        
        /// Very simple error handling.
        this.lzma_worker.onerror = function(event) {
            var err = new Error(event.message + " (" + event.filename + ":" + event.lineno + ")");
            
            for (var cbn in this.callback_obj) {
                this.callback_obj[cbn].on_finish(null, err);
            }
            
            console.error('Uncaught error in lzma_worker', err);
        }.bind(this)
        
    }

    send_to_worker(action, data, mode, on_finish, on_progress) {
        var cbn;
        
        do {
            cbn = Math.floor(Math.random() * (10000000));
        } while(typeof this.callback_obj[cbn] !== "undefined");
        
        this.callback_obj[cbn] = {
            on_finish:   on_finish,
            on_progress: on_progress
        };
        
        this.lzma_worker.postMessage({
            action: action, /// action_compress = 1, action_decompress = 2, action_progress = 3
            cbn:    cbn,    /// callback number
            data:   data,
            mode:   mode
        });
    }

    compress(mixed, mode, on_finish, on_progress) {
        this.send_to_worker(action_compress, mixed, mode, on_finish, on_progress);
    }
    decompress(byte_arr, on_finish, on_progress) {
        this.send_to_worker(action_decompress, byte_arr, false, on_finish, on_progress);
    }
    worker() {
        return this.lzma_worker;
    }
}
*/

const GlbTool = {

	getMesh:( scene, multyMaterialGroup ) => {
        let meshs = {};

 

        if( multyMaterialGroup ){

            let oldGroup = [];
            let nMesh = [];
            let tmpMesh = {};
            let groupName = [];
            scene.traverse( ( child ) => {
                if ( child.isGroup ){ 
                    let m = GlbTool.groupToMesh(child);

                    if(m){
                        oldGroup.push(child);
                        groupName.push( child.name );

                        m.applyMatrix4(child.matrix);
                        /*m.position.copy(child.position)
                        m.quaternion.copy(child.quaternion)
                        m.scale.copy(child.scale)*/
                        nMesh.push(m);

                        tmpMesh[m.name] = nMesh;
                    }
                }
            });

            // remove old group and add remplace mesh
            let i = oldGroup.length, p, name;
            while(i--){
                p = oldGroup[i].parent;
                name = p.name;

                p.remove(oldGroup[i]);

                if(groupName.indexOf(name)!==-1) p = tmpMesh[name];
                
                p.add(nMesh[i]);

            }

        }
        //if( keepMaterial ) GlbTool.keepMaterial( scene )
        scene.traverse( ( child ) => {
            if ( child.isMesh ) meshs[ child.name ] = child;
        });
        return meshs;
    },

    /*keepMaterial: ( scene ) => {

        let Mats = {}, m 

        scene.traverse( ( child ) => {
            if ( child.isMesh ){ 
                m = child.material;
                if( !Mats[m.name] ){
                    Shader.add( m );
                    console.log(m.name)
                    Mats[m.name] = true;
                }
            }
        })

    },*/

    getGroup:( scene, autoMesh, autoMaterial ) => {

        const groups = {};
        scene.traverse( ( child ) => {
            if ( child.isGroup ){ 
            	groups[ child.name ] = autoMesh ? GlbTool.groupToMesh(child, mats) : child;
            }
        });
        return groups;

    },

    // Material should be name like 
    // 0_concret
    // 10_silver ...

    getMaterial:( scene ) => {

    	const Mats = {};
        let names = [];
        let m;

        scene.traverse( ( child ) => {

            if ( child.isMesh ){ 

            	m = child.material;

            	if( names.indexOf(m.name) === -1 ){

                    names.push(m.name);
            		//Shader.add( m );
                    
            		Mats[m.name] = m;

                    //if( m.color ) m.color.convertSRGBToLinear();
                    //if( m.vertexColors ) m.vertexColors = false;
            		
            	}

            }
        });

        return Mats;

    },

    // convert multymaterial group to mesh

    groupToMesh: ( group ) => {

    	if( group.children[0].name !== (group.name + '_1') ) return false
    	if( !group.children[0].isMesh ) return false

    	let geometry = [];
        let material = [];
        let i = group.children.length;

        while(i--){

            material[i] = group.children[i].material;
			geometry[i] = group.children[i].geometry;
            geometry[i].group = i;

		}

		let mesh = new THREE.Mesh( new mergeGeometries( geometry, true ), material);
		mesh.name = group.name;
		return mesh;

    },

    symetric: ( g ) => {

		if( g.isMesh ) g = g.geometry;

        let uv = g.attributes.uv.array;
        let i = uv.length*0.5;

        while( i-- ){
        	if( uv[i*2] < 0 ) uv[i*2]*=-1;
        }
        g.attributes.uv.needsUpdate = true;

    },

    uv2: ( g ) => {

		if( g.isMesh ) g = g.geometry;
        g.setAttribute( 'uv2', g.attributes.uv );

    },


    autoMorph: ( mod, meshs, normal = true, relative = false ) => {

    	let morph = {};
    	let tmpMesh = [];
        mod.traverse( ( node ) => { 
            if ( node.isMesh && node.name.search('__M__') !== -1){ 
            	morph[ node.name ] = node.geometry;
            	tmpMesh.push(node);
            }
        });

		let oName, tName, target, id, g, gm, j, dp, dn, ar, m;
		

		for ( let name in morph ){

			oName = name.substring( 0, name.indexOf('__') );
            tName = name.substring( name.lastIndexOf('__') + 2 );

            target = meshs[ oName ];

			if( target ){

				g = target.geometry;
				gm = morph[name];

				g.morphTargetsRelative = relative;

				if( g.attributes.position.count === gm.attributes.position.count ){

					if( !g.morphAttributes.position ){
                        g.morphAttributes.position = [];
                        if( normal ) g.morphAttributes.normal = [];
                        target.morphTargetInfluences = [];
                        target.morphTargetDictionary = {};
                    }

                    id = g.morphAttributes.position.length;

                    // position
                    if( relative ){
                        j = gm.attributes.position.array.length;
                        ar = []; 
                        while(j--) ar[j] = gm.attributes.position.array[j] - g.attributes.position.array[j];
                        dp = new Float32BufferAttribute( ar, 3 );
                    } else {
                        dp = new Float32BufferAttribute( gm.attributes.position.array, 3 );
                    }

                    g.morphAttributes.position.push( dp );

                    // normal
                    if( normal ){
                        /*if( relative ){
                            j = gm.attributes.normal.length;
                            ar = [];
                            while(j--) ar[j] = gm.attributes.normal.array[j] - g.attributes.normal.array[j]
                            dn = new Float32BufferAttribute( ar, 3 );
                        } else {
                            dn = new Float32BufferAttribute( gm.attributes.normal.array, 3 );
                        }*/

                        dn = new Float32BufferAttribute( gm.attributes.normal.array, 3 );

                        g.morphAttributes.normal.push( dn );

                    }

                    target.morphTargetInfluences.push(0);
                    target.morphTargetDictionary[ tName ] = id;

                    /*if( !target.morph ) {
                        target.morph = function ( name, value ){
                            //console.log(this.morphTargetInfluences)
                            if(!this.morphTargetInfluences) return
                            if(this.morphTargetDictionary[name] === undefined ) return
                            this.morphTargetInfluences[ this.morphTargetDictionary[name] ] = value;
                        }

                        
                    }*/
                    //console.log( target.name + ' have morph call '+ tName )

				} else {
					console.warn( 'Morph '+ tName + ' target is no good on ' + target.name );
				}

			}

		}

		morph = {};

		// claer garbege
		j = tmpMesh.length;
		while(j--){
            m = tmpMesh[j];
			if( m.parent ) m.parent.remove( m );
			if( m.material ) m.material.dispose();
			if( m.geometry ) m.geometry.dispose();
		}

	},


};

/** __
*    _)_|_|_
*   __) |_| | 2023
* @author lo.th / https://github.com/lo-th
*/

const Pool = {

    manager: new LoadingManager(),
    renderer: null,

    msg:'',
    inLoad:false,

    clip:[],
    data: new Map(),
    tmp: [],

    lzma:null,
    //extraTexture: [],
    dracoLoader: null,
    //dracoLoaderType:'js',
    dracoPath:'./src/libs/draco/',
    basisPath:'./src/jsm/libs/basis/',

    formatGltf : {
        draco:true,
        ktx2: false,
        meshop: false,
    },

    setSupport: ( o ) => {

        for(let m in o){
            if(Pool.formatGltf[m]) Pool.formatGltf[m] = o[m];
        }

    },


    maxAnisotropy:1,

    onLoad:() => {},
    onEnd:() => {},
    log: ( msg ) => {},

    materialRoot:(n) => {console.log( n );},

    setLoadEvent:( onload, onend ) => {
        Pool.onLoad = onload;
        Pool.onEnd = onend;
    },

    prefix:( type ) => {
        let p = '';
        switch( type ){
            case 'S': case 'sound': case 'mp3': case 'wav': case 'ogg': p = 'S_';  break;
            case 'I': case 'image': case 'jpg': case 'png': p = 'I_';  break;
            case 'E': case 'hdr': case 'env': p = 'T_';  break;
            case 'J': case 'json': p = 'J_';  break;
            case 'JS': case 'js': p = 'JS_';  break;
            case 'H':  case 'bin': case 'hex': p = 'H_';  break;
            
            case 'O': case 'object3d': p = 'O_';  break;
            case 'M': case 'material': p = 'M_';  break;
            case 'T': case 'texture': p = 'T_';  break;
        }
        return p
    },

    dispose:() => {

        Pool.data.forEach( function( node, key ) {

            if( node.isMaterial || node.isTexture ){ 
                node.dispose();
                Pool.data.delete( key );
                //console.log( key + ' is delete')
            }

            if( node.isObject3D ){
                node.traverse( function ( snode ) {
                    if ( snode.isMesh ){
                        if( snode.geometry ) snode.geometry.dispose();
                        if( snode.material ){ 
                            if(snode.material.dispose) snode.material.dispose();
                        }
                    }
                });
                Pool.data.delete( key );
            }
           

        });

        //console.log('clear extra texture !!')
        /*let i = Pool.extraTexture.length
        while(i--){
            let p = Pool.get( Pool.extraTexture[i], 'T' )
            if(p) p.dispose();
            Pool.delete( Pool.extraTexture[i], 'T' )
        }
        Pool.extraTexture = [];*/
    
    },
    
    createElementNS: ( name ) => ( document.createElementNS( 'http://www.w3.org/1999/xhtml', name ) ),
    exist: ( name, type = '' ) => ( Pool.get( name, type ) ? true : false ),
    delete: ( name, type = '' ) => ( Pool.data.delete( Pool.prefix( type ) + name ) ),
    get: ( name, type = '' ) => ( Pool.data.get( Pool.prefix( type ) + name ) ),

    set: ( name, node, type = '', direct ) => {
        if( !node ){ 
            console.log('Loading error on ' + name); 
            return; 
        }
        if( node.isMaterial ){ 
            type = 'material';
            node.name = name;
            Pool.materialRoot( node, direct );
        }
        if( node.isTexture ) type = 'texture';
        if( node.isObject3D ) type = 'object3d';
        
        if( Pool.get( name, type ) ) return
        Pool.data.set( Pool.prefix( type ) + name, node );
    },

    getScript: ( name ) => ( Pool.data.get( Pool.prefix( 'js' ) + name ) ),

    getMaterials:( obj ) => {
        if( typeof obj === 'string' ) obj = Pool.get( obj, 'O' );
        return GlbTool.getMaterial( obj )
    },

    getGLB:( obj, multyMaterialGroup ) => {
        if( typeof obj === 'string' ) obj = Pool.get( obj, 'O' );
        if(!obj) return console.error('Not find Model ?')
        if(multyMaterialGroup) GlbTool.getMesh( obj, multyMaterialGroup );

    
        return obj
    },

    /*getMaterialList:( obj, keepMaterial ) => {
        if( typeof obj === 'string' ) obj = Pool.get( obj, 'O' );
        if(!obj) return console.error('Not find Model ?')
        return GlbTool.getMesh( obj, keepMaterial )
    },*/

    getMesh:( obj, multyMaterialGroup ) => {

        if( typeof obj === 'string' ) obj = Pool.get( obj, 'O' );
        if(!obj) return console.error('Not find Model ?')
        return GlbTool.getMesh( obj, multyMaterialGroup );

    },

    getGroup:( obj, autoMesh, autoMaterial ) => {
        if( typeof obj === 'string' ) obj = Pool.get( obj, 'O' );
        return GlbTool.getGroup( obj, autoMesh, autoMaterial )
    },

    applyMorph( modelName, meshs = null, normal = true, relative = true ){

        let model;
        if( modelName.isObject3D ) model = modelName;
        else model = Pool.get( modelName, 'O' );

        if( !meshs ) meshs = Pool.getMesh( modelName );
        if( !model || !meshs ) return
        GlbTool.autoMorph( model, meshs, normal, relative );

    },

    uv2( model ){
        GlbTool.uv2( model );
    },

    symetric( model ){
        GlbTool.symetric( model );
    },

    objectSpaceNormal( model ){
        // glTF currently supports only tangent-space normal maps.
        // this model has been modified to demonstrate the use of an object-space normal map.

        model.material.normalMapType = ObjectSpaceNormalMap;

        // attribute normals are not required with an object-space normal map. remove them.
        //model.geometry.deleteAttribute( 'normal' );
        //model.geometry.deleteAttribute( 'tangent' );

        //console.log(model, model.material)
    },

    add: ( name, node, type ) => {
        Pool.set( name, node, type );
        Pool.next();
        //console.log( name, type )
    },

    getMaterial:( name ) => ( Pool.data.get( 'M_' + name ) ),

    //getMap:( name, o = {} ) => ( Pool.getTexture(name, o) ),


    //--------------------
    //   TEXTURES
    //--------------------

    texture:( o = {} ) => {

        if( !Pool.loaderMap ) Pool.loaderMap = new TextureLoader();

        let name = o.name || '';

        if( o.url ){ 
            if( o.url.lastIndexOf('.') !==-1 ) name = o.url.substring( o.url.lastIndexOf('/')+1, o.url.lastIndexOf('.') );
            else name = o.url.substring( o.url.lastIndexOf('/')+1 );
        }

        if( name.search('_c') !== -1 || name.search('_l') !== -1 || name.search('_u') !== -1|| name.search('_d') !== -1) o.srgb = true;

        if( Pool.exist( name, 'texture' )) return Pool.get( name, 'texture' );
        else if( Pool.exist( name, 'image' )) {
            //console.log('preload', name )
            return Pool.getTexture( name, o );
        } else {

            return Pool.loaderMap.load( o.url, function ( t ) { 
                //console.log('use TextureLoader !!', name )
                Pool.setTextureOption( t, o );
                Pool.data.set( 'T_' + name, t );
                if( o.callback ) o.callback();
                return t
            })
        }
            
        

    },

    getTexture:( name, o = {} ) => {

        let k = o.quality ? o.quality+'k_' : ''; 
        name = k + name;

        //console.log(name)

        let t = Pool.get( name, 'texture' );
        if(!t){
            let im = Pool.get( name, 'image' );
            if(!im){ 
                //console.log('not find image', name );
                return null
            }
            t = new Texture( im );
            if( name.search('_c') !== -1 || name.search('_d') !== -1 || name.search('_l') !== -1 || name.search('_u') !== -1 ) o.srgb = true;
            Pool.data.set( 'T_' + name, t );
        }
        Pool.setTextureOption( t, o );
        return t;
    },

    setTextureOption:( t, o = {} ) => {

        //if( o.colorSpace ) t.colorSpace = o.colorSpace;
        if( o.encoding ) t.colorSpace = SRGBColorSpace;
        if( o.srgb ) t.colorSpace = SRGBColorSpace;
        t.flipY = o.flipY!== undefined || o.flip !== undefined ? o.flipY : false;

        if( o.anisotropy ){
            t.anisotropy = o.anisotropy === 'max' ? Pool.maxAnisotropy : o.anisotropy;
        }
           
        //if( o.anisotropy !== undefined ) t.anisotropy = o.anisotropy
        if( o.generateMipmaps !== undefined ) t.generateMipmaps = o.generateMipmaps;
        if( o.repeat ){
            t.repeat.fromArray( o.repeat );
            t.wrapS = t.wrapT = RepeatWrapping;
        }

        if( o.center ) t.center.fromArray( o.center );
        if( o.offset ) t.offset.fromArray( o.offset );
        
        if( o.filter ){
            if( o.filter === 'near' ){
                t.minFilter = NearestFilter;
                t.magFilter = NearestFilter;
            }
        }

        if( o.channel ) t.channel = o.channel;
        t.needsUpdate = true;

    },

    

    ///

    loadAsync: ( Urls, Path = '', msg = '' ) => {

        return new Promise((resolve, reject) => {

            Pool.waiting = true;
            Pool.load( Urls, () => { Pool.waiting = false; }, Path, msg );

            //if (!Pool.waiting) resolve()
            //Pool.load( Urls, resolve, Path, msg );

        })

    },

    ///

    load: ( Urls, Callback, Path = '', msg = '', quality = 0 ) => {

        Pool.msg = msg;

        let urls = [];
        let callback = Callback || function(){};
        let start = ( typeof performance === 'undefined' ? Date : performance ).now();

        if ( typeof Urls === 'string' || Urls instanceof String ) urls.push( Urls );
        else urls = urls.concat( Urls );

        Pool.tmp.push( { urls:urls, path:Path, callback:callback, start:start, quality:quality } );

        if( !Pool.inLoad ) Pool.loadOne();

    },

    loadOne: () => {

        Pool.inLoad = true;
        Pool.onLoad();

        let url = Pool.tmp[0].path + Pool.tmp[0].urls[0];
        let name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        let type = url.substring( url.lastIndexOf('.')+1 ).toLowerCase();

        if( type==='jpg' || type==='png' ) name = (Pool.tmp[0].quality ? Pool.tmp[0].quality+'k_':'') + name;

        //console.log(name)

        if( Pool.exist( name, type ) ) Pool.next();
        else Pool.loading( url, name, type );

    },

    next: () => {

        Pool.tmp[0].urls.shift();

        if( Pool.tmp[0].urls.length === 0 ){

            Math.floor(( typeof performance === 'undefined' ? Date : performance ).now() - Pool.tmp[0].start);

            //if( end !== 0 ) console.log( 'pool load time:', end, 'ms' );
            
            Pool.tmp[0].callback();
            Pool.tmp.shift();

            if( Pool.tmp.length > 0 ) Pool.loadOne();
            else {
                Pool.inLoad = false;
                Pool.clearDRACO();
                Pool.onEnd();
            }

        } else {

            Pool.loadOne();

        }

    },

    loading: ( url, name, type ) => {

        Pool.log( Pool.msg );

        switch( type ){
            
            case 'glb': case 'gltf': Pool.load_GLTF( url, name );  break;
            case 'fbx': case 'FBX': Pool.load_FBX( url, name ); break;
            case 'obj': Pool.load_OBJ( url, name ); break;
            case 'stl': Pool.load_STL( url, name ); break;

            case 'ktx2': Pool.load_KTX2( url, name );  break;
            case 'hdr': Pool.load_RGBE( url, name ); break;
            case 'exr': Pool.load_EXR( url, name ); break;
            default: Pool.extand( url, name, type );
        }

    },

    extand: ( url, name, type ) => {

        if( !Pool.XHTTP ) Pool.XHTTP = new XMLHttpRequest();
        const xml = Pool.XHTTP;

        xml.open('GET', url, true );
        if(type === "json") xml.overrideMimeType( "application/json");

        switch( type ){

            case 'bin': case 'hex': case 'wasm': case 'mp3': case 'wav': case 'ogg': xml.responseType = "arraybuffer"; break;
            case 'jpg': case 'png': xml.responseType = 'blob'; break;
            case 'bvh': case 'glsl': case 'js':  case 'json': xml.responseType = 'text'; break;

        }

        xml.onreadystatechange = function () {

            if ( xml.readyState === 4 ) {
            	if (xml.status >= 300) {
                    console.log("Error, status code = " + xml.status);
                } else {
                    //console.log(xml.response)
                	Pool.direct( xml.response, name, type );
                    //Pool.add( name, JSON.parse( xhr.responseText ), 'json' )
                }
                //if ( Pool.XML.status === 200 || Pool.XML.status === 0 ) Pool.load_direct( Pool.XML.response, name, type );
                //else console.error( "Couldn't load ["+ name + "] [" + Pool.XML.status + "]" );
            }

        };

        if ('onprogress' in xml){
            xml.onprogress = function(e) {
                //console.log( parseInt((e.loaded / e.total) * 100) );
            };
        }

        xml.send(null);

    },

    direct: ( response, name, type ) => {

        switch( type ){
        	case 'jpg': case 'png':
                let img = Pool.createElementNS('img');
                img.onload = function(e) {
                    window.URL.revokeObjectURL( img.src ); // Clean up after yourself.
                    Pool.add( name, img, 'image' );
                };
                img.src = window.URL.createObjectURL( response );

        	    /*let img = Pool.createElementNS('img');
	            img.src = window.URL.createObjectURL( new Blob([response]) );
                //img.onload = function(){
                    console.log(img)
                    Pool.add( name, img, 'image' );
                //}*/
        	break;
            case 'mp3': case 'wav': case 'ogg':
                AudioContext.getContext().decodeAudioData(
                    response.slice( 0 ),
                    function( buffer ){ Pool.add( name, buffer, 'sound' ); },
                    function( error ){ console.error('decodeAudioData error', error); }
                );
            break;
            case 'hex': case 'bin': LZMA.decompress( response, ( result ) => { Pool.add( name, result, type ); }); break;
            case 'wasm': Pool.add( name, new Uint8Array( response ), type ); break;
            case 'json': Pool.add( name, JSON.parse( response ), type ); break;
            case 'js': Pool.add( name, response, type ); break;
            default: Pool.add( name, response, type );

        }

    },

    //////////////////////////////////

    clearDRACO: () => {

        if( Pool.dracoLoader ){
            Pool.dracoLoader.dispose();
            Pool.dracoLoader = null;
        }

        if( Pool.GLTF ){
            Pool.GLTF = null;
        }

    },

    loaderDRACO: () => {

        if( Pool.dracoLoader ) return Pool.dracoLoader

        if( !Pool.dracoLoaderType ){
            if ( navigator.userAgentData ) Pool.dracoLoaderType = 'wasm';
            else {
                let ua = navigator.userAgent.toLowerCase();
                Pool.dracoLoaderType = (ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1) ? 'js' : 'wasm';
            }

            //console.log(Pool.dracoLoaderType)
        }

        Pool.dracoLoader = new DRACOLoader().setDecoderPath( Pool.dracoPath );
        //Pool.dracoLoader.setWorkerLimit(1)
        Pool.dracoLoader.setDecoderConfig( { type: Pool.dracoLoaderType } );
        return Pool.dracoLoader

    },

    loaderKTX2: () => {

        if( !Pool.KTX2 ){
            Pool.KTX2 = new KTX2Loader( Pool.manager )
                .setTranscoderPath( Pool.basisPath )
                .detectSupport( Pool.renderer );
        }
        return Pool.KTX2

    },

    loaderGLTF: () => {

        if( !Pool.GLTF ){
            Pool.GLTF = new GLTFLoader( Pool.manager )
            .setCrossOrigin('anonymous');

            if(Pool.formatGltf.draco) Pool.GLTF.setDRACOLoader( Pool.loaderDRACO() );
            if(Pool.formatGltf.ktx2) Pool.GLTF.setKTX2Loader( Pool.loaderKTX2() );
            if(Pool.formatGltf.meshop) Pool.GLTF.setMeshoptDecoder( MeshoptDecoder );
        }
        return Pool.GLTF

    },

    loaderFBX: () => {

        if( !Pool.FBX ) Pool.FBX = new FBXLoader( Pool.manager );
        return Pool.FBX

    },

    loaderSTL: () => {

        if( !Pool.STL ) Pool.STL = new STLLoader( Pool.manager );
        return Pool.STL

    },

    loaderOBJ: () => {

        if( !Pool.OBJ ) Pool.OBJ = new OBJLoader( Pool.manager );
        return Pool.OBJ

    },

    loaderRGBE: () => {

        if( !Pool.RGBE ) Pool.RGBE = new RGBELoader( Pool.manager );
        return Pool.RGBE

    },

    loaderEXR: () => {

        if( !Pool.EXR ) Pool.EXR = new EXRLoader( Pool.manager );
        return Pool.EXR

    },

    //////////////////////////////////

    load_GLTF: ( url, name ) => {

        /*Pool.loaderGLTF().setDRACOLoader( Pool.loaderDRACO() ).load( url, function ( gltf ) { 
            Pool.add( name, gltf.scene )
            Pool.dracoLoader.dispose()
        })*/

        Pool.loaderGLTF().load( url, function ( gltf ) {

            const model = gltf.scene;

            //console.log(gltf.animations)

            if( gltf.animations ){ 
                const animations = gltf.animations;
                const mixer = new AnimationMixer( gltf.scene );
                model.mixer = mixer;
                model.actions = {};
                for ( let i = 0; i < animations.length; i ++ ) {
                    let anim = animations[ i ];
                    model.actions[ anim.name ] = mixer.clipAction( anim );
                    //model.actions[ anim.name ].play()
                }

                model.play = (name) => {
                    if(model.actions[ name ]){ 
                        model.actions[ name ].paused = false;
                        model.actions[ name ].time = 0;
                        model.actions[ name ].play();
                    }
                };
                model.pause = (name, v=true) => {
                    if(model.actions[ name ]) model.actions[ name ].paused = v;
                };
            }
            
            Pool.add( name, model );
            //Pool.clearDRACO()
        });

    },

    load_FBX: ( url, name ) => {

        Pool.loaderFBX().load( url, function ( node ) { Pool.add( name, node ); });

    },

    load_OBJ: ( url, name ) => {

        Pool.loaderOBJ().load( url, function ( node ) { Pool.add( name, node ); });

    },

    load_STL: ( url, name ) => {

        Pool.loaderSTL().load( url, function ( node ) { 
            let object = new Mesh( node );
            Pool.add( name, object ); 
        });

    },

    load_KTX2: ( url, name, cb ) => {

        Pool.loaderKTX2().load( url, function ( texture ) {
            Pool.add( name, texture ); 
            //console.log(texture)
            //if(cb) cb(texture)
            return texture
        });

    },

    load_RGBE: ( url, name ) => {

        Pool.loaderRGBE().load( url, function ( texture ) {
            texture.mapping = EquirectangularReflectionMapping; 
            Pool.add( name, texture ); 
        });

    },

    load_EXR: ( url, name, cb ) => {

        Pool.loaderEXR().load( url, function ( texture ) {
            //Pool.add( name, texture ) 
            //console.log(texture)
            if(cb) cb(texture);
            return texture
        });

    },

    direct_EXR: ( data, name ) => {

        Pool.loaderEXR().parse( url, function ( texture ) {
            Pool.add( name, texture );
            return texture
        });

    },

};

//import { Motor } from '../motor/Motor.js'

/** __
*    _)_|_|_
*   __) |_| | 2023
* @author lo.th / https://github.com/lo-th
*/


const Styles = {
    menuName:'font-size:14px; font-weight:400; letter-spacing: -0.022em; text-shadow: 1px 1px 2px black;',
    demoName:'font-size:14px; width:fit-content; font-weight:400; letter-spacing: -0.022em; text-shadow: 1px 1px 2px black;',
};
//text-shadow: 1px 1px 3px #000000;
//letter-spacing: -0.022em;

let Main$3 = null;


//

const marge = [40,40];

let svg$1 = h$2.dom;
let setSvg = h$2.setSvg;
let grad = h$2.makeGradiant;

let parent;
let content$1, cross = null, border, txt, loader, textRight;
let unselectable = '-o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none; pointer-events:none; ';

let menu, title, engine, demo, downMenu, innerMenu, zoning, guiButton, prevOver, tmpLeft = 0;
let corner;

let top$1 = null;
let maxHeight = 0;
let maxListItem = 10;

let guiOpen = false;

let currentMenu = '';

let h1,h2;

const listdata = {
    home : ['Code', 'Worker', 'Github', 'Docs'],
    engine : [],
    demo:[],
    visited:[],
};

let isDisplay = false;

let a_base = [ 1, 0, 0, 1,   0, 1, -1, 0,  -1, 0, 0, -1,   0, -1, 1, 0 ];
let fps = null;
let statistics = null;
let debug$1 = null;

let lock = false;

let isDay = false;
let color$2 = '';
let colorVisite = '';
let colorDemo = 'rgba(255,235,205,0.7)';
let panelBackground = '';
let topDown = null;

let bgBlur = 'blur(4px)';
let dayColor = ['#000', '#444', '#feb', 'rgba(213,211,212,0.32)'];
let nightColor = ['#fff', '#bee', '#bfb', 'rgba(0,0,0,0.4)'];

let engineLogo = null;



let setting$6 = {
    cross:4,
    border:'#020206',
};

let p0 = 'M 0.5 1.5 L 9.5 1.5 M 0.5 5.5 L 9.5 5.5 M 0.5 9.5 L 9.5 9.5';
let p1 = 'M 1.5 0.5 L 1.5 9.5 M 5.5 0.5 L 5.5 9.5 M 9.5 0.5 L 9.5 9.5';

class Hub {

    static setMain( r ) { Main$3 = r; }

    static setColors( day ) {

        color$2 = day ? dayColor[0] : nightColor[0];
        colorVisite = day ? dayColor[1] : nightColor[1];
        colorDemo = day ? dayColor[2] : nightColor[2];
        panelBackground = day ? dayColor[3] : nightColor[3];
        isDay = day;

        if(!content$1) return;

        content$1.style.color = color$2;
        document.querySelector("#svgLogo").setAttributeNS(null, 'stroke', color$2 );
        document.querySelector("#guiPath").setAttributeNS(null, 'stroke', color$2 );
        document.querySelector("#svgLoader").setAttributeNS(null, 'fill', color$2 );
       //top.style.background = panelBackground;

    }

    static reset() {

        Hub.log();
        if( cross ) content$1.removeChild( cross );
        cross = null;
        
    }

    static resize ( s ){

        tmpLeft = s.left;
        content$1.style.left = tmpLeft + "px";
        content$1.style.width = tmpLeft !== 0 ? 'calc(100% - ' + tmpLeft + 'px)' : '100%';

    }

    static init ( Camera, Size, text, Parent ) {

        if( isDisplay ) return;

        Hub.setColors( isDay );
        parent = Parent || document.body;

        //const fragment = document.createDocumentFragment();

        content$1 = document.createElement( 'div' );
        content$1.style.cssText = unselectable + 'position:absolute; margin:0; padding:0; top:0px; left:0px; width:100%; height:100%; display:block; color:'+color$2+';';// font-family: Mulish,sans-serif;
        parent.appendChild( content$1 );

        content$1.addEventListener( 'contextmenu', (e)=>{e.preventDefault();}, false );

        // for extra gui
        corner = document.createElement( 'div' );
        corner.style.cssText = unselectable + 'position:absolute; margin:0; padding:0; top:0px; left:0px; width:1px; height:1px; display:block; background:none;';// font-family: Mulish,sans-serif;
        content$1.appendChild( corner );

        
        txt = document.createElement( 'div' );
        txt.style.cssText = " color: #fff; font-size:16px; text-align:center; position:absolute; margin:0; padding:0; top:50%; left:50%; width:512px; height:20px; margin-left:-256px; margin-top:-38px; display:block; pointer-events:none; text-shadow: 2px 2px #000000;";
        txt.textContent = text || 'load...';
        content$1.appendChild( txt );

        loader = document.createElement( 'div' );
        loader.style.cssText = "position:absolute; top:50%; left:50%; width:60px; height:60px; margin-left:-30px; margin-top:-30px; display:block; ";
        loader.innerHTML = this.miniLoader( '#000' );
        content$1.appendChild( loader );
        

        //loader.textContent = 'load...';
        //this.addJoystick()

        //this.addBorder()
        //this.init3dHub()

        isDisplay = true;

    }

    static getCorner() {
        return corner;
    }

    static removeJoystick() {
        return
    }

    static addJoystick () {
        //joy = UIL.add('Joystick', {  w:120, mode:1, text:false, precision:1, pos:{left:'10px', bottom:'10px' }, target:content, simple:true, ...ccs }).onChange( function(v){ Motor.setKey(0, v[0]); Motor.setKey(1, v[1]) } )
        //joy.neverlock = true
    }

    static snipperMode ( b ) {

    }

    /*static loadSvg ( url, div ) {

        var xhr = new XMLHttpRequest();
        xhr.open("GET",url,true);
        xhr.overrideMimeType("image/svg+xml");
        xhr.onload = function(e) {
            if( this.status == 200 ) div.appendChild( xhr.responseXML.documentElement );
        }
        xhr.send("");

    }*/

    /*clear: function () {

        if( !isDisplay ) return;

        if( tween !== null ){ TWEEN.remove( tween ); alpha = { n:1 } }

        tween = new TWEEN.Tween( alpha ).to( { n:0 }, 2000 )
            .easing( TWEEN.Easing.Quadratic.Out )
            .onUpdate( function() { intro.opacity ( alpha.n ); } )
            .onComplete( function () { intro.dispose(); } )
            .start();

    },*/

    static log ( t = '' ) {

        if( debug$1 === null ) return;
        debug$1.innerHTML = t;

    }

    static setFps ( t ) {

        if( fps === null ) return;
        fps.innerHTML = t;

    }

    static showTimeTest ( t ) {

        if( statistics === null ) return;
        let txt = JSON.stringify(t, null, 2);
        txt = txt.replace(/[",*+?^${}()|[\]\\]/g, '');
        statistics.textContent = txt;

    }

    static setStats ( txt = '' ) {

        statistics.textContent = txt;

    }

    static endLoading () {

        loader.style.top = (marge[1]-1)+'px';
        loader.style.left = (marge[0]+20)+'px';
        //content.removeChild( loader )
        
        content$1.removeChild( txt );
        //txt.style.top = '50px'
        //txt.textContent ='';
        //txt.style.display = 'none'

        Pool.setLoadEvent(
            function(){ loader.style.display = 'block'; },
            function(){ loader.style.display = 'none'; }
        );

        


        /*let logo = `<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none;' 
        preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 256 256'>
        <path id='svgLogo' stroke='${color}' stroke-width='30' style='stroke-opacity: 1;' stroke-linejoin='round' stroke-linecap='round' 
        fill='none' d='M 72.85 52.85 Q 70.9 53.8 69.15 55 45 72.35 45 96.5 45 120.65 69.15 137.7 93.55 155 127.95 155 L 127.95 37.95 Q 
        162.35 37.95 186.5 55 210.9 72.35 210.9 96.5 210.9 120.65 186.5 137.7 162.35 155 127.95 155 L 127.95 237.95'/></svg>`*/

        /*let logo = `<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none;' 
        preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 40 40'>
        <path id='svgLogo' stroke='${color}' stroke-width='4' transform='translate(0, 4)' stroke-linejoin='round' stroke-linecap='round' 
        fill='none' d='${iLogo}''></svg>`*/



        let bg = 'none';//'rgba(255,255,255,0.1)'
        let bg2 = 'none';//'rgba(255,0,0,0.5)'

        zoning = document.createElement( 'div' );
        zoning.style.cssText = 'position:absolute; top:20px; background:'+bg2+'; left:60px; pointer-events:auto;';
        zoning.id = 'zone';
        //zoning.style.background = 'rgba(10,0,0,0.2)'
        content$1.appendChild( zoning );

        {
            topDown = document.createElement( 'div' );
            topDown.style.cssText = 'position:absolute; top:0px; left:0px; height:0px; width:100%; pointer-events:none; transition:all 0.12s allow-discrete ease-out; transition-property: height, opacity; ';
            //topDown.style.cssText += 'border-bottom: 1px solid black;';
            topDown.style.opacity = 0;
            topDown.style.background = panelBackground;
            topDown.style.backdropFilter = bgBlur;
            content$1.appendChild( topDown );
        }

        menu = document.createElement( 'div' );
        menu.style.cssText = 'position:absolute; top:24px; background:'+bg+'; left:'+marge[0]+'px; display:flex; align-self: stretch; justify-content: flex-start; gap: 0px 6px; align-items:baseline; ';
        content$1.appendChild( menu );

        downMenu = document.createElement( 'div' );
        downMenu.style.cssText = 'position:absolute; top:60px; left:'+marge[0]+'px; overflow:hidden; background:'+bg+'; height:0px; width:0px;';//'top:54px; width:0px;' //transition: all .1s ease-in-out;
        //downMenu.style.background = 'rgba(10,10, 10,0.2)'
        content$1.appendChild( downMenu );

        innerMenu = document.createElement( 'div' );
        innerMenu.style.cssText = 'box-sizing: border-box; position:absolute; overflow:hidden; background:'+bg+'; display:flex; flex-wrap:warp; opacity:0; transition-delay: 0.12s; transition:opacity 0.5s allow-discrete ease-out;';
        downMenu.appendChild( innerMenu );
        

        zoning.addEventListener("pointerleave", (e) => {
            lock = false;
            //Hub.hideMenu()
            setTimeout( function(){
                if(!lock) Hub.hideMenu(); 
            }, 100 );
        });
        //zoning.addEventListener("pointerdown", (e) => { lock = true });

        zoning.addEventListener("pointermove", Hub.moving );

        title = document.createElement( 'div' );
        menu.appendChild( title );
        title.id = 'home';
        title.innerHTML = Hub.miniIcon('logo', color$2 );

        engine = document.createElement( 'div' );
        engine.style.cssText = Styles.menuName;//'font-size:16px; ';//font-weight:700;
        engine.id = 'engine';
        menu.appendChild( engine );
        
        demo = document.createElement( 'div' );
        demo.style.cssText = Styles.menuName;//'font-size:16px; '//'font-size:16px; font-weight:500;'font-weight:700; 
        demo.id = 'demo';
        menu.appendChild( demo );
        
        this.effect(title);
        this.effect(engine);
        this.effect(demo);


        debug$1 = document.createElement( 'div' );
        debug$1.style.cssText = 'position:absolute; width:300px; bottom:15px; left:'+(marge[0]+8)+'px; font-size:12px; vertical-align:bottom; text-align:left;';
        //debug.style.cssText = 'position:absolute; background:'+bg+'; width:300px; margin-left:-150px; bottom:25px; left:50%; font-size:14px; font-weight:500; vertical-align:bottom; text-align:center;'
        content$1.appendChild( debug$1 );

        statistics = document.createElement( 'div' );
        statistics.style.cssText = 'position:absolute; bottom:25px; left:10px; font-size:14px; width:400px; white-space: pre; line-height:20px; margin-left:10px;';
        content$1.appendChild( statistics );

        // gui bg
        top$1 = document.createElement( 'div' );
        top$1.style.cssText = unselectable + "position:absolute; top:0px; right:0px; width:260px; height:100%; background:"+panelBackground+"; display:none;";
        top$1.style.backdropFilter = bgBlur;
        content$1.appendChild( top$1 );

        fps = document.createElement( 'div' );
        fps.style.cssText = Styles.menuName + 'position:absolute; top:33px; right:'+(marge[0]+20)+'px; text-align:right; ';
        content$1.appendChild( fps );

        guiButton = document.createElement( 'div' );
        guiButton.style.cssText = 'position:absolute; right:'+marge[0]+'px;  top:31px; pointer-events:auto; cursor: pointer;';
        content$1.appendChild( guiButton );
        guiButton.innerHTML = `<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none;' 
        preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='10px' height='10px' viewBox='0 0 10 10'>
        <path stroke='${color$2}' id='guiPath' stroke-width='1' fill='none' d='${p0}'/></svg>`;
        guiButton.addEventListener("pointerdown", Main$3.showGui );

        /*let mouse = document.createElement( 'div' );
        mouse.style.cssText = 'position:absolute; right:80px;  top:27px; pointer-events:auto; cursor: pointer;'
        content.appendChild( mouse )
        mouse.id = 'mouse'
        mouse.innerHTML = Hub.miniIcon('drag', color );*/


        //Hub.colors(true)

    }

    static setTopColor ( c = '#000000' ) {
        //if(top) top.style.background = c
    }

    static harmony ( v ) {

        let lineColor = 'rgba(0,0,0,0.5)';

        if(v){
            if(!h1 && !h2){
                h1 = document.createElement( 'div' );
                h1.style.cssText = 'position:absolute; top:33.33%; width:100%; height:33.33%; border-top:1px dashed '+lineColor+'; border-bottom:1px dashed '+lineColor+';';
                content$1.appendChild( h1 );

                h2 = document.createElement( 'div' );
                h2.style.cssText = 'position:absolute; left:33.33%; height:100%; width:33.33%; border-left:1px dashed '+lineColor+'; border-right:1px dashed '+lineColor+';';
                content$1.appendChild( h2 );
            }
        } else {
            if(h1 && h2){
                content$1.removeChild( h1 );
                content$1.removeChild( h2 );
                h1 = null;
                h2 = null;
            }
        }
        
    }

    static miniLoader( color ){
        return `
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
        viewBox="0 0 100 100" enable-background="new 0 0 0 0" xml:space="preserve">
        <path id="svgLoader" fill="${color}" d="M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50 M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50">
        <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="1s" from="0 50 50" to="360 50 50" repeatCount="indefinite" />
        </path></svg>
        `
    }

    static miniIcon( name, color ){

        let p;

        switch(name){
            case 'logo' : p = 'M 11.2 7.3 Q 10.9 7.45 10.6 7.7 6.75 10.45 6.75 14.35 6.75 18.15 10.6 20.9 14.5 23.65 20 23.65 L 20 4.95 Q 25.5 4.95 29.4 7.7 33.25 10.45 33.25 14.35 33.25 18.15 29.4 20.9 25.5 23.65 20 23.65 L 20 35'; break
            case 'drag' : p = 'M 23.975 7.025 Q 21.93 5 19 5 L 5 5 M 12 19 L 5 19 M 19 12 L 19 35 35.15 28.9 19 12 Z'; break
            case 'build' : p = 'M 20 20 L 20 5 35 5 35 20 35 35 20 35 5 35 5 20 20 20 35 20 M 20 20 L 20 35'; break
            case 'cible' : p = 'M 27.05 12.95 Q 30 15.8 30 20 30 24.1 27.05 27.05 24.1 30 20 30 15.8 30 12.95 27.05 10 24.1 10 20 10 15.8 12.95 12.95 15.8 10 20 10 24.1 10 27.05 12.95 Z M 35 20 L 32 20 M 20 5 L 20 8 M 8 20 L 5 20 M 20 32 L 20 35'; break
        }

        return `<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none;' 
        preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 40 40'>
        <path id='svgLogo' stroke='${color}' stroke-width='3' transform='translate(0, 4)' stroke-linejoin='round' stroke-linecap='round' 
        fill='none' d='${p}''></svg>`

    }

    static switchGuiButton( b ){

        topDown.style.width = b ? 'calc(100% - 260px)': '100%';

        document.querySelector("#guiPath").setAttributeNS(null, 'd', b ? p1 : p0);
        guiOpen = b;
        top$1.style.display = b ? 'block':'none';

        let cc = b ? nightColor[0] : color$2;
        document.querySelector("#guiPath").setAttributeNS(null, 'stroke', cc );
        fps.style.color = cc;

    }

    static hideMenu () {

        Hub.clearLogoImage();

        downMenu.style.height = '0px';
        innerMenu.innerHTML = '';
        //innerMenu.style.background = 'none';
        
        zoning.style.width = '0px';
        zoning.style.height = '0px';
        currentMenu = '';
        { 
            topDown.style.height = '0px';
            topDown.style.opacity = 0;
        }
        
        innerMenu.style.opacity = 0;
        
        Hub.updatePad(null);

    }

    static showMenu ( target ) {

        let type = target.id;

        if( currentMenu === type ) return;

        Hub.hideMenu();

        currentMenu = type;

        //downMenu.style.left = ( type === 'engine' ? 125:80 ) + 'px'
        //if(type === 'home') downMenu.style.left = '70px'
        downMenu.style.left = marge[0] + 'px';
        if(type === 'home') downMenu.style.left = (marge[0]-10) + 'px';
        if(type === 'engine'){ 
            downMenu.style.left = (marge[0]+36) + 'px';
            Hub.addLogoImage();
        } else {
            Hub.clearLogoImage();
        }

        let list = listdata[ type ];
        /*type === 'demo' ?  demolist : engineList
        if( type === 'logo') list = ['Github', 'About']*/
        let i = list.length, m, n=0, itemH = 0, name;

        //innerMenu.style.cssText = " top:0px; width:auto; display:flex; flex-direction:column; "
        innerMenu.style.padding = '10px 0px';
        innerMenu.style.top = '0px';
        innerMenu.style.width = 'auto';
        innerMenu.style.display = 'flex';
        innerMenu.style.flexDirection = 'column';
        //innerMenu.style.background = panelBackground;
        //innerMenu.style.border = '4px solid rgba(20,20,20,0.1)'
        innerMenu.style.opacity = 1;
        
        while( i-- ){

            name = list[n];
            m = document.createElement( 'div' );
            innerMenu.appendChild( m );
            m.classList.add("down");
            
            m.style.cssText = Styles.demoName;//'font-size:14px; width:fit-content; padding:4px 10px; text-shadow: 1px 1px #000000;';//type === 'demo' ? 'font-size:16px; font-weight:500;' : 'font-size:16px; font-weight:700;'font-weight:700; 
            m.id = name;
            m.textContent = name;
            //m.style.background = '#ff00ff'

            if( listdata.visited.indexOf(name) !== -1 ) m.style.color = colorVisite;
            if( Main$3.devDemo[name] ) m.style.color = colorDemo;
            if( name === 'Worker' ) m.style.color = Main$3.isWorker ? color$2 : colorVisite;
            if( name === 'Code' ) m.style.color = Main$3.isEditor ? color$2 : colorVisite;

            if( n===0 ) itemH = m.offsetHeight;
            //bb[n] = m
            
            this.effect( m, true );
            n++;

        }

        
        let rect = innerMenu.getBoundingClientRect();
        let max = maxListItem * itemH;
        let maxH = n * itemH; 
        maxHeight = maxH > max ? max : rect.height;

        //if( ratio !== 1 && full ){
        if( type === 'demo' ){
            innerMenu.style.display = 'grid';
            innerMenu.style.gridTemplateColumns = 'repeat(auto-fill, 120px)';
            innerMenu.style.justifyContent = 'space-between';
            let dw = guiOpen ? (255+80) : 160; 

            downMenu.style.left = 80 + 'px';
            downMenu.style.width = 'calc(100% - '+dw+'px)';
            innerMenu.style.width = '100%';
            rect = innerMenu.getBoundingClientRect();
            
            downMenu.style.height = rect.height+'px';//maxHeight + 'px'

        } else {
            downMenu.style.width = rect.width + 'px';
            downMenu.style.height = maxHeight + 'px';
            
        }

        zoning.style.left = (rect.left-20) + 'px';
        zoning.style.width = (rect.width + 40) + 'px';
        zoning.style.height = (rect.height + 50) + 'px';
        //zoning.style.height = (rect.height + 70) + 'px';

        //const rect = elem.getBoundingClientRect();

        { 
            topDown.style.height = 60 + rect.height+'px';
            topDown.style.opacity = 1;
        }

    }

    static upMenu () {

        engine.textContent = this.reformat( Main$3.engineType );
        demo.textContent = this.reformat( Main$3.currentDemo );

        listdata.visited.push( demo.textContent );

        let list = [...Main$3.demoList];
        list.splice(list.indexOf(Main$3.currentDemo), 1);
        list.sort();
        list = list.map( x => Hub.reformat(x) );

        listdata.demo = list;

        list = [...Main$3.engineList];
        list.sort();
        list.splice(list.indexOf(Main$3.engineType), 1);
        list = list.map( x => Hub.reformat(x) );

        listdata.engine = list;

    }

    static reformat ( n ) {

        return n.toUpperCase().substring(0,1) + n.substring(1).toLowerCase();

    }

    static effect ( dom, item ) {

        dom.classList.add("menu");

        if(!Main$3.isMobile) dom.addEventListener("pointermove", Hub.moving );

        dom.style.padding = '4px 10px';

        dom.addEventListener( 'pointerleave', (e) => {
            e.target.style.fontWeight = 400;
        });
       
        dom.addEventListener("pointerdown", (e) => {
            //e.target.style.textDecoration = 'underline ' + color;
            if( e.target.id === 'home' || e.target.id === 'engine' || e.target.id === 'demo' ) Hub.showMenu( e.target );
            else Hub.onClick( e.target.id );
        });

    }

    static onClick ( name ) {

        lock = false;
        Hub.hideMenu();
        
        setTimeout( function(){ 
            if( listdata.engine.indexOf(name) !== -1 ) Hub.swapEngine( name );
            else if( listdata.home.indexOf(name) !== -1 ) Hub.homeLink( name );
            else Main$3.loadDemo( name.toLowerCase() ); 
        }, 100 );

    }

    static homeLink ( type ) {

        switch(type){
            case 'Github': window.open( 'https://github.com/lo-th/phy', '_blank'); break;
            case 'Docs': window.open( './docs/index.html#manual/Welcome', '_blank'); break;
            case 'Worker': Hub.swapWorker(); break;
            case 'Code': Hub.swapCode(); break;
        }

    }

    static swapWorker () {

        Main$3.isWorker = !Main$3.isWorker;
        Hub.swapEngine();

    }

    static swapCode () {

        Main$3.isEditor = !Main$3.isEditor;
        Main$3.showEditor(Main$3.isEditor);

    }

    static swapEngine ( type ) {

        if( !type ) type = Main$3.engineType;
        let name = type.toLowerCase();
        let hash = location.hash;
        let url = 'index';
        let param = 'E=';
        if( Main$3.devMode ) param += 'dev_';
        if( Main$3.isWorker ) param += 'w_';
        param += name;
        window.open( url+'.html?'+param+hash, '_self');

    }

    static updatePad ( t ) {
        if( t && t.id ){
            t.id === 'home' || t.id === 'engine' || t.id === 'demo'; 
            if( t.id === prevOver ) return false;

            prevOver = t.id;
        } else {
            prevOver = null;
        }

        return true;

    }

    static moving ( e ) {

        lock = true;
        if( e.target.id === 'zone'){ 
            return
        }

        e.target.style.fontWeight = 500;

        if( listdata.engine.indexOf(e.target.id) !== -1) Hub.setLogoImage( e.target.id );
        if( e.target.id === 'engine' ) Hub.setLogoImage();

        let isNewTarget = Hub.updatePad( e.target );
        if( !isNewTarget ) return;


        if( e.target.id === 'home' || e.target.id === 'engine' || e.target.id === 'demo' ){ 
            Hub.showMenu( e.target );
           // innerMenu.style.opacity = 1;
            return 
        }

        return 

    }

    static count ( data, fire ) {

        if( fire ){
            data.n--;
            data.t--;
        }

        textRight.textContent = data.n + ' / '+ data.t;

        if( data.n === 0 ) return 'reload';
        if( data.t === 0 ) return 'empty';
        return 'fire';

    }

    static dispose () {

        if( !isDisplay ) return;

        while (content$1.firstChild) content$1.removeChild(content$1.lastChild);
        parent.removeChild( content$1 );
        isDisplay = false;

    }


    //-------------------------
    //
    //  ENGINE LOGO
    //
    //-------------------------


    static clearLogoImage() {

        if(!engineLogo) return;
        menu.removeChild(engineLogo);
        engineLogo = null;

    }

    static addLogoImage() {

        if(engineLogo) return;
        Main$3.engineType.toLowerCase();
        engineLogo = new Image(256, 128);
        engineLogo.style.cssText = 'position:absolute; top:40px; left:200px; width:256px; height: 128px;';
        menu.appendChild(engineLogo);
        Hub.setLogoImage();

    }

    static setLogoImage( name ) {

        if(!engineLogo) return;
        name = name ? name.toLowerCase() : Main$3.engineType.toLowerCase();
        engineLogo.src = './assets/logo/'+name+'.png';

    }


    //-------------------------
    //
    //  BORDER
    //
    //-------------------------


    static addBorder() {

        let ccc = [ 
            [68, setting$6.border, 0], 
            [75, setting$6.border, 0.08], 
            [93, setting$6.border, 0.4],
            [100, setting$6.border, 0.6],
        ];

        var css =  "position:absolute; margin:0; padding:0; top:0; left:0; width:100%; height:100%; display:block; pointer-events:none;";

        border = svg$1( 'svg', css , { viewBox:'0 0 512 512', width:512, height:512, preserveAspectRatio:'none' } );
        svg$1( 'defs', '', {}, border );
        grad( 'radialGradient', { id:'grad', cx:0, cy:0, r:338, fx:0, fy:0, gradientTransform:'matrix( 0, 1, -1, 0, 256, 256 )', gradientUnits:"userSpaceOnUse" }, border, ccc );
        svg$1( 'rect', '', {  x:0, y:0, width:512, height:512, fill:'url(#grad)' }, border );

        content$1.appendChild( border );

    }


    //-------------------------
    //
    //  CROSS
    //
    //-------------------------

    static hideCross( b ) {

        cross.style.visibility = !b ? 'visible' : 'hidden';

    }

    static addCross() {

        var css =  "position:absolute; margin:0; padding:0; top:50%; left:50%; width:128px; height:128px; margin-left:-64px; margin-top:-64px; display:block;";
        cross = svg$1( 'svg', css , { viewBox:'0 0 64 64', width:64, height:64, preserveAspectRatio:'none' } );

        svg$1( 'defs', '', {}, cross );
        svg$1( 'path', '', { id:'cc', d:'M 0 1.5 L 0 -1.5', stroke:'#FFFFFF', 'stroke-width':2, fill:'none', 'stroke-linecap':'butt', 'vector-effect':'non-scaling-stroke' }, cross, 0 );
        svg$1( 'g', '', {}, cross );

        var g = cross.childNodes[1];

        for( var i = 0; i<4; i++ ){
            svg$1( 'g', '', {}, g );
            svg$1( 'use', '', { link:'#cc' }, g, i );
        }

        this.setCrossSize( setting$6.cross );

        content$1.appendChild( cross );

    }

    static setCross ( n, time ) {

        /*if( crossTween !== null ) TWEEN.remove( crossTween );

        crossTween = new TWEEN.Tween( setting ).to( { cross:n }, time || 300 )
        .easing( TWEEN.Easing.Quartic.Out )
        .onUpdate( function( o ) { this.setCrossSize( o.cross ); }.bind(this) )
        .start();*/

    }

    static setCrossSize ( d ) {

        let i,n, m, t = a_base;
        let p = [ 32, 32-d,   32+d, 32,   32, 32+d,   32-d, 32 ];

        for( i = 0; i<4; i++){
            m=i*4;
            n = i*2;
            setSvg( cross, 'transform', 'matrix( '+ t[m]+' '+t[m+1]+' '+t[m+2]+' '+t[m+3]+' '+p[n]+' '+p[n+1] +' )', 1, i );
        }

    }

   

}

//import { Main } from '../Main.js'
//import { Shader } from './Shader.js'

class Video {

    constructor (renderer) {

        this.renderer = renderer;
        this.isCapture = false;
        this.ready = false;

    }

    update(){
        if( this.isCapture ) this.capturer.capture( this.renderer.domElement );
    }
    
    stop(){

        if( !this.isCapture ) return;

        this.capturer.stop();
        this.capturer.save();
        
        this.isCapture = false;

    }

    start () {

        if( this.isCapture ) return;
        if( !this.ready ){ 
            this.loadCCapture();
            return
        }

        this.capturer = new CCapture( {

            verbose: false,
            display: false,
            framerate: 60,
            //motionBlurFrames: 1,//( 960 / framerate ) * 0 ,
            quality: 50,//80
            format:"webm-mediarecorder",
            //format:"webm",
            currentTime:0,
            timeLimit: 60,
            frameLimit: 0,
            autoSaveTime: 0,
            //autoSaveTime:10,
            //workersPath:'./js/',
            //timeLimit: 60,//second
            //frameLimit: 0,
            //autoSaveTime: 0,
            //onProgress: function( p ) { progress.style.width = ( p * 100 ) + '%' }
        });

        //console.log('CCapture is ready', this.capturer )
        this.isCapture = true;
        this.capturer.start();
        
    }

    

    loadCCapture () {

        var xml = new XMLHttpRequest();
        xml.open('GET', './src/libs/CCapture.all.min.js');
        xml.overrideMimeType( "text/javascript" );
        xml.onreadystatechange = function() {
            if ( xml.readyState === 4 ) {
                if ( xml.status === 200 || xml.status === 0 ) {
                    let n = document.createElement("script");
                    n.type = "text/javascript";
                    n.async = true;
                    n.charset = "utf-8";
                    n.text = xml.responseText;
                    document.getElementsByTagName('head')[0].appendChild(n);
                    this.ready = true;
                    this.start();
                }
                else console.error( "Couldn't load [ccapture] [" + xml.status + "]" );
            }
            
        }.bind(this);
        xml.send();

    }

   /* mode(){

        this.isCaptureMode = b;

        if( this.isCaptureMode ){

            window.removeEventListener( 'resize', view.resize );

            renderer.domElement.style.position = "absolute";
            renderer.domElement.style.left = "50%";
            renderer.domElement.style.top = "50%";
            renderer.domElement.style.border = '1px solid #F00';

            view.setVideoSize();
            view.initCapture();

        } else {

            renderer.domElement.style.position = "absolute";
            renderer.domElement.style.left = "0px";
            renderer.domElement.style.top = "0px";
            renderer.domElement.style.margin = '0px 0px';
            renderer.domElement.style.border = 'none';

            window.addEventListener( 'resize', view.resize );
            view.resize();

        }

    }*/

    /*size(){

        if( !isCaptureMode ) return;

        if( v !== undefined ) view.videoSize = v;

        var w = view.videoSize[0];
        var h = view.videoSize[1];
        renderer.domElement.style.margin = (-h*0.5)+'px '+ (-w*0.5)+'px';
        view.resize( null, w, h );

    }*/


}

/**
 * Ground projected env map adapted from @react-three/drei.
 * https://github.com/pmndrs/drei/blob/master/src/core/Environment.tsx
 */
class GroundProjectedSkybox extends Mesh {

	constructor( texture, options = {} ) {

		const isCubeMap = texture.isCubeTexture;

		const defines = [
			isCubeMap ? '#define ENVMAP_TYPE_CUBE' : ''
		];

		const vertexShader = /* glsl */ `
			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}
			`;
		const fragmentShader = defines.join( '\n' ) + /* glsl */ `

				varying vec3 vWorldPosition;

				uniform float radius;
				uniform float height;
				uniform float angle;

				#ifdef ENVMAP_TYPE_CUBE

					uniform samplerCube map;

				#else

					uniform sampler2D map;

				#endif

				// From: https://www.shadertoy.com/view/4tsBD7
				float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
				{

					float d = dot ( rd, n );

					if( d > 0.0 ) { return 1e6; }

					vec3 o = ro - c;
					float t = - dot( n, o ) / d;
					vec3 q = o + rd * t;

					return ( dot( q, q ) < r * r ) ? t : 1e6;

				}

				// From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
				float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) {

					vec3 oc = ro - ce;
					float b = dot( oc, rd );
					float c = dot( oc, oc ) - ra * ra;
					float h = b * b - c;

					if( h < 0.0 ) { return -1.0; }

					h = sqrt( h );

					return - b + h;

				}

				vec3 project() {

					vec3 p = normalize( vWorldPosition );
					vec3 camPos = cameraPosition;
					camPos.y -= height;

					float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
					if( intersection > 0.0 ) {

						vec3 h = vec3( 0.0, - height, 0.0 );
						float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
						p = ( camPos + min( intersection, intersection2 ) * p ) / radius;

					} else {

						p = vec3( 0.0, 1.0, 0.0 );

					}

					return p;

				}

				#include <common>

				void main() {

					vec3 projectedWorldPosition = project();

					#ifdef ENVMAP_TYPE_CUBE

						vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;

					#else

						vec3 direction = normalize( projectedWorldPosition );
						vec2 uv = equirectUv( direction );
						vec3 outcolor = texture2D( map, uv ).rgb;

					#endif

					gl_FragColor = vec4( outcolor, 1.0 );

					#include <tonemapping_fragment>
					#include <colorspace_fragment>

				}
				`;

		const uniforms = {
			map: { value: texture },
			height: { value: options.height || 15 },
			radius: { value: options.radius || 100 },
		};

		const geometry = new IcosahedronGeometry( 1, 16 );
		const material = new ShaderMaterial( {
			uniforms,
			fragmentShader,
			vertexShader,
			side: DoubleSide,
		} );

		super( geometry, material );

	}

	set radius( radius ) {

		this.material.uniforms.radius.value = radius;

	}

	get radius() {

		return this.material.uniforms.radius.value;

	}

	set height( height ) {

		this.material.uniforms.height.value = height;

	}

	get height() {

		return this.material.uniforms.height.value;

	}

}

/*! 
 * quantize.js Copyright 2008 Nick Rabinowitz.
 * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php
 */

 
/**
 * Basic Javascript port of the MMCQ (modified median cut quantization)
 * algorithm from the Leptonica library (http://www.leptonica.com/).
 * Returns a color map you can use to map original pixels to the reduced
 * palette. Still a work in progress.
 * 
 * @author Nick Rabinowitz
 * @example
// array of pixels as [R,G,B] arrays
var myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]
                // etc
                ];
var maxColors = 4;
var cmap = MMCQ.quantize(myPixels, maxColors);
var newPalette = cmap.palette();
var newPixels = myPixels.map(function(p) { 
    return cmap.map(p); 
});
 
 */
//var MMCQ = (function() {

    // fill out a couple protovis dependencies
    /*!
    * Block below copied from Protovis: http://mbostock.github.com/protovis/
    * Copyright 2010 Stanford Visualization Group
    * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php
    */
    const pv = {
        map: function(array, f) {
          var o = {};
          return f
              ? array.map(function(d, i) { o.index = i; return f.call(o, d); })
              : array.slice();
        },
        naturalOrder: function(a, b) {
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        },
        sum: function(array, f) {
          var o = {};
          return array.reduce(f
              ? function(p, d, i) { o.index = i; return p + f.call(o, d); }
              : function(p, d) { return p + d; }, 0);
        },
        max: function(array, f) {
          return Math.max.apply(null, f ? pv.map(array, f) : array);
        }
    };

    // private constants
    var sigbits = 5,
        rshift = 8 - sigbits,
        maxIterations = 1000,
        fractByPopulations = 0.75;
    
    // get reduced-space color index for a pixel
    function getColorIndex(r, g, b) {
        return (r << (2 * sigbits)) + (g << sigbits) + b;
    }
    
    // Simple priority queue
    function PQueue( comparator ) {
        var contents = [],
            sorted = false;
        
        function sort() {
            contents.sort(comparator);
            sorted = true;
        }
        
        return {
            push: function(o) {
                contents.push(o);
                sorted = false;
            },
            peek: function(index) {
                if (!sorted) sort();
                if (index===undefined) index = contents.length - 1;
                return contents[index];
            },
            pop: function() {
                if (!sorted) sort();
                return contents.pop();
            },
            size: function() {
                return contents.length;
            },
            map: function(f) {
                return contents.map(f);
            },
            debug: function() {
                if (!sorted) sort();
                return contents;
            }
        };
    }

    





    
    // histo (1-d array, giving the number of pixels in
    // each quantized region of color space), or null on error

    function getHisto( pixels ) {

        var histosize = 1 << (3 * sigbits), histo = new Array(histosize), index, rval, gval, bval;

        pixels.forEach(function(pixel) {
            rval = pixel[0] >> rshift;
            gval = pixel[1] >> rshift;
            bval = pixel[2] >> rshift;
            index = getColorIndex(rval, gval, bval);
            histo[index] = (histo[index] || 0) + 1;
        });
        return histo;

    }
    
    function vboxFromPixels( pixels, histo ) {

        var rmin=1000000, rmax=0, gmin=1000000, gmax=0, bmin=1000000, bmax=0, rval, gval, bval;
        // find min/max
        pixels.forEach(function(pixel) {
            rval = pixel[0] >> rshift;
            gval = pixel[1] >> rshift;
            bval = pixel[2] >> rshift;
            if (rval < rmin) rmin = rval;
            else if (rval > rmax) rmax = rval;
            if (gval < gmin) gmin = gval;
            else if (gval > gmax) gmax = gval;
            if (bval < bmin) bmin = bval;
            else if (bval > bmax)  bmax = bval;
        });
        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);

    }
    
    function medianCutApply( histo, vbox ) {

        if (!vbox.count()) return;
        
        var rw = vbox.r2 - vbox.r1 + 1, gw = vbox.g2 - vbox.g1 + 1, bw = vbox.b2 - vbox.b1 + 1, maxw = pv.max([rw, gw, bw]);
        // only one pixel, no split
        if (vbox.count() == 1) {
            return [vbox.copy()]
        }
        /* Find the partial sum arrays along the selected axis. */
        var total = 0,
            partialsum = [],
            lookaheadsum = [],
            i, j, k, sum, index;
        if (maxw == rw) {
            for (i = vbox.r1; i <= vbox.r2; i++) {
                sum = 0;
                for (j = vbox.g1; j <= vbox.g2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = getColorIndex(i,j,k);
                        sum += (histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        }
        else if (maxw == gw) {
            for (i = vbox.g1; i <= vbox.g2; i++) {
                sum = 0;
                for (j = vbox.r1; j <= vbox.r2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = getColorIndex(j,i,k);
                        sum += (histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        }
        else {  /* maxw == bw */
            for (i = vbox.b1; i <= vbox.b2; i++) {
                sum = 0;
                for (j = vbox.r1; j <= vbox.r2; j++) {
                    for (k = vbox.g1; k <= vbox.g2; k++) {
                        index = getColorIndex(j,k,i);
                        sum += (histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        }
        partialsum.forEach(function(d,i) { 
            lookaheadsum[i] = total-d; 
        });

        function doCut(color) {
            var dim1 = color + '1',
                dim2 = color + '2', 
                left, right, vbox1, vbox2, d2, count2=0;
            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {
                if (partialsum[i] > total / 2) {
                    vbox1 = vbox.copy();
                    vbox2 = vbox.copy();
                    left = i - vbox[dim1];
                    right = vbox[dim2] - i;
                    if (left <= right)
                        d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));
                    else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));
                    // avoid 0-count boxes
                    while (!partialsum[d2]) d2++;
                    count2 = lookaheadsum[d2];
                    while (!count2 && partialsum[d2-1]) count2 = lookaheadsum[--d2];
                    // set dimensions
                    vbox1[dim2] = d2;
                    vbox2[dim1] = vbox1[dim2] + 1;
                    //console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());
                    return [vbox1, vbox2];
                }
            }
        
        }
        // determine the cut planes
        return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');

    }

    function quantize( pixels, maxcolors ) {

        // short-circuit
        if ( !pixels.length || maxcolors < 2 || maxcolors > 256 ) {
            console.log('wrong number of maxcolors');
            return false;
        }
        
        // XXX: check color content and convert to grayscale if insufficient
        
        var histo = getHisto(pixels);
        histo.forEach(function() { });
        //if (nColors <= maxcolors) {
            // XXX: generate the new colors from the histo and return
        //}
        
        // get the beginning vbox from the colors
        var vbox = vboxFromPixels(pixels, histo),
            pq = new PQueue(function(a,b) { return pv.naturalOrder(a.count(), b.count()) });
        pq.push(vbox);
        
        // inner function to do the iteration
        function iter( lh, target ) {
            var ncolors = 1,
                niters = 0,
                vbox;
            while (niters < maxIterations) {
                vbox = lh.pop();
                if (!vbox.count())  { /* just put it back */
                    lh.push(vbox);
                    niters++;
                    continue;
                }
                // do the cut
                var vboxes = medianCutApply(histo, vbox),
                    vbox1 = vboxes[0],
                    vbox2 = vboxes[1];
                    
                if (!vbox1) {
                    console.log("vbox1 not defined; shouldn't happen!");
                    return;
                }
                lh.push(vbox1);
                if (vbox2) {  /* vbox2 can be null */
                    lh.push(vbox2);
                    ncolors++;
                }
                if (ncolors >= target) return;
                if (niters++ > maxIterations) {
                    console.log("infinite loop; perhaps too few pixels!");
                    return;
                }
            }
        }
        
        // first set of colors, sorted by population
        iter( pq, fractByPopulations * maxcolors );
        // console.log(pq.size(), pq.debug().length, pq.debug().slice());
        
        // Re-sort by the product of pixel occupancy times the size in color space.
        var pq2 = new PQueue(function(a,b) { 
            return pv.naturalOrder(a.count()*a.volume(), b.count()*b.volume()) 
        });

        while ( pq.size() ) { pq2.push(pq.pop()); }
        
        // next set - generate the median cuts using the (npix * vol) sorting.
        iter( pq2, maxcolors - pq2.size() );
        
        // calculate the actual colors
        var cmap = new CMap();
        while (pq2.size()) { cmap.push(pq2.pop()); }
        
        return cmap;

    }
    
/*    return { 
        quantize: quantize
    }

})();*/



var URL$1 = (window.URL || window.webkitURL);

var canvas = null, context, w, h;

var colors = [];
var maxCount = 0;
var highestColor = '';
var ambientColor = '';
var luminousColor = '';
var darkerColor = '';

var range = {

    lumTargetDark: 0.26,
    lumMaxDark: 0.45,

    lumMinLight : 0.55,
    lumTargetLight : 0.74,

    lumMinNormal : 0.3,
    lumTargetNormal : 0.5,
    lumMaxNormal : 0.7,

    satTargetMuted : 0.3,
    satMaxMuted : 0.4,

    satWeight : 3,
    lumWeight : 6.5,
    nWeight : 0.5,

};

var vibrants = {};



var adaptiveRange = {};

var slice = [].slice;


const ImgTool = {

    format:'html',
    //format:'hex',

    makeCanvasFromImage: function ( image ) {

        if( canvas === null ) canvas = document.createElement('canvas');
        context = canvas.getContext('2d',{ willReadFrequently: true });
        w = canvas.width  = image.width;
        h = canvas.height = image.height;
        context.drawImage( image, 0, 0, w, h );

    },

    makeCanvasFromData: function ( data ) {

        if( canvas === null ) canvas = document.createElement('canvas');
        context = canvas.getContext('2d',{ willReadFrequently: true });
        w = canvas.width  = data.w;
        h = canvas.height = data.h;
        let dt = context.createImageData( w, h );
        let k = dt.data.length;
        while(k--) dt.data[k] = data.data[k];
        context.putImageData( dt, 0, 0 );

    },

    clear: function() {

        context.clearRect(0, 0, w, h);

    },

    getImageData: function() {

        return context.getImageData(0, 0, w, h);

    },
    
    getPalette: function( sourceImage, colorCount, Quality ) {

        //this.makeCanvasFromImage( sourceImage );
        this.makeCanvasFromData( sourceImage );

        colorCount = colorCount || 64; // between 2 and 256
        var quality = Math.round( w / 256 ); // pixel space less = more quality & calculation

        if( Quality !== undefined ) quality = Quality;


        // Create custom CanvasImage object
        
        var imageData  = this.getImageData();
        var pixelCount = w * h;

        var pixelArray = this.createPixelArray( imageData.data, pixelCount, quality );

        // Send array to quantize function which clusters values
        // using median cut algorithm
        var cmap = quantize( pixelArray, colorCount );

        // color palette of full color
        //var palette = cmap ? cmap.palette() : null;

        colors = cmap.colors();

        //console.log(colors)

        this.getRange();

        var r = adaptiveRange ;

        vibrants = {
            
            vibrant : this.findColorVariation( r.lumTargetNormal, r.lumMinNormal, r.lumMaxNormal, r.satTargetVibrant, r.satMinVibrant, 1),
            lightVibrant: this.findColorVariation(r.lumTargetLight, r.lumMinLight, 1, r.satTargetVibrant, r.satMinVibrant, 1),
            darkVibrant : this.findColorVariation(r.lumTargetDark, 0, r.lumMaxDark, r.satTargetVibrant, r.satMinVibrant, 1),
            muted : this.findColorVariation( r.lumTargetNormal, r.lumMinNormal, r.lumMaxNormal, r.satTargetMuted, 0, r.satMaxMuted),
            lightMuted : this.findColorVariation(r.lumTargetLight, r.lumMinLight, 1, r.satTargetMuted, 0, r.satMaxMuted),
            darkMuted : this.findColorVariation(r.lumTargetDark, 0, r.lumMaxDark, r.satTargetMuted, 0, r.satMaxMuted, true),
            highest : highestColor,
            ambient : ambientColor,
            maxLuma: luminousColor,
            minLuma: darkerColor,
        };



        this.clear();

        //if( this.format === 'hex' ) ImgTool.getHex();

        return vibrants;

    },

    getHex: function () {

        let vibrantsHex = {};

        for( var c in vibrants ){
            
            if( vibrants[c]!==undefined ) vibrantsHex[c] = Tools.htmlToHex( vibrants[c] );
        }

        return vibrantsHex

    },

    getRange: function () {

        var count = 0;
        var minLuma = 1;
        var maxLuma = 0;

        var minSat = 1;
        var maxSat = 0;
        var i = colors.length;

        var g = [0,0,0];
        var gn = 0;
        var n = 0;
        
        while( i-- ){ 

            n = colors[i].count;

            count = Math.max( count, n );

            minLuma = Math.min( minLuma, colors[i].hsl[2] );
            maxLuma = Math.max( maxLuma, colors[i].hsl[2] );

            minSat = Math.min( minSat, colors[i].hsl[1] );
            maxSat = Math.max( maxSat, colors[i].hsl[1] );

            g[0] += colors[i].rgb[0] * n;
            g[1] += colors[i].rgb[1] * n;
            g[2] += colors[i].rgb[2] * n;
            gn += n;

        }

        g[0] /= gn;
        g[1] /= gn;
        g[2] /= gn;

        ambientColor = Tools.getHtml( g );

       
        var lumaRange = (maxLuma - minLuma);
        var satRange = (maxSat - minSat);

        var min = 0;

        {


            // luminosity
            //min = minLuma;
            adaptiveRange.lumTargetDark = min + range.lumTargetDark * lumaRange;
            adaptiveRange.lumMaxDark = min + range.lumMaxDark * lumaRange;
            adaptiveRange.lumMinLight = min + range.lumMinLight * lumaRange;
            adaptiveRange.lumTargetLight = min + range.lumTargetLight * lumaRange;
            adaptiveRange.lumMinNormal = min + range.lumMinNormal * lumaRange;
            adaptiveRange.lumTargetNormal = min + range.lumTargetNormal * lumaRange;
            adaptiveRange.lumMaxNormal = min + range.lumMaxNormal * lumaRange;

            adaptiveRange.lumWeight = min + range.lumWeight * lumaRange;

            

            // saturation
            //min = minSat;
            adaptiveRange.satTargetMuted = min + range.satTargetMuted * satRange;
            adaptiveRange.satMaxMuted = min + range.satMaxMuted * satRange;
            //adaptiveRange.satTargetVibrant = min + range.satTargetVibrant * satRange;
            //adaptiveRange.satMinVibrant = min + range.satMinVibrant * satRange;

            adaptiveRange.satTargetVibrant = maxSat;
            adaptiveRange.satMinVibrant = minSat;

            adaptiveRange.satWeight = min + range.satWeight * satRange;

        }

        

        //console.log( lumaRange, satRange, colors.length )

        maxCount = count;

        var i = colors.length;
        while( i-- ){
            if( colors[i].count === maxCount ) highestColor = colors[i].hex;
            if( colors[i].hsl[2] === maxLuma ) luminousColor = colors[i].hex;
            if( colors[i].hsl[2] === minLuma ) darkerColor = colors[i].hex;
        }

    },

    findColorVariation: function( targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation, tt ) {

        let j, len, luma, maxValue, sat, c, value;
        let color = null;
       
        maxValue = 0;
        for (j = 0, len = colors.length; j < len; j++) {
            c = colors[j];
            sat = c.hsl[1];
            luma = c.hsl[2];

            //if( tt ) console.log( sat <= maxSaturation , luma <= maxLuma )

            //if( tt ) console.log(sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !c.select)
            
            if ( sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !c.select ) {
                value = this.createComparisonValue( sat, targetSaturation, luma, targetLuma, c.count );

                if ( color === null || value > maxValue ) {

                   color = c;
                   maxValue = value;
                }
            }
        }

        if( color !== null ){ 
            color.select = true;
            return color.hex;
        } else {
            
            return '#000'
        }
        
    },

    createComparisonValue: function( saturation, targetSaturation, luma, targetLuma, count ) {
        return this.weightedMean( this.invertDiff( saturation, targetSaturation ), adaptiveRange.satWeight, this.invertDiff( luma, targetLuma ), adaptiveRange.lumWeight, count / maxCount, range.nWeight );
    },

    invertDiff: function( value, targetValue ) {

        return 1 - Math.abs( value - targetValue );

    },

    weightedMean: function() {

        var i, sum, sumWeight, value, values, weight;
        values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        sum = 0;
        sumWeight = 0;
        i = 0;
        while ( i < values.length ) {
            value = values[i];
            weight = values[i + 1];
            sum += value * weight;
            sumWeight += weight;
            i += 2;
        }
        return sum / sumWeight;

    },


    createPixelArray : function ( imgData, pixelCount, quality ) {

        var pixels = imgData;
        var pixelArray = [];

        for ( var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality ) {

            offset = i * 4;
            r = pixels[offset + 0];
            g = pixels[offset + 1];
            b = pixels[offset + 2];
            a = pixels[offset + 3];

            // If pixel is mostly opaque and not white
            if (typeof a === 'undefined' || a >= 125) {
                if (!(r > 250 && g > 250 && b > 250)) {
                    pixelArray.push([r, g, b]);
                }
            }
        }

        return pixelArray;

    },


    getColorFromUrl: function( url, callback ) {

        var _this = this;

        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'blob';
        xhr.onload = function() {
            if ( xhr.readyState === 2 ) ; else if ( xhr.readyState === 3 ) ; else if ( xhr.readyState === 4 ) {
                if ( xhr.status === 200 || xhr.status === 0 ) {
                    
                    var img = new Image();

                    img.onload = function(e) {
                        URL$1.revokeObjectURL( img.src );
                        callback( _this.getPalette( img ), img );
                    };

                    img.src = URL$1.createObjectURL( xhr.response );

                }
                else console.error( "Couldn't load [image] [" + xhr.status + "]" );
            }
        };

        xhr.send();

    },

};





// color conversion

const Tools = {

    getHtml: function(rgb) {

        return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1, 7);

    },

    getHsl: function( rgb ) {

        var d, h, l, max, min, s;
        var r = rgb[0]/255;
        var g = rgb[1]/255;
        var b = rgb[2]/255;
        max = Math.max(r, g, b);
        min = Math.min(r, g, b);
        h = 0;
        s = 0;
        l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return [h, s, l];

    },

    htmlToHex: function ( v ) { 
        return  v.toUpperCase().replace( "#", "0x" );
    },

    hexToHtml: function ( v ) {
        v = v === undefined ? 0x000000 : v;
        return "#" + ("000000" + v.toString(16)).substr(-6);
    },

};



    
// 3d color space box

class VBox {

    constructor ( r1, r2, g1, g2, b1, b2, histo ) {

        var vbox = this;
        vbox.r1 = r1;
        vbox.r2 = r2;
        vbox.g1 = g1;
        vbox.g2 = g2;
        vbox.b1 = b1;
        vbox.b2 = b2;
        vbox.histo = histo;

    }

    volume ( force ) {

        var vbox = this;
        if (!vbox._volume || force) {
            vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));
        }
        return vbox._volume;

    }

    count ( force ) {

        var vbox = this, histo = vbox.histo;

        if (!vbox._count_set || force) {
            var npix = 0, i, j, k, index;
            for (i = vbox.r1; i <= vbox.r2; i++) {
                for (j = vbox.g1; j <= vbox.g2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = getColorIndex(i,j,k);
                        npix += (histo[index] || 0);
                    }
                }
            }
            vbox._count = npix;
            vbox._count_set = true;
        }
        return vbox._count;

    }

    copy () {

        var vbox = this;
        return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);

    }

    avg ( force ) {
        var vbox = this,
            histo = vbox.histo;
        if (!vbox._avg || force) {
            var ntot = 0, mult = 1 << (8 - sigbits), rsum = 0, gsum = 0, bsum = 0, hval, i, j, k, histoindex;
            for (i = vbox.r1; i <= vbox.r2; i++) {
                for (j = vbox.g1; j <= vbox.g2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        histoindex = getColorIndex(i,j,k);
                        hval = histo[histoindex] || 0;
                        ntot += hval;
                        rsum += (hval * (i + 0.5) * mult);
                        gsum += (hval * (j + 0.5) * mult);
                        bsum += (hval * (k + 0.5) * mult);
                    }
                }
            }
            if (ntot) {
                vbox._avg = [~~(rsum/ntot), ~~(gsum/ntot), ~~(bsum/ntot)];
            } else {
                //console.log('empty box');
                vbox._avg = [
                    ~~(mult * (vbox.r1 + vbox.r2 + 1) / 2),
                    ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2),
                    ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)
                ];
            }
        }
        return vbox._avg;
    }

    contains ( pixel ) {

        var vbox = this, rval = pixel[0] >> rshift; 
        var gval = pixel[1] >> rshift;
        var bval = pixel[2] >> rshift;
        return (rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && rval <= vbox.g2 && bval >= vbox.b1 && rval <= vbox.b2);

    }

}
    
    
 // Color map

class CMap {

    constructor() {

        this.vboxes = new PQueue(function(a,b) { 
            return pv.naturalOrder(
                a.vbox.count()*a.vbox.volume(), 
                b.vbox.count()*b.vbox.volume()
            )
        });

    }

    push ( vbox ) {
        this.vboxes.push({ vbox: vbox, color: vbox.avg() });
    }

    palette () {
        return this.vboxes.map( function(vb) { return vb.color } );
    }

    colors () {

        var c = [];

        this.vboxes.map( function(vb) {
            
            var count = vb.vbox.count() || 0;
            var color = vb.color;
            if( count ) c.push({ rgb:color, hsl:Tools.getHsl( color ), hex:Tools.getHtml( color ), count:count, select:false });

        });

        return c;

    }

    size () {
        return this.vboxes.size();
    }

    map (color) {
        var vboxes = this.vboxes;
        for (var i=0; i<vboxes.size(); i++) {
            if (vboxes.peek(i).vbox.contains(color)) {
                return vboxes.peek(i).color;
            }
        }
        return this.nearest(color);
    }

    nearest (color) {
        var vboxes = this.vboxes,
            d1, d2, pColor;
        for (var i=0; i<vboxes.size(); i++) {
            d2 = Math.sqrt(
                Math.pow(color[0] - vboxes.peek(i).color[0], 2) +
                Math.pow(color[1] - vboxes.peek(i).color[1], 2) +
                Math.pow(color[1] - vboxes.peek(i).color[1], 2)
            );
            if (d2 < d1 || d1 === undefined) {
                d1 = d2;
                pColor = vboxes.peek(i).color;
            }
        }
        return pColor;
    }

    forcebw () {
        // XXX: won't  work yet
        var vboxes = this.vboxes;
        vboxes.sort(function(a,b) { return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color) )});
        
        // force darkest color to black if everything < 5
        var lowest = vboxes[0].color;
        if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)
            vboxes[0].color = [0,0,0];
        
        // force lightest color to white if everything > 251
        var idx = vboxes.length-1,
            highest = vboxes[idx].color;
        if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)
            vboxes[idx].color = [255,255,255];
    }

}

class TextureAnalys {
	
	constructor ( renderer ) {

		this.previewH = 128;
		this.useHalfFloat = true;
		this.gamma = 1;//2.2;
		this.renderer = renderer;

		this.sunSpherical = new Spherical();
		this.sunPosition = new Vector3(0,1,0);

		this.dataPreview = null;
		this.palette = {};

		this.color = {
			sun: new Color(1,1,1),
			fog: new Color(0.5,0.5,0.5),
			sky: new Color(0,0,0),
			ground: new Color(0,0,0),
		};

	}

	init ( w, h, texture ) {

		if( this.target ) return

		this.plane = new Mesh( new PlaneGeometry( 1, 1 ), new MeshBasicMaterial({ map:texture, toneMapped:false }) );
		this.plane.scale.y = -1;
		this.scene = new Scene();
		this.scene.add( this.plane );
		this.camera = new OrthographicCamera( -0.5, 0.5, 0.5, -0.5, 0, 1 );
		this.target = new WebGLRenderTarget( w, h, { format: RGBAFormat, type:this.useHalfFloat ? HalfFloatType : FloatType } );
	    this.read = this.useHalfFloat ? new Uint16Array( w * h * 4 ) : new Float32Array( w * h * 4 );

	}

	clear () {

		this.sunPosition.set(0,1,0);
		this.color.sun.set(1,1,1);
		this.color.fog.set(0.5,0.5,0.5);
		this.color.sky.set(0,0,0);
		this.color.ground.set(0,0,0);

		this.dataPreview = null;
		this.palette = {};

		if( !this.target ) return

		if(this.target.texture) this.target.texture.dispose();
		this.target.dispose();
		this.scene.remove( this.plane );
		this.plane.material.map.dispose();
		this.plane.geometry.dispose();
		this.plane.material.dispose();
		this.plane = null;
		this.scene = null;
		this.camera = null;
		this.target = null;
		this.read = null;

	}

	render ( texture, w, h ) {

		this.init( w, h, texture );
		this.renderer.setRenderTarget( this.target );
		this.renderer.render( this.scene, this.camera );
		this.renderer.setRenderTarget( null );
		this.renderer.readRenderTargetPixels( this.target, 0, 0, w, h, this.read );
		const colors = [];
		if( this.useHalfFloat ){
			let i = this.read.length/4, n;
			while(i--) {
				n = i * 4;
				colors[n] = this.float16ToNumber(this.read[n]) * 255;
				colors[n+1] = this.float16ToNumber(this.read[n+1]) * 255;
				colors[n+2] = this.float16ToNumber(this.read[n+2]) * 255;
				colors[n+3] = this.float16ToNumber(this.read[n+3]) * 255;
			}
		} else {
			 colors = this.read.map( x => Math.round(x * 255) );
		}

		return colors;

	}


	float16ToNumber (input) {

	    // Create a 32 bit DataView to store the input
	    const arr = new ArrayBuffer(4);
	    const dv = new DataView(arr);
	    // Set the Float16 into the last 16 bits of the dataview
	    // So our dataView is [00xx]
	    dv.setUint16(2, input, false);
	    // Get all 32 bits as a 32 bit integer
	    // (JS bitwise operations are performed on 32 bit signed integers)
	    const asInt32 = dv.getInt32(0, false);
	    // All bits aside from the sign
	    let rest = asInt32 & 0x7fff;
	    // Sign bit
	    let sign = asInt32 & 0x8000;
	    // Exponent bits
	    const exponent = asInt32 & 0x7c00;
	    // Shift the non-sign bits into place for a 32 bit Float
	    rest <<= 13;
	    // Shift the sign bit into place for a 32 bit Float
	    sign <<= 16;
	    // Adjust bias
	    // https://en.wikipedia.org/wiki/Half-precision_floating-point_format#Exponent_encoding
	    rest += 0x38000000;
	    // Denormals-as-zero
	    rest = (exponent === 0 ? 0 : rest);
	    // Re-insert sign bit
	    rest |= sign;
	    // Set the adjusted float32 (stored as int32) back into the dataview
	    dv.setInt32(0, rest, false);
	    // Get it back out as a float32 (which js will convert to a Number)
	    return dv.getFloat32(0, false);

	}

	run ( texture ) {

		const image = texture.image;
		//console.log( image )
		let sizer = this.previewH / image.height;
		const w = image.width * sizer;
		const h = image.height * sizer;
		const d = this.render(texture, w, h );

		const lng = d.length/4;
		const color = new Uint8ClampedArray( 4 );
		const dt = new Uint8ClampedArray( d.length );//[];

		const gammaCorrection = 1 / this.gamma;

		let maxId;
		let i = lng, n, r, g, b, t, x, y, rs = 1/255, fr=0, fg=0, fb=0;
		let br=0, bg=0, bb=0;
		let cr=0, cg=0, cb=0;
		let max = 0;

		while( i-- ){

			n = i*4;

			x = i % w;
			y = Math.floor((i-x)/w);

			r = 255 * Math.pow((d[n+0] / 255), gammaCorrection);
			g = 255 * Math.pow((d[n+1] / 255), gammaCorrection);
			b = 255 * Math.pow((d[n+2] / 255), gammaCorrection);

			t = ( r + g + b );

			if( y === h * 0.5 ){
				fr += r;
				fg += g;
				fb += b;
			}

			if( y === h * 0.25 ){
				cr += r;
				cg += g;
				cb += b;
			}

			if( y === h * 0.75 ){
				br += r;
				bg += g;
				bb += b;
			}

			if( t > max ){ 
				color[0] = r;
				color[1] = g;
				color[2] = b;
				color[3] = 255;
				maxId = i;
				max = t;
			}

			dt[n] = r;
			dt[n+1] = g;
			dt[n+2] = b;
			dt[n+3] = 255;

		}

		x = maxId % w;
		y = Math.floor((maxId-x)/w);

		// main color
		this.color.sun.setRGB( color[0] * rs, color[1] * rs, color[1] * rs, SRGBColorSpace );
		this.color.fog.setRGB( (fr/w)*rs, (fg/w)*rs, (fb/w)*rs, SRGBColorSpace );
		this.color.sky.setRGB( (cr/w)*rs, (cg/w)*rs, (cb/w)*rs, SRGBColorSpace );
		this.color.ground.setRGB( (br/w)*rs, (bg/w)*rs, (bb/w)*rs, SRGBColorSpace );

		// sun position
		this.sunSpherical.set( 1,  (y / h)*Math.PI, -(x / w)*(Math.PI * 2)-(Math.PI*0.5) );
		this.sunPosition.setFromSpherical(this.sunSpherical);

		this.dataPreview = { data:dt, x:x, y:y, w:w, h:h };

		this.palette = {

			sun: '#' + this.color.sun.getHexString(),
			m: undefined,
			sky: '#' + this.color.sky.getHexString(),
			fog: '#' + this.color.fog.getHexString(),
			ground: '#' + this.color.ground.getHexString(),

			...ImgTool.getPalette( this.dataPreview )

		};

	}

}

class DirectionalHelper extends DirectionalLightHelper {

	constructor( light, size, color ) {

		size = size || 1;

		super( light, size, color );

		let g = new PlaneGeometry( size*2, size*2 );
		let m = new MeshBasicMaterial( { color: this.light.color, fog: false, toneMapped: false } );

		this.m2 = new Mesh( g, m );

		this.shadow = new CameraHelper( light.shadow.camera );
		this.shadow.setColors( light.color, new Color( 0x222222 ), new Color( 0x222222 ), light.color, new Color( 0x666666) );

		this.children[ 0 ].add( this.m2 );

	}

	dispose() {
		super.dispose();
		if(this.m2){
			this.m2.geometry.dispose();
			this.m2.material.dispose();
		}
	}

	update() {

		super.update();
		if(this.m2) this.m2.material.color.copy( this.light.color );

	}

}

let light = [];
let LL = {};
let helper = [];
let debug = false;


class Lights {

	//get debug() { return debug; }
    //set debug( value ) { Lights.debug(value) }

    static define ( o = {}, parent, isWebGPU = false ) {

    	let biasSide = o.shadowType === 'PCSS' ? -1:1;

    	Lights.add({ 
			type:'direct', name:'sun',
			intensity:o.direct,
			distance:30, parent:parent,
		    shadow:{ range:30, near:5, far:70, bias: -5e-4 * biasSide, radius:4, quality: 2048 * o.quality, intensity:o.shadowIntensity }
		});

		Lights.add({ 
			type:'hemi', name:'hemi',
			intensity:o.hemiIntensity,
			skyColor:0xddeeff,
			groundColor:0x0f0e0d,
			pos:[0,1,0], 
			parent:parent
		});

    }

    static update ( o = {} ) {

    	let move = false;

    	if( o.sunIntensity!==undefined ){

    		/*if( LL.sun && LL.sun2 ){
    			LL.sun.intensity = o.sunIntensity*0.3;
    			if( LL.sun2 ) LL.sun2.intensity = o.sunIntensity*0.7;
    		} else {*/
    			if( LL.sun ) LL.sun.intensity = o.sunIntensity;
    		//}
    		
    	}

    	if( o.shadowIntensity!==undefined ){
    		if( LL.sun ) LL.sun.shadow.intensity = o.shadowIntensity;
    	}

    	if(o.sunPos){
    		if( LL.sun ){ 
    			LL.sun.position.fromArray( o.sunPos ).multiplyScalar( LL.sun.distance );
    			LL.sun.target.position.set( 0, 1, 0 );
    			move = true;
    			//LL.sun.updateMatrixWorld();
    		}
    		if( LL.sun2 ){ 
    			LL.sun2.position.fromArray( o.sunPos ).multiplyScalar( LL.sun2.distance );
    			LL.sun2.target.position.set( 0, 1, 0 );
    			move = true;
    			//LL.sun2.updateMatrixWorld();
    		}
    	}

    	if(o.sunColor){
    		if( LL.sun ) Lights.setColor(LL.sun.color, o.sunColor );
    		if( LL.sun2 ) Lights.setColor(LL.sun2.color, o.sunColor );
    		move = true;
    	}

    	if( LL.hemi ){
    		if(o.hemiIntensity!==undefined) LL.hemi.intensity = o.hemiIntensity;//*0.7;
    		if(o.skyColor) Lights.setColor(LL.hemi.color, o.skyColor );
    		if(o.groundColor) Lights.setColor(LL.hemi.groundColor, o.groundColor );
    		move = true;
    	}

    	if( move ) Lights.updateHelper();
    
    }

    static setColor ( c, v ) {
    	if( v.isColor ) c.copy( v );
    	else c.setHex( v );
    }

    static adds ( ar ) {

    	let i = ar.length, n = 0;
    	while(i--){
    		Lights.add( ar[n] );
    		n++;
    	}
    }

	static add ( o = {} ) {

		if ( o.constructor === Array ) return Lights.adds( o );

		let l = null;

		if(!o.color) o.color = 0xFFFFFF;

		switch(o.type){
			
			case 'direct':
			l = new DirectionalLight( o.color, o.intensity );
			l.distance = o.distance !== undefined ? o.distance : 2.0;
			break;
			case 'spot':
			l = new SpotLight( o.color, o.intensity, o.distance, o.angle, o.penumbra, o.decay );
			break;
			case 'point':
			l = new PointLight( o.color, o.intensity, o.distance, o.decay );
			break;
			case 'ambient':
			l = new AmbientLight( o.color, o.intensity );
			break;
			case 'rec':
			l = new RectAreaLight( o.color, o.intensity, o.width = 10, o.height );
			break;
			case 'hemi':
			l = new HemisphereLight( o.skyColor || 0x000000, o.groundColor || 0x000000, o.intensity );
			break;
		}

		if(!l) return

		l.name = o.name || 'light' + light.length;

		if( o.pos ) l.position.fromArray( o.pos );

		if( o.parent ){
			if( l.target ) o.parent.add( l.target );
			o.parent.add( l );
		}

		if( l.shadow && o.shadow ){
			Lights.setShadow( l, o.shadow );
		}

	    light.push(l);
	    LL[l.name] = l;

	    return l

	}

	static setShadow ( l, o ) {

		const s = l.shadow;
		if(!s) return;

		if(o.quality) s.mapSize.width = s.mapSize.height = o.quality;
		const cam = s.camera;

		if( cam.isOrthographicCamera ){
			if(o.range){
				cam.top = cam.right = o.range;
				cam.bottom = cam.left = -o.range;
			}
			if(o.near) cam.near = o.near;
			if(o.far) cam.far = o.far;
		}
		if( cam.isPerspectiveCamera ){
			if(o.near) cam.near = o.near;
			if(o.far) cam.far = o.far;
		}

		if(o.bias) s.bias = o.bias;
		if(o.radius) s.radius = o.radius;
		if(o.blurSamples) s.blurSamples = o.blurSamples; // only for VSM 
		if(o.intensity) s.intensity = o.intensity;

		s.needsUpdate = true;
		l.updateWorldMatrix( true, true );
		l.target.updateWorldMatrix( true, true );

		l.castShadow = true;

    }

	static byName ( name ) {
		return LL[name]
	}

	static dispose () {

		Lights.disposeHelper();

		let i = light.length, l;
		while(i--){
			l = light[i];
			if( l.parent ) l.parent.remove(l);
			if( l.target && l.target.parent ) l.target.parent.remove(l.target);
			l.dispose();
		}

		light = [];
		LL = {};

	}

	static castShadow ( v ) {

		let i = light.length, l;
		while(i--){
			l = light[i];
			if( l.shadow !== undefined ){ 
				l.castShadow = v;
				if(!v) l.shadow.dispose();
			}
		}

	}


	//--------------------
	//   HELPER
	//--------------------

	static addHelper ( b, pp ) {

		if( b && !debug ){

			let i = light.length, l, h;
			while(i--){
				l = light[i];
				switch(l.type){
					case 'DirectionalLight':
					h = new DirectionalHelper( l );
					break;
					case 'PointLight':
					h = new PointLightHelper( l, 0.25, l.color );
					break;
					case 'SpotLight':
					h = new SpotLightHelper( l, l.color );
					break;
					case 'HemisphereLight':
					h = new HemisphereLightHelper( l, 0.25 );
					h.material.wireframe = false;
					break;
				}

				if(h){ 
					helper.push(h);
					pp.add( h );
					if( h.shadow ){ 
						helper.push( h.shadow );
						pp.add( h.shadow );
						//h.shadow.update()
					}
				}
			}

			debug = true;

		}

		if( !b ){
			Lights.disposeHelper();
		}

		return debug;

	}

	static updateHelper () {

		if( !debug ) return;

		let i = helper.length;
		while(i--){
			helper[i].update();
		}

	}

	static disposeHelper () {

		if( !debug ) return;

		let i = helper.length, h;
		while(i--){
			h = helper[i];
			h.parent.remove(h);
			h.dispose();
		}
		helper = [];
		debug = false;

	}

}

//import { HDRTool } from './utils/HDRTool.js';

const autoSize = 0.25;
let envName = '';
let autosun = true;
let usePmrem = true;
let isWebGPU$1 = false;

let textureAnalys = null;

let skybox = null;
let needSkybox = false;

/*let sunColor = new Color();
let fogColor = new Color();
let skyColor = new Color();
let groundColor = new Color();
*/
let previewCanvas = null;
let previewPalette = null;
let isPreviewDisplay = false;
let isPaletteDisplay = false;
//let previewData = null;

let pm = null;
let env = null;
let hdr = null;
let pmrem = null;
let floor = null;
//let data = {};
//let palette = {};
let color$1 =  new Color();
let scene$1 = null, renderer$1 = null;

//const s1 = new Spherical();
//const s2 = new Spherical();

//const tmpV = new Vector3();

//let cc = new Color();
//let cc2 = new Color();
//let cc3 = new Color();

let tt = 0;

new Vector2();
const hdrLoader = new RGBELoader();
const exrLoader = new EXRLoader();
let backIsColor = false;

let main = null;



// https://discourse.threejs.org/t/how-to-dispose-scene-background-with-webglrendertarget/19935

//let plane, sceneR, cameraR, targetR = null, read = null, read16 = null

class Env {

	static setMain (m) { main = m; }

	static get () { return env }
	//static getData () { return data }

	static dispose () {

	    if( scene$1.background && scene$1.background.dispose ){ scene$1.background.dispose(); }
	    if( scene$1.environment && scene$1.environment.dispose ){ scene$1.environment.dispose(); }

	    scene$1.background = null;
		scene$1.environment = null;
		backIsColor = false;
	    
	    //this.clearTargetRender();
	    if(textureAnalys) textureAnalys.clear();

	    if(skybox) Env.clearProject();

		if( env ) env.dispose();
		if( hdr ) hdr.dispose();
		if( pm ) pm.dispose();
		
		env = null;
		hdr = null;

	}

	static reset () {

		Env.clearProject();
		needSkybox = false;
		
	}

	static clearProject () {

		if(!skybox) return;

		//needSkybox = false;

		scene$1.remove( skybox );
		//skybox.material.map.dispose()
		skybox.geometry.dispose();
	    skybox = null;

	}

	static project ( radius = 500, height = 100 ) {

		needSkybox = true;
		if(!hdr) return;
		if(skybox) Env.clearProject();

		skybox = new GroundProjectedSkybox( hdr );
		skybox.scale.setScalar( 100 );
		scene$1.add( skybox );

		skybox.radius = radius;// 200 / 600
		skybox.height = height;// 20 / 50

	}

    static set ( value, callback = ()=>{} ) {

    	Env.dispose();

    	if( typeof value  === 'string' ){
    		if( value !== 'null' ){ 
    			if( value.search('/') !== -1 ) this.load( value, callback );
    			else {
    				envName = value;
    				if( envName.search('_4k') !== -1 ) this.load( './assets/textures/env/'+value+'.jpg', callback, 'jpg' );
    				else this.load( './assets/textures/equirectangular/'+value+'.hdr', callback, 'hdr' );
    			}
    		} else {
    			scene$1.environment = null;
    			scene$1.background = null;
    			callback();
    		}
		} else if (!isNaN(value)){
			this.setBackgroud( value );
			callback();
		}

    }

    static setFloorRadius ( v ) {
    	if(!floor) return
    	floor.radius = v;
    }

    static setFloorHeight ( v ) {
    	if(!floor) return
    	floor.height = v;
    }

    static setBlur ( v ) {
    	if(!scene$1) return
    	scene$1.backgroundBlurriness = v;
    }

    static addFloor ( v, s=2 ) {

    	console.log('addFloor', v);

    	if( v ){
    		floor = new GroundProjectedEnv( env );
			floor.scale.setScalar( 100 );
			floor.radius = 100;
			floor.height = 10;
			scene$1.add( floor );
    	} else {
    		if(floor){
    			scene$1.remove( floor );
    		}
    	}

		

		//floor.radius = params.radius;
		//floor.height = params.height;

	}

    static setBackgroud ( c ) {

		if( c !== undefined ){ 
			backIsColor = true;
			scene$1.background = color$1.setHex(c);
		} else { 
			backIsColor = false;
			scene$1.background = env;
		}

	}

    static init ( Renderer, Scene, Autosun = true ) {

    	if( Renderer ){ 
    		renderer$1 = Renderer;
    		isWebGPU$1 = renderer$1.isWebGPURenderer || false;
    		usePmrem = isWebGPU$1 ? false : usePmrem;
    	}
		if( Scene ) scene$1 = Scene;
		autosun = Autosun !== undefined ? Autosun : true;
	    if( isWebGPU$1 ) autosun = false;

	    if(autosun) textureAnalys = new TextureAnalys( renderer$1 );

	    //if( useHdrTool ) hdrTool = new HDRTool()

	    if( usePmrem ){
			pmrem = new PMREMGenerator( renderer$1 );
			pmrem.compileEquirectangularShader();
		}

		//if( useJpgHdr ){
		//	jpgLoader = new HDRJPGLoader( renderer );
		//}

	    //this.initTargetRender()

    }

	static async load ( url, callback, type = 'hdr' ) {

		/*data = {
			pos: new Vector3(0,1,0),
			sun: new Color(0xffffff),
			fog: new Color(0x000000),
			envmap:null,
		}*/

		if( type === 'hdr' ) hdr = await hdrLoader.loadAsync( url );
		else if( type === 'exr' ) hdr = await exrLoader.loadAsync( url );

		//console.log(hdr)

		Env.process();
		
		if( callback ) callback();

	}

    static process () {

		if( usePmrem ){ 
			pm = pmrem.fromEquirectangular( hdr );
			env = pm.texture;
			pmrem.dispose();
		} else {
			env = hdr;
		    env.mapping = EquirectangularReflectionMapping;
		}
	
		if( scene$1 ) {
			scene$1.environment = env;
			if( floor ) floor.map = env;
			else {
				if( backIsColor ) scene$1.background = color$1;
				else scene$1.background = env;
			}
			
		}

		if( needSkybox ) Env.project();

		// autosun
		tt = 0;
		if(autosun) Env.up();

	}



	static up () {

		if(tt=== 0){
			Env.autoSun();
			Env.upLight();
		}
		tt++;
		if(tt<6) tt = 0;
		tt = 0;
		
	}

	static getCanvas () {

		const ref = textureAnalys.dataPreview;

		if( previewCanvas === null ) previewCanvas = document.createElement("canvas");
		previewCanvas.style.cssText = 'position:absolute; left:10px; bottom:20px; width:'+ref.w+'px; height:'+ref.h+'px; border:1px solid #222;';
        previewCanvas.width = ref.w;
        previewCanvas.height = ref.h;
        let ctx = previewCanvas.getContext("2d");
		let dt = ctx.createImageData( ref.w, ref.h );
		let k = dt.data.length;
		while(k--) dt.data[k] = ref.data[k];
		ctx.putImageData( dt, 0, 0 );
		/*ctx.lineWidth = 2;
		ctx.strokeStyle = 'red';
		ctx.beginPath();
		ctx.arc(ref.x, ref.y, 20*autoSize, 0, 2 * Math.PI);
		ctx.stroke()*/
		
	}

	static getPalette () {

		return textureAnalys.palette;//ImgTool.getPalette( previewData )
		
	}

	static preview ( b ) {

		Env.palettePreview( b );

		const ref = textureAnalys.dataPreview;//previewData;
		if( ref === null ) return
		if(b){
			if( previewCanvas === null ) previewCanvas = document.createElement("canvas");
			previewCanvas.style.cssText = 'position:absolute; left:10px; bottom:10px; width:'+ref.w+'px; height:'+ref.h+'px; border:1px solid #222;';
	        previewCanvas.width = ref.w;
	        previewCanvas.height = ref.h;
	        let ctx = previewCanvas.getContext("2d");
			let dt = ctx.createImageData( ref.w, ref.h );

			//dt.data = [...ref.data]
			let k = dt.data.length;
			while(k--) dt.data[k] = ref.data[k];
			ctx.putImageData( dt, 0, 0 );
			ctx.lineWidth = 2;
			ctx.strokeStyle = 'red';
			ctx.beginPath();
			ctx.arc(ref.x, ref.y, 20*autoSize, 0, 2 * Math.PI);
			ctx.stroke();

			if( !isPreviewDisplay ) {
				document.body.appendChild( previewCanvas );
				isPreviewDisplay = true;
			}
			
		} else {
			if( isPreviewDisplay ){
				document.body.removeChild( previewCanvas );
				isPreviewDisplay = false;
			}
		}
	}

	static palettePreview ( b ) {
		
		let size = 25.6;
		let n = 0, y = 0, x = 0, d = 5;
		//let num = 10 + 4 
		let w = (size * 3) + d;
		let h = size * 5;
		let palette = textureAnalys.palette;
		

		if(b){
			if( previewPalette === null ) previewPalette = document.createElement("canvas");			previewPalette.style.cssText = 'position:absolute; left:271px; bottom:10px; width:'+w+'px; height:'+h+'px; border:1px solid #222;';
			previewPalette.width = w;
	        previewPalette.height = h;
	        const ctx = previewPalette.getContext("2d");

	        ctx.fillStyle = '#000';
			ctx.fillRect(0, 0, w, h);

			for(let m in palette){
				
				if(palette[m]!==undefined){

					x = Math.floor( n / 5 );
					y = (n - (x*5)); 
					
					ctx.fillStyle = palette[m];
					ctx.fillRect(x*size+(x>0? d : 0), y* size, size, size);
					
				}
				
				n++;

			}

			if( !isPaletteDisplay ) {
				document.body.appendChild( previewPalette );
				isPaletteDisplay = true;
			}

		} else {

			if( isPaletteDisplay ){
				document.body.removeChild( previewPalette );
				isPaletteDisplay = false;
			}

		}

	}

	static autoSun () {

		textureAnalys.run(hdr);
		if( main ) main.setColors( textureAnalys.palette );
		Env.preview( isPreviewDisplay );

	}

	static getFogColor () {
		return textureAnalys.color.fog
	}

	static upLight () {

		let r = textureAnalys;

		//if( !light ) return

		if( scene$1.fog ) scene$1.fog.color.copy( r.color.fog );
			
		const dt = {
			sunPos: r.sunPosition.toArray(), //tmpV.setFromSpherical(s1).toArray(),
			sunColor: r.color.sun,
			skyColor: r.color.sky,
			groundColor: r.color.ground, 
		};

		Lights.update( dt );
	
	}


}

/** __
*    _)_|_|_
*   __) |_| | 2023
* @author lo.th / https://github.com/lo-th
*/

const menuList = ['ENV', 'PHY', 'CAM', 'POST', 'MAT', 'OBJ'];

let Main$2 = null;

const Gui = {

	tool:h$2,

	open:false,
	isInit:false,
	graph:null,

	ui:null,
	uix:null,
	gp:null,
	video:null,
	envui:null,

	CameraOptions:[],

	//mat:null,
	startMode:'ENV',
	mode:'',
	currentMat:'',
	matList:null,

	imageMap: ['map', 'map1', 'map2', 'emissiveMap', 'sheenColorMap'],
	imageNormal: [ 'normalMap', 'normalMap1','normalMap2','aoMap', 'metalnessMap', 'thicknessMap', 'roughnessMap', 'alphaMap','anisotropyMap', 'specularIntensityMap', 'displacementMap', 'bumpMap' ],
	
	MaterialMesh:[ 'Basic', 'Physical', 'Standard', 'Toon', 'Lambert', 'Phong', 'Shader' ],

	joy: null,
	p0: 'M 0.5 1.5 L 9.5 1.5 M 0.5 5.5 L 9.5 5.5 M 0.5 9.5 L 9.5 9.5',
	p1: 'M 1.5 0.5 L 1.5 9.5 M 5.5 0.5 L 5.5 9.5 M 9.5 0.5 L 9.5 9.5',

	bg:'rgba(0,0,8,0.5)',

	colors:{
		over:'#025B18',
		overoff:'#025B18',
		select:'#023612',
		textSelect:'#1FC742',
		border:'none',
		//content:'rgba(0,0,8,0.5)',
		fontShadow:'#000',
		//sx: 4,
        //sy: 4,
        radius:0,

        showOver:0,

        content:'none',
		background:'none', //'none',
		backgroundOver:'none',//'rgba(255,255,255,0.02)',
		font:"'SegoeUI', 'Segoe UI', 'Helvetica Neue', -apple-system, BlinkMacSystemFont, Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif",
		//font:"'Roboto Mono', 'Source Code Pro', Consolas, monospace",
		//font:"'Roboto Mono', 'Source Code Pro', Consolas, monospace", 
		//font:"Mulish, sans-serif", 
		fontSize:13,
		//weight:'500',
		//weight:'bold',
		text:'#fff',
		title:'#eee',
		borderSize:2,
		joyOut:'rgba(255,255,255,0.1)',
		joyOver:'rgba(127,255,0,0.2)',
        joySelect:'#7fFF00',

	},

	setMain: ( r ) => { 
		Main$2 = r;
	},

	extraUi: ( data = null ) => { 

		if( Gui.uix ){ 
			Gui.uix.dispose();
			console.log('uix dispose');
		}

		//console.log('uix add')

		Gui.uix = new H( { parent:Main$2.getCorner(), w:200, h:24, open:true, close:false, css:'left:40px;', bottom:40, colors:Gui.colors, transition:0 } );//

		if( data ){
			let d;
			let lng = data.length;

			for( let i = 0; i<lng; i++ ){
				d = data[i];
				Gui.uix.add( d.obj, d.name, d );
			}
		}

		return Gui.uix;

	},

	setTextureConstrutor: ( Texture ) => {
		h$2.texture = Texture;
	},

	showHide: () => { 

		if( !Gui.isInit ) Gui.init();

		if( Gui.open ) Gui.open = false;
		else Gui.open = true;

		Gui.ui.isOpen = Gui.open;

		Hub.switchGuiButton( Gui.open );

		Gui.menu.display( Gui.open );
		Gui.ui.display( Gui.open );

		Gui.ui.calc();
		Gui.ui.mode('def');

	},

	init:() => {

		h$2.setStyle(Gui.colors);

		Gui.menu = T( 'button', { type:'button', values:menuList, value:Gui.startMode, selectable:true, unselect:false, p:0, h:30, w:250, radius:0, pos:{right:'5px', top:'60px'} }).onChange( Gui.setMode );

		Gui.menu.icon( iconUI('env'), 0, 2 );
		Gui.menu.icon( iconUI('phy'), 0, 3 );
		Gui.menu.icon( iconUI('cam'), 0, 4 );
		Gui.menu.icon( iconUI('post'), 0, 5 );
		Gui.menu.icon( iconUI('mat'), 0, 6 );
		Gui.menu.icon( iconUI('asset'), 0, 7 );

		Gui.ui = new H( { w:250, h:25, open:false, close:false, css:'right:5px; top:97px;', colors:Gui.colors, transition:0 } );//


		//Gui.display()

		Gui.setMode(Gui.startMode);

		Gui.isInit = true;

	},

	setMode( name ){

		if(Gui.mode === name) return
		Gui.mode = name;
	    Gui.graph = null;
	    Gui.ui.clear();

	    switch(Gui.mode){
	    	case 'ENV': Gui.display(); break;
	    	case 'PHY': Gui.physics(); break;
	    	case 'CAM': Gui.camera(); break;
	    	case 'POST': Gui.postprocess(); break;
	    	case 'MAT': Gui.material(); break;
	    }

	    Gui.ui.add( 'empty', {h:6});

	},

	doReset: () => {

		if( !Gui.isInit ) return
		if( !Gui.open ) return
		setTimeout( Gui.reset, 0 ); 

	},

	reset: () => {

		if( !Gui.isInit ) return
		if( !Gui.open ) return

		let oldMode = Gui.mode;
	    Gui.mode = '';
	    Gui.currentMat = '';
	    if(oldMode) Gui.setMode(oldMode);

	},

	resetExtra: () => {
		if( Gui.uix ) { 
			Gui.uix.dispose(); 
			Gui.uix = null;
			//console.log('uix dispose')
		}
	},


	display:() => {

		if( Gui.mode !== 'ENV' ) return

		const ui = Gui.ui;

		const mode = 2;

		const options = Main$2.getOption();
		//const setting = Main.getSetting()
		const renderer = Main$2.getRenderer();
		Main$2.getScene();
		const toneMappingOptions = Main$2.getToneMappingOptions();

		ui.add( options, 'mode', { type:'button', values:['LOW', 'HIGH'], selectable:true, unselect:false, p:0 }).onChange( Main$2.changeMode );

		ui.add( options, 'debug', { type:'bool' }).onChange( Main$2.debugMode );
		//ui.add( options, 'day', { type:'bool' }).onChange( Hub.setColors )
		ui.add( options, 'harmony', { type:'bool' }).onChange( Hub.harmony );
		ui.add( options, 'show_light', { type:'bool' }).onChange( Main$2.showDebugLight );
		ui.add( options, 'show_stat', { type:'bool' }).onChange( Main$2.showStatistic );

		//ui.add( options, 'fogMode', { type:'selector', values:[0,1], selectable:true, unselect:false, h:24 }).onChange( function(n){ Shader.up( options ) })

		

		ui.add( options, 'tone',  { type:'list', list:toneMappingOptions, full:true }).onChange( function(v){
			renderer.toneMapping  = toneMappingOptions[ options.tone ];
		});

		ui.add( options, 'exposure', { min:0, max:1, step:0.001, pecision:3, mode:mode } ).onChange( function( v ){ 
			renderer.toneMappingExposure = v; 
			//Env.up()
		});

		ui.add( options, 'direct', { rename:'Light Direct', min:0, max:100, mode:mode, color:'#ff0' } ).onChange( Main$2.lightIntensity );
		ui.add( options, 'spherical', { rename:'Light Hemi', min:0, max:10, mode:mode, color:'#ff0' } ).onChange( Main$2.lightIntensity );
		ui.add( options, 'shadowIntensity', { rename:'shadow', min:0, max:1, mode:mode, color:'#ff0' } ).onChange( Main$2.shadowIntensity );

		ui.add( options, 'envIntensity', { min:0, max:20, mode:mode, color:'#8ff' } ).onChange( Main$2.envmapIntensity );
		ui.add( options, 'bgIntensity', { min:0, max:20, mode:mode, color:'#8ff' } ).onChange( Main$2.bgIntensity );
		ui.add( options, 'envBlur', { min:0, max:1, mode:mode, color:'#8ff' } ).onChange( Main$2.setBlur );
		ui.add( options, 'reflect', { min:0, max:1, mode:mode, color:'#8ff' } ).onChange( Main$2.setReflect );

		Gui.envui = ui.add( 'list', { name:'Envmap', list:Main$2.envList, value:options.envmap, path:'assets/textures/equirectangular/mini/', format:'.jpg', m:0, imageSize: [128,64], h:40}).onChange( Main$2.setEnv );
		
		//ui.add( options, 'envPower', { min:0, max:10, mode:mode, color:'#8ff' } ).onChange( Main.envmapIntensity )
		//ui.add( options, 'legacy',  { type:'bool' }).onChange( function(v){ renderer.useLegacyLights  = v })
        //ui.add( options, 'shadow', { min:0, max:1, mode:mode, color:'#8ff' } ).onChange( Main.setShadow )//.listen()
		//.listen()

		const hub3d = Main$2.getHub3d();
		if(hub3d){
			let g0 = ui.add('group', { name:'VIGNETTE', open:false });
			g0.add( hub3d, 'grain', { min:0, max:0.5, mode:mode, color:'#8ff' } );
			g0.add( hub3d, 'offset', { min:0, max:2, mode:mode, color:'#8ff' } );
			g0.add( hub3d, 'darkness', { min:0, max:1, mode:mode, color:'#8ff' } );
			g0.add( hub3d, 'color', { type:'color' } ).listen();
		}

		

		

		//return

		
		

		
		

		/*g.add( 'bool', { name:'ground', value:setting.ground }).onChange( showGround )

		g.add( 'bool', { name:'floor', value:false }).onChange( Env.addFloor )
		g.add( 'slide', { name:'height', min:1, max:100, precision:0, value:10, mode:mode } ).onChange( Env.setFloorHeight )
		g.add( 'slide', { name:'radius', min:1, max:600, precision:0, value:100, mode:mode } ).onChange( Env.setFloorRadius )

		g.add( options, 'reflect', { min:0, max:1, mode:mode } ).onChange( setReflect ).listen()

		
		g.add( options, 'shadowType', { type:'list', rename:'type', list:shadowMapType, full:true }).onChange( function(v){
			renderer.shadowMap.type = shadowMapType[options.shadowType]
		})

		g.add( options, 'lightSizeUV', { min:1, max:10, precision:4, mode:mode } ).onChange( upShader )
		g.add( options, 'nearPlane', { min:1, max:20, precision:2, mode:mode } ).onChange( upShader )
		g.add( options, 'rings', { min:1, max:30, precision:0, mode:mode} ).onChange( upShader )
		//grV.add( options, 'nSample', {min:2, max:32, precision:0} ).onChange( function(){ Shader.up( options ) } )
		*/

		

	},

	objects:() => {
		if( Gui.mode !== 'OBJ' ) return


	},

	physics:() => {

		if( Gui.mode !== 'PHY' ) return

		const ui = Gui.ui;

	    const setting = Main$2.motor.getSetting();

	    Gui.graph = ui.add('fps', { 
	        name:'stat', h:22, hplus:180, custom:true, alpha:0.5, res:50, 
	        names:['three','phy'], cc:['200,200,200','50,120,220'], 
	        range:[25,25], precision:2, radius:4, color:'#EEEEEE', adding:false  
	    });
	    Gui.graph.open();

	   //ui.add('button', { values:Main.engineList, selectable:true, value:Main.engineType, h:30  }).onChange( Gui.swapEngine )
		//if( Main.devMode ) ui.add('button', { values:['RAPIER','CANNON'], selectable:true, value:Main.engineType }).onChange( Gui.swapEngine )
		ui.add( 'bool', { name:'WORKER OFF', onName:'WORKER ON', value:Main$2.isWorker, mode:1 }).onChange( Gui.swapWorker );
		

	    let rrr = ui.add( 'button', { type:'button', values:['REPLAY', 'PAUSE'], p:0 }).onChange( (n)=>{ 
			//if(n === 'EDIT'){ Main.showEditor(true); this.switchValues(0, 'CLOSE' ); }
			//if(n === 'CLOSE'){ Main.showEditor(false); this.switchValues(0, 'EDIT' ); }
			if(n === 'PAUSE'){ phy.pause( true ); rrr.switchValues(1, 'PLAY' ); }
			if(n === 'PLAY'){ phy.pause( false ); rrr.switchValues(1, 'PAUSE' ); }
			if(n === 'REPLAY') Main$2.injectCode( Main$2.getCode() );
		});



		ui.add( 'empty', {h:6});

	    ui.add( 'button', { type:'button', values:['DRAG', 'SHOOT', 'BUILD'], value:'DRAG', selectable:true, unselect:false, p:0 }).onChange( (n)=>{ 
			phy.mouseMode( n.toLowerCase() );
		});

		//ui.add( 'number', { name:'Gravity', value:[0,-9.81,0] })


		ui.add( setting, 'gravity', { type:'number' }).onChange( Main$2.motor.setGravity );
		//ui.add( setting, 'substep', { type:'number' })
		//ui.add( setting, 'fps', { type:'number' })

	},

	camera:() => {

		if( Gui.mode !== 'CAM' ) return

		const ui = Gui.ui;

	    const controler = Main$2.getControler();
	    Main$2.getRenderer();
	    Main$2.getOption();

	    //Gui.CameraOptions = 
	    const up = function(){ 
	    	Main$2.setCamera( {...controler.info } );
	    };
	    const mode = 2;

	    //console.log(options)

	    let g0 = ui.add('group', { name:'CAMERA', open:true });

	    
	    //ui.add( 'empty', {h:6})
	    g0.add( controler.info, 'phi', {min:-90, max:90, precision:1, mode:mode, color:'#ff0' }).onChange( up ).listen();
	    g0.add( controler.info, 'theta', {min:-180, max:180, precision:1, mode:mode, color:'#ff0'  }).onChange( up ).listen();
	    g0.add( 'empty', {h:6});
	    g0.add( controler.info, 'fov', {min:1, max:180, precision:1, mode:mode, color:'#8ff' }).onChange( up ).listen();
	    g0.add( controler.info, 'zoom', {min:0.1, max:10, precision:1, mode:mode, color:'#8ff'  }).onChange( up ).listen();
	    g0.add( 'empty', {h:6});

	    //ui.add( controler.info, 'target', { type:'number' }).onChange( up ).listen()
	    g0.add( controler.info, 'distance', { type:'number', min:0, max:100, mode:mode} ).onChange( up ).listen();
	    g0.add( controler.info, 'x', { type:'number', min:-50, max:50, precision:2, mode:mode }).onChange( up ).listen();
	    g0.add( controler.info, 'y', { type:'number', min:-50, max:50, precision:2, mode:mode  }).onChange( up ).listen();
	    g0.add( controler.info, 'z', { type:'number', min:-50, max:50, precision:2, mode:mode }).onChange( up ).listen();

	   

	    //ui.add( 'bool', { name:'CAPTURE', onName:'STOP', value:false, mode:1 }).onChange( Gui.capture )
		//ui.add('button', { name:'CAMERA' }).onChange( function(){ console.log( controls.getInfo() )} )
		//g0.add( options, 'renderMode', { type:'button', values:[ 'color', 'depth', 'normal' ], selectable:true, unselect:false, p:0 }).onChange( Main.changeRenderMode )

		g0.add('button', { name:'SCREENSHOT' }).onChange( function(){ Main$2.motor.screenshot(); } );

		/*let setts = Shader.setting()

		let g1 = ui.add('group', { name:'SHADOW', open:false })
		g1.add( options, 'shadowType', { type:'button', values:['PCSS', 'PCF', 'PCFSoft', 'VSM'], value:'DRAG', selectable:true, unselect:false, p:0 } ).onChange( Main.setShadowType )//.listen()
		g1.add( options, 'shadow', { min:0, max:1, mode:mode, color:'#8ff' } ).onChange( Main.setShadow )//.listen()
		g1.add( setts.shadowGamma, 'value', { rename:'gamma', min:0, max:4, precision:3, mode:mode, color:'#8ff' } )
		g1.add( setts.shadowLuma, 'value', { rename:'lLuma', min:0, max:4, precision:3, mode:mode, color:'#8ff' } )
		g1.add( setts.shadowContrast, 'value', { rename:'contrast', min:0, max:4, precision:3, mode:mode, color:'#8ff' } )
		g1.add( 'empty', {h:6})
		g1.add( setts.lightSizeUV, 'value', { rename:'light size', min:1, max:10, precision:4, mode:mode } )
		g1.add( setts.nearPlane, 'value', { rename:'near plane', min:1, max:20, precision:2, mode:mode } )
		g1.add( setts.rings, 'value', { rename:'ring', min:1, max:30, precision:0, color:'#ff0', mode:mode} )
		g1.add( setts.nSample, 'value', { rename:'sample', min:2, max:32, precision:0, color:'#ff0', mode:mode })

		//g1.add( setts.noiseIntensity, 'value', { rename:'noise', min:0, max:10, precision:3, mode:mode } )
		g1.add( setts.softness, 'value', { rename:'softness', min:0, max:4, precision:3, mode:mode } ) */



	},

	postprocess:( direct ) => {

		if( Gui.mode !== 'POST' ) return



    	const ui = Gui.ui;

        const options = Main$2.getOption();

        if(!direct){
        	ui.clear(); 
        	/*ui.add( options, 'renderMode', { type:'selector', values:[0,1,2,3], selectable:true, unselect:false, p:0, h:24 }).onChange( function(n){ 

				if( n!== 0 ) scene.helper.visible = false
				if( n===1 ) { Env.setBackgroud(0x000000)}
				else if( n===2 ) Env.setBackgroud(0x7777ff)
				else if( n===3 ) Env.setBackgroud(0xffffff)
				else {
					Env.setBackgroud()
					scene.helper.visible = true
				}
				//Hub.setRenderMode( n )
				Shader.up( options ) 
			})*/
        	ui.add( options, 'composer', { type:'bool', rename:'POST PROCESS OFF', onName:'POST PROCESS ON', mode:1, h:40 }).onChange( Main$2.setComposer );
        	Gui.gp = ui.add('group', { name:'OPTION' });
        }

        let g = Gui.gp;
        g.clear();

		const composer = Main$2.getComposer();
		Main$2.getScene();

		if(!composer) return

		let data = composer.getPass();
	    let i = data.length, n=0;
	    while(i--){
	    	data[n];
	    	g.add( data[n], 'enabled', { type:'bool', rename:data[n].name+' OFF', onName:data[n].name+' ON', mode:1, h:30 }).onChange( Main$2.setComposer );
	    	n++;
	    }

	    g.open();
		return
	    
	    
	    /*
	    g.add( 'empty', {h:6})
		g.add( composer.options, 'kernelRadius', {min:0.01, max:1} ).onChange( function(){ composer.update() } )
		g.add( composer.options, 'minDistance', {min:0, max:0.001, precision:5} ).onChange( function(){ composer.update() } )
		g.add( composer.options, 'maxDistance', {min:0, max:20} ).onChange( function(){ composer.update() } )
	    */

	},

	/*demo:(gg) => {

		return

		let data = Main.getDemos()

		/*let colors = [
		'rgba(180,255,180,0.1)',
		'rgba(255,255,180,0.1)',
		'rgba(255,180,180,0.1)'
		]*/

	/*	let colors = [
		'rgba(255,255,255,0.1)',
		'rgba(200,200,200,0.1)',
		'rgba(150,150,150,0.1)'
		]

		let grB = gg.add('group', { name:'BASIC', open:true, bg:colors[0] })
		Gui.g1 = grB.add( 'grid', { values:data.Basic, selectable:true } ).onChange( Main.loadDemo )

		let grA = gg.add('group', { name:'ADVANCED', open:true, bg:colors[1] })
		Gui.g2 = grA.add( 'grid', { values:data.Advanced, selectable:true } ).onChange( Main.loadDemo )

		if( data[Main.engineType] ){
			let grC = gg.add('group', { name:'SPECIFIC', open:true, bg:colors[2] })
			Gui.g3 = grC.add( 'grid', { values:data[Main.engineType], selectable:true } ).onChange( Main.loadDemo )
		}

		gg.add( 'empty', {h:3})



		gg.reset()

	},*/

	

	/*resetDemoGroup: ( name ) => {

		return

		let cc1 = false, cc2 = false, cc3 = false;

		if(Gui.g1) { Gui.g1.setValue(name); cc1 = Gui.g1.reset() }
		if(Gui.g2) { Gui.g2.setValue(name); cc2 = Gui.g2.reset() }
		if(Gui.g3) { Gui.g3.setValue(name); cc3 = Gui.g3.reset() }

		// if demo not existe reset to default demo 
		if(!cc1 && !cc2 && !cc3){ 
			if(Gui.g1) { Gui.g1.setValue('start'); cc1 = Gui.g1.reset() }
			return false
		}
		else return true

	},*/

	gotoGithub: () => { window.open( 'https://github.com/lo-th/phy', '_blank' ); },

	

	swapWorker: ( b ) => {
		Main$2.isWorker = b;
		Gui.swapEngine();
	},

	swapEngine: ( type ) => {
		if( !type ) type = Main$2.engineType;
		let name = type.toLowerCase();
		let hash = location.hash;
		let url = 'index';
		let param = 'E=';
		if( Main$2.devMode ) param += 'dev_';
		if( Main$2.isWorker ) param += 'w_';
		param += name;
		window.open( url+'.html?'+param+hash, '_self');
	},

	capture: ( B ) => {
		if(!Gui.video && B ) Gui.video = new Video();
		else {
			if( B ) Gui.video.start();
			else {
				Gui.video.stop();
				Gui.video = null;
			}
		}
		
	},

    update: () => {
		if( Gui.video ) Gui.video.update();
		if( Gui.graph ) Gui.graph.tick( [ Main$2.motor.getDelta()*1000, Main$2.motor.getDelta2()*1000 ] );
	},

    /*addJoystick:() => {
    	Gui.joy = UIL.add('Joystick', {  w:160, mode:1, text:false, pos:{left:'10px', bottom:'30px' }, simple:true })//.onChange( callbackSize )
    }*/

    material:() => {

    	if( Gui.mode !== 'MAT' ) return

    	const ui = Gui.ui;

        const mode = 2;

        ui.clear();

        const Mat = Main$2.motor.getMatRef();
        let mats = Mat.getList();

        /*if( Mat.isRealism ) {

        	let options = Mat.realismOption

        	const upShader = function(){ 
        		//Mat.upShader( options );
		    	//Main.setCamera( {...controler.info } )
		    }

        	let gr = ui.add('group', { name:'REAL LIGHT', color:'#FFFF88', h:30 });
        	gr.add( options, 'enableESL', {}).onChange(upShader)
        	//gr.add( options, 'exposure', { min:0, max:2 }).onChange((v)=>{renderer.toneMappingExposure = v;}) 
			gr.add( options, 'envMapIntensity', { min:0.01, max:2 }).onChange(upShader)
			gr.add( 'empty', { h:10 }) 
			gr.add( options, 'aoColor', { }).onChange(upShader) 
			gr.add( options, 'hemisphereColor',  { }).onChange(upShader) 
			gr.add( options, 'irradianceColor',  { }).onChange(upShader)
			gr.add( options, 'radianceColor', { }).onChange(upShader)
			gr.add( 'empty', { h:10 }) 
			gr.add( options, 'aoPower', { min:0, max:12 }).onChange(upShader) 
			gr.add( options, 'aoSmoothing',  { min:0, max:1 }).onChange(upShader) 
			gr.add( options, 'aoMapGamma',  { min:0.5, max:1.5 }).onChange(upShader)
			gr.add( 'empty', { h:10 }) 
			gr.add( options, 'lightMapGamma', { min:0.5, max:1.5 }).onChange(upShader) 
			gr.add( options, 'lightMapSaturation',  { min:0, max:2.5 }).onChange(upShader) 
			gr.add( options, 'lightMapContrast', { min:0.5, max:1.5 }).onChange(upShader) 
			gr.add( 'empty', { h:10 }) 
			gr.add( options, 'envPower',  { min:0, max:16 }).onChange(upShader)
			gr.add( options, 'roughnessPower', { min:0, max:4 }).onChange(upShader) 
			gr.add( options, 'sunIntensity',  { min:0, max:15 }).onChange(upShader) 
			gr.add( options, 'mapContrast',  { min:0.5, max:1.5 }).onChange(upShader)
			
			gr.add( options, 'smoothingPower',  { min:0, max:1 }).onChange(upShader) 
			gr.add( options, 'irradianceIntensity',  { min:0, max:10 }).onChange(upShader)
			gr.add( options, 'radianceIntensity',  { min:0, max:10 }).onChange(upShader)

        }*/

		//let mats = Main.motor.getMaterialList();
		const matList = ui.add( 'list', { name:'', list:mats, p:0, value:Gui.currentMat, h:40 }).onChange( Gui.materialEdit );

		if( !Gui.currentMat ) {

			matList.text('Select Material');
			return

		}
		
		let m = mats[ Gui.currentMat ];

		//console.log(m)

		let type = m.type;
		if( type.search( 'Mesh' )!==-1 ) type = type.substring( 4 ); 

		let mm = type.search( 'Material' );
		type = type.substring( 0, mm );

		ui.add( 'list', { name:'Type', list:Gui.MaterialMesh, value:type, h:30 }).onChange();

		if(m.side!==undefined) ui.add( m, 'side', { type:'list', list:{ front:0, back:1, double:2 } }).onChange( function( c ){ m.side = this.list.indexOf(c); });
		if(m.shadowSide!==undefined) ui.add( m, 'shadowSide', { type:'list', list:{ front:0, back:1, double:2 } }).onChange( function( c ){ m.shadowSide = this.list.indexOf(c); });

		//return

		let g0 = ui.add('group', { name:'COLORS', color:'#FFaaaa', h:30 });

	    if( m.color!==undefined ) g0.add( m, 'color', {} );
		if( m.specularColor!==undefined ) g0.add( m, 'specularColor', { rename:'specular' } );
		if( m.emissive!==undefined ) g0.add( m, 'emissive', {} );
		if( m.sheen!==undefined ) g0.add( m, 'sheenColor', { rename:'sheen' } );
	    

		let g1 = ui.add('group', { name:'IMAGES', color:'#FFFF88', h:30 });

	    let images = [...Gui.imageMap, ...Gui.imageNormal ], t;

	    for( let i = 0; i<images.length; i++ ){
	    	t = images[i];
	    	name = 'null';
	    	/*if(m[t]){
	    		str = m[t].source.data.currentSrc || 'Direct';
	    	    name = str.substring( str.lastIndexOf('/')+1 )
	    	} */
	    	if(m[t]!==undefined){ 
	    		let short = t.substring( 0, t.lastIndexOf('M') );
	    		let colorSpace = '';
	    		if( short==='displacement') short='displace';
	    		if( t==='map' || short==='emissive' || short==='sheen' ) colorSpace = 'srgb';
	    		//g1.add( 'bitmap',  { name:t, rename:short, value:name, type:'bitmap' }).onChange( function( file, img, name ){ Gui.setTexture(file, img, name, m ) } )
	    	    g1.add( m, t,  { name:t, rename:short, colorSpace:colorSpace, type:'bitmap', h:30 });//.onChange( function( file, img, name ){ Gui.setTexture(file, img, name, m ) } )
	    	}

	    }

	    let g2 = ui.add('group', { name:'OPTIONS', color:'#88FFFF', h:30 });

	    if(m.randomUv!==undefined) g2.add( m, 'randomUv', {  });
		if(m.wireframe!==undefined) g2.add( m, 'wireframe', {  });
		if(m.vertexColors!==undefined) g2.add( m, 'vertexColors', {  });
		if(m.forceSinglePass!==undefined) g2.add( m, 'forceSinglePass', { rename:'singlePass' });
		if(m.visible!==undefined) g2.add( m, 'visible', {  });
		if(m.depthTest!==undefined) g2.add( m, 'depthTest', {  });
		if(m.depthWrite!==undefined) g2.add( m, 'depthWrite', {  });
		if(m.alphaToCoverage!==undefined) g2.add( m, 'alphaToCoverage', {  });
		if(m.premultipliedAlpha!==undefined) g2.add( m, 'premultipliedAlpha', {  });
		if(m.transparent!==undefined) g2.add( m, 'transparent', {  });

		let g3 = ui.add('group', { name:'VALUES', open:true, h:30 });

		if(m.normalScale!==undefined){
			g3.add( m, 'normalScale', { rename:'normal', min:-10, max:10, precision:2 });
			//g3.add( m.normalScale, 'x', { rename:'normal x', min:-10, max:10, precision:1 })
			//g3.add( m.normalScale, 'y', { rename:'normal y', min:-10, max:10, precision:1 })
		}
		if(m.clearcoatNormalScale!==undefined){
			g3.add( m, 'clearcoatNormalScale', { rename:'clearcoat n', min:-10, max:10, precision:2 });
		}

		let deff = { min:0, max:1, mode:mode };

		


	    if(m.metalness!==undefined) g3.add( m, 'metalness', { ...deff });
		if(m.roughness!==undefined) g3.add( m, 'roughness', { ...deff });

		if(m.envMapIntensity!==undefined) g3.add( m, 'envMapIntensity', { ...deff, rename:'envmap', max:3 });
		if(m.opacity!==undefined) g3.add( m, 'opacity', { ...deff });
		if(m.reflectivity!==undefined) g3.add( m, 'reflectivity', {...deff});

		if(m.specularIntensity!==undefined) g3.add( m, 'specularIntensity', { ...deff });
		if(m.aoMapIntensity!==undefined) g3.add( m, 'aoMapIntensity', { ...deff, rename:'ax' });
		if(m.emissiveIntensity!==undefined) g3.add( m, 'emissiveIntensity', { ...deff, rename:'emissive', max:3 });

		if(m.displacementScale!==undefined) g3.add( m, 'displacementScale', { ...deff, min:-0.1, max:0.1 });
		if(m.displacementBias!==undefined) g3.add( m, 'displacementBias', { ...deff, min:-0.1, max:0.1 });

		if(m.bumpScale!==undefined) g3.add( m, 'bumpScale', { ...deff, rename:'bump', max:3 });
		if(m.reflectif!==undefined) g3.add( m, 'reflectif', { ...deff });

	    
	    if(m.thickness!==undefined) g3.add( m, 'thickness', { ...deff, min:-4, max:4 });
	    if(m.clearcoat!==undefined) g3.add( m, 'clearcoat', { ...deff });
	    if(m.clearcoatRoughness!==undefined) g3.add( m, 'clearcoatRoughness', { ...deff });



	    if(m.sheen!==undefined){ 
	    	g3.add( m, 'sheen', {...deff,min:0, max:20});
	    	g3.add( m, 'sheenRoughness', {...deff});
	    	
	    }

	    if(m.iridescence!==undefined) g3.add( m, 'iridescence', {...deff});

	    if(m.anisotropy!==undefined) g3.add( m, 'anisotropy', {...deff});
	    if(m.anisotropyRotation!==undefined) g3.add( m, 'anisotropyRotation', {...deff});

	    if(m.ior!==undefined) g3.add( m, 'ior', { ...deff, min:0, max:4 });
	    if(m.transmission!==undefined) g3.add( m, 'transmission', { ...deff });


		//Gui.mat.open()

		//

	},

	setTexture:( file, img, name, mat, o = {} ) => {

		if( name==='displace') name = 'displacementMap';
		else if( name!=='map') name = name + 'Map';

		if( file === null ){ 
			mat[name] = null;
			//mat.needsUpdate = true;
			return;
		}

		let ref = mat[name];
		if(ref){
			o.repeat = ref.repeat.toArray();
		}

		o.encoding = Gui.imageMap.indexOf(name) !== -1;
		o.flipY = false;

		let fileName = file.substring( 0, file.lastIndexOf('.') );
		let fileType = file.substring( file.lastIndexOf('.')+1 );
		

		if( fileType==='exr' ){
			//console.log(img)
			//mat[name] = 
			Pool.load_EXR( file, fileName, function(t){mat[name] = t;} );
		} else {

			let im = new Image();
			im.src = img;
			im.onload = function (){

				Pool.data.set( 'I_' + fileName, im );
			    mat[name] = Pool.getTexture( fileName, o );
			    //mat.needsUpdate = true;

			};
		}


		

	},

	materialEdit:( name ) => {

		if( Gui.mode !== 'MAT' ) return
		if( name === Gui.currentMat ) return

		Gui.currentMat = name;
	    setTimeout( Gui.material, 0 );

	},

	postprocessEdit:( name ) => {

		if( Gui.mode !== 'POST' ) return

		Gui.postprocess(true);

	    //setTimeout( Gui.postprocess, 100 )

	},

};







const iconUI =  function ( type, over = false ){

    var viewBox = '0 0 30 26';
    var d = '';

    var c = over ? ['#baabfb', '#9e87fb', '#7463b8', '#221d36'] : ['#E5E5E5', '#D1D1D1', '#999999', '#383838'];

    var t = ["<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none; margin-top:0px;' preserveAspectRatio='none' x='0px' y='0px' width='30px' height='26px' viewBox='"+viewBox+"'><g>"];
    switch(type){

        case 'phy':
        d = 'M 22.2 11.35 Q 21.95 10.15 21.25 9.1 L 22.45 7.85 Q 21.95 7.2 21.4 6.65 20.8 6 20.1 5.55 L 18.95 6.75 Q 17.9 6.05 16.65 5.8 L 16.65 4.15 Q 15.9 4 15.05 4 14.2 4 13.4 4.2 L 13.4 5.8 Q 12.15 6.05 11.15 6.75 L 9.95 5.55 Q 9.25 6 8.65 6.65 8.1 7.2 7.65 7.9 L 8.8 9.05 Q 8.1 10.1 7.85 11.35 L 6.2 11.35 Q 6.1 12.15 6.1 13 6.1 13.85 6.2 14.65 L 7.85 14.65 Q 8.1 15.85 8.8 16.9 L 7.6 18.05 Q 8.1 18.7 8.7 19.3 9.25 19.9 9.95 20.4 L 11.1 19.25 Q 12.15 19.9 13.4 20.2 L 13.4 21.85 Q 14.2 21.95 15.05 21.95 15.9 21.95 16.65 21.85 L 16.65 20.2 Q 17.9 19.9 19 19.25 L 20.15 20.4 Q 20.8 19.95 21.4 19.35 22 18.75 22.45 18.05 L 21.25 16.85 Q 21.95 15.85 22.2 14.65 L 23.95 14.65 Q 24.05 13.85 24.05 13 24.05 12.15 23.95 11.35 L 22.2 11.35 M 13.25 11.3 Q 14 10.55 15.05 10.55 16 10.55 16.75 11.3 17.5 12 17.5 13 17.5 14.05 16.75 14.7 16 15.45 15.05 15.45 14 15.45 13.25 14.7 12.6 14.05 12.6 13 12.6 12 13.25 11.3 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='"+d+"'/>";
       break;

       case 'env':
        d = 'M 7.95 18.65 L 9.35 20.05 10.75 18.65 9.35 17.25 7.95 18.65 M 9.35 5.95 L 7.95 7.35 9.35 8.75 10.75 7.35 9.35 5.95 M 20.65 20.05 L 22.05 18.65 20.65 17.25 19.25 18.65 20.65 20.05 M 20.65 8.75 L 22.05 7.35 20.65 5.95 19.25 7.35 20.65 8.75 M 14 22 L 16 22 16 20 14 20 14 22 M 16 6 L 16 4 14 4 14 6 16 6 M 24 12 L 22 12 22 14 24 14 24 12 M 8 12 L 6 12 6 14 8 14 8 12 M 19.3 17.3 Q 21.05 15.55 21.05 13.05 21.05 10.5 19.3 8.75 17.55 7.05 15.05 7.05 12.55 7.05 10.8 8.75 9.05 10.5 9.05 13.05 9.05 15.55 10.8 17.3 12.55 19.05 15.05 19.05 17.55 19.05 19.3 17.3 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='"+d+"'/>";
       break;

       case 'post':
        d = 'M 24 22 L 24 8 20 8 20 4 6 4 6 18 10 18 10 22 24 22 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='M 20 8 L 20 4 6 4 6 18 10 18 10 8 20 8 Z'/>";
        break;

        case 'cam':
        d = 'M 23 20 L 24 20 24 6 23 6 19 10 18.05 10 18.05 6.05 6.05 6.05 6.05 20.3 18.05 20.3 18.05 16 19 16 23 20 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='M 23 20 L 24 20 24 6 23 6 19 10 19 16 23 20 M 18 6.05 L 8 6.05 8 18.15 18 18.15 18 6.05 Z'/>";
        //t[1]+="<path fill="+c[0]+" stroke='none' d='M 10 4 L 6 8 19 8 24 4 10 4 Z'/>";
        break;

        /*case 'post':
        d = 'M 24 15 L 24 11 17 11 17 4 13 4 13 11 6 11 6 15 13 15 13 22 17 22 17 15 24 15 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='"+d+"'/>";
        break;*/

        case 'mat':
        d = 'M 24 4 L 6 4 6 22 24 22 24 4 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='M 15 4 L 6 4 6 13 15 13 15 4 M 24 13 L 15 13 15 22 24 22 24 13 Z'/>";
        break;

        /*case 'cam':
        d = 'M 24 18 L 24 4 10 4 6 8 6 22 19 22 24 18 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='M 19 8 L 6 8 6 22 19 22 19 8 Z'/>";
        t[1]+="<path fill="+c[0]+" stroke='none' d='M 10 4 L 6 8 19 8 24 4 10 4 Z'/>";
        break;*/

        case 'asset':
        d = 'M 24 19.8 L 24 14.2 19.5 11.95 19.5 6.3 15 4.05 10.5 6.3 10.5 11.95 6 14.2 6 19.8 10.5 22.05 15 19.8 19.5 22.05 24 19.8 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='M 6 14.2 L 6 19.8 10.5 22.05 10.5 16.45 6 14.2 M 19.5 22.05 L 19.5 16.45 15 14.2 15 19.8 19.5 22.05 M 15 8.55 L 10.5 6.3 10.5 11.95 15 14.2 15 8.55 Z'/>";
        t[1]+="<path fill="+c[0]+" stroke='none' d='M 15 14.2 L 19.5 16.45 24 14.2 19.5 11.95 15 14.2 M 10.5 16.45 L 15 14.2 10.5 11.95 6 14.2 10.5 16.45 M 10.5 6.3 L 15 8.55 19.5 6.3 15 4.05 10.5 6.3 Z'/>";
        break;


    }
    t[2] = "</g></svg>";
    return t.join("\n");

};

var BACKGROUND_COLOR="#282923",LINE_HEIGHT="19px",FONT_SIZE="15px",defaultCssTheme="\n.codeflask {\n  background: "+BACKGROUND_COLOR+";\n  //color: rgba(0, 0, 0, 0);\n  color: #f8f8f2;\n  //border-radius: 12px;\n  //text-shadow: 1px 1px 1px black;\n  //resize: true;\n}\n\n.codeflask ::-webkit-scrollbar {\n  width: 15px;\n  height:15px;\n}\n\n.codeflask ::-webkit-scrollbar-track {\n  background:none;\n  /*background-clip: content-box;*/\n  \n}\n\n.codeflask ::-webkit-scrollbar-thumb {\n  background-color: #555652; \n  width: 7px;\n  //border-radius: 12px;\n  border: 4px solid "+BACKGROUND_COLOR+";\n}\n\n.codeflask ::-webkit-scrollbar-corner {\n  background-color: rgba(0,0,0,0);\n}\n\n\n\n.codeflask ::selection {\n  color: transparent;\n  background-color: #47473d; //rgba(71, 71, 61, 0.5);\n}\n\n.codeflask ::-moz-selection{\n  color: transparent;\n  background-color: #47473d; //rgba(71, 71, 61, 0.5);\n}\n\n\n.codeflask .token.punctuation { color: #f8f8f2; /* white */ }\n\n.codeflask .token.function { color: #67d8ef; /* blue */ } \n.codeflask .token.keyword { color: #67d8ef; font-style: italic; /* blue */ }\n\n.codeflask .token.function-variable { color: #a6e22c; /* green */ }\n.codeflask .token.class-name { color: #a6e22c; /* green */ }\n.codeflask .token.function-extra { color: #a6e22c; /* green */ }\n\n.codeflask .token.keyword-variable { color: #f92672; font-style: normal; /* red */ }\n.codeflask .token.operator { color: #f92672; /* red */ }\n\n.codeflask .token.parameter { color: #fd9621;/* orange */}\n.codeflask .token.parameter-variable { color: #fd9621;/* orange */}\n\n.codeflask .token.string { color: #e7db75; /* yellow */ }\n\n.codeflask .token.comment { color: #75715e; /* grey */ }\n\n\n\n.codeflask .token.boolean { color: #ae81ff; /* purple */ }\n.codeflask .token.number { color: #ae81ff; /* purple */ }\n\n.codeflask .token-template-string { color: #000000; }\n.codeflask .token-class-name { color: #000000; }\n.codeflask .token-regex { color: #000000; }\n\n.codeflask .token.selector { color: #00FF00; }\n.codeflask .token.property { color: #ac80ff;}\n.codeflask .token.tag { color: #FFFF00; }\n.codeflask .token.attr-value { color: #0000FF;}\n\n";function cssSupports(e,t){return "undefined"!=typeof CSS?CSS.supports(e,t):"undefined"!=typeof document&&toCamelCase(e)in document.body.style}function toCamelCase(e){return (e=e.split("-").filter(function(e){return !!e}).map(function(e){return e[0].toUpperCase()+e.substr(1)}).join(""))[0].toLowerCase()+e.substr(1)}var FONT_FAMILY="Consolas, Menlo, Courier, monospace",COLOR=cssSupports("caret-color","#F00")?BACKGROUND_COLOR:"#ccc",LINE_NUMBER_WIDTH="40px",editorCss="\n  .codeflask {\n    -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none;\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n\n  .codeflask, .codeflask * {\n    box-sizing: border-box;\n    border: none;\n    resize: none;\n    outline: none;\n  }\n\n  .codeflask__pre {\n    -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none; pointer-events:none;\n    z-index: 3;\n    transform:translate3d(0, 0, 0);\n    box-sizing: border-box;\n    //white-space: pre;\n    padding:0px;\n    word-wrap: normal;\n    box-sizing: border-box;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: visible; !important;\n  }\n\n  .codeflask__textarea {\n\n    background: none;\n    //background:red;\n    border: none;\n    color: "+COLOR+";\n    color: rgba(0, 0, 0, 0);\n    z-index: 1;\n    resize: none;\n    //font-family: "+FONT_FAMILY+";\n    //text-rendering: optimizeSpeed;\n    //text-rendering: inherit;\n    //-webkit-appearance: pre;\n    caret-color: #fff;\n    z-index: 2;\n    width: 100%;\n    height: 100%;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n\n    border: none;\n    outline: none;\n    spellcheck:false;\n    //overflow: hidden;\n    overflow: scroll !important;\n\n  }\n\n  .codeflask--has-line-numbers .codeflask__textarea {\n    width: calc(100% - "+LINE_NUMBER_WIDTH+");\n  }\n\n  .codeflask__code {\n    //padding: 10px;\n    //background:black;\n    display:block;\n    font-size: "+FONT_SIZE+";\n    line-height: "+LINE_HEIGHT+";\n    font-family: "+FONT_FAMILY+";\n    //overflow: hidden;\n    //overflow: scroll !important;\n    //left:3px;\n    //width: auto;\n    //position: absolute;\n    outline: none;\n    resize: none;\n    box-sizing: content-box;\n    display: inline-block;\n  }\n\n  .codeflask__flatten {\n\n    //background:grey;\n    padding: 10px;\n    font-size: "+FONT_SIZE+";\n    line-height: "+LINE_HEIGHT+";\n    font-family: "+FONT_FAMILY+";\n    text-rendering: optimizeLegibility;\n    //letter-spacing: 1px;\n    white-space: pre;\n    word-wrap: normal;\n    box-sizing: border-box;\n    position: absolute;\n    top: 0;\n    left: 0;\n    margin: 0 !important;\n    outline: none;\n    text-align: left;\n    cursor:auto;\n    outline: none;\n    border-radius: 0;\n    border-width: 0;\n    background: transparent;\n    //-webkit-background-clip: padding-box;\n    background-clip: padding-box;\n    resize: none;\n\n  }\n\n  .codeflask--has-line-numbers .codeflask__flatten {\n    width: calc(100% - "+LINE_NUMBER_WIDTH+");\n    left: "+LINE_NUMBER_WIDTH+";\n    outline: none;\n  }\n\n  .codeflask__line-highlight {\n    position: absolute;\n    top: 10px;\n    left: 0;\n    width: 100%;\n    height: "+LINE_HEIGHT+";\n    background: rgba(0,0,0,0.1);\n\n    z-index: 1;\n    //visibility: hidden;\n    outline: none;\n  }\n\n  .codeflask__lines {\n    padding: 10px 4px;\n    font-size:  "+FONT_SIZE+";\n    line-height: "+LINE_HEIGHT+";\n    font-family: "+FONT_FAMILY+";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: "+LINE_NUMBER_WIDTH+";\n    height: 100%;\n    text-align: right;\n    color: #90918b;\n    z-index: 2;\n    outline: none;\n  }\n\n  .codeflask__lines__line {\n    display: block;\n    outline: none;\n  }\n\n  .codeflask.codeflask--has-line-numbers {\n    padding-left: "+LINE_NUMBER_WIDTH+";\n  }\n\n  .codeflask.codeflask--has-line-numbers:before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: "+LINE_NUMBER_WIDTH+";\n    height: 100%;\n    //background: "+BACKGROUND_COLOR+";\n    z-index: 1;\n    outline: none;\n  }\n\n  .codeflask__error {\n    padding: 0px 0px;\n    padding-right:4px;\n    font-size:  "+FONT_SIZE+";\n    font-family: "+FONT_FAMILY+";\n    position: absolute;\n    left: 0;\n    width: "+LINE_NUMBER_WIDTH+";\n    height: "+LINE_HEIGHT+";\n    text-align: right;\n    color: #FF0000;\n    background:rgba(255,0,0,0.3);\n    outline: none;\n    z-index: 3;\n    display:none;\n  }\n";function injectCss(e,t,n){var a=t||"codeflask-style",r=n||document.head;if(!e)return  false;if(document.getElementById(a))return  true;var s=document.createElement("style");return s.innerHTML=e,s.id=a,r.appendChild(s),true}var entityMap={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;","`":"&#x60;","=":"&#x3D;"};function escapeHtml(e){return String(e).replace(/[&<>"'`=/]/g,function(e){return entityMap[e]})}var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(e){var t=/(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,n=0,a={},r={manual:e.Prism&&e.Prism.manual,disableWorkerMessageHandler:e.Prism&&e.Prism.disableWorkerMessageHandler,util:{encode:function e(t){return t instanceof s?new s(t.type,e(t.content),t.alias):Array.isArray(t)?t.map(e):t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++n}),e.__id},clone:function e(t,n){var a,s;switch(n=n||{},r.util.type(t)){case "Object":if(s=r.util.objId(t),n[s])return n[s];for(var i in a={},n[s]=a,t)t.hasOwnProperty(i)&&(a[i]=e(t[i],n));return a;case "Array":return s=r.util.objId(t),n[s]?n[s]:(a=[],n[s]=a,t.forEach(function(t,r){a[r]=e(t,n);}),a);default:return t}},getLanguage:function(e){for(;e;){var n=t.exec(e.className);if(n)return n[1].toLowerCase();e=e.parentElement;}return "none"},setLanguage:function(e,n){e.className=e.className.replace(RegExp(t,"gi"),""),e.classList.add("language-"+n);},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(a){var e=(/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(a.stack)||[])[1];if(e){var t=document.getElementsByTagName("script");for(var n in t)if(t[n].src==e)return t[n]}return null}},isActive:function(e,t,n){for(var a="no-"+t;e;){var r=e.classList;if(r.contains(t))return  true;if(r.contains(a))return  false;e=e.parentElement;}return !!n}},languages:{plain:a,plaintext:a,text:a,txt:a,extend:function(e,t){var n=r.util.clone(r.languages[e]);for(var a in t)n[a]=t[a];return n},insertBefore:function(e,t,n,a){var s=(a=a||r.languages)[e],i={};for(var o in s)if(s.hasOwnProperty(o)){if(o==t)for(var l in n)n.hasOwnProperty(l)&&(i[l]=n[l]);n.hasOwnProperty(o)||(i[o]=s[o]);}var c=a[e];return a[e]=i,r.languages.DFS(r.languages,function(t,n){n===c&&t!=e&&(this[t]=i);}),i},DFS:function e(t,n,a,s){s=s||{};var i=r.util.objId;for(var o in t)if(t.hasOwnProperty(o)){n.call(t,o,t[o],a||o);var l=t[o],c=r.util.type(l);"Object"!==c||s[i(l)]?"Array"!==c||s[i(l)]||(s[i(l)]=true,e(l,n,o,s)):(s[i(l)]=true,e(l,n,null,s));}}},plugins:{},highlightAll:function(e,t){r.highlightAllUnder(document,e,t);},highlightAllUnder:function(e,t,n){var a={callback:n,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};r.hooks.run("before-highlightall",a),a.elements=Array.prototype.slice.apply(a.container.querySelectorAll(a.selector)),r.hooks.run("before-all-elements-highlight",a);for(var s,i=0;s=a.elements[i++];)r.highlightElement(s,true===t,a.callback);},highlightElement:function(t,n,a){var s=r.util.getLanguage(t),i=r.languages[s];r.util.setLanguage(t,s);var o=t.parentElement;o&&"pre"===o.nodeName.toLowerCase()&&r.util.setLanguage(o,s);var l={element:t,language:s,grammar:i,code:t.textContent};function c(e){l.highlightedCode=e,r.hooks.run("before-insert",l),l.element.innerHTML=l.highlightedCode,r.hooks.run("after-highlight",l),r.hooks.run("complete",l),a&&a.call(l.element);}if(r.hooks.run("before-sanity-check",l),(o=l.element.parentElement)&&"pre"===o.nodeName.toLowerCase()&&!o.hasAttribute("tabindex")&&o.setAttribute("tabindex","0"),!l.code)return r.hooks.run("complete",l),void(a&&a.call(l.element));if(r.hooks.run("before-highlight",l),l.grammar)if(n&&e.Worker){var u=new Worker(r.filename);u.onmessage=function(e){c(e.data);},u.postMessage(JSON.stringify({language:l.language,code:l.code,immediateClose:true}));}else c(r.highlight(l.code,l.grammar,l.language));else c(r.util.encode(l.code));},highlight:function(e,t,n){var a={code:e,grammar:t,language:n};if(r.hooks.run("before-tokenize",a),!a.grammar)throw new Error('The language "'+a.language+'" has no grammar.');return a.tokens=r.tokenize(a.code,a.grammar),r.hooks.run("after-tokenize",a),s.stringify(r.util.encode(a.tokens),a.language)},tokenize:function(e,t){var n=t.rest;if(n){for(var a in n)t[a]=n[a];delete t.rest;}var c=new function(){var e={value:null,prev:null,next:null},t={value:null,prev:e,next:null};e.next=t,this.head=e,this.tail=t,this.length=0;};return o(c,c.head,e),function e(t,n,a,c,u,d){for(var p in a)if(a.hasOwnProperty(p)&&a[p]){var h=a[p];h=Array.isArray(h)?h:[h];for(var g=0;g<h.length;++g){if(d&&d.cause==p+","+g)return;var f=h[g],m=f.inside,b=!!f.lookbehind,k=!!f.greedy,y=f.alias;if(k&&!f.pattern.global){var x=f.pattern.toString().match(/[imsuy]*$/)[0];f.pattern=RegExp(f.pattern.source,x+"g");}for(var v=f.pattern||f,F=c.next,w=u;F!==n.tail&&!(d&&w>=d.reach);w+=F.value.length,F=F.next){var _=F.value;if(n.length>t.length)return;if(!(_ instanceof s)){var C,E=1;if(k){if(!(C=i(v,w,t,b))||C.index>=t.length)break;var A=C.index,T=C.index+C[0].length,L=w;for(L+=F.value.length;A>=L;)F=F.next,L+=F.value.length;if(L-=F.value.length,w=L,F.value instanceof s)continue;for(var P=F;P!==n.tail&&(L<T||"string"==typeof P.value);P=P.next)E++,L+=P.value.length;E--,_=t.slice(w,L),C.index-=w;}else if(!(C=i(v,0,_,b)))continue;var A=C.index,S=C[0],N=_.slice(0,A),I=_.slice(A+S.length),z=w+_.length;d&&z>d.reach&&(d.reach=z);var $=F.prev;N&&($=o(n,$,N),w+=N.length),l(n,$,E);var O=new s(p,m?r.tokenize(S,m):S,y,S);if(F=o(n,$,O),I&&o(n,F,I),E>1){var D={cause:p+","+g,reach:z};e(t,n,a,F.prev,w,D),d&&D.reach>d.reach&&(d.reach=D.reach);}}}}}}(e,c,t,c.head,0),function(e){var t=[],n=e.head.next;for(;n!==e.tail;)t.push(n.value),n=n.next;return t}(c)},hooks:{all:{},add:function(e,t){var n=r.hooks.all;n[e]=n[e]||[],n[e].push(t);},run:function(e,t){var n=r.hooks.all[e];if(n&&n.length)for(var a,s=0;a=n[s++];)a(t);}},Token:s};function s(e,t,n,a){this.type=e,this.content=t,this.alias=n,this.length=0|(a||"").length;}function i(e,t,n,a){e.lastIndex=t;var r=e.exec(n);if(r&&a&&r[1]){var s=r[1].length;r.index+=s,r[0]=r[0].slice(s);}return r}function o(e,t,n){var a=t.next,r={value:n,prev:t,next:a};return t.next=r,a.prev=r,e.length++,r}function l(e,t,n){for(var a=t.next,r=0;r<n&&a!==e.tail;r++)a=a.next;t.next=a,a.prev=t,e.length-=r;}if(e.Prism=r,s.stringify=function e(t,n){if("string"==typeof t)return t;if(Array.isArray(t)){var a="";return t.forEach(function(t){a+=e(t,n);}),a}var s={type:t.type,content:e(t.content,n),tag:"span",classes:["token",t.type],attributes:{},language:n},i=t.alias;i&&(Array.isArray(i)?Array.prototype.push.apply(s.classes,i):s.classes.push(i)),r.hooks.run("wrap",s);var o="";for(var l in s.attributes)o+=" "+l+'="'+(s.attributes[l]||"").replace(/"/g,"&quot;")+'"';return "<"+s.tag+' class="'+s.classes.join(" ")+'"'+o+">"+s.content+"</"+s.tag+">"},!e.document)return e.addEventListener?(r.disableWorkerMessageHandler||e.addEventListener("message",function(t){var n=JSON.parse(t.data),a=n.language,s=n.code,i=n.immediateClose;e.postMessage(r.highlight(s,r.languages[a],a)),i&&e.close();},false),r):r;var c=r.util.currentScript();function u(){r.manual||r.highlightAll();}if(c&&(r.filename=c.src,c.hasAttribute("data-manual")&&(r.manual=true)),!r.manual){var d=document.readyState;"loading"===d||"interactive"===d&&c&&c.defer?document.addEventListener("DOMContentLoaded",u):window.requestAnimationFrame?window.requestAnimationFrame(u):window.setTimeout(u,16);}return r}(_self);"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism),Prism.languages.markup={comment:{pattern:/<!--(?:(?!<!--)[\s\S])*?-->/,greedy:true},prolog:{pattern:/<\?[\s\S]+?\?>/,greedy:true},doctype:{pattern:/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,greedy:true,inside:{"internal-subset":{pattern:/(^[^\[]*\[)[\s\S]+(?=\]>$)/,lookbehind:true,greedy:true,inside:null},string:{pattern:/"[^"]*"|'[^']*'/,greedy:true},punctuation:/^<!|>$|[[\]]/,"doctype-tag":/^DOCTYPE/i,name:/[^\s<>'"]+/}},cdata:{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,greedy:true},tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,greedy:true,inside:{tag:{pattern:/^<\/?[^\s>\/]+/,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"special-attr":[],"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,inside:{punctuation:[{pattern:/^=/,alias:"attr-equals"},{pattern:/^(\s*)["']|["']$/,lookbehind:true}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:[{pattern:/&[\da-z]{1,8};/i,alias:"named-entity"},/&#x?[\da-f]{1,8};/i]},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.languages.markup.doctype.inside["internal-subset"].inside=Prism.languages.markup,Prism.hooks.add("wrap",function(e){"entity"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,"&"));}),Object.defineProperty(Prism.languages.markup.tag,"addInlined",{value:function(e,t){var n={};n["language-"+t]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:true,inside:Prism.languages[t]},n.cdata=/^<!\[CDATA\[|\]\]>$/i;var a={"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:n}};a["language-"+t]={pattern:/[\s\S]+/,inside:Prism.languages[t]};var r={};r[e]={pattern:RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g,function(){return e}),"i"),lookbehind:true,greedy:true,inside:a},Prism.languages.insertBefore("markup","cdata",r);}}),Object.defineProperty(Prism.languages.markup.tag,"addAttribute",{value:function(e,t){Prism.languages.markup.tag.inside["special-attr"].push({pattern:RegExp(/(^|["'\s])/.source+"(?:"+e+")"+/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,"i"),lookbehind:true,inside:{"attr-name":/^[^\s=]+/,"attr-value":{pattern:/=[\s\S]+/,inside:{value:{pattern:/(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,lookbehind:true,alias:[t,"language-"+t],inside:Prism.languages[t]},punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}}}});}}),Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup,Prism.languages.xml=Prism.languages.extend("markup",{}),Prism.languages.ssml=Prism.languages.xml,Prism.languages.atom=Prism.languages.xml,Prism.languages.rss=Prism.languages.xml,function(e){var t=/(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;e.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:RegExp("@[\\w-](?:"+/[^;{\s"']|\s+(?!\s)/.source+"|"+t.source+")*?"+/(?:;|(?=\s*\{))/.source),inside:{rule:/^@[\w-]+/,"selector-function-argument":{pattern:/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,lookbehind:true,alias:"selector"},keyword:{pattern:/(^|[^\w-])(?:and|not|only|or)(?![\w-])/,lookbehind:true}}},url:{pattern:RegExp("\\burl\\((?:"+t.source+"|"+/(?:[^\\\r\n()"']|\\[\s\S])*/.source+")\\)","i"),greedy:true,inside:{function:/^url/i,punctuation:/^\(|\)$/,string:{pattern:RegExp("^"+t.source+"$"),alias:"url"}}},selector:{pattern:RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|"+t.source+")*(?=\\s*\\{)"),lookbehind:true},string:{pattern:t,greedy:true},property:{pattern:/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,lookbehind:true},important:/!important\b/i,function:{pattern:/(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,lookbehind:true},punctuation:/[(){};:,]/},e.languages.css.atrule.inside.rest=e.languages.css;var n=e.languages.markup;n&&(n.tag.addInlined("style","css"),n.tag.addAttribute("style","css"));}(Prism),Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:true,greedy:true},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:true,greedy:true}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:true},"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:true,inside:{punctuation:/[.\\]/}},keyword:/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,boolean:/\b(?:false|true)\b/,function:/\b\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,punctuation:/[{}[\];(),.:]/},Prism.languages.javascript=Prism.languages.extend("clike",{"class-name":[Prism.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype))/,lookbehind:true}],keyword:[{pattern:/((?:^|\})\s*)catch\b/,lookbehind:true},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|window|document|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|of|package|private|protected|public|return|static|super|switch|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:true}],function:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,number:{pattern:RegExp(/(^|[^\w$])/.source+"(?:"+/NaN|Infinity|null/.source+"|"+/0[bB][01]+(?:_[01]+)*n?/.source+"|"+/0[oO][0-7]+(?:_[0-7]+)*n?/.source+"|"+/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source+"|"+/\d+(?:_\d+)*n/.source+"|"+/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source+")"+/(?![\w$])/.source),lookbehind:true},operator:/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?/}),Prism.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new|)\s+)[\w.\\]+/,Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source+/\//.source+"(?:"+/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source+"|"+/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source+")"+/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),lookbehind:true,greedy:true,inside:{"regex-source":{pattern:/^(\/)[\s\S]+(?=\/[a-z]*$)/,lookbehind:true,alias:"language-regex",inside:Prism.languages.regex},"regex-delimiter":/^\/|\/$/,"regex-flags":/^[a-z]+$/}},"function-variable":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,alias:"function"},"function-extra":{pattern:/(?:constructor)/,alias:"keyword"},"keyword-variable":{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|continue|debugger|default|delete|do|else|enum|export|default|extends|for|from|(?:get|set)(?=\s*[\[$\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|new|of|package|private|protected|public|return|static|super|switch|throw|try|typeof|undefined|void|while|with|yield)\b/,alias:"keyword"},"parameter-variable":{pattern:/this/,alias:"keyword"},parameter:[{pattern:/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,lookbehind:true,inside:Prism.languages.javascript},{pattern:/(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,inside:Prism.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,lookbehind:true,inside:Prism.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,lookbehind:true,inside:Prism.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),Prism.languages.insertBefore("javascript","string",{hashbang:{pattern:/^#!.*/,greedy:true,alias:"comment"},"template-string":{pattern:/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,greedy:true,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,lookbehind:true,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}},"string-property":{pattern:/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,lookbehind:true,greedy:true,alias:"property"}}),Prism.languages.markup&&(Prism.languages.markup.tag.addInlined("script","javascript"),Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,"javascript")),Prism.languages.js=Prism.languages.javascript,Prism.languages.c=Prism.languages.extend("clike",{comment:{pattern:/\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,greedy:true},string:{pattern:/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,greedy:true},"class-name":{pattern:/(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,lookbehind:true},keyword:/\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,function:/\b[a-z_]\w*(?=\s*\()/i,number:/(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/}),Prism.languages.insertBefore("c","string",{char:{pattern:/'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,greedy:true}}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,lookbehind:true,greedy:true,alias:"property",inside:{string:[{pattern:/^(#\s*include\s*)<[^>]+>/,lookbehind:true},Prism.languages.c.string],char:Prism.languages.c.char,comment:Prism.languages.c.comment,"macro-name":[{pattern:/(^#\s*define\s+)\w+\b(?!\()/i,lookbehind:true},{pattern:/(^#\s*define\s+)\w+\b(?=\()/i,lookbehind:true,alias:"function"}],directive:{pattern:/^(#\s*)[a-z]+/,lookbehind:true,alias:"keyword"},"directive-hash":/^#/,punctuation:/##|\\(?=[\r\n])/,expression:{pattern:/\S[\s\S]*/,inside:Prism.languages.c}}}}),Prism.languages.insertBefore("c","function",{constant:/\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/}),delete Prism.languages.c.boolean,Prism.languages.glsl=Prism.languages.extend("c",{keyword:/\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/});var CodeFlask=function(e,t){if(!e)throw Error("CodeFlask expects a parameter which is Element or a String selector");if(!t)throw Error("CodeFlask expects an object containing options as second parameter");if(e.nodeType)this.editorRoot=e;else {var n=document.querySelector(e);n&&(this.editorRoot=n);}this.opts=t,this.startEditor();};CodeFlask.prototype.clear=function(){this.elPre.removeChild(this.elCode),this.opts.lineNumbers&&this.elWrapper.removeChild(this.elLineNumbers),this.elWrapper.removeChild(this.elPre),this.elWrapper.removeChild(this.elTextarea),this.editorRoot.removeChild(this.elWrapper),this.code="",this.editorRoot.innerHTML="";},CodeFlask.prototype.startEditor=function(){if(!injectCss(editorCss,null,this.opts.styleParent))throw Error("Failed to inject CodeFlask CSS.");this.isEdit=false,this.createWrapper(),this.createTextarea(),this.createPre(),this.createCode(),this.runOptions(),this.listenTextarea(),this.populateDefault(),this.updateCode(this.code);},CodeFlask.prototype.getDom=function(){return this.elWrapper},CodeFlask.prototype.getText=function(){return this.elTextarea},CodeFlask.prototype.createWrapper=function(){this.code=this.editorRoot.innerHTML,this.editorRoot.innerHTML="",this.elWrapper=this.createElement("div",this.editorRoot),this.elWrapper.classList.add("codeflask");},CodeFlask.prototype.createTextarea=function(){this.elTextarea=this.createElement("textarea",this.elWrapper),this.elTextarea.classList.add("codeflask__textarea","codeflask__flatten");},CodeFlask.prototype.createPre=function(){this.elPre=this.createElement("pre",this.elWrapper),this.elPre.classList.add("codeflask__pre","codeflask__flatten");},CodeFlask.prototype.createCode=function(){this.elCode=this.createElement("code",this.elPre),this.elCode.classList.add("codeflask__code","language-"+(this.opts.language||"html"));},CodeFlask.prototype.createLineNumbers=function(){this.elLineNumbers=this.createElement("div",this.elWrapper),this.elLineNumbers.classList.add("codeflask__lines"),this.setLineNumber();},CodeFlask.prototype.createError=function(){this.elError=this.createElement("div",this.elWrapper),this.elError.classList.add("codeflask__error");},CodeFlask.prototype.createElement=function(e,t){var n=document.createElement(e);return t.appendChild(n),n},CodeFlask.prototype.runOptions=function(){this.opts.rtl=this.opts.rtl||false,this.opts.tabSize=this.opts.tabSize||4,this.opts.enableAutocorrect=this.opts.enableAutocorrect||false,this.opts.lineNumbers=this.opts.lineNumbers||false,this.opts.defaultTheme=false!==this.opts.defaultTheme,this.opts.areaId=this.opts.areaId||null,this.opts.ariaLabelledby=this.opts.ariaLabelledby||null,this.opts.readonly=this.opts.readonly||null,"boolean"!=typeof this.opts.handleTabs&&(this.opts.handleTabs=true),"boolean"!=typeof this.opts.handleSelfClosingCharacters&&(this.opts.handleSelfClosingCharacters=true),"boolean"!=typeof this.opts.handleNewLineIndentation&&(this.opts.handleNewLineIndentation=true),true===this.opts.rtl&&(this.elTextarea.setAttribute("dir","rtl"),this.elPre.setAttribute("dir","rtl")),false===this.opts.enableAutocorrect&&(this.elTextarea.setAttribute("spellcheck","false"),this.elTextarea.setAttribute("autocapitalize","off"),this.elTextarea.setAttribute("autocomplete","off"),this.elTextarea.setAttribute("autocorrect","off")),this.opts.lineNumbers&&(this.elWrapper.classList.add("codeflask--has-line-numbers"),this.createLineNumbers(),this.createError()),this.opts.defaultTheme&&injectCss(defaultCssTheme,"theme-default",this.opts.styleParent),this.opts.areaId&&this.elTextarea.setAttribute("id",this.opts.areaId),this.opts.ariaLabelledby&&this.elTextarea.setAttribute("aria-labelledby",this.opts.ariaLabelledby),this.opts.readonly&&this.enableReadonlyMode();},CodeFlask.prototype.updateLineNumbersCount=function(){for(var e="",t=1;t<=this.lineNumber;t++)e=e+'<span class="codeflask__lines__line">'+t+"</span>";this.elLineNumbers.innerHTML=e;},CodeFlask.prototype.listenTextarea=function(){var e=this;this.elTextarea.addEventListener("input",function(t){e.code=t.target.value,e.elCode.innerHTML=escapeHtml(t.target.value),e.highlight(),setTimeout(function(){e.runUpdate(),e.setLineNumber();},1);}),this.elTextarea.addEventListener("keydown",function(t){if(!e.opts.readonly){e.handleTabs(t),e.handleSelfClosingCharacters(t),e.handleNewLineIndentation(t),e.isEdit=true;}}),this.elTextarea.addEventListener("scroll",function(t){e.scroll(t);});},CodeFlask.prototype.wheel=function(e){var t=e.deltaY>0?1:-1;this.elTextarea.scrollTop+=100*t,this.elPre.style.transform="translate3d(0, -"+this.elTextarea.scrollTop+"px, 0)",this.elLineNumbers&&(this.elLineNumbers.style.transform="translate3d(0, -"+this.elTextarea.scrollTop+"px, 0)"),this.elError&&(this.elError.style.transform="translate3d(0, -"+this.elTextarea.scrollTop+"px, 0)");},CodeFlask.prototype.scroll=function(e){this.elPre.style.transform="translate3d(-"+e.target.scrollLeft+"px, -"+e.target.scrollTop+"px, 0)",this.elLineNumbers&&(this.elLineNumbers.style.transform="translate3d(-"+this.elTextarea.scrollLeft+"px, -"+e.target.scrollTop+"px, 0)"),this.elError&&(this.elError.style.transform="translate3d(-"+this.elTextarea.scrollLeft+"px, -"+e.target.scrollTop+"px, 0)");},CodeFlask.prototype.handleTabs=function(e){if(this.opts.handleTabs){if(9!==e.keyCode)return  false;e.preventDefault();var t=this.elTextarea,n=t.selectionDirection,a=t.selectionStart,r=t.selectionEnd,s=t.value,i=s.substr(0,a),o=s.substring(a,r),l=s.substring(r),c=" ".repeat(this.opts.tabSize);if(a!==r&&o.length>=c.length){var u=a-i.split("\n").pop().length,d=c.length,p=c.length;if(e.shiftKey)s.substr(u,c.length)===c?(d=-d,u>a?(o=o.substring(0,u)+o.substring(u+c.length),p=0):u===a?(d=0,p=0,o=o.substring(c.length)):(p=-p,i=i.substring(0,u)+i.substring(u+c.length))):(d=0,p=0),o=o.replace(new RegExp("\n"+c.split("").join("\\"),"g"),"\n");else i=i.substr(0,u)+c+i.substring(u,a),o=o.replace(/\n/g,"\n"+c);t.value=i+o+l,t.selectionStart=a+d,t.selectionEnd=a+o.length+p,t.selectionDirection=n;}else t.value=i+c+l,t.selectionStart=a+c.length,t.selectionEnd=a+c.length;var h=t.value;this.updateCode(h),this.elTextarea.selectionEnd=r+this.opts.tabSize;}return  true},CodeFlask.prototype.handleSelfClosingCharacters=function(e){if(this.opts.handleSelfClosingCharacters){var t=e.key;if(!["(","[","{","<","'",'"'].includes(t)&&![")","]","}",">","'",'"'].includes(t))return  false;switch(t){case "(":case ")":this.closeCharacter(t);break;case "[":case "]":this.closeCharacter(t);break;case "{":case "}":this.closeCharacter(t);break;case "<":case ">":case "'":case '"':this.closeCharacter(t);}return  true}},CodeFlask.prototype.setLineNumber=function(){this.lineNumber=this.code.split("\n").length,this.opts.lineNumbers&&this.updateLineNumbersCount();},CodeFlask.prototype.handleNewLineIndentation=function(e){if(!this.opts.handleNewLineIndentation)return  false;if(13!==e.keyCode)return  false;e.preventDefault();var t=this.elTextarea,n=t.selectionStart,a=t.selectionEnd,r=t.value,s=r.substr(0,n),i=r.substring(a),o=r.lastIndexOf("\n",n-1),l=o+r.slice(o+1).search(/[^ ]|$/),c=l>o?l-o:0,u=s+"\n"+" ".repeat(c)+i;return t.value=u,t.selectionStart=n+c+1,t.selectionEnd=n+c+1,this.updateCode(t.value),true},CodeFlask.prototype.closeCharacter=function(e){var t=this.elTextarea.selectionStart,n=this.elTextarea.selectionEnd;if(this.skipCloseChar(e)){var a=this.code.substr(n,1)===e,r=a?n+1:n,s=!a&&["'",'"'].includes(e)?e:"",i=""+this.code.substring(0,t)+s+this.code.substring(r);this.updateCode(i),this.elTextarea.selectionEnd=++this.elTextarea.selectionStart;}else {var o=e;switch(e){case "(":o=String.fromCharCode(e.charCodeAt()+1);break;case "<":case "{":case "[":o=String.fromCharCode(e.charCodeAt()+2);}var l=this.code.substring(t,n),c=""+this.code.substring(0,t)+l+o+this.code.substring(n);this.updateCode(c);}this.elTextarea.selectionEnd=t;},CodeFlask.prototype.skipCloseChar=function(e){var t=this.elTextarea.selectionStart,n=this.elTextarea.selectionEnd,a=Math.abs(n-t)>0;return [")","}","]",">"].includes(e)||["'",'"'].includes(e)&&!a},CodeFlask.prototype.updateCode=function(e){this.isEdit=false,this.code=e,this.elTextarea.value=e,this.elCode.innerHTML=escapeHtml(e),this.highlight(),this.setLineNumber(),setTimeout(this.runUpdate.bind(this),1);},CodeFlask.prototype.updateLanguage=function(e){var t=this.opts.language;this.elCode.classList.remove("language-"+t),this.elCode.classList.add("language-"+e),this.opts.language=e,this.highlight();},CodeFlask.prototype.addLanguage=function(e,t){Prism.languages[e]=t;},CodeFlask.prototype.populateDefault=function(){this.updateCode(this.code);},CodeFlask.prototype.highlight=function(){Prism.highlightElement(this.elCode,false);},CodeFlask.prototype.onUpdate=function(e){if(e&&"[object Function]"!=={}.toString.call(e))throw Error("CodeFlask expects callback of type Function");this.updateCallBack=e;},CodeFlask.prototype.getCode=function(){return this.code},CodeFlask.prototype.runUpdate=function(){this.updateCallBack&&this.updateCallBack(this.code);},CodeFlask.prototype.enableReadonlyMode=function(){this.elTextarea.setAttribute("readonly",true);},CodeFlask.prototype.disableReadonlyMode=function(){this.elTextarea.removeAttribute("readonly");},CodeFlask.prototype.noError=function(){this.elError&&(this.elError.innerHTML="",this.elError.style.display="none");},CodeFlask.prototype.addError=function(e,t,n){this.elError&&(this.elError.style.display="block",this.elError.innerHTML=t,this.elError.style.marginTop=19*t-9+"px");};

class Text{constructor(){}lineAt(e){if(e<0||e>this.length)throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);return this.lineInner(e,false,1,0)}line(e){if(e<1||e>this.lines)throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);return this.lineInner(e,true,1,0)}replace(e,t,i){let n=[];return this.decompose(0,e,n,2),i.length&&i.decompose(0,i.length,n,3),this.decompose(t,this.length,n,1),TextNode.from(n,this.length-(t-e)+i.length)}append(e){return this.replace(this.length,this.length,e)}slice(e,t=this.length){let i=[];return this.decompose(e,t,i,0),TextNode.from(i,t-e)}eq(e){if(e==this)return  true;if(e.length!=this.length||e.lines!=this.lines)return  false;let t=this.scanIdentical(e,1),i=this.length-this.scanIdentical(e,-1),n=new RawTextCursor(this),o=new RawTextCursor(e);for(let e=t,r=t;;){if(n.next(e),o.next(e),e=0,n.lineBreak!=o.lineBreak||n.done!=o.done||n.value!=o.value)return  false;if(r+=n.value.length,n.done||r>=i)return  true}}iter(e=1){return new RawTextCursor(this,e)}iterRange(e,t=this.length){return new PartialTextCursor(this,e,t)}iterLines(e,t){let i;if(null==e)i=this.iter();else {null==t&&(t=this.lines+1);let n=this.line(e).from;i=this.iterRange(n,Math.max(n,t==this.lines+1?this.length:t<=1?0:this.line(t-1).to));}return new LineCursor(i)}toString(){return this.sliceString(0)}toJSON(){let e=[];return this.flatten(e),e}static of(e){if(0==e.length)throw new RangeError("A document must have at least one line");return 1!=e.length||e[0]?e.length<=32?new TextLeaf(e):TextNode.from(TextLeaf.split(e,[])):Text.empty}}class TextLeaf extends Text{constructor(e,t=textLength(e)){super(),this.text=e,this.length=t;}get lines(){return this.text.length}get children(){return null}lineInner(e,t,i,n){for(let o=0;;o++){let r=this.text[o],s=n+r.length;if((t?i:s)>=e)return new Line(n,s,i,r);n=s+1,i++;}}decompose(e,t,i,n){let o=e<=0&&t>=this.length?this:new TextLeaf(sliceText(this.text,e,t),Math.min(t,this.length)-Math.max(0,e));if(1&n){let e=i.pop(),t=appendText(o.text,e.text.slice(),0,o.length);if(t.length<=32)i.push(new TextLeaf(t,e.length+o.length));else {let e=t.length>>1;i.push(new TextLeaf(t.slice(0,e)),new TextLeaf(t.slice(e)));}}else i.push(o);}replace(e,t,i){if(!(i instanceof TextLeaf))return super.replace(e,t,i);let n=appendText(this.text,appendText(i.text,sliceText(this.text,0,e)),t),o=this.length+i.length-(t-e);return n.length<=32?new TextLeaf(n,o):TextNode.from(TextLeaf.split(n,[]),o)}sliceString(e,t=this.length,i="\n"){let n="";for(let o=0,r=0;o<=t&&r<this.text.length;r++){let s=this.text[r],a=o+s.length;o>e&&r&&(n+=i),e<a&&t>o&&(n+=s.slice(Math.max(0,e-o),t-o)),o=a+1;}return n}flatten(e){for(let t of this.text)e.push(t);}scanIdentical(){return 0}static split(e,t){let i=[],n=-1;for(let o of e)i.push(o),n+=o.length+1,32==i.length&&(t.push(new TextLeaf(i,n)),i=[],n=-1);return n>-1&&t.push(new TextLeaf(i,n)),t}}class TextNode extends Text{constructor(e,t){super(),this.children=e,this.length=t,this.lines=0;for(let t of e)this.lines+=t.lines;}lineInner(e,t,i,n){for(let o=0;;o++){let r=this.children[o],s=n+r.length,a=i+r.lines-1;if((t?a:s)>=e)return r.lineInner(e,t,i,n);n=s+1,i=a+1;}}decompose(e,t,i,n){for(let o=0,r=0;r<=t&&o<this.children.length;o++){let s=this.children[o],a=r+s.length;if(e<=a&&t>=r){let o=n&((r<=e?1:0)|(a>=t?2:0));r>=e&&a<=t&&!o?i.push(s):s.decompose(e-r,t-r,i,o);}r=a+1;}}replace(e,t,i){if(i.lines<this.lines)for(let n=0,o=0;n<this.children.length;n++){let r=this.children[n],s=o+r.length;if(e>=o&&t<=s){let a=r.replace(e-o,t-o,i),l=this.lines-r.lines+a.lines;if(a.lines<l>>4&&a.lines>l>>6){let o=this.children.slice();return o[n]=a,new TextNode(o,this.length-(t-e)+i.length)}return super.replace(o,s,a)}o=s+1;}return super.replace(e,t,i)}sliceString(e,t=this.length,i="\n"){let n="";for(let o=0,r=0;o<this.children.length&&r<=t;o++){let s=this.children[o],a=r+s.length;r>e&&o&&(n+=i),e<a&&t>r&&(n+=s.sliceString(e-r,t-r,i)),r=a+1;}return n}flatten(e){for(let t of this.children)t.flatten(e);}scanIdentical(e,t){if(!(e instanceof TextNode))return 0;let i=0,[n,o,r,s]=t>0?[0,0,this.children.length,e.children.length]:[this.children.length-1,e.children.length-1,-1,-1];for(;;n+=t,o+=t){if(n==r||o==s)return i;let a=this.children[n],l=e.children[o];if(a!=l)return i+a.scanIdentical(l,t);i+=a.length+1;}}static from(e,t=e.reduce((e,t)=>e+t.length+1,-1)){let i=0;for(let t of e)i+=t.lines;if(i<32){let i=[];for(let t of e)t.flatten(i);return new TextLeaf(i,t)}let n=Math.max(32,i>>5),o=n<<1,r=n>>1,s=[],a=0,l=-1,h=[];function c(e){let t;if(e.lines>o&&e instanceof TextNode)for(let t of e.children)c(t);else e.lines>r&&(a>r||!a)?(d(),s.push(e)):e instanceof TextLeaf&&a&&(t=h[h.length-1])instanceof TextLeaf&&e.lines+t.lines<=32?(a+=e.lines,l+=e.length+1,h[h.length-1]=new TextLeaf(t.text.concat(e.text),t.length+1+e.length)):(a+e.lines>n&&d(),a+=e.lines,l+=e.length+1,h.push(e));}function d(){0!=a&&(s.push(1==h.length?h[0]:TextNode.from(h,l)),l=-1,a=h.length=0);}for(let t of e)c(t);return d(),1==s.length?s[0]:new TextNode(s,t)}}function textLength(e){let t=-1;for(let i of e)t+=i.length+1;return t}function appendText(e,t,i=0,n=1e9){for(let o=0,r=0,s=true;r<e.length&&o<=n;r++){let a=e[r],l=o+a.length;l>=i&&(l>n&&(a=a.slice(0,n-o)),o<i&&(a=a.slice(i-o)),s?(t[t.length-1]+=a,s=false):t.push(a)),o=l+1;}return t}function sliceText(e,t,i){return appendText(e,[""],t,i)}Text.empty=new TextLeaf([""],0);class RawTextCursor{constructor(e,t=1){this.dir=t,this.done=false,this.lineBreak=false,this.value="",this.nodes=[e],this.offsets=[t>0?1:(e instanceof TextLeaf?e.text.length:e.children.length)<<1];}nextInner(e,t){for(this.done=this.lineBreak=false;;){let i=this.nodes.length-1,n=this.nodes[i],o=this.offsets[i],r=o>>1,s=n instanceof TextLeaf?n.text.length:n.children.length;if(r==(t>0?s:0)){if(0==i)return this.done=true,this.value="",this;t>0&&this.offsets[i-1]++,this.nodes.pop(),this.offsets.pop();}else if((1&o)==(t>0?0:1)){if(this.offsets[i]+=t,0==e)return this.lineBreak=true,this.value="\n",this;e--;}else if(n instanceof TextLeaf){let o=n.text[r+(t<0?-1:0)];if(this.offsets[i]+=t,o.length>Math.max(0,e))return this.value=0==e?o:t>0?o.slice(e):o.slice(0,o.length-e),this;e-=o.length;}else {let o=n.children[r+(t<0?-1:0)];e>o.length?(e-=o.length,this.offsets[i]+=t):(t<0&&this.offsets[i]--,this.nodes.push(o),this.offsets.push(t>0?1:(o instanceof TextLeaf?o.text.length:o.children.length)<<1));}}}next(e=0){return e<0&&(this.nextInner(-e,-this.dir),e=this.value.length),this.nextInner(e,this.dir)}}class PartialTextCursor{constructor(e,t,i){this.value="",this.done=false,this.cursor=new RawTextCursor(e,t>i?-1:1),this.pos=t>i?e.length:0,this.from=Math.min(t,i),this.to=Math.max(t,i);}nextInner(e,t){if(t<0?this.pos<=this.from:this.pos>=this.to)return this.value="",this.done=true,this;e+=Math.max(0,t<0?this.pos-this.to:this.from-this.pos);let i=t<0?this.pos-this.from:this.to-this.pos;e>i&&(e=i),i-=e;let{value:n}=this.cursor.next(e);return this.pos+=(n.length+e)*t,this.value=n.length<=i?n:t<0?n.slice(n.length-i):n.slice(0,i),this.done=!this.value,this}next(e=0){return e<0?e=Math.max(e,this.from-this.pos):e>0&&(e=Math.min(e,this.to-this.pos)),this.nextInner(e,this.cursor.dir)}get lineBreak(){return this.cursor.lineBreak&&""!=this.value}}class LineCursor{constructor(e){this.inner=e,this.afterBreak=true,this.value="",this.done=false;}next(e=0){let{done:t,lineBreak:i,value:n}=this.inner.next(e);return t?(this.done=true,this.value=""):i?this.afterBreak?this.value="":(this.afterBreak=true,this.next()):(this.value=n,this.afterBreak=false),this}get lineBreak(){return  false}}"undefined"!=typeof Symbol&&(Text.prototype[Symbol.iterator]=function(){return this.iter()},RawTextCursor.prototype[Symbol.iterator]=PartialTextCursor.prototype[Symbol.iterator]=LineCursor.prototype[Symbol.iterator]=function(){return this});class Line{constructor(e,t,i,n){this.from=e,this.to=t,this.number=i,this.text=n;}get length(){return this.to-this.from}}let extend="lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(e=>e?parseInt(e,36):1);for(let e=1;e<extend.length;e++)extend[e]+=extend[e-1];function isExtendingChar(e){for(let t=1;t<extend.length;t+=2)if(extend[t]>e)return extend[t-1]<=e;return  false}function isRegionalIndicator(e){return e>=127462&&e<=127487}const ZWJ=8205;function findClusterBreak(e,t,i=true,n=true){return (i?nextClusterBreak:prevClusterBreak)(e,t,n)}function nextClusterBreak(e,t,i){if(t==e.length)return t;t&&surrogateLow(e.charCodeAt(t))&&surrogateHigh(e.charCodeAt(t-1))&&t--;let n=codePointAt(e,t);for(t+=codePointSize(n);t<e.length;){let o=codePointAt(e,t);if(n==ZWJ||o==ZWJ||i&&isExtendingChar(o))t+=codePointSize(o),n=o;else {if(!isRegionalIndicator(o))break;{let i=0,n=t-2;for(;n>=0&&isRegionalIndicator(codePointAt(e,n));)i++,n-=2;if(i%2==0)break;t+=2;}}}return t}function prevClusterBreak(e,t,i){for(;t>0;){let n=nextClusterBreak(e,t-2,i);if(n<t)return n;t--;}return 0}function surrogateLow(e){return e>=56320&&e<57344}function surrogateHigh(e){return e>=55296&&e<56320}function codePointAt(e,t){let i=e.charCodeAt(t);if(!surrogateHigh(i)||t+1==e.length)return i;let n=e.charCodeAt(t+1);return surrogateLow(n)?n-56320+(i-55296<<10)+65536:i}function fromCodePoint(e){return e<=65535?String.fromCharCode(e):(e-=65536,String.fromCharCode(55296+(e>>10),56320+(1023&e)))}function codePointSize(e){return e<65536?1:2}const DefaultSplit=/\r\n?|\n/;var MapMode=function(e){return e[e.Simple=0]="Simple",e[e.TrackDel=1]="TrackDel",e[e.TrackBefore=2]="TrackBefore",e[e.TrackAfter=3]="TrackAfter",e}(MapMode||(MapMode={}));class ChangeDesc{constructor(e){this.sections=e;}get length(){let e=0;for(let t=0;t<this.sections.length;t+=2)e+=this.sections[t];return e}get newLength(){let e=0;for(let t=0;t<this.sections.length;t+=2){let i=this.sections[t+1];e+=i<0?this.sections[t]:i;}return e}get empty(){return 0==this.sections.length||2==this.sections.length&&this.sections[1]<0}iterGaps(e){for(let t=0,i=0,n=0;t<this.sections.length;){let o=this.sections[t++],r=this.sections[t++];r<0?(e(i,n,o),n+=o):n+=r,i+=o;}}iterChangedRanges(e,t=false){iterChanges(this,e,t);}get invertedDesc(){let e=[];for(let t=0;t<this.sections.length;){let i=this.sections[t++],n=this.sections[t++];n<0?e.push(i,n):e.push(n,i);}return new ChangeDesc(e)}composeDesc(e){return this.empty?e:e.empty?this:composeSets(this,e)}mapDesc(e,t=false){return e.empty?this:mapSet(this,e,t)}mapPos(e,t=-1,i=MapMode.Simple){let n=0,o=0;for(let r=0;r<this.sections.length;){let s=this.sections[r++],a=this.sections[r++],l=n+s;if(a<0){if(l>e)return o+(e-n);o+=s;}else {if(i!=MapMode.Simple&&l>=e&&(i==MapMode.TrackDel&&n<e&&l>e||i==MapMode.TrackBefore&&n<e||i==MapMode.TrackAfter&&l>e))return null;if(l>e||l==e&&t<0&&!s)return e==n||t<0?o:o+a;o+=a;}n=l;}if(e>n)throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);return o}touchesRange(e,t=e){for(let i=0,n=0;i<this.sections.length&&n<=t;){let o=n+this.sections[i++];if(this.sections[i++]>=0&&n<=t&&o>=e)return !(n<e&&o>t)||"cover";n=o;}return  false}toString(){let e="";for(let t=0;t<this.sections.length;){let i=this.sections[t++],n=this.sections[t++];e+=(e?" ":"")+i+(n>=0?":"+n:"");}return e}toJSON(){return this.sections}static fromJSON(e){if(!Array.isArray(e)||e.length%2||e.some(e=>"number"!=typeof e))throw new RangeError("Invalid JSON representation of ChangeDesc");return new ChangeDesc(e)}static create(e){return new ChangeDesc(e)}}class ChangeSet extends ChangeDesc{constructor(e,t){super(e),this.inserted=t;}apply(e){if(this.length!=e.length)throw new RangeError("Applying change set to a document with the wrong length");return iterChanges(this,(t,i,n,o,r)=>e=e.replace(n,n+(i-t),r),false),e}mapDesc(e,t=false){return mapSet(this,e,t,true)}invert(e){let t=this.sections.slice(),i=[];for(let n=0,o=0;n<t.length;n+=2){let r=t[n],s=t[n+1];if(s>=0){t[n]=s,t[n+1]=r;let a=n>>1;for(;i.length<a;)i.push(Text.empty);i.push(r?e.slice(o,o+r):Text.empty);}o+=r;}return new ChangeSet(t,i)}compose(e){return this.empty?e:e.empty?this:composeSets(this,e,true)}map(e,t=false){return e.empty?this:mapSet(this,e,t,true)}iterChanges(e,t=false){iterChanges(this,e,t);}get desc(){return ChangeDesc.create(this.sections)}filter(e){let t=[],i=[],n=[],o=new SectionIter(this);e:for(let r=0,s=0;;){let a=r==e.length?1e9:e[r++];for(;s<a||s==a&&0==o.len;){if(o.done)break e;let e=Math.min(o.len,a-s);addSection(n,e,-1);let r=-1==o.ins?-1:0==o.off?o.ins:0;addSection(t,e,r),r>0&&addInsert(i,t,o.text),o.forward(e),s+=e;}let l=e[r++];for(;s<l;){if(o.done)break e;let e=Math.min(o.len,l-s);addSection(t,e,-1),addSection(n,e,-1==o.ins?-1:0==o.off?o.ins:0),o.forward(e),s+=e;}}return {changes:new ChangeSet(t,i),filtered:ChangeDesc.create(n)}}toJSON(){let e=[];for(let t=0;t<this.sections.length;t+=2){let i=this.sections[t],n=this.sections[t+1];n<0?e.push(i):0==n?e.push([i]):e.push([i].concat(this.inserted[t>>1].toJSON()));}return e}static of(e,t,i){let n=[],o=[],r=0,s=null;function a(e=false){if(!e&&!n.length)return;r<t&&addSection(n,t-r,-1);let i=new ChangeSet(n,o);s=s?s.compose(i.map(s)):i,n=[],o=[],r=0;}return function e(l){if(Array.isArray(l))for(let t of l)e(t);else if(l instanceof ChangeSet){if(l.length!=t)throw new RangeError(`Mismatched change set length (got ${l.length}, expected ${t})`);a(),s=s?s.compose(l.map(s)):l;}else {let{from:e,to:s=e,insert:h}=l;if(e>s||e<0||s>t)throw new RangeError(`Invalid change range ${e} to ${s} (in doc of length ${t})`);let c=h?"string"==typeof h?Text.of(h.split(i||DefaultSplit)):h:Text.empty,d=c.length;if(e==s&&0==d)return;e<r&&a(),e>r&&addSection(n,e-r,-1),addSection(n,s-e,d),addInsert(o,n,c),r=s;}}(e),a(!s),s}static empty(e){return new ChangeSet(e?[e,-1]:[],[])}static fromJSON(e){if(!Array.isArray(e))throw new RangeError("Invalid JSON representation of ChangeSet");let t=[],i=[];for(let n=0;n<e.length;n++){let o=e[n];if("number"==typeof o)t.push(o,-1);else {if(!Array.isArray(o)||"number"!=typeof o[0]||o.some((e,t)=>t&&"string"!=typeof e))throw new RangeError("Invalid JSON representation of ChangeSet");if(1==o.length)t.push(o[0],0);else {for(;i.length<n;)i.push(Text.empty);i[n]=Text.of(o.slice(1)),t.push(o[0],i[n].length);}}}return new ChangeSet(t,i)}static createSet(e,t){return new ChangeSet(e,t)}}function addSection(e,t,i,n=false){if(0==t&&i<=0)return;let o=e.length-2;o>=0&&i<=0&&i==e[o+1]?e[o]+=t:0==t&&0==e[o]?e[o+1]+=i:n?(e[o]+=t,e[o+1]+=i):e.push(t,i);}function addInsert(e,t,i){if(0==i.length)return;let n=t.length-2>>1;if(n<e.length)e[e.length-1]=e[e.length-1].append(i);else {for(;e.length<n;)e.push(Text.empty);e.push(i);}}function iterChanges(e,t,i){let n=e.inserted;for(let o=0,r=0,s=0;s<e.sections.length;){let a=e.sections[s++],l=e.sections[s++];if(l<0)o+=a,r+=a;else {let h=o,c=r,d=Text.empty;for(;h+=a,c+=l,l&&n&&(d=d.append(n[s-2>>1])),!(i||s==e.sections.length||e.sections[s+1]<0);)a=e.sections[s++],l=e.sections[s++];t(o,h,r,c,d),o=h,r=c;}}}function mapSet(e,t,i,n=false){let o=[],r=n?[]:null,s=new SectionIter(e),a=new SectionIter(t);for(let e=-1;;)if(-1==s.ins&&-1==a.ins){let e=Math.min(s.len,a.len);addSection(o,e,-1),s.forward(e),a.forward(e);}else if(a.ins>=0&&(s.ins<0||e==s.i||0==s.off&&(a.len<s.len||a.len==s.len&&!i))){let t=a.len;for(addSection(o,a.ins,-1);t;){let i=Math.min(s.len,t);s.ins>=0&&e<s.i&&s.len<=i&&(addSection(o,0,s.ins),r&&addInsert(r,o,s.text),e=s.i),s.forward(i),t-=i;}a.next();}else {if(!(s.ins>=0)){if(s.done&&a.done)return r?ChangeSet.createSet(o,r):ChangeDesc.create(o);throw new Error("Mismatched change set lengths")}{let t=0,i=s.len;for(;i;)if(-1==a.ins){let e=Math.min(i,a.len);t+=e,i-=e,a.forward(e);}else {if(!(0==a.ins&&a.len<i))break;i-=a.len,a.next();}addSection(o,t,e<s.i?s.ins:0),r&&e<s.i&&addInsert(r,o,s.text),e=s.i,s.forward(s.len-i);}}}function composeSets(e,t,i=false){let n=[],o=i?[]:null,r=new SectionIter(e),s=new SectionIter(t);for(let e=false;;){if(r.done&&s.done)return o?ChangeSet.createSet(n,o):ChangeDesc.create(n);if(0==r.ins)addSection(n,r.len,0,e),r.next();else if(0!=s.len||s.done){if(r.done||s.done)throw new Error("Mismatched change set lengths");{let t=Math.min(r.len2,s.len),i=n.length;if(-1==r.ins){let i=-1==s.ins?-1:s.off?0:s.ins;addSection(n,t,i,e),o&&i&&addInsert(o,n,s.text);}else  -1==s.ins?(addSection(n,r.off?0:r.len,t,e),o&&addInsert(o,n,r.textBit(t))):(addSection(n,r.off?0:r.len,s.off?0:s.ins,e),o&&!s.off&&addInsert(o,n,s.text));e=(r.ins>t||s.ins>=0&&s.len>t)&&(e||n.length>i),r.forward2(t),s.forward(t);}}else addSection(n,0,s.ins,e),o&&addInsert(o,n,s.text),s.next();}}class SectionIter{constructor(e){this.set=e,this.i=0,this.next();}next(){let{sections:e}=this.set;this.i<e.length?(this.len=e[this.i++],this.ins=e[this.i++]):(this.len=0,this.ins=-2),this.off=0;}get done(){return  -2==this.ins}get len2(){return this.ins<0?this.len:this.ins}get text(){let{inserted:e}=this.set,t=this.i-2>>1;return t>=e.length?Text.empty:e[t]}textBit(e){let{inserted:t}=this.set,i=this.i-2>>1;return i>=t.length&&!e?Text.empty:t[i].slice(this.off,null==e?void 0:this.off+e)}forward(e){e==this.len?this.next():(this.len-=e,this.off+=e);}forward2(e){ -1==this.ins?this.forward(e):e==this.ins?this.next():(this.ins-=e,this.off+=e);}}class SelectionRange{constructor(e,t,i){this.from=e,this.to=t,this.flags=i;}get anchor(){return 16&this.flags?this.to:this.from}get head(){return 16&this.flags?this.from:this.to}get empty(){return this.from==this.to}get assoc(){return 4&this.flags?-1:8&this.flags?1:0}get bidiLevel(){let e=3&this.flags;return 3==e?null:e}get goalColumn(){let e=this.flags>>5;return 33554431==e?void 0:e}map(e,t=-1){let i,n;return this.empty?i=n=e.mapPos(this.from,t):(i=e.mapPos(this.from,1),n=e.mapPos(this.to,-1)),i==this.from&&n==this.to?this:new SelectionRange(i,n,this.flags)}extend(e,t=e){if(e<=this.anchor&&t>=this.anchor)return EditorSelection.range(e,t);let i=Math.abs(e-this.anchor)>Math.abs(t-this.anchor)?e:t;return EditorSelection.range(this.anchor,i)}eq(e){return this.anchor==e.anchor&&this.head==e.head}toJSON(){return {anchor:this.anchor,head:this.head}}static fromJSON(e){if(!e||"number"!=typeof e.anchor||"number"!=typeof e.head)throw new RangeError("Invalid JSON representation for SelectionRange");return EditorSelection.range(e.anchor,e.head)}static create(e,t,i){return new SelectionRange(e,t,i)}}class EditorSelection{constructor(e,t){this.ranges=e,this.mainIndex=t;}map(e,t=-1){return e.empty?this:EditorSelection.create(this.ranges.map(i=>i.map(e,t)),this.mainIndex)}eq(e){if(this.ranges.length!=e.ranges.length||this.mainIndex!=e.mainIndex)return  false;for(let t=0;t<this.ranges.length;t++)if(!this.ranges[t].eq(e.ranges[t]))return  false;return  true}get main(){return this.ranges[this.mainIndex]}asSingle(){return 1==this.ranges.length?this:new EditorSelection([this.main],0)}addRange(e,t=true){return EditorSelection.create([e].concat(this.ranges),t?0:this.mainIndex+1)}replaceRange(e,t=this.mainIndex){let i=this.ranges.slice();return i[t]=e,EditorSelection.create(i,this.mainIndex)}toJSON(){return {ranges:this.ranges.map(e=>e.toJSON()),main:this.mainIndex}}static fromJSON(e){if(!e||!Array.isArray(e.ranges)||"number"!=typeof e.main||e.main>=e.ranges.length)throw new RangeError("Invalid JSON representation for EditorSelection");return new EditorSelection(e.ranges.map(e=>SelectionRange.fromJSON(e)),e.main)}static single(e,t=e){return new EditorSelection([EditorSelection.range(e,t)],0)}static create(e,t=0){if(0==e.length)throw new RangeError("A selection needs at least one range");for(let i=0,n=0;n<e.length;n++){let o=e[n];if(o.empty?o.from<=i:o.from<i)return EditorSelection.normalized(e.slice(),t);i=o.to;}return new EditorSelection(e,t)}static cursor(e,t=0,i,n){return SelectionRange.create(e,e,(0==t?0:t<0?4:8)|(null==i?3:Math.min(2,i))|(null!==n&&void 0!==n?n:33554431)<<5)}static range(e,t,i){let n=(null!==i&&void 0!==i?i:33554431)<<5;return t<e?SelectionRange.create(t,e,24|n):SelectionRange.create(e,t,n|(t>e?4:0))}static normalized(e,t=0){let i=e[t];e.sort((e,t)=>e.from-t.from),t=e.indexOf(i);for(let i=1;i<e.length;i++){let n=e[i],o=e[i-1];if(n.empty?n.from<=o.to:n.from<o.to){let r=o.from,s=Math.max(n.to,o.to);i<=t&&t--,e.splice(--i,2,n.anchor>n.head?EditorSelection.range(s,r):EditorSelection.range(r,s));}}return new EditorSelection(e,t)}}function checkSelection(e,t){for(let i of e.ranges)if(i.to>t)throw new RangeError("Selection points outside of document")}let nextID=0;class Facet{constructor(e,t,i,n,o){this.combine=e,this.compareInput=t,this.compare=i,this.isStatic=n,this.id=nextID++,this.default=e([]),this.extensions="function"==typeof o?o(this):o;}static define(e={}){return new Facet(e.combine||(e=>e),e.compareInput||((e,t)=>e===t),e.compare||(e.combine?(e,t)=>e===t:sameArray),!!e.static,e.enables)}of(e){return new FacetProvider([],this,0,e)}compute(e,t){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(e,this,1,t)}computeN(e,t){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(e,this,2,t)}from(e,t){return t||(t=(e=>e)),this.compute([e],i=>t(i.field(e)))}}function sameArray(e,t){return e==t||e.length==t.length&&e.every((e,i)=>e===t[i])}class FacetProvider{constructor(e,t,i,n){this.dependencies=e,this.facet=t,this.type=i,this.value=n,this.id=nextID++;}dynamicSlot(e){var t;let i=this.value,n=this.facet.compareInput,o=this.id,r=e[o]>>1,s=2==this.type,a=false,l=false,h=[];for(let i of this.dependencies)"doc"==i?a=true:"selection"==i?l=true:0==(1&(null!==(t=e[i.id])&&void 0!==t?t:1))&&h.push(e[i.id]);return {create:e=>(e.values[r]=i(e),1),update(e,t){if(a&&t.docChanged||l&&(t.docChanged||t.selection)||ensureAll(e,h)){let t=i(e);if(s?!compareArray(t,e.values[r],n):!n(t,e.values[r]))return e.values[r]=t,1}return 0},reconfigure:(e,t)=>{let a,l=t.config.address[o];if(null!=l){let o=getAddr(t,l);if(this.dependencies.every(i=>i instanceof Facet?t.facet(i)===e.facet(i):!(i instanceof StateField)||t.field(i,false)==e.field(i,false))||(s?compareArray(a=i(e),o,n):n(a=i(e),o)))return e.values[r]=o,0}else a=i(e);return e.values[r]=a,1}}}}function compareArray(e,t,i){if(e.length!=t.length)return  false;for(let n=0;n<e.length;n++)if(!i(e[n],t[n]))return  false;return  true}function ensureAll(e,t){let i=false;for(let n of t)1&ensureAddr(e,n)&&(i=true);return i}function dynamicFacetSlot(e,t,i){let n=i.map(t=>e[t.id]),o=i.map(e=>e.type),r=n.filter(e=>!(1&e)),s=e[t.id]>>1;function a(e){let i=[];for(let t=0;t<n.length;t++){let r=getAddr(e,n[t]);if(2==o[t])for(let e of r)i.push(e);else i.push(r);}return t.combine(i)}return {create(e){for(let t of n)ensureAddr(e,t);return e.values[s]=a(e),1},update(e,i){if(!ensureAll(e,r))return 0;let n=a(e);return t.compare(n,e.values[s])?0:(e.values[s]=n,1)},reconfigure(e,o){let r=ensureAll(e,n),l=o.config.facets[t.id],h=o.facet(t);if(l&&!r&&sameArray(i,l))return e.values[s]=h,0;let c=a(e);return t.compare(c,h)?(e.values[s]=h,0):(e.values[s]=c,1)}}}const initField=Facet.define({static:true});class StateField{constructor(e,t,i,n,o){this.id=e,this.createF=t,this.updateF=i,this.compareF=n,this.spec=o,this.provides=void 0;}static define(e){let t=new StateField(nextID++,e.create,e.update,e.compare||((e,t)=>e===t),e);return e.provide&&(t.provides=e.provide(t)),t}create(e){let t=e.facet(initField).find(e=>e.field==this);return ((null===t||void 0===t?void 0:t.create)||this.createF)(e)}slot(e){let t=e[this.id]>>1;return {create:e=>(e.values[t]=this.create(e),1),update:(e,i)=>{let n=e.values[t],o=this.updateF(n,i);return this.compareF(n,o)?0:(e.values[t]=o,1)},reconfigure:(e,i)=>null!=i.config.address[this.id]?(e.values[t]=i.field(this),0):(e.values[t]=this.create(e),1)}}init(e){return [this,initField.of({field:this,create:e})]}get extension(){return this}}const Prec_={lowest:4,low:3,default:2,high:1,highest:0};function prec(e){return t=>new PrecExtension(t,e)}const Prec={highest:prec(Prec_.highest),high:prec(Prec_.high),default:prec(Prec_.default),low:prec(Prec_.low),lowest:prec(Prec_.lowest)};class PrecExtension{constructor(e,t){this.inner=e,this.prec=t;}}class Compartment{of(e){return new CompartmentInstance(this,e)}reconfigure(e){return Compartment.reconfigure.of({compartment:this,extension:e})}get(e){return e.config.compartments.get(this)}}class CompartmentInstance{constructor(e,t){this.compartment=e,this.inner=t;}}class Configuration{constructor(e,t,i,n,o,r){for(this.base=e,this.compartments=t,this.dynamicSlots=i,this.address=n,this.staticValues=o,this.facets=r,this.statusTemplate=[];this.statusTemplate.length<i.length;)this.statusTemplate.push(0);}staticFacet(e){let t=this.address[e.id];return null==t?e.default:this.staticValues[t>>1]}static resolve(e,t,i){let n=[],o=Object.create(null),r=new Map;for(let i of flatten(e,t,r))i instanceof StateField?n.push(i):(o[i.facet.id]||(o[i.facet.id]=[])).push(i);let s=Object.create(null),a=[],l=[];for(let e of n)s[e.id]=l.length<<1,l.push(t=>e.slot(t));let h=null===i||void 0===i?void 0:i.config.facets;for(let e in o){let t=o[e],n=t[0].facet,r=h&&h[e]||[];if(t.every(e=>0==e.type))if(s[n.id]=a.length<<1|1,sameArray(r,t))a.push(i.facet(n));else {let e=n.combine(t.map(e=>e.value));a.push(i&&n.compare(e,i.facet(n))?i.facet(n):e);}else {for(let e of t)0==e.type?(s[e.id]=a.length<<1|1,a.push(e.value)):(s[e.id]=l.length<<1,l.push(t=>e.dynamicSlot(t)));s[n.id]=l.length<<1,l.push(e=>dynamicFacetSlot(e,n,t));}}let c=l.map(e=>e(s));return new Configuration(e,r,c,s,a,o)}}function flatten(e,t,i){let n=[[],[],[],[],[]],o=new Map;return function e(r,s){let a=o.get(r);if(null!=a){if(a<=s)return;let e=n[a].indexOf(r);e>-1&&n[a].splice(e,1),r instanceof CompartmentInstance&&i.delete(r.compartment);}if(o.set(r,s),Array.isArray(r))for(let t of r)e(t,s);else if(r instanceof CompartmentInstance){if(i.has(r.compartment))throw new RangeError("Duplicate use of compartment in extensions");let n=t.get(r.compartment)||r.inner;i.set(r.compartment,n),e(n,s);}else if(r instanceof PrecExtension)e(r.inner,r.prec);else if(r instanceof StateField)n[s].push(r),r.provides&&e(r.provides,s);else if(r instanceof FacetProvider)n[s].push(r),r.facet.extensions&&e(r.facet.extensions,Prec_.default);else {let t=r.extension;if(!t)throw new Error(`Unrecognized extension value in extension set (${r}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);e(t,s);}}(e,Prec_.default),n.reduce((e,t)=>e.concat(t))}function ensureAddr(e,t){if(1&t)return 2;let i=t>>1,n=e.status[i];if(4==n)throw new Error("Cyclic dependency between fields and/or facets");if(2&n)return n;e.status[i]=4;let o=e.computeSlot(e,e.config.dynamicSlots[i]);return e.status[i]=2|o}function getAddr(e,t){return 1&t?e.config.staticValues[t>>1]:e.values[t>>1]}const languageData=Facet.define(),allowMultipleSelections=Facet.define({combine:e=>e.some(e=>e),static:true}),lineSeparator=Facet.define({combine:e=>e.length?e[0]:void 0,static:true}),changeFilter=Facet.define(),transactionFilter=Facet.define(),transactionExtender=Facet.define(),readOnly=Facet.define({combine:e=>!!e.length&&e[0]});class Annotation{constructor(e,t){this.type=e,this.value=t;}static define(){return new AnnotationType}}class AnnotationType{of(e){return new Annotation(this,e)}}class StateEffectType{constructor(e){this.map=e;}of(e){return new StateEffect(this,e)}}class StateEffect{constructor(e,t){this.type=e,this.value=t;}map(e){let t=this.type.map(this.value,e);return void 0===t?void 0:t==this.value?this:new StateEffect(this.type,t)}is(e){return this.type==e}static define(e={}){return new StateEffectType(e.map||(e=>e))}static mapEffects(e,t){if(!e.length)return e;let i=[];for(let n of e){let e=n.map(t);e&&i.push(e);}return i}}StateEffect.reconfigure=StateEffect.define(),StateEffect.appendConfig=StateEffect.define();class Transaction{constructor(e,t,i,n,o,r){this.startState=e,this.changes=t,this.selection=i,this.effects=n,this.annotations=o,this.scrollIntoView=r,this._doc=null,this._state=null,i&&checkSelection(i,t.newLength),o.some(e=>e.type==Transaction.time)||(this.annotations=o.concat(Transaction.time.of(Date.now())));}static create(e,t,i,n,o,r){return new Transaction(e,t,i,n,o,r)}get newDoc(){return this._doc||(this._doc=this.changes.apply(this.startState.doc))}get newSelection(){return this.selection||this.startState.selection.map(this.changes)}get state(){return this._state||this.startState.applyTransaction(this),this._state}annotation(e){for(let t of this.annotations)if(t.type==e)return t.value}get docChanged(){return !this.changes.empty}get reconfigured(){return this.startState.config!=this.state.config}isUserEvent(e){let t=this.annotation(Transaction.userEvent);return !(!t||!(t==e||t.length>e.length&&t.slice(0,e.length)==e&&"."==t[e.length]))}}function joinRanges(e,t){let i=[];for(let n=0,o=0;;){let r,s;if(n<e.length&&(o==t.length||t[o]>=e[n]))r=e[n++],s=e[n++];else {if(!(o<t.length))return i;r=t[o++],s=t[o++];}!i.length||i[i.length-1]<r?i.push(r,s):i[i.length-1]<s&&(i[i.length-1]=s);}}function mergeTransaction(e,t,i){var n;let o,r,s;return i?(o=t.changes,r=ChangeSet.empty(t.changes.length),s=e.changes.compose(t.changes)):(o=t.changes.map(e.changes),r=e.changes.mapDesc(t.changes,true),s=e.changes.compose(o)),{changes:s,selection:t.selection?t.selection.map(r):null===(n=e.selection)||void 0===n?void 0:n.map(o),effects:StateEffect.mapEffects(e.effects,o).concat(StateEffect.mapEffects(t.effects,r)),annotations:e.annotations.length?e.annotations.concat(t.annotations):t.annotations,scrollIntoView:e.scrollIntoView||t.scrollIntoView}}function resolveTransactionInner(e,t,i){let n=t.selection,o=asArray(t.annotations);return t.userEvent&&(o=o.concat(Transaction.userEvent.of(t.userEvent))),{changes:t.changes instanceof ChangeSet?t.changes:ChangeSet.of(t.changes||[],i,e.facet(lineSeparator)),selection:n&&(n instanceof EditorSelection?n:EditorSelection.single(n.anchor,n.head)),effects:asArray(t.effects),annotations:o,scrollIntoView:!!t.scrollIntoView}}function resolveTransaction(e,t,i){let n=resolveTransactionInner(e,t.length?t[0]:{},e.doc.length);t.length&&false===t[0].filter&&(i=false);for(let o=1;o<t.length;o++){ false===t[o].filter&&(i=false);let r=!!t[o].sequential;n=mergeTransaction(n,resolveTransactionInner(e,t[o],r?n.changes.newLength:e.doc.length),r);}let o=Transaction.create(e,n.changes,n.selection,n.effects,n.annotations,n.scrollIntoView);return extendTransaction(i?filterTransaction(o):o)}function filterTransaction(e){let t=e.startState,i=true;for(let n of t.facet(changeFilter)){let t=n(e);if(false===t){i=false;break}Array.isArray(t)&&(i=true===i?t:joinRanges(i,t));}if(true!==i){let n,o;if(false===i)o=e.changes.invertedDesc,n=ChangeSet.empty(t.doc.length);else {let t=e.changes.filter(i);n=t.changes,o=t.filtered.mapDesc(t.changes).invertedDesc;}e=Transaction.create(t,n,e.selection&&e.selection.map(o),StateEffect.mapEffects(e.effects,o),e.annotations,e.scrollIntoView);}let n=t.facet(transactionFilter);for(let i=n.length-1;i>=0;i--){let o=n[i](e);e=o instanceof Transaction?o:Array.isArray(o)&&1==o.length&&o[0]instanceof Transaction?o[0]:resolveTransaction(t,asArray(o),false);}return e}function extendTransaction(e){let t=e.startState,i=t.facet(transactionExtender),n=e;for(let o=i.length-1;o>=0;o--){let r=i[o](e);r&&Object.keys(r).length&&(n=mergeTransaction(n,resolveTransactionInner(t,r,e.changes.newLength),true));}return n==e?e:Transaction.create(t,e.changes,e.selection,n.effects,n.annotations,n.scrollIntoView)}Transaction.time=Annotation.define(),Transaction.userEvent=Annotation.define(),Transaction.addToHistory=Annotation.define(),Transaction.remote=Annotation.define();const none=[];function asArray(e){return null==e?none:Array.isArray(e)?e:[e]}var CharCategory=function(e){return e[e.Word=0]="Word",e[e.Space=1]="Space",e[e.Other=2]="Other",e}(CharCategory||(CharCategory={}));const nonASCIISingleCaseWordChar=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;let wordChar;try{wordChar=new RegExp("[\\p{Alphabetic}\\p{Number}_]","u");}catch(e){}function hasWordChar(e){if(wordChar)return wordChar.test(e);for(let t=0;t<e.length;t++){let i=e[t];if(/\w/.test(i)||i>""&&(i.toUpperCase()!=i.toLowerCase()||nonASCIISingleCaseWordChar.test(i)))return  true}return  false}function makeCategorizer(e){return t=>{if(!/\S/.test(t))return CharCategory.Space;if(hasWordChar(t))return CharCategory.Word;for(let i=0;i<e.length;i++)if(t.indexOf(e[i])>-1)return CharCategory.Word;return CharCategory.Other}}class EditorState{constructor(e,t,i,n,o,r){this.config=e,this.doc=t,this.selection=i,this.values=n,this.status=e.statusTemplate.slice(),this.computeSlot=o,r&&(r._state=this);for(let e=0;e<this.config.dynamicSlots.length;e++)ensureAddr(this,e<<1);this.computeSlot=null;}field(e,t=true){let i=this.config.address[e.id];if(null!=i)return ensureAddr(this,i),getAddr(this,i);if(t)throw new RangeError("Field is not present in this state")}update(...e){return resolveTransaction(this,e,true)}applyTransaction(e){let t,i=this.config,{base:n,compartments:o}=i;for(let t of e.effects)t.is(Compartment.reconfigure)?(i&&(o=new Map,i.compartments.forEach((e,t)=>o.set(t,e)),i=null),o.set(t.value.compartment,t.value.extension)):t.is(StateEffect.reconfigure)?(i=null,n=t.value):t.is(StateEffect.appendConfig)&&(i=null,n=asArray(n).concat(t.value));if(i)t=e.startState.values.slice();else {i=Configuration.resolve(n,o,this),t=new EditorState(i,this.doc,this.selection,i.dynamicSlots.map(()=>null),(e,t)=>t.reconfigure(e,this),null).values;}new EditorState(i,e.newDoc,e.newSelection,t,(t,i)=>i.update(t,e),e);}replaceSelection(e){return "string"==typeof e&&(e=this.toText(e)),this.changeByRange(t=>({changes:{from:t.from,to:t.to,insert:e},range:EditorSelection.cursor(t.from+e.length)}))}changeByRange(e){let t=this.selection,i=e(t.ranges[0]),n=this.changes(i.changes),o=[i.range],r=asArray(i.effects);for(let i=1;i<t.ranges.length;i++){let s=e(t.ranges[i]),a=this.changes(s.changes),l=a.map(n);for(let e=0;e<i;e++)o[e]=o[e].map(l);let h=n.mapDesc(a,true);o.push(s.range.map(h)),n=n.compose(l),r=StateEffect.mapEffects(r,l).concat(StateEffect.mapEffects(asArray(s.effects),h));}return {changes:n,selection:EditorSelection.create(o,t.mainIndex),effects:r}}changes(e=[]){return e instanceof ChangeSet?e:ChangeSet.of(e,this.doc.length,this.facet(EditorState.lineSeparator))}toText(e){return Text.of(e.split(this.facet(EditorState.lineSeparator)||DefaultSplit))}sliceDoc(e=0,t=this.doc.length){return this.doc.sliceString(e,t,this.lineBreak)}facet(e){let t=this.config.address[e.id];return null==t?e.default:(ensureAddr(this,t),getAddr(this,t))}toJSON(e){let t={doc:this.sliceDoc(),selection:this.selection.toJSON()};if(e)for(let i in e){let n=e[i];n instanceof StateField&&null!=this.config.address[n.id]&&(t[i]=n.spec.toJSON(this.field(e[i]),this));}return t}static fromJSON(e,t={},i){if(!e||"string"!=typeof e.doc)throw new RangeError("Invalid JSON representation for EditorState");let n=[];if(i)for(let t in i)if(Object.prototype.hasOwnProperty.call(e,t)){let o=i[t],r=e[t];n.push(o.init(e=>o.spec.fromJSON(r,e)));}return EditorState.create({doc:e.doc,selection:EditorSelection.fromJSON(e.selection),extensions:t.extensions?n.concat([t.extensions]):n})}static create(e={}){let t=Configuration.resolve(e.extensions||[],new Map),i=e.doc instanceof Text?e.doc:Text.of((e.doc||"").split(t.staticFacet(EditorState.lineSeparator)||DefaultSplit)),n=e.selection?e.selection instanceof EditorSelection?e.selection:EditorSelection.single(e.selection.anchor,e.selection.head):EditorSelection.single(0);return checkSelection(n,i.length),t.staticFacet(allowMultipleSelections)||(n=n.asSingle()),new EditorState(t,i,n,t.dynamicSlots.map(()=>null),(e,t)=>t.create(e),null)}get tabSize(){return this.facet(EditorState.tabSize)}get lineBreak(){return this.facet(EditorState.lineSeparator)||"\n"}get readOnly(){return this.facet(readOnly)}phrase(e,...t){for(let t of this.facet(EditorState.phrases))if(Object.prototype.hasOwnProperty.call(t,e)){e=t[e];break}return t.length&&(e=e.replace(/\$(\$|\d*)/g,(e,i)=>{if("$"==i)return "$";let n=+(i||1);return !n||n>t.length?e:t[n-1]})),e}languageDataAt(e,t,i=-1){let n=[];for(let o of this.facet(languageData))for(let r of o(this,t,i))Object.prototype.hasOwnProperty.call(r,e)&&n.push(r[e]);return n}charCategorizer(e){return makeCategorizer(this.languageDataAt("wordChars",e).join(""))}wordAt(e){let{text:t,from:i,length:n}=this.doc.lineAt(e),o=this.charCategorizer(e),r=e-i,s=e-i;for(;r>0;){let e=findClusterBreak(t,r,false);if(o(t.slice(e,r))!=CharCategory.Word)break;r=e;}for(;s<n;){let e=findClusterBreak(t,s);if(o(t.slice(s,e))!=CharCategory.Word)break;s=e;}return r==s?null:EditorSelection.range(r+i,s+i)}}function combineConfig(e,t,i={}){let n={};for(let t of e)for(let e of Object.keys(t)){let o=t[e],r=n[e];if(void 0===r)n[e]=o;else if(r===o||void 0===o);else {if(!Object.hasOwnProperty.call(i,e))throw new Error("Config merge conflict for field "+e);n[e]=i[e](r,o);}}for(let e in t) void 0===n[e]&&(n[e]=t[e]);return n}EditorState.allowMultipleSelections=allowMultipleSelections,EditorState.tabSize=Facet.define({combine:e=>e.length?e[0]:4}),EditorState.lineSeparator=lineSeparator,EditorState.readOnly=readOnly,EditorState.phrases=Facet.define({compare(e,t){let i=Object.keys(e),n=Object.keys(t);return i.length==n.length&&i.every(i=>e[i]==t[i])}}),EditorState.languageData=languageData,EditorState.changeFilter=changeFilter,EditorState.transactionFilter=transactionFilter,EditorState.transactionExtender=transactionExtender,Compartment.reconfigure=StateEffect.define();class RangeValue{eq(e){return this==e}range(e,t=e){return Range.create(e,t,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0,RangeValue.prototype.point=false,RangeValue.prototype.mapMode=MapMode.TrackDel;class Range{constructor(e,t,i){this.from=e,this.to=t,this.value=i;}static create(e,t,i){return new Range(e,t,i)}}function cmpRange(e,t){return e.from-t.from||e.value.startSide-t.value.startSide}class Chunk{constructor(e,t,i,n){this.from=e,this.to=t,this.value=i,this.maxPoint=n;}get length(){return this.to[this.to.length-1]}findIndex(e,t,i,n=0){let o=i?this.to:this.from;for(let r=n,s=o.length;;){if(r==s)return r;let n=r+s>>1,a=o[n]-e||(i?this.value[n].endSide:this.value[n].startSide)-t;if(n==r)return a>=0?r:s;a>=0?s=n:r=n+1;}}between(e,t,i,n){for(let o=this.findIndex(t,-1e9,true),r=this.findIndex(i,1e9,false,o);o<r;o++)if(false===n(this.from[o]+e,this.to[o]+e,this.value[o]))return  false}map(e,t){let i=[],n=[],o=[],r=-1,s=-1;for(let a=0;a<this.value.length;a++){let l,h,c=this.value[a],d=this.from[a]+e,u=this.to[a]+e;if(d==u){let e=t.mapPos(d,c.startSide,c.mapMode);if(null==e)continue;if(l=h=e,c.startSide!=c.endSide&&(h=t.mapPos(d,c.endSide))<l)continue}else if((l=t.mapPos(d,c.startSide))>(h=t.mapPos(u,c.endSide))||l==h&&c.startSide>0&&c.endSide<=0)continue;(h-l||c.endSide-c.startSide)<0||(r<0&&(r=l),c.point&&(s=Math.max(s,h-l)),i.push(c),n.push(l-r),o.push(h-r));}return {mapped:i.length?new Chunk(n,o,i,s):null,pos:r}}}class RangeSet{constructor(e,t,i,n){this.chunkPos=e,this.chunk=t,this.nextLayer=i,this.maxPoint=n;}static create(e,t,i,n){return new RangeSet(e,t,i,n)}get length(){let e=this.chunk.length-1;return e<0?0:Math.max(this.chunkEnd(e),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let e=this.nextLayer.size;for(let t of this.chunk)e+=t.value.length;return e}chunkEnd(e){return this.chunkPos[e]+this.chunk[e].length}update(e){let{add:t=[],sort:i=false,filterFrom:n=0,filterTo:o=this.length}=e,r=e.filter;if(0==t.length&&!r)return this;if(i&&(t=t.slice().sort(cmpRange)),this.isEmpty)return t.length?RangeSet.of(t):this;let s=new LayerCursor(this,null,-1).goto(0),a=0,l=[],h=new RangeSetBuilder;for(;s.value||a<t.length;)if(a<t.length&&(s.from-t[a].from||s.startSide-t[a].value.startSide)>=0){let e=t[a++];h.addInner(e.from,e.to,e.value)||l.push(e);}else 1==s.rangeIndex&&s.chunkIndex<this.chunk.length&&(a==t.length||this.chunkEnd(s.chunkIndex)<t[a].from)&&(!r||n>this.chunkEnd(s.chunkIndex)||o<this.chunkPos[s.chunkIndex])&&h.addChunk(this.chunkPos[s.chunkIndex],this.chunk[s.chunkIndex])?s.nextChunk():((!r||n>s.to||o<s.from||r(s.from,s.to,s.value))&&(h.addInner(s.from,s.to,s.value)||l.push(Range.create(s.from,s.to,s.value))),s.next());return h.finishInner(this.nextLayer.isEmpty&&!l.length?RangeSet.empty:this.nextLayer.update({add:l,filter:r,filterFrom:n,filterTo:o}))}map(e){if(e.empty||this.isEmpty)return this;let t=[],i=[],n=-1;for(let o=0;o<this.chunk.length;o++){let r=this.chunkPos[o],s=this.chunk[o],a=e.touchesRange(r,r+s.length);if(false===a)n=Math.max(n,s.maxPoint),t.push(s),i.push(e.mapPos(r));else if(true===a){let{mapped:o,pos:a}=s.map(r,e);o&&(n=Math.max(n,o.maxPoint),t.push(o),i.push(a));}}let o=this.nextLayer.map(e);return 0==t.length?o:new RangeSet(i,t,o||RangeSet.empty,n)}between(e,t,i){if(!this.isEmpty){for(let n=0;n<this.chunk.length;n++){let o=this.chunkPos[n],r=this.chunk[n];if(t>=o&&e<=o+r.length&&false===r.between(o,e-o,t-o,i))return}this.nextLayer.between(e,t,i);}}iter(e=0){return HeapCursor.from([this]).goto(e)}get isEmpty(){return this.nextLayer==this}static iter(e,t=0){return HeapCursor.from(e).goto(t)}static compare(e,t,i,n,o=-1){let r=e.filter(e=>e.maxPoint>0||!e.isEmpty&&e.maxPoint>=o),s=t.filter(e=>e.maxPoint>0||!e.isEmpty&&e.maxPoint>=o),a=findSharedChunks(r,s,i),l=new SpanCursor(r,a,o),h=new SpanCursor(s,a,o);i.iterGaps((e,t,i)=>compare(l,e,h,t,i,n)),i.empty&&0==i.length&&compare(l,0,h,0,0,n);}static eq(e,t,i=0,n){null==n&&(n=1e9-1);let o=e.filter(e=>!e.isEmpty&&t.indexOf(e)<0),r=t.filter(t=>!t.isEmpty&&e.indexOf(t)<0);if(o.length!=r.length)return  false;if(!o.length)return  true;let s=findSharedChunks(o,r),a=new SpanCursor(o,s,0).goto(i),l=new SpanCursor(r,s,0).goto(i);for(;;){if(a.to!=l.to||!sameValues(a.active,l.active)||a.point&&(!l.point||!a.point.eq(l.point)))return  false;if(a.to>n)return  true;a.next(),l.next();}}static spans(e,t,i,n,o=-1){let r=new SpanCursor(e,null,o).goto(t),s=t,a=r.openStart;for(;;){let e=Math.min(r.to,i);if(r.point){let i=r.activeForPoint(r.to),o=r.pointFrom<t?i.length+1:Math.min(i.length,a);n.point(s,e,r.point,i,o,r.pointRank),a=Math.min(r.openEnd(e),i.length);}else e>s&&(n.span(s,e,r.active,a),a=r.openEnd(e));if(r.to>i)return a+(r.point&&r.to>i?1:0);s=r.to,r.next();}}static of(e,t=false){let i=new RangeSetBuilder;for(let n of e instanceof Range?[e]:t?lazySort(e):e)i.add(n.from,n.to,n.value);return i.finish()}}function lazySort(e){if(e.length>1)for(let t=e[0],i=1;i<e.length;i++){let n=e[i];if(cmpRange(t,n)>0)return e.slice().sort(cmpRange);t=n;}return e}RangeSet.empty=new RangeSet([],[],null,-1),RangeSet.empty.nextLayer=RangeSet.empty;class RangeSetBuilder{constructor(){this.chunks=[],this.chunkPos=[],this.chunkStart=-1,this.last=null,this.lastFrom=-1e9,this.lastTo=-1e9,this.from=[],this.to=[],this.value=[],this.maxPoint=-1,this.setMaxPoint=-1,this.nextLayer=null;}finishChunk(e){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint)),this.chunkPos.push(this.chunkStart),this.chunkStart=-1,this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint),this.maxPoint=-1,e&&(this.from=[],this.to=[],this.value=[]);}add(e,t,i){this.addInner(e,t,i)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(e,t,i);}addInner(e,t,i){let n=e-this.lastTo||i.startSide-this.last.endSide;if(n<=0&&(e-this.lastFrom||i.startSide-this.last.startSide)<0)throw new Error("Ranges must be added sorted by `from` position and `startSide`");return !(n<0)&&(250==this.from.length&&this.finishChunk(true),this.chunkStart<0&&(this.chunkStart=e),this.from.push(e-this.chunkStart),this.to.push(t-this.chunkStart),this.last=i,this.lastFrom=e,this.lastTo=t,this.value.push(i),i.point&&(this.maxPoint=Math.max(this.maxPoint,t-e)),true)}addChunk(e,t){if((e-this.lastTo||t.value[0].startSide-this.last.endSide)<0)return  false;this.from.length&&this.finishChunk(true),this.setMaxPoint=Math.max(this.setMaxPoint,t.maxPoint),this.chunks.push(t),this.chunkPos.push(e);let i=t.value.length-1;return this.last=t.value[i],this.lastFrom=t.from[i]+e,this.lastTo=t.to[i]+e,true}finish(){return this.finishInner(RangeSet.empty)}finishInner(e){if(this.from.length&&this.finishChunk(false),0==this.chunks.length)return e;let t=RangeSet.create(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(e):e,this.setMaxPoint);return this.from=null,t}}function findSharedChunks(e,t,i){let n=new Map;for(let t of e)for(let e=0;e<t.chunk.length;e++)t.chunk[e].maxPoint<=0&&n.set(t.chunk[e],t.chunkPos[e]);let o=new Set;for(let e of t)for(let t=0;t<e.chunk.length;t++){let r=n.get(e.chunk[t]);null==r||(i?i.mapPos(r):r)!=e.chunkPos[t]||(null===i||void 0===i?void 0:i.touchesRange(r,r+e.chunk[t].length))||o.add(e.chunk[t]);}return o}class LayerCursor{constructor(e,t,i,n=0){this.layer=e,this.skip=t,this.minPoint=i,this.rank=n;}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(e,t=-1e9){return this.chunkIndex=this.rangeIndex=0,this.gotoInner(e,t,false),this}gotoInner(e,t,i){for(;this.chunkIndex<this.layer.chunk.length;){let t=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(t)||this.layer.chunkEnd(this.chunkIndex)<e||t.maxPoint<this.minPoint))break;this.chunkIndex++,i=false;}if(this.chunkIndex<this.layer.chunk.length){let n=this.layer.chunk[this.chunkIndex].findIndex(e-this.layer.chunkPos[this.chunkIndex],t,true);(!i||this.rangeIndex<n)&&this.setRangeIndex(n);}this.next();}forward(e,t){(this.to-e||this.endSide-t)<0&&this.gotoInner(e,t,true);}next(){for(;;){if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9,this.value=null;break}{let e=this.layer.chunkPos[this.chunkIndex],t=this.layer.chunk[this.chunkIndex],i=e+t.from[this.rangeIndex];if(this.from=i,this.to=e+t.to[this.rangeIndex],this.value=t.value[this.rangeIndex],this.setRangeIndex(this.rangeIndex+1),this.minPoint<0||this.value.point&&this.to-this.from>=this.minPoint)break}}}setRangeIndex(e){if(e==this.layer.chunk[this.chunkIndex].value.length){if(this.chunkIndex++,this.skip)for(;this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++;this.rangeIndex=0;}else this.rangeIndex=e;}nextChunk(){this.chunkIndex++,this.rangeIndex=0,this.next();}compare(e){return this.from-e.from||this.startSide-e.startSide||this.rank-e.rank||this.to-e.to||this.endSide-e.endSide}}class HeapCursor{constructor(e){this.heap=e;}static from(e,t=null,i=-1){let n=[];for(let o=0;o<e.length;o++)for(let r=e[o];!r.isEmpty;r=r.nextLayer)r.maxPoint>=i&&n.push(new LayerCursor(r,t,i,o));return 1==n.length?n[0]:new HeapCursor(n)}get startSide(){return this.value?this.value.startSide:0}goto(e,t=-1e9){for(let i of this.heap)i.goto(e,t);for(let e=this.heap.length>>1;e>=0;e--)heapBubble(this.heap,e);return this.next(),this}forward(e,t){for(let i of this.heap)i.forward(e,t);for(let e=this.heap.length>>1;e>=0;e--)heapBubble(this.heap,e);(this.to-e||this.value.endSide-t)<0&&this.next();}next(){if(0==this.heap.length)this.from=this.to=1e9,this.value=null,this.rank=-1;else {let e=this.heap[0];this.from=e.from,this.to=e.to,this.value=e.value,this.rank=e.rank,e.value&&e.next(),heapBubble(this.heap,0);}}}function heapBubble(e,t){for(let i=e[t];;){let n=1+(t<<1);if(n>=e.length)break;let o=e[n];if(n+1<e.length&&o.compare(e[n+1])>=0&&(o=e[n+1],n++),i.compare(o)<0)break;e[n]=i,e[t]=o,t=n;}}class SpanCursor{constructor(e,t,i){this.minPoint=i,this.active=[],this.activeTo=[],this.activeRank=[],this.minActive=-1,this.point=null,this.pointFrom=0,this.pointRank=0,this.to=-1e9,this.endSide=0,this.openStart=-1,this.cursor=HeapCursor.from(e,t,i);}goto(e,t=-1e9){return this.cursor.goto(e,t),this.active.length=this.activeTo.length=this.activeRank.length=0,this.minActive=-1,this.to=e,this.endSide=t,this.openStart=-1,this.next(),this}forward(e,t){for(;this.minActive>-1&&(this.activeTo[this.minActive]-e||this.active[this.minActive].endSide-t)<0;)this.removeActive(this.minActive);this.cursor.forward(e,t);}removeActive(e){remove(this.active,e),remove(this.activeTo,e),remove(this.activeRank,e),this.minActive=findMinIndex(this.active,this.activeTo);}addActive(e){let t=0,{value:i,to:n,rank:o}=this.cursor;for(;t<this.activeRank.length&&this.activeRank[t]<=o;)t++;insert(this.active,t,i),insert(this.activeTo,t,n),insert(this.activeRank,t,o),e&&insert(e,t,this.cursor.from),this.minActive=findMinIndex(this.active,this.activeTo);}next(){let e=this.to,t=this.point;this.point=null;let i=this.openStart<0?[]:null;for(;;){let n=this.minActive;if(n>-1&&(this.activeTo[n]-this.cursor.from||this.active[n].endSide-this.cursor.startSide)<0){if(this.activeTo[n]>e){this.to=this.activeTo[n],this.endSide=this.active[n].endSide;break}this.removeActive(n),i&&remove(i,n);}else {if(!this.cursor.value){this.to=this.endSide=1e9;break}if(this.cursor.from>e){this.to=this.cursor.from,this.endSide=this.cursor.startSide;break}{let e=this.cursor.value;if(e.point){if(!(t&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)){this.point=e,this.pointFrom=this.cursor.from,this.pointRank=this.cursor.rank,this.to=this.cursor.to,this.endSide=e.endSide,this.cursor.next(),this.forward(this.to,this.endSide);break}this.cursor.next();}else this.addActive(i),this.cursor.next();}}}if(i){this.openStart=0;for(let t=i.length-1;t>=0&&i[t]<e;t--)this.openStart++;}}activeForPoint(e){if(!this.active.length)return this.active;let t=[];for(let i=this.active.length-1;i>=0&&!(this.activeRank[i]<this.pointRank);i--)(this.activeTo[i]>e||this.activeTo[i]==e&&this.active[i].endSide>=this.point.endSide)&&t.push(this.active[i]);return t.reverse()}openEnd(e){let t=0;for(let i=this.activeTo.length-1;i>=0&&this.activeTo[i]>e;i--)t++;return t}}function compare(e,t,i,n,o,r){e.goto(t),i.goto(n);let s=n+o,a=n,l=n-t;for(;;){let t=e.to+l-i.to||e.endSide-i.endSide,n=t<0?e.to+l:i.to,o=Math.min(n,s);if(e.point||i.point?e.point&&i.point&&(e.point==i.point||e.point.eq(i.point))&&sameValues(e.activeForPoint(e.to+l),i.activeForPoint(i.to))||r.comparePoint(a,o,e.point,i.point):o>a&&!sameValues(e.active,i.active)&&r.compareRange(a,o,e.active,i.active),n>s)break;a=n,t<=0&&e.next(),t>=0&&i.next();}}function sameValues(e,t){if(e.length!=t.length)return  false;for(let i=0;i<e.length;i++)if(e[i]!=t[i]&&!e[i].eq(t[i]))return  false;return  true}function remove(e,t){for(let i=t,n=e.length-1;i<n;i++)e[i]=e[i+1];e.pop();}function insert(e,t,i){for(let i=e.length-1;i>=t;i--)e[i+1]=e[i];e[t]=i;}function findMinIndex(e,t){let i=-1,n=1e9;for(let o=0;o<t.length;o++)(t[o]-n||e[o].endSide-e[i].endSide)<0&&(i=o,n=t[o]);return i}function countColumn(e,t,i=e.length){let n=0;for(let o=0;o<i;)9==e.charCodeAt(o)?(n+=t-n%t,o++):(n++,o=findClusterBreak(e,o));return n}function findColumn(e,t,i,n){for(let n=0,o=0;;){if(o>=t)return n;if(n==e.length)break;o+=9==e.charCodeAt(n)?i-o%i:1,n=findClusterBreak(e,n);}return e.length}const C$1="ͼ",COUNT="undefined"==typeof Symbol?"__"+C$1:Symbol.for(C$1),SET="undefined"==typeof Symbol?"__styleSet"+Math.floor(1e8*Math.random()):Symbol("styleSet"),top="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:{};class StyleModule{constructor(e,t){this.rules=[];let{finish:i}=t||{};function n(e){return /^@/.test(e)?[e]:e.split(/,\s*/)}function o(e,t,r,s){let a=[],l=/^@(\w+)\b/.exec(e[0]),h=l&&"keyframes"==l[1];if(l&&null==t)return r.push(e[0]+";");for(let i in t){let s=t[i];if(/&/.test(i))o(i.split(/,\s*/).map(t=>e.map(e=>t.replace(/&/,e))).reduce((e,t)=>e.concat(t)),s,r);else if(s&&"object"==typeof s){if(!l)throw new RangeError("The value of a property ("+i+") should be a primitive value.");o(n(i),s,a,h);}else null!=s&&a.push(i.replace(/_.*/,"").replace(/[A-Z]/g,e=>"-"+e.toLowerCase())+": "+s+";");}(a.length||h)&&r.push((!i||l||s?e:e.map(i)).join(", ")+" {"+a.join(" ")+"}");}for(let t in e)o(n(t),e[t],this.rules);}getRules(){return this.rules.join("\n")}static newName(){let e=top[COUNT]||1;return top[COUNT]=e+1,C$1+e.toString(36)}static mount(e,t){(e[SET]||new StyleSet(e)).mount(Array.isArray(t)?t:[t]);}}let adoptedSet=null;class StyleSet{constructor(e){if(!e.head&&e.adoptedStyleSheets&&"undefined"!=typeof CSSStyleSheet){if(adoptedSet)return e.adoptedStyleSheets=[adoptedSet.sheet].concat(e.adoptedStyleSheets),e[SET]=adoptedSet;this.sheet=new CSSStyleSheet,e.adoptedStyleSheets=[this.sheet].concat(e.adoptedStyleSheets),adoptedSet=this;}else {this.styleTag=(e.ownerDocument||e).createElement("style");let t=e.head||e;t.insertBefore(this.styleTag,t.firstChild);}this.modules=[],e[SET]=this;}mount(e){let t=this.sheet,i=0,n=0;for(let o=0;o<e.length;o++){let r=e[o],s=this.modules.indexOf(r);if(s<n&&s>-1&&(this.modules.splice(s,1),n--,s=-1),-1==s){if(this.modules.splice(n++,0,r),t)for(let e=0;e<r.rules.length;e++)t.insertRule(r.rules[e],i++);}else {for(;n<s;)i+=this.modules[n++].rules.length;i+=r.rules.length,n++;}}if(!t){let e="";for(let t=0;t<this.modules.length;t++)e+=this.modules[t].getRules()+"\n";this.styleTag.textContent=e;}}}for(var base={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},shift={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},chrome="undefined"!=typeof navigator&&/Chrome\/(\d+)/.exec(navigator.userAgent),gecko="undefined"!=typeof navigator&&/Gecko\/\d+/.test(navigator.userAgent),mac="undefined"!=typeof navigator&&/Mac/.test(navigator.platform),ie="undefined"!=typeof navigator&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),brokenModifierNames=mac||chrome&&+chrome[1]<57,i=0;i<10;i++)base[48+i]=base[96+i]=String(i);for(i=1;i<=24;i++)base[i+111]="F"+i;for(i=65;i<=90;i++)base[i]=String.fromCharCode(i+32),shift[i]=String.fromCharCode(i);for(var code$1 in base)shift.hasOwnProperty(code$1)||(shift[code$1]=base[code$1]);function keyName(e){var t=!(brokenModifierNames&&(e.ctrlKey||e.altKey||e.metaKey)||ie&&e.shiftKey&&e.key&&1==e.key.length||"Unidentified"==e.key)&&e.key||(e.shiftKey?shift:base)[e.keyCode]||e.key||"Unidentified";return "Esc"==t&&(t="Escape"),"Del"==t&&(t="Delete"),"Left"==t&&(t="ArrowLeft"),"Up"==t&&(t="ArrowUp"),"Right"==t&&(t="ArrowRight"),"Down"==t&&(t="ArrowDown"),t}function getSelection(e){return (11==e.nodeType?e.getSelection?e:e.ownerDocument:e).getSelection()}function contains(e,t){return !!t&&(e==t||e.contains(1!=t.nodeType?t.parentNode:t))}function deepActiveElement(e){let t=e.activeElement;for(;t&&t.shadowRoot;)t=t.shadowRoot.activeElement;return t}function hasSelection(e,t){if(!t.anchorNode)return  false;try{return contains(e,t.anchorNode)}catch(e){return  false}}function clientRectsFor(e){return 3==e.nodeType?textRange(e,0,e.nodeValue.length).getClientRects():1==e.nodeType?e.getClientRects():[]}function isEquivalentPosition(e,t,i,n){return !!i&&(scanFor(e,t,i,n,-1)||scanFor(e,t,i,n,1))}function domIndex(e){for(var t=0;;t++)if(!(e=e.previousSibling))return t}function scanFor(e,t,i,n,o){for(;;){if(e==i&&t==n)return  true;if(t==(o<0?0:maxOffset(e))){if("DIV"==e.nodeName)return  false;let i=e.parentNode;if(!i||1!=i.nodeType)return  false;t=domIndex(e)+(o<0?0:1),e=i;}else {if(1!=e.nodeType)return  false;if(1==(e=e.childNodes[t+(o<0?-1:0)]).nodeType&&"false"==e.contentEditable)return  false;t=o<0?maxOffset(e):0;}}}function maxOffset(e){return 3==e.nodeType?e.nodeValue.length:e.childNodes.length}const Rect0={left:0,right:0,top:0,bottom:0};function flattenRect(e,t){let i=t?e.left:e.right;return {left:i,right:i,top:e.top,bottom:e.bottom}}function windowRect(e){return {left:0,right:e.innerWidth,top:0,bottom:e.innerHeight}}function scrollRectIntoView(e,t,i,n,o,r,s,a){let l=e.ownerDocument,h=l.defaultView||window;for(let c=e;c;)if(1==c.nodeType){let e,d=c==l.body;if(d)e=windowRect(h);else {if(c.scrollHeight<=c.clientHeight&&c.scrollWidth<=c.clientWidth){c=c.assignedSlot||c.parentNode;continue}let t=c.getBoundingClientRect();e={left:t.left,right:t.left+c.clientWidth,top:t.top,bottom:t.top+c.clientHeight};}let u=0,f=0;if("nearest"==o)t.top<e.top?(f=-(e.top-t.top+s),i>0&&t.bottom>e.bottom+f&&(f=t.bottom-e.bottom+f+s)):t.bottom>e.bottom&&(f=t.bottom-e.bottom+s,i<0&&t.top-f<e.top&&(f=-(e.top+f-t.top+s)));else {let n=t.bottom-t.top,r=e.bottom-e.top;f=("center"==o&&n<=r?t.top+n/2-r/2:"start"==o||"center"==o&&i<0?t.top-s:t.bottom-r+s)-e.top;}if("nearest"==n)t.left<e.left?(u=-(e.left-t.left+r),i>0&&t.right>e.right+u&&(u=t.right-e.right+u+r)):t.right>e.right&&(u=t.right-e.right+r,i<0&&t.left<e.left+u&&(u=-(e.left+u-t.left+r)));else {u=("center"==n?t.left+(t.right-t.left)/2-(e.right-e.left)/2:"start"==n==a?t.left-r:t.right-(e.right-e.left)+r)-e.left;}if(u||f)if(d)h.scrollBy(u,f);else {let e=0,i=0;if(f){let e=c.scrollTop;c.scrollTop+=f,i=c.scrollTop-e;}if(u){let t=c.scrollLeft;c.scrollLeft+=u,e=c.scrollLeft-t;}t={left:t.left-e,top:t.top-i,right:t.right-e,bottom:t.bottom-i},e&&Math.abs(e-u)<1&&(n="nearest"),i&&Math.abs(i-f)<1&&(o="nearest");}if(d)break;c=c.assignedSlot||c.parentNode;}else {if(11!=c.nodeType)break;c=c.host;}}class DOMSelectionState{constructor(){this.anchorNode=null,this.anchorOffset=0,this.focusNode=null,this.focusOffset=0;}eq(e){return this.anchorNode==e.anchorNode&&this.anchorOffset==e.anchorOffset&&this.focusNode==e.focusNode&&this.focusOffset==e.focusOffset}setRange(e){this.set(e.anchorNode,e.anchorOffset,e.focusNode,e.focusOffset);}set(e,t,i,n){this.anchorNode=e,this.anchorOffset=t,this.focusNode=i,this.focusOffset=n;}}let scratchRange,preventScrollSupported=null;function focusPreventScroll(e){if(e.setActive)return e.setActive();if(preventScrollSupported)return e.focus(preventScrollSupported);let t=[];for(let i=e;i&&(t.push(i,i.scrollTop,i.scrollLeft),i!=i.ownerDocument);i=i.parentNode);if(e.focus(null==preventScrollSupported?{get preventScroll(){return preventScrollSupported={preventScroll:true},true}}:void 0),!preventScrollSupported){preventScrollSupported=false;for(let e=0;e<t.length;){let i=t[e++],n=t[e++],o=t[e++];i.scrollTop!=n&&(i.scrollTop=n),i.scrollLeft!=o&&(i.scrollLeft=o);}}}function textRange(e,t,i=t){let n=scratchRange||(scratchRange=document.createRange());return n.setEnd(e,i),n.setStart(e,t),n}function dispatchKey(e,t,i){let n={key:t,code:t,keyCode:i,which:i,cancelable:true},o=new KeyboardEvent("keydown",n);o.synthetic=true,e.dispatchEvent(o);let r=new KeyboardEvent("keyup",n);return r.synthetic=true,e.dispatchEvent(r),o.defaultPrevented||r.defaultPrevented}function getRoot(e){for(;e;){if(e&&(9==e.nodeType||11==e.nodeType&&e.host))return e;e=e.assignedSlot||e.parentNode;}return null}function clearAttributes(e){for(;e.attributes.length;)e.removeAttributeNode(e.attributes[0]);}function atElementStart(e,t){let i=t.focusNode,n=t.focusOffset;if(!i||t.anchorNode!=i||t.anchorOffset!=n)return  false;for(;;)if(n){if(1!=i.nodeType)return  false;let e=i.childNodes[n-1];"false"==e.contentEditable?n--:n=maxOffset(i=e);}else {if(i==e)return  true;n=domIndex(i),i=i.parentNode;}}class DOMPos{constructor(e,t,i=true){this.node=e,this.offset=t,this.precise=i;}static before(e,t){return new DOMPos(e.parentNode,domIndex(e),t)}static after(e,t){return new DOMPos(e.parentNode,domIndex(e)+1,t)}}const noChildren=[];class ContentView{constructor(){this.parent=null,this.dom=null,this.dirty=2;}get editorView(){if(!this.parent)throw new Error("Accessing view in orphan content view");return this.parent.editorView}get overrideDOMText(){return null}get posAtStart(){return this.parent?this.parent.posBefore(this):0}get posAtEnd(){return this.posAtStart+this.length}posBefore(e){let t=this.posAtStart;for(let i of this.children){if(i==e)return t;t+=i.length+i.breakAfter;}throw new RangeError("Invalid child in posBefore")}posAfter(e){return this.posBefore(e)+e.length}coordsAt(e,t){return null}sync(e){if(2&this.dirty){let t,i=this.dom,n=null;for(let o of this.children){if(o.dirty){if(!o.dom&&(t=n?n.nextSibling:i.firstChild)){let e=ContentView.get(t);(!e||!e.parent&&e.canReuseDOM(o))&&o.reuseDOM(t);}o.sync(e),o.dirty=0;}if(t=n?n.nextSibling:i.firstChild,e&&!e.written&&e.node==i&&t!=o.dom&&(e.written=true),o.dom.parentNode==i)for(;t&&t!=o.dom;)t=rm$1(t);else i.insertBefore(o.dom,t);n=o.dom;}for((t=n?n.nextSibling:i.firstChild)&&e&&e.node==i&&(e.written=true);t;)t=rm$1(t);}else if(1&this.dirty)for(let t of this.children)t.dirty&&(t.sync(e),t.dirty=0);}reuseDOM(e){}localPosFromDOM(e,t){let i;if(e==this.dom)i=this.dom.childNodes[t];else {let n=0==maxOffset(e)?0:0==t?-1:1;for(;;){let t=e.parentNode;if(t==this.dom)break;0==n&&t.firstChild!=t.lastChild&&(n=e==t.firstChild?-1:1),e=t;}i=n<0?e:e.nextSibling;}if(i==this.dom.firstChild)return 0;for(;i&&!ContentView.get(i);)i=i.nextSibling;if(!i)return this.length;for(let e=0,t=0;;e++){let n=this.children[e];if(n.dom==i)return t;t+=n.length+n.breakAfter;}}domBoundsAround(e,t,i=0){let n=-1,o=-1,r=-1,s=-1;for(let a=0,l=i,h=i;a<this.children.length;a++){let i=this.children[a],c=l+i.length;if(l<e&&c>t)return i.domBoundsAround(e,t,l);if(c>=e&&-1==n&&(n=a,o=l),l>t&&i.dom.parentNode==this.dom){r=a,s=h;break}h=c,l=c+i.breakAfter;}return {from:o,to:s<0?i+this.length:s,startDOM:(n?this.children[n-1].dom.nextSibling:null)||this.dom.firstChild,endDOM:r<this.children.length&&r>=0?this.children[r].dom:null}}markDirty(e=false){this.dirty|=2,this.markParentsDirty(e);}markParentsDirty(e){for(let t=this.parent;t;t=t.parent){if(e&&(t.dirty|=2),1&t.dirty)return;t.dirty|=1,e=false;}}setParent(e){this.parent!=e&&(this.parent=e,this.dirty&&this.markParentsDirty(true));}setDOM(e){this.dom&&(this.dom.cmView=null),this.dom=e,e.cmView=this;}get rootView(){for(let e=this;;){let t=e.parent;if(!t)return e;e=t;}}replaceChildren(e,t,i=noChildren){this.markDirty();for(let i=e;i<t;i++){let e=this.children[i];e.parent==this&&e.destroy();}this.children.splice(e,t-e,...i);for(let e=0;e<i.length;e++)i[e].setParent(this);}ignoreMutation(e){return  false}ignoreEvent(e){return  false}childCursor(e=this.length){return new ChildCursor(this.children,e,this.children.length)}childPos(e,t=1){return this.childCursor().findPos(e,t)}toString(){let e=this.constructor.name.replace("View","");return e+(this.children.length?"("+this.children.join()+")":this.length?"["+("Text"==e?this.text:this.length)+"]":"")+(this.breakAfter?"#":"")}static get(e){return e.cmView}get isEditable(){return  true}merge(e,t,i,n,o,r){return  false}become(e){return  false}canReuseDOM(e){return e.constructor==this.constructor}getSide(){return 0}destroy(){this.parent=null;}}function rm$1(e){let t=e.nextSibling;return e.parentNode.removeChild(e),t}ContentView.prototype.breakAfter=0;class ChildCursor{constructor(e,t,i){this.children=e,this.pos=t,this.i=i,this.off=0;}findPos(e,t=1){for(;;){if(e>this.pos||e==this.pos&&(t>0||0==this.i||this.children[this.i-1].breakAfter))return this.off=e-this.pos,this;let i=this.children[--this.i];this.pos-=i.length+i.breakAfter;}}}function replaceRange(e,t,i,n,o,r,s,a,l){let{children:h}=e,c=h.length?h[t]:null,d=r.length?r[r.length-1]:null,u=d?d.breakAfter:s;if(!(t==n&&c&&!s&&!u&&r.length<2&&c.merge(i,o,r.length?d:null,0==i,a,l))){if(n<h.length){let e=h[n];e&&o<e.length?(t==n&&(e=e.split(o),o=0),!u&&d&&e.merge(0,o,d,true,0,l)?r[r.length-1]=e:(o&&e.merge(0,o,null,false,0,l),r.push(e))):(null===e||void 0===e?void 0:e.breakAfter)&&(d?d.breakAfter=1:s=1),n++;}for(c&&(c.breakAfter=s,i>0&&(!s&&r.length&&c.merge(i,c.length,r[0],false,a,0)?c.breakAfter=r.shift().breakAfter:(i<c.length||c.children.length&&0==c.children[c.children.length-1].length)&&c.merge(i,c.length,null,false,a,0),t++));t<n&&r.length;)if(h[n-1].become(r[r.length-1]))n--,r.pop(),l=r.length?0:a;else {if(!h[t].become(r[0]))break;t++,r.shift(),a=r.length?0:l;}!r.length&&t&&n<h.length&&!h[t-1].breakAfter&&h[n].merge(0,0,h[t-1],false,a,l)&&t--,(t<n||r.length)&&e.replaceChildren(t,n,r);}}function mergeChildrenInto(e,t,i,n,o,r){let s=e.childCursor(),{i:a,off:l}=s.findPos(i,1),{i:h,off:c}=s.findPos(t,-1),d=t-i;for(let e of n)d+=e.length;e.length+=d,replaceRange(e,h,c,a,l,n,0,o,r);}let nav="undefined"!=typeof navigator?navigator:{userAgent:"",vendor:"",platform:""},doc="undefined"!=typeof document?document:{documentElement:{style:{}}};const ie_edge=/Edge\/(\d+)/.exec(nav.userAgent),ie_upto10=/MSIE \d/.test(nav.userAgent),ie_11up=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent),ie$1=!!(ie_upto10||ie_11up||ie_edge),gecko$1=!ie$1&&/gecko\/(\d+)/i.test(nav.userAgent),chrome$1=!ie$1&&/Chrome\/(\d+)/.exec(nav.userAgent),webkit="webkitFontSmoothing"in doc.documentElement.style,safari=!ie$1&&/Apple Computer/.test(nav.vendor),ios=safari&&(/Mobile\/\w+/.test(nav.userAgent)||nav.maxTouchPoints>2);var browser={mac:ios||/Mac/.test(nav.platform),windows:/Win/.test(nav.platform),linux:/Linux|X11/.test(nav.platform),ie:ie$1,ie_version:ie_upto10?doc.documentMode||6:ie_11up?+ie_11up[1]:ie_edge?+ie_edge[1]:0,gecko:gecko$1,gecko_version:gecko$1?+(/Firefox\/(\d+)/.exec(nav.userAgent)||[0,0])[1]:0,chrome:!!chrome$1,chrome_version:chrome$1?+chrome$1[1]:0,ios:ios,android:/Android\b/.test(nav.userAgent),safari:safari,webkit_version:webkit?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0,tabSize:null!=doc.documentElement.style.tabSize?"tab-size":"-moz-tab-size"};const MaxJoinLen=256;class TextView extends ContentView{constructor(e){super(),this.text=e;}get length(){return this.text.length}createDOM(e){this.setDOM(e||document.createTextNode(this.text));}sync(e){this.dom||this.createDOM(),this.dom.nodeValue!=this.text&&(e&&e.node==this.dom&&(e.written=true),this.dom.nodeValue=this.text);}reuseDOM(e){3==e.nodeType&&this.createDOM(e);}merge(e,t,i){return (!i||i instanceof TextView&&!(this.length-(t-e)+i.length>MaxJoinLen))&&(this.text=this.text.slice(0,e)+(i?i.text:"")+this.text.slice(t),this.markDirty(),true)}split(e){let t=new TextView(this.text.slice(e));return this.text=this.text.slice(0,e),this.markDirty(),t}localPosFromDOM(e,t){return e==this.dom?t:t?this.text.length:0}domAtPos(e){return new DOMPos(this.dom,e)}domBoundsAround(e,t,i){return {from:i,to:i+this.length,startDOM:this.dom,endDOM:this.dom.nextSibling}}coordsAt(e,t){return textCoords(this.dom,e,t)}}class MarkView extends ContentView{constructor(e,t=[],i=0){super(),this.mark=e,this.children=t,this.length=i;for(let e of t)e.setParent(this);}setAttrs(e){if(clearAttributes(e),this.mark.class&&(e.className=this.mark.class),this.mark.attrs)for(let t in this.mark.attrs)e.setAttribute(t,this.mark.attrs[t]);return e}reuseDOM(e){e.nodeName==this.mark.tagName.toUpperCase()&&(this.setDOM(e),this.dirty|=6);}sync(e){this.dom?4&this.dirty&&this.setAttrs(this.dom):this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),super.sync(e);}merge(e,t,i,n,o,r){return (!i||!(!(i instanceof MarkView&&i.mark.eq(this.mark))||e&&o<=0||t<this.length&&r<=0))&&(mergeChildrenInto(this,e,t,i?i.children:[],o-1,r-1),this.markDirty(),true)}split(e){let t=[],i=0,n=-1,o=0;for(let r of this.children){let s=i+r.length;s>e&&t.push(i<e?r.split(e-i):r),n<0&&i>=e&&(n=o),i=s,o++;}let r=this.length-e;return this.length=e,n>-1&&(this.children.length=n,this.markDirty()),new MarkView(this.mark,t,r)}domAtPos(e){return inlineDOMAtPos(this,e)}coordsAt(e,t){return coordsInChildren(this,e,t)}}function textCoords(e,t,i){let n=e.nodeValue.length;t>n&&(t=n);let o=t,r=t,s=0;0==t&&i<0||t==n&&i>=0?browser.chrome||browser.gecko||(t?(o--,s=1):r<n&&(r++,s=-1)):i<0?o--:r<n&&r++;let a=textRange(e,o,r).getClientRects();if(!a.length)return Rect0;let l=a[(s?s<0:i>=0)?0:a.length-1];return browser.safari&&!s&&0==l.width&&(l=Array.prototype.find.call(a,e=>e.width)||l),s?flattenRect(l,s<0):l||null}class WidgetView extends ContentView{constructor(e,t,i){super(),this.widget=e,this.length=t,this.side=i,this.prevWidget=null;}static create(e,t,i){return new(e.customView||WidgetView)(e,t,i)}split(e){let t=WidgetView.create(this.widget,this.length-e,this.side);return this.length-=e,t}sync(){this.dom&&this.widget.updateDOM(this.dom)||(this.dom&&this.prevWidget&&this.prevWidget.destroy(this.dom),this.prevWidget=null,this.setDOM(this.widget.toDOM(this.editorView)),this.dom.contentEditable="false");}getSide(){return this.side}merge(e,t,i,n,o,r){return !(i&&(!(i instanceof WidgetView&&this.widget.compare(i.widget))||e>0&&o<=0||t<this.length&&r<=0))&&(this.length=e+(i?i.length:0)+(this.length-t),true)}become(e){return e.length==this.length&&e instanceof WidgetView&&e.side==this.side&&this.widget.constructor==e.widget.constructor&&(this.widget.eq(e.widget)||this.markDirty(true),this.dom&&!this.prevWidget&&(this.prevWidget=this.widget),this.widget=e.widget,true)}ignoreMutation(){return  true}ignoreEvent(e){return this.widget.ignoreEvent(e)}get overrideDOMText(){if(0==this.length)return Text.empty;let e=this;for(;e.parent;)e=e.parent;let t=e.editorView,i=t&&t.state.doc,n=this.posAtStart;return i?i.slice(n,n+this.length):Text.empty}domAtPos(e){return 0==e?DOMPos.before(this.dom):DOMPos.after(this.dom,e==this.length)}domBoundsAround(){return null}coordsAt(e,t){let i=this.dom.getClientRects(),n=null;if(!i.length)return Rect0;for(let t=e>0?i.length-1:0;n=i[t],!(e>0?0==t:t==i.length-1||n.top<n.bottom);t+=e>0?-1:1);return this.length?n:flattenRect(n,this.side>0)}get isEditable(){return  false}destroy(){super.destroy(),this.dom&&this.widget.destroy(this.dom);}}class CompositionView extends WidgetView{domAtPos(e){let{topView:t,text:i}=this.widget;return t?scanCompositionTree(e,0,t,i,(e,t)=>e.domAtPos(t),e=>new DOMPos(i,Math.min(e,i.nodeValue.length))):new DOMPos(i,Math.min(e,i.nodeValue.length))}sync(){this.setDOM(this.widget.toDOM());}localPosFromDOM(e,t){let{topView:i,text:n}=this.widget;return i?posFromDOMInCompositionTree(e,t,i,n):Math.min(t,this.length)}ignoreMutation(){return  false}get overrideDOMText(){return null}coordsAt(e,t){let{topView:i,text:n}=this.widget;return i?scanCompositionTree(e,t,i,n,(e,t,i)=>e.coordsAt(t,i),(e,t)=>textCoords(n,e,t)):textCoords(n,e,t)}destroy(){var e;super.destroy(),null===(e=this.widget.topView)||void 0===e||e.destroy();}get isEditable(){return  true}canReuseDOM(){return  true}}function scanCompositionTree(e,t,i,n,o,r){if(i instanceof MarkView){for(let s=i.dom.firstChild;s;s=s.nextSibling){let i=ContentView.get(s);if(!i)return r(e,t);let a=contains(s,n),l=i.length+(a?n.nodeValue.length:0);if(e<l||e==l&&i.getSide()<=0)return a?scanCompositionTree(e,t,i,n,o,r):o(i,e,t);e-=l;}return o(i,i.length,-1)}return i.dom==n?r(e,t):o(i,e,t)}function posFromDOMInCompositionTree(e,t,i,n){if(i instanceof MarkView)for(let o of i.children){let i=0,r=contains(o.dom,n);if(contains(o.dom,e))return i+(r?posFromDOMInCompositionTree(e,t,o,n):o.localPosFromDOM(e,t));i+=r?n.nodeValue.length:o.length;}else if(i.dom==n)return Math.min(t,n.nodeValue.length);return i.localPosFromDOM(e,t)}class WidgetBufferView extends ContentView{constructor(e){super(),this.side=e;}get length(){return 0}merge(){return  false}become(e){return e instanceof WidgetBufferView&&e.side==this.side}split(){return new WidgetBufferView(this.side)}sync(){if(!this.dom){let e=document.createElement("img");e.className="cm-widgetBuffer",e.setAttribute("aria-hidden","true"),this.setDOM(e);}}getSide(){return this.side}domAtPos(e){return DOMPos.before(this.dom)}localPosFromDOM(){return 0}domBoundsAround(){return null}coordsAt(e){let t=this.dom.getBoundingClientRect(),i=inlineSiblingRect(this,this.side>0?-1:1);return i&&i.top<t.bottom&&i.bottom>t.top?{left:t.left,right:t.right,top:i.top,bottom:i.bottom}:t}get overrideDOMText(){return Text.empty}}function inlineSiblingRect(e,t){let i=e.parent,n=i?i.children.indexOf(e):-1;for(;i&&n>=0;)if(t<0?n>0:n<i.children.length){let e=i.children[n+t];if(e instanceof TextView){let i=e.coordsAt(t<0?e.length:0,t);if(i)return i}n+=t;}else {if(!(i instanceof MarkView&&i.parent)){let e=i.dom.lastChild;if(e&&"BR"==e.nodeName)return e.getClientRects()[0];break}n=i.parent.children.indexOf(i)+(t<0?0:1),i=i.parent;}}function inlineDOMAtPos(e,t){let i=e.dom,{children:n}=e,o=0;for(let e=0;o<n.length;o++){let r=n[o],s=e+r.length;if(!(s==e&&r.getSide()<=0)){if(t>e&&t<s&&r.dom.parentNode==i)return r.domAtPos(t-e);if(t<=e)break;e=s;}}for(let e=o;e>0;e--){let t=n[e-1];if(t.dom.parentNode==i)return t.domAtPos(t.length)}for(let e=o;e<n.length;e++){let t=n[e];if(t.dom.parentNode==i)return t.domAtPos(0)}return new DOMPos(i,0)}function joinInlineInto(e,t,i){let n,{children:o}=e;i>0&&t instanceof MarkView&&o.length&&(n=o[o.length-1])instanceof MarkView&&n.mark.eq(t.mark)?joinInlineInto(n,t.children[0],i-1):(o.push(t),t.setParent(e)),e.length+=t.length;}function coordsInChildren(e,t,i){let n=null,o=-1,r=null,s=-1;!function e(t,i){for(let a=0,l=0;a<t.children.length&&l<=i;a++){let h=t.children[a],c=l+h.length;c>=i&&(h.children.length?e(h,i-l):!r&&(c>i||l==c&&h.getSide()>0)?(r=h,s=i-l):(l<i||l==c&&h.getSide()<0)&&(n=h,o=i-l)),l=c;}}(e,t);let a=(i<0?n:r)||n||r;return a?a.coordsAt(Math.max(0,a==n?o:s),i):fallbackRect(e)}function fallbackRect(e){let t=e.dom.lastChild;if(!t)return e.dom.getBoundingClientRect();let i=clientRectsFor(t);return i[i.length-1]||null}function combineAttrs(e,t){for(let i in e)"class"==i&&t.class?t.class+=" "+e.class:"style"==i&&t.style?t.style+=";"+e.style:t[i]=e[i];return t}function attrsEq(e,t){if(e==t)return  true;if(!e||!t)return  false;let i=Object.keys(e),n=Object.keys(t);if(i.length!=n.length)return  false;for(let o of i)if(-1==n.indexOf(o)||e[o]!==t[o])return  false;return  true}function updateAttrs(e,t,i){let n=null;if(t)for(let o in t)i&&o in i||e.removeAttribute(n=o);if(i)for(let o in i)t&&t[o]==i[o]||e.setAttribute(n=o,i[o]);return !!n}TextView.prototype.children=WidgetView.prototype.children=WidgetBufferView.prototype.children=noChildren;class WidgetType{eq(e){return  false}updateDOM(e){return  false}compare(e){return this==e||this.constructor==e.constructor&&this.eq(e)}get estimatedHeight(){return  -1}ignoreEvent(e){return  true}get customView(){return null}destroy(e){}}var BlockType=function(e){return e[e.Text=0]="Text",e[e.WidgetBefore=1]="WidgetBefore",e[e.WidgetAfter=2]="WidgetAfter",e[e.WidgetRange=3]="WidgetRange",e}(BlockType||(BlockType={}));class Decoration extends RangeValue{constructor(e,t,i,n){super(),this.startSide=e,this.endSide=t,this.widget=i,this.spec=n;}get heightRelevant(){return  false}static mark(e){return new MarkDecoration(e)}static widget(e){let t=e.side||0,i=!!e.block;return new PointDecoration(e,t+=i?t>0?3e8:-4e8:t>0?1e8:-1e8,t,i,e.widget||null,false)}static replace(e){let t,i,n=!!e.block;if(e.isBlockGap)t=-5e8,i=4e8;else {let{start:o,end:r}=getInclusive(e,n);t=(o?n?-3e8:-1:5e8)-1,i=1+(r?n?2e8:1:-6e8);}return new PointDecoration(e,t,i,n,e.widget||null,true)}static line(e){return new LineDecoration(e)}static set(e,t=false){return RangeSet.of(e,t)}hasHeight(){return !!this.widget&&this.widget.estimatedHeight>-1}}Decoration.none=RangeSet.empty;class MarkDecoration extends Decoration{constructor(e){let{start:t,end:i}=getInclusive(e);super(t?-1:5e8,i?1:-6e8,null,e),this.tagName=e.tagName||"span",this.class=e.class||"",this.attrs=e.attributes||null;}eq(e){return this==e||e instanceof MarkDecoration&&this.tagName==e.tagName&&this.class==e.class&&attrsEq(this.attrs,e.attrs)}range(e,t=e){if(e>=t)throw new RangeError("Mark decorations may not be empty");return super.range(e,t)}}MarkDecoration.prototype.point=false;class LineDecoration extends Decoration{constructor(e){super(-2e8,-2e8,null,e);}eq(e){return e instanceof LineDecoration&&attrsEq(this.spec.attributes,e.spec.attributes)}range(e,t=e){if(t!=e)throw new RangeError("Line decoration ranges must be zero-length");return super.range(e,t)}}LineDecoration.prototype.mapMode=MapMode.TrackBefore,LineDecoration.prototype.point=true;class PointDecoration extends Decoration{constructor(e,t,i,n,o,r){super(t,i,o,e),this.block=n,this.isReplace=r,this.mapMode=n?t<=0?MapMode.TrackBefore:MapMode.TrackAfter:MapMode.TrackDel;}get type(){return this.startSide<this.endSide?BlockType.WidgetRange:this.startSide<=0?BlockType.WidgetBefore:BlockType.WidgetAfter}get heightRelevant(){return this.block||!!this.widget&&this.widget.estimatedHeight>=5}eq(e){return e instanceof PointDecoration&&widgetsEq(this.widget,e.widget)&&this.block==e.block&&this.startSide==e.startSide&&this.endSide==e.endSide}range(e,t=e){if(this.isReplace&&(e>t||e==t&&this.startSide>0&&this.endSide<=0))throw new RangeError("Invalid range for replacement decoration");if(!this.isReplace&&t!=e)throw new RangeError("Widget decorations can only have zero-length ranges");return super.range(e,t)}}function getInclusive(e,t=false){let{inclusiveStart:i,inclusiveEnd:n}=e;return null==i&&(i=e.inclusive),null==n&&(n=e.inclusive),{start:null!==i&&void 0!==i?i:t,end:null!==n&&void 0!==n?n:t}}function widgetsEq(e,t){return e==t||!!(e&&t&&e.compare(t))}function addRange(e,t,i,n=0){let o=i.length-1;o>=0&&i[o]+n>=e?i[o]=Math.max(i[o],t):i.push(e,t);}PointDecoration.prototype.point=true;class LineView extends ContentView{constructor(){super(...arguments),this.children=[],this.length=0,this.prevAttrs=void 0,this.attrs=null,this.breakAfter=0;}merge(e,t,i,n,o,r){if(i){if(!(i instanceof LineView))return  false;this.dom||i.transferDOM(this);}return n&&this.setDeco(i?i.attrs:null),mergeChildrenInto(this,e,t,i?i.children:[],o,r),true}split(e){let t=new LineView;if(t.breakAfter=this.breakAfter,0==this.length)return t;let{i:i,off:n}=this.childPos(e);n&&(t.append(this.children[i].split(n),0),this.children[i].merge(n,this.children[i].length,null,false,0,0),i++);for(let e=i;e<this.children.length;e++)t.append(this.children[e],0);for(;i>0&&0==this.children[i-1].length;)this.children[--i].destroy();return this.children.length=i,this.markDirty(),this.length=e,t}transferDOM(e){this.dom&&(this.markDirty(),e.setDOM(this.dom),e.prevAttrs=void 0===this.prevAttrs?this.attrs:this.prevAttrs,this.prevAttrs=void 0,this.dom=null);}setDeco(e){attrsEq(this.attrs,e)||(this.dom&&(this.prevAttrs=this.attrs,this.markDirty()),this.attrs=e);}append(e,t){joinInlineInto(this,e,t);}addLineDeco(e){let t=e.spec.attributes,i=e.spec.class;t&&(this.attrs=combineAttrs(t,this.attrs||{})),i&&(this.attrs=combineAttrs({class:i},this.attrs||{}));}domAtPos(e){return inlineDOMAtPos(this,e)}reuseDOM(e){"DIV"==e.nodeName&&(this.setDOM(e),this.dirty|=6);}sync(e){var t;this.dom?4&this.dirty&&(clearAttributes(this.dom),this.dom.className="cm-line",this.prevAttrs=this.attrs?null:void 0):(this.setDOM(document.createElement("div")),this.dom.className="cm-line",this.prevAttrs=this.attrs?null:void 0),void 0!==this.prevAttrs&&(updateAttrs(this.dom,this.prevAttrs,this.attrs),this.dom.classList.add("cm-line"),this.prevAttrs=void 0),super.sync(e);let i=this.dom.lastChild;for(;i&&ContentView.get(i)instanceof MarkView;)i=i.lastChild;if(!(i&&this.length&&("BR"==i.nodeName||0!=(null===(t=ContentView.get(i))||void 0===t?void 0:t.isEditable)||browser.ios&&this.children.some(e=>e instanceof TextView)))){let e=document.createElement("BR");e.cmIgnore=true,this.dom.appendChild(e);}}measureTextSize(){if(0==this.children.length||this.length>20)return null;let e=0;for(let t of this.children){if(!(t instanceof TextView)||/[^ -~]/.test(t.text))return null;let i=clientRectsFor(t.dom);if(1!=i.length)return null;e+=i[0].width;}return e?{lineHeight:this.dom.getBoundingClientRect().height,charWidth:e/this.length}:null}coordsAt(e,t){return coordsInChildren(this,e,t)}become(e){return  false}get type(){return BlockType.Text}static find(e,t){for(let i=0,n=0;i<e.children.length;i++){let o=e.children[i],r=n+o.length;if(r>=t){if(o instanceof LineView)return o;if(r>t)break}n=r+o.breakAfter;}return null}}class BlockWidgetView extends ContentView{constructor(e,t,i){super(),this.widget=e,this.length=t,this.type=i,this.breakAfter=0,this.prevWidget=null;}merge(e,t,i,n,o,r){return !(i&&(!(i instanceof BlockWidgetView&&this.widget.compare(i.widget))||e>0&&o<=0||t<this.length&&r<=0))&&(this.length=e+(i?i.length:0)+(this.length-t),true)}domAtPos(e){return 0==e?DOMPos.before(this.dom):DOMPos.after(this.dom,e==this.length)}split(e){let t=this.length-e;this.length=e;let i=new BlockWidgetView(this.widget,t,this.type);return i.breakAfter=this.breakAfter,i}get children(){return noChildren}sync(){this.dom&&this.widget.updateDOM(this.dom)||(this.dom&&this.prevWidget&&this.prevWidget.destroy(this.dom),this.prevWidget=null,this.setDOM(this.widget.toDOM(this.editorView)),this.dom.contentEditable="false");}get overrideDOMText(){return this.parent?this.parent.view.state.doc.slice(this.posAtStart,this.posAtEnd):Text.empty}domBoundsAround(){return null}become(e){return e instanceof BlockWidgetView&&e.type==this.type&&e.widget.constructor==this.widget.constructor&&(e.widget.eq(this.widget)||this.markDirty(true),this.dom&&!this.prevWidget&&(this.prevWidget=this.widget),this.widget=e.widget,this.length=e.length,this.breakAfter=e.breakAfter,true)}ignoreMutation(){return  true}ignoreEvent(e){return this.widget.ignoreEvent(e)}destroy(){super.destroy(),this.dom&&this.widget.destroy(this.dom);}}class ContentBuilder{constructor(e,t,i,n){this.doc=e,this.pos=t,this.end=i,this.disallowBlockEffectsFor=n,this.content=[],this.curLine=null,this.breakAtStart=0,this.pendingBuffer=0,this.atCursorPos=true,this.openStart=-1,this.openEnd=-1,this.text="",this.textOff=0,this.cursor=e.iter(),this.skip=t;}posCovered(){if(0==this.content.length)return !this.breakAtStart&&this.doc.lineAt(this.pos).from!=this.pos;let e=this.content[this.content.length-1];return !(e.breakAfter||e instanceof BlockWidgetView&&e.type==BlockType.WidgetBefore)}getLine(){return this.curLine||(this.content.push(this.curLine=new LineView),this.atCursorPos=true),this.curLine}flushBuffer(e){this.pendingBuffer&&(this.curLine.append(wrapMarks(new WidgetBufferView(-1),e),e.length),this.pendingBuffer=0);}addBlockWidget(e){this.flushBuffer([]),this.curLine=null,this.content.push(e);}finish(e){e?this.pendingBuffer=0:this.flushBuffer([]),this.posCovered()||this.getLine();}buildText(e,t,i){for(;e>0;){if(this.textOff==this.text.length){let{value:t,lineBreak:i,done:n}=this.cursor.next(this.skip);if(this.skip=0,n)throw new Error("Ran out of text content when drawing inline views");if(i){this.posCovered()||this.getLine(),this.content.length?this.content[this.content.length-1].breakAfter=1:this.breakAtStart=1,this.flushBuffer([]),this.curLine=null,e--;continue}this.text=t,this.textOff=0;}let n=Math.min(this.text.length-this.textOff,e,512);this.flushBuffer(t.slice(t.length-i)),this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff,this.textOff+n)),t),i),this.atCursorPos=true,this.textOff+=n,e-=n,i=0;}}span(e,t,i,n){this.buildText(t-e,i,n),this.pos=t,this.openStart<0&&(this.openStart=n);}point(e,t,i,n,o,r){if(this.disallowBlockEffectsFor[r]&&i instanceof PointDecoration){if(i.block)throw new RangeError("Block decorations may not be specified via plugins");if(t>this.doc.lineAt(this.pos).to)throw new RangeError("Decorations that replace line breaks may not be specified via plugins")}let s=t-e;if(i instanceof PointDecoration)if(i.block){let{type:e}=i;e!=BlockType.WidgetAfter||this.posCovered()||this.getLine(),this.addBlockWidget(new BlockWidgetView(i.widget||new NullWidget("div"),s,e));}else {let r=WidgetView.create(i.widget||new NullWidget("span"),s,s?0:i.startSide),a=this.atCursorPos&&!r.isEditable&&o<=n.length&&(e<t||i.startSide>0),l=!r.isEditable&&(e<t||i.startSide<=0),h=this.getLine();2!=this.pendingBuffer||a||(this.pendingBuffer=0),this.flushBuffer(n),a&&(h.append(wrapMarks(new WidgetBufferView(1),n),o),o=n.length+Math.max(0,o-n.length)),h.append(wrapMarks(r,n),o),this.atCursorPos=l,this.pendingBuffer=l?e<t?1:2:0;}else this.doc.lineAt(this.pos).from==this.pos&&this.getLine().addLineDeco(i);s&&(this.textOff+s<=this.text.length?this.textOff+=s:(this.skip+=s-(this.text.length-this.textOff),this.text="",this.textOff=0),this.pos=t),this.openStart<0&&(this.openStart=o);}static build(e,t,i,n,o){let r=new ContentBuilder(e,t,i,o);return r.openEnd=RangeSet.spans(n,t,i,r),r.openStart<0&&(r.openStart=r.openEnd),r.finish(r.openEnd),r}}function wrapMarks(e,t){for(let i of t)e=new MarkView(i,[e],e.length);return e}class NullWidget extends WidgetType{constructor(e){super(),this.tag=e;}eq(e){return e.tag==this.tag}toDOM(){return document.createElement(this.tag)}updateDOM(e){return e.nodeName.toLowerCase()==this.tag}}const clickAddsSelectionRange=Facet.define(),dragMovesSelection$1=Facet.define(),mouseSelectionStyle=Facet.define(),exceptionSink=Facet.define(),updateListener=Facet.define(),inputHandler=Facet.define(),perLineTextDirection=Facet.define({combine:e=>e.some(e=>e)}),nativeSelectionHidden=Facet.define({combine:e=>e.some(e=>e)});class ScrollTarget{constructor(e,t="nearest",i="nearest",n=5,o=5){this.range=e,this.y=t,this.x=i,this.yMargin=n,this.xMargin=o;}map(e){return e.empty?this:new ScrollTarget(this.range.map(e),this.y,this.x,this.yMargin,this.xMargin)}}const scrollIntoView=StateEffect.define({map:(e,t)=>e.map(t)});function logException(e,t,i){let n=e.facet(exceptionSink);n.length?n[0](t):window.onerror?window.onerror(String(t),i,void 0,void 0,t):i?console.error(i+":",t):console.error(t);}const editable=Facet.define({combine:e=>!e.length||e[0]});let nextPluginID=0;const viewPlugin=Facet.define();class ViewPlugin{constructor(e,t,i,n){this.id=e,this.create=t,this.domEventHandlers=i,this.extension=n(this);}static define(e,t){const{eventHandlers:i,provide:n,decorations:o}=t||{};return new ViewPlugin(nextPluginID++,e,i,e=>{let t=[viewPlugin.of(e)];return o&&t.push(decorations.of(t=>{let i=t.plugin(e);return i?o(i):Decoration.none})),n&&t.push(n(e)),t})}static fromClass(e,t){return ViewPlugin.define(t=>new e(t),t)}}class PluginInstance{constructor(e){this.spec=e,this.mustUpdate=null,this.value=null;}update(e){if(this.value){if(this.mustUpdate){let e=this.mustUpdate;if(this.mustUpdate=null,this.value.update)try{this.value.update(e);}catch(t){if(logException(e.state,t,"CodeMirror plugin crashed"),this.value.destroy)try{this.value.destroy();}catch(e){}this.deactivate();}}}else if(this.spec)try{this.value=this.spec.create(e);}catch(t){logException(e.state,t,"CodeMirror plugin crashed"),this.deactivate();}return this}destroy(e){var t;if(null===(t=this.value)||void 0===t?void 0:t.destroy)try{this.value.destroy();}catch(t){logException(e.state,t,"CodeMirror plugin crashed");}}deactivate(){this.spec=this.value=null;}}const editorAttributes=Facet.define(),contentAttributes=Facet.define(),decorations=Facet.define(),atomicRanges=Facet.define(),scrollMargins=Facet.define(),styleModule=Facet.define();class ChangedRange{constructor(e,t,i,n){this.fromA=e,this.toA=t,this.fromB=i,this.toB=n;}join(e){return new ChangedRange(Math.min(this.fromA,e.fromA),Math.max(this.toA,e.toA),Math.min(this.fromB,e.fromB),Math.max(this.toB,e.toB))}addToSet(e){let t=e.length,i=this;for(;t>0;t--){let n=e[t-1];if(!(n.fromA>i.toA)){if(n.toA<i.fromA)break;i=i.join(n),e.splice(t-1,1);}}return e.splice(t,0,i),e}static extendWithRanges(e,t){if(0==t.length)return e;let i=[];for(let n=0,o=0,r=0,s=0;;n++){let a=n==e.length?null:e[n],l=r-s,h=a?a.fromB:1e9;for(;o<t.length&&t[o]<h;){let e=t[o],n=t[o+1],r=Math.max(s,e),a=Math.min(h,n);if(r<=a&&new ChangedRange(r+l,a+l,r,a).addToSet(i),n>h)break;o+=2;}if(!a)return i;new ChangedRange(a.fromA,a.toA,a.fromB,a.toB).addToSet(i),r=a.toA,s=a.toB;}}}class ViewUpdate{constructor(e,t,i){this.view=e,this.state=t,this.transactions=i,this.flags=0,this.startState=e.state,this.changes=ChangeSet.empty(this.startState.doc.length);for(let e of i)this.changes=this.changes.compose(e.changes);let n=[];this.changes.iterChangedRanges((e,t,i,o)=>n.push(new ChangedRange(e,t,i,o))),this.changedRanges=n;let o=e.hasFocus;o!=e.inputState.notifiedFocused&&(e.inputState.notifiedFocused=o,this.flags|=1);}static create(e,t,i){return new ViewUpdate(e,t,i)}get viewportChanged(){return (4&this.flags)>0}get heightChanged(){return (2&this.flags)>0}get geometryChanged(){return this.docChanged||(10&this.flags)>0}get focusChanged(){return (1&this.flags)>0}get docChanged(){return !this.changes.empty}get selectionSet(){return this.transactions.some(e=>e.selection)}get empty(){return 0==this.flags&&0==this.transactions.length}}var Direction=function(e){return e[e.LTR=0]="LTR",e[e.RTL=1]="RTL",e}(Direction||(Direction={}));const LTR=Direction.LTR,RTL=Direction.RTL;function dec(e){let t=[];for(let i=0;i<e.length;i++)t.push(1<<+e[i]);return t}const LowTypes=dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"),ArabicTypes=dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"),Brackets=Object.create(null),BracketStack=[];for(let e of ["()","[]","{}"]){let t=e.charCodeAt(0),i=e.charCodeAt(1);Brackets[t]=i,Brackets[i]=-t;}function charType(e){return e<=247?LowTypes[e]:1424<=e&&e<=1524?2:1536<=e&&e<=1785?ArabicTypes[e-1536]:1774<=e&&e<=2220?4:8192<=e&&e<=8203?256:64336<=e&&e<=65023?4:8204==e?256:1}const BidiRE=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;class BidiSpan{constructor(e,t,i){this.from=e,this.to=t,this.level=i;}get dir(){return this.level%2?RTL:LTR}side(e,t){return this.dir==t==e?this.to:this.from}static find(e,t,i,n){let o=-1;for(let r=0;r<e.length;r++){let s=e[r];if(s.from<=t&&s.to>=t){if(s.level==i)return r;(o<0||(0!=n?n<0?s.from<t:s.to>t:e[o].level>s.level))&&(o=r);}}if(o<0)throw new RangeError("Index out of range");return o}}const types=[];function computeOrder(e,t){let i=e.length,n=t==LTR?1:2,o=t==LTR?2:1;if(!e||1==n&&!BidiRE.test(e))return trivialOrder(i);for(let t=0,o=n,r=n;t<i;t++){let i=charType(e.charCodeAt(t));512==i?i=o:8==i&&4==r&&(i=16),types[t]=4==i?2:i,7&i&&(r=i),o=i;}for(let e=0,t=n,o=n;e<i;e++){let n=types[e];if(128==n)e<i-1&&t==types[e+1]&&24&t?n=types[e]=t:types[e]=256;else if(64==n){let n=e+1;for(;n<i&&64==types[n];)n++;let r=e&&8==t||n<i&&8==types[n]?1==o?1:8:256;for(let t=e;t<n;t++)types[t]=r;e=n-1;}else 8==n&&1==o&&(types[e]=1);t=n,7&n&&(o=n);}for(let t,r,s,a=0,l=0,h=0;a<i;a++)if(r=Brackets[t=e.charCodeAt(a)])if(r<0){for(let e=l-3;e>=0;e-=3)if(BracketStack[e+1]==-r){let t=BracketStack[e+2],i=2&t?n:4&t?1&t?o:n:0;i&&(types[a]=types[BracketStack[e]]=i),l=e;break}}else {if(189==BracketStack.length)break;BracketStack[l++]=a,BracketStack[l++]=t,BracketStack[l++]=h;}else if(2==(s=types[a])||1==s){let e=s==n;h=e?0:1;for(let t=l-3;t>=0;t-=3){let i=BracketStack[t+2];if(2&i)break;if(e)BracketStack[t+2]|=2;else {if(4&i)break;BracketStack[t+2]|=4;}}}for(let e=0;e<i;e++)if(256==types[e]){let t=e+1;for(;t<i&&256==types[t];)t++;let o=1==(e?types[e-1]:n),r=o==(1==(t<i?types[t]:n))?o?1:2:n;for(let i=e;i<t;i++)types[i]=r;e=t-1;}let r=[];if(1==n)for(let e=0;e<i;){let t=e,n=1!=types[e++];for(;e<i&&n==(1!=types[e]);)e++;if(n)for(let i=e;i>t;){let e=i,n=2!=types[--i];for(;i>t&&n==(2!=types[i-1]);)i--;r.push(new BidiSpan(i,e,n?2:1));}else r.push(new BidiSpan(t,e,0));}else for(let e=0;e<i;){let t=e,n=2==types[e++];for(;e<i&&n==(2==types[e]);)e++;r.push(new BidiSpan(t,e,n?1:2));}return r}function trivialOrder(e){return [new BidiSpan(0,e,0)]}let movedOver="";function moveVisually(e,t,i,n,o){var r;let s=n.head-e.from,a=-1;if(0==s){if(!o||!e.length)return null;t[0].level!=i&&(s=t[0].side(false,i),a=0);}else if(s==e.length){if(o)return null;let e=t[t.length-1];e.level!=i&&(s=e.side(true,i),a=t.length-1);}a<0&&(a=BidiSpan.find(t,s,null!==(r=n.bidiLevel)&&void 0!==r?r:-1,n.assoc));let l=t[a];s==l.side(o,i)&&(s=(l=t[a+=o?1:-1]).side(!o,i));let h=o==(l.dir==i),c=findClusterBreak(e.text,s,h);if(movedOver=e.text.slice(Math.min(s,c),Math.max(s,c)),c!=l.side(o,i))return EditorSelection.cursor(c+e.from,h?-1:1,l.level);let d=a==(o?t.length-1:0)?null:t[a+(o?1:-1)];return d||l.level==i?d&&d.level<l.level?EditorSelection.cursor(d.side(!o,i)+e.from,o?1:-1,d.level):EditorSelection.cursor(c+e.from,o?-1:1,l.level):EditorSelection.cursor(o?e.to:e.from,o?-1:1,i)}const LineBreakPlaceholder="￿";class DOMReader{constructor(e,t){this.points=e,this.text="",this.lineSeparator=t.facet(EditorState.lineSeparator);}append(e){this.text+=e;}lineBreak(){this.text+=LineBreakPlaceholder;}readRange(e,t){if(!e)return this;let i=e.parentNode;for(let n=e;;){this.findPointBefore(i,n),this.readNode(n);let e=n.nextSibling;if(e==t)break;let o=ContentView.get(n),r=ContentView.get(e);(o&&r?o.breakAfter:(o?o.breakAfter:isBlockElement(n))||isBlockElement(e)&&("BR"!=n.nodeName||n.cmIgnore))&&this.lineBreak(),n=e;}return this.findPointBefore(i,t),this}readTextNode(e){let t=e.nodeValue;for(let i of this.points)i.node==e&&(i.pos=this.text.length+Math.min(i.offset,t.length));for(let i=0,n=this.lineSeparator?null:/\r\n?|\n/g;;){let o,r=-1,s=1;if(this.lineSeparator?(r=t.indexOf(this.lineSeparator,i),s=this.lineSeparator.length):(o=n.exec(t))&&(r=o.index,s=o[0].length),this.append(t.slice(i,r<0?t.length:r)),r<0)break;if(this.lineBreak(),s>1)for(let t of this.points)t.node==e&&t.pos>this.text.length&&(t.pos-=s-1);i=r+s;}}readNode(e){if(e.cmIgnore)return;let t=ContentView.get(e),i=t&&t.overrideDOMText;if(null!=i){this.findPointInside(e,i.length);for(let e=i.iter();!e.next().done;)e.lineBreak?this.lineBreak():this.append(e.value);}else 3==e.nodeType?this.readTextNode(e):"BR"==e.nodeName?e.nextSibling&&this.lineBreak():1==e.nodeType&&this.readRange(e.firstChild,null);}findPointBefore(e,t){for(let i of this.points)i.node==e&&e.childNodes[i.offset]==t&&(i.pos=this.text.length);}findPointInside(e,t){for(let i of this.points)(3==e.nodeType?i.node==e:e.contains(i.node))&&(i.pos=this.text.length+Math.min(t,i.offset));}}function isBlockElement(e){return 1==e.nodeType&&/^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(e.nodeName)}class DOMPoint{constructor(e,t){this.node=e,this.offset=t,this.pos=-1;}}class DocView extends ContentView{constructor(e){super(),this.view=e,this.compositionDeco=Decoration.none,this.decorations=[],this.dynamicDecorationMap=[],this.minWidth=0,this.minWidthFrom=0,this.minWidthTo=0,this.impreciseAnchor=null,this.impreciseHead=null,this.forceSelection=false,this.lastUpdate=Date.now(),this.setDOM(e.contentDOM),this.children=[new LineView],this.children[0].setParent(this),this.updateDeco(),this.updateInner([new ChangedRange(0,0,0,e.state.doc.length)],0);}get editorView(){return this.view}get length(){return this.view.state.doc.length}update(e){let t=e.changedRanges;this.minWidth>0&&t.length&&(t.every(({fromA:e,toA:t})=>t<this.minWidthFrom||e>this.minWidthTo)?(this.minWidthFrom=e.changes.mapPos(this.minWidthFrom,1),this.minWidthTo=e.changes.mapPos(this.minWidthTo,1)):this.minWidth=this.minWidthFrom=this.minWidthTo=0),this.view.inputState.composing<0?this.compositionDeco=Decoration.none:(e.transactions.length||this.dirty)&&(this.compositionDeco=computeCompositionDeco(this.view,e.changes)),(browser.ie||browser.chrome)&&!this.compositionDeco.size&&e&&e.state.doc.lines!=e.startState.doc.lines&&(this.forceSelection=true);let i=findChangedDeco(this.decorations,this.updateDeco(),e.changes);return t=ChangedRange.extendWithRanges(t,i),(0!=this.dirty||0!=t.length)&&(this.updateInner(t,e.startState.doc.length),e.transactions.length&&(this.lastUpdate=Date.now()),true)}updateInner(e,t){this.view.viewState.mustMeasureContent=true,this.updateChildren(e,t);let{observer:i}=this.view;i.ignore(()=>{this.dom.style.height=this.view.viewState.contentHeight+"px",this.dom.style.flexBasis=this.minWidth?this.minWidth+"px":"";let e=browser.chrome||browser.ios?{node:i.selectionRange.focusNode,written:false}:void 0;this.sync(e),this.dirty=0,e&&(e.written||i.selectionRange.focusNode!=e.node)&&(this.forceSelection=true),this.dom.style.height="";});let n=[];if(this.view.viewport.from||this.view.viewport.to<this.view.state.doc.length)for(let e of this.children)e instanceof BlockWidgetView&&e.widget instanceof BlockGapWidget&&n.push(e.dom);i.updateGaps(n);}updateChildren(e,t){let i=this.childCursor(t);for(let t=e.length-1;;t--){let n=t>=0?e[t]:null;if(!n)break;let{fromA:o,toA:r,fromB:s,toB:a}=n,{content:l,breakAtStart:h,openStart:c,openEnd:d}=ContentBuilder.build(this.view.state.doc,s,a,this.decorations,this.dynamicDecorationMap),{i:u,off:f}=i.findPos(r,1),{i:p,off:O}=i.findPos(o,-1);replaceRange(this,p,O,u,f,l,h,c,d);}}updateSelection(e=false,t=false){if(!e&&this.view.observer.selectionRange.focusNode||this.view.observer.readSelectionRange(),!t&&!this.mayControlSelection())return;let i=this.forceSelection;this.forceSelection=false;let n=this.view.state.selection.main,o=this.domAtPos(n.anchor),r=n.empty?o:this.domAtPos(n.head);if(browser.gecko&&n.empty&&betweenUneditable(o)){let e=document.createTextNode("");this.view.observer.ignore(()=>o.node.insertBefore(e,o.node.childNodes[o.offset]||null)),o=r=new DOMPos(e,0),i=true;}let s=this.view.observer.selectionRange;!i&&s.focusNode&&isEquivalentPosition(o.node,o.offset,s.anchorNode,s.anchorOffset)&&isEquivalentPosition(r.node,r.offset,s.focusNode,s.focusOffset)||(this.view.observer.ignore(()=>{browser.android&&browser.chrome&&this.dom.contains(s.focusNode)&&inUneditable(s.focusNode,this.dom)&&(this.dom.blur(),this.dom.focus({preventScroll:true}));let e=getSelection(this.view.root);if(e)if(n.empty){if(browser.gecko){let e=nextToUneditable(o.node,o.offset);if(e&&3!=e){let t=nearbyTextNode(o.node,o.offset,1==e?1:-1);t&&(o=new DOMPos(t,1==e?0:t.nodeValue.length));}}e.collapse(o.node,o.offset),null!=n.bidiLevel&&null!=s.cursorBidiLevel&&(s.cursorBidiLevel=n.bidiLevel);}else if(e.extend){e.collapse(o.node,o.offset);try{e.extend(r.node,r.offset);}catch(e){}}else {let t=document.createRange();n.anchor>n.head&&([o,r]=[r,o]),t.setEnd(r.node,r.offset),t.setStart(o.node,o.offset),e.removeAllRanges(),e.addRange(t);}}),this.view.observer.setSelectionRange(o,r)),this.impreciseAnchor=o.precise?null:new DOMPos(s.anchorNode,s.anchorOffset),this.impreciseHead=r.precise?null:new DOMPos(s.focusNode,s.focusOffset);}enforceCursorAssoc(){if(this.compositionDeco.size)return;let{view:e}=this,t=e.state.selection.main,i=getSelection(e.root),{anchorNode:n,anchorOffset:o}=e.observer.selectionRange;if(!(i&&t.empty&&t.assoc&&i.modify))return;let r=LineView.find(this,t.head);if(!r)return;let s=r.posAtStart;if(t.head==s||t.head==s+r.length)return;let a=this.coordsAt(t.head,-1),l=this.coordsAt(t.head,1);if(!a||!l||a.bottom>l.top)return;let h=this.domAtPos(t.head+t.assoc);i.collapse(h.node,h.offset),i.modify("move",t.assoc<0?"forward":"backward","lineboundary"),e.observer.readSelectionRange();let c=e.observer.selectionRange;e.docView.posFromDOM(c.anchorNode,c.anchorOffset)!=t.from&&i.collapse(n,o);}mayControlSelection(){let e=this.view.root.activeElement;return e==this.dom||hasSelection(this.dom,this.view.observer.selectionRange)&&!(e&&this.dom.contains(e))}nearest(e){for(let t=e;t;){let e=ContentView.get(t);if(e&&e.rootView==this)return e;t=t.parentNode;}return null}posFromDOM(e,t){let i=this.nearest(e);if(!i)throw new RangeError("Trying to find position for a DOM position outside of the document");return i.localPosFromDOM(e,t)+i.posAtStart}domAtPos(e){let{i:t,off:i}=this.childCursor().findPos(e,-1);for(;t<this.children.length-1;){let e=this.children[t];if(i<e.length||e instanceof LineView)break;t++,i=0;}return this.children[t].domAtPos(i)}coordsAt(e,t){for(let i=this.length,n=this.children.length-1;;n--){let o=this.children[n],r=i-o.breakAfter-o.length;if(e>r||e==r&&o.type!=BlockType.WidgetBefore&&o.type!=BlockType.WidgetAfter&&(!n||2==t||this.children[n-1].breakAfter||this.children[n-1].type==BlockType.WidgetBefore&&t>-2))return o.coordsAt(e-r,t);i=r;}}measureVisibleLineHeights(e){let t=[],{from:i,to:n}=e,o=this.view.contentDOM.clientWidth,r=o>Math.max(this.view.scrollDOM.clientWidth,this.minWidth)+1,s=-1,a=this.view.textDirection==Direction.LTR;for(let e=0,l=0;l<this.children.length;l++){let h=this.children[l],c=e+h.length;if(c>n)break;if(e>=i){let i=h.dom.getBoundingClientRect();if(t.push(i.height),r){let t=h.dom.lastChild,n=t?clientRectsFor(t):[];if(n.length){let t=n[n.length-1],r=a?t.right-i.left:i.right-t.left;r>s&&(s=r,this.minWidth=o,this.minWidthFrom=e,this.minWidthTo=c);}}}e=c+h.breakAfter;}return t}textDirectionAt(e){let{i:t}=this.childPos(e,1);return "rtl"==getComputedStyle(this.children[t].dom).direction?Direction.RTL:Direction.LTR}measureTextSize(){for(let e of this.children)if(e instanceof LineView){let t=e.measureTextSize();if(t)return t}let e,t,i=document.createElement("div");return i.className="cm-line",i.style.width="99999px",i.textContent="abc def ghi jkl mno pqr stu",this.view.observer.ignore(()=>{this.dom.appendChild(i);let n=clientRectsFor(i.firstChild)[0];e=i.getBoundingClientRect().height,t=n?n.width/27:7,i.remove();}),{lineHeight:e,charWidth:t}}childCursor(e=this.length){let t=this.children.length;return t&&(e-=this.children[--t].length),new ChildCursor(this.children,e,t)}computeBlockGapDeco(){let e=[],t=this.view.viewState;for(let i=0,n=0;;n++){let o=n==t.viewports.length?null:t.viewports[n],r=o?o.from-1:this.length;if(r>i){let n=t.lineBlockAt(r).bottom-t.lineBlockAt(i).top;e.push(Decoration.replace({widget:new BlockGapWidget(n),block:true,inclusive:true,isBlockGap:true}).range(i,r));}if(!o)break;i=o.to+1;}return Decoration.set(e)}updateDeco(){let e=this.view.state.facet(decorations).map((e,t)=>{return (this.dynamicDecorationMap[t]="function"==typeof e)?e(this.view):e});for(let t=e.length;t<e.length+3;t++)this.dynamicDecorationMap[t]=false;return this.decorations=[...e,this.compositionDeco,this.computeBlockGapDeco(),this.view.viewState.lineGapDeco]}scrollIntoView(e){let t,{range:i}=e,n=this.coordsAt(i.head,i.empty?i.assoc:i.head>i.anchor?-1:1);if(!n)return;!i.empty&&(t=this.coordsAt(i.anchor,i.anchor>i.head?-1:1))&&(n={left:Math.min(n.left,t.left),top:Math.min(n.top,t.top),right:Math.max(n.right,t.right),bottom:Math.max(n.bottom,t.bottom)});let o=0,r=0,s=0,a=0;for(let e of this.view.state.facet(scrollMargins).map(e=>e(this.view)))if(e){let{left:t,right:i,top:n,bottom:l}=e;null!=t&&(o=Math.max(o,t)),null!=i&&(r=Math.max(r,i)),null!=n&&(s=Math.max(s,n)),null!=l&&(a=Math.max(a,l));}let l={left:n.left-o,top:n.top-s,right:n.right+r,bottom:n.bottom+a};scrollRectIntoView(this.view.scrollDOM,l,i.head<i.anchor?-1:1,e.x,e.y,e.xMargin,e.yMargin,this.view.textDirection==Direction.LTR);}}function betweenUneditable(e){return 1==e.node.nodeType&&e.node.firstChild&&(0==e.offset||"false"==e.node.childNodes[e.offset-1].contentEditable)&&(e.offset==e.node.childNodes.length||"false"==e.node.childNodes[e.offset].contentEditable)}class BlockGapWidget extends WidgetType{constructor(e){super(),this.height=e;}toDOM(){let e=document.createElement("div");return this.updateDOM(e),e}eq(e){return e.height==this.height}updateDOM(e){return e.style.height=this.height+"px",true}get estimatedHeight(){return this.height}}function compositionSurroundingNode(e){let t=e.observer.selectionRange,i=t.focusNode&&nearbyTextNode(t.focusNode,t.focusOffset,0);if(!i)return null;let n=e.docView.nearest(i);if(!n)return null;if(n instanceof LineView){let e=i;for(;e.parentNode!=n.dom;)e=e.parentNode;let t=e.previousSibling;for(;t&&!ContentView.get(t);)t=t.previousSibling;let o=t?ContentView.get(t).posAtEnd:n.posAtStart;return {from:o,to:o,node:e,text:i}}{for(;;){let{parent:e}=n;if(!e)return null;if(e instanceof LineView)break;n=e;}let e=n.posAtStart;return {from:e,to:e+n.length,node:n.dom,text:i}}}function computeCompositionDeco(e,t){let i=compositionSurroundingNode(e);if(!i)return Decoration.none;let{from:n,to:o,node:r,text:s}=i,a=t.mapPos(n,1),l=Math.max(a,t.mapPos(o,-1)),{state:h}=e,c=3==r.nodeType?r.nodeValue:new DOMReader([],h).readRange(r.firstChild,null).text;if(l-a<c.length)if(h.doc.sliceString(a,Math.min(h.doc.length,a+c.length),LineBreakPlaceholder)==c)l=a+c.length;else {if(h.doc.sliceString(Math.max(0,l-c.length),l,LineBreakPlaceholder)!=c)return Decoration.none;a=l-c.length;}else if(h.doc.sliceString(a,l,LineBreakPlaceholder)!=c)return Decoration.none;let d=ContentView.get(r);return d instanceof CompositionView?d=d.widget.topView:d&&(d.parent=null),Decoration.set(Decoration.replace({widget:new CompositionWidget(r,s,d),inclusive:true}).range(a,l))}class CompositionWidget extends WidgetType{constructor(e,t,i){super(),this.top=e,this.text=t,this.topView=i;}eq(e){return this.top==e.top&&this.text==e.text}toDOM(){return this.top}ignoreEvent(){return  false}get customView(){return CompositionView}}function nearbyTextNode(e,t,i){for(;;){if(3==e.nodeType)return e;if(1==e.nodeType&&t>0&&i<=0)t=maxOffset(e=e.childNodes[t-1]);else {if(!(1==e.nodeType&&t<e.childNodes.length&&i>=0))return null;e=e.childNodes[t],t=0;}}}function nextToUneditable(e,t){return 1!=e.nodeType?0:(t&&"false"==e.childNodes[t-1].contentEditable?1:0)|(t<e.childNodes.length&&"false"==e.childNodes[t].contentEditable?2:0)}class DecorationComparator$1{constructor(){this.changes=[];}compareRange(e,t){addRange(e,t,this.changes);}comparePoint(e,t){addRange(e,t,this.changes);}}function findChangedDeco(e,t,i){let n=new DecorationComparator$1;return RangeSet.compare(e,t,i,n),n.changes}function inUneditable(e,t){for(let i=e;i&&i!=t;i=i.assignedSlot||i.parentNode)if(1==i.nodeType&&"false"==i.contentEditable)return  true;return  false}function groupAt(e,t,i=1){let n=e.charCategorizer(t),o=e.doc.lineAt(t),r=t-o.from;if(0==o.length)return EditorSelection.cursor(t);0==r?i=1:r==o.length&&(i=-1);let s=r,a=r;i<0?s=findClusterBreak(o.text,r,false):a=findClusterBreak(o.text,r);let l=n(o.text.slice(s,a));for(;s>0;){let e=findClusterBreak(o.text,s,false);if(n(o.text.slice(e,s))!=l)break;s=e;}for(;a<o.length;){let e=findClusterBreak(o.text,a);if(n(o.text.slice(a,e))!=l)break;a=e;}return EditorSelection.range(s+o.from,a+o.from)}function getdx(e,t){return t.left>e?t.left-e:Math.max(0,e-t.right)}function getdy(e,t){return t.top>e?t.top-e:Math.max(0,e-t.bottom)}function yOverlap(e,t){return e.top<t.bottom-1&&e.bottom>t.top+1}function upTop(e,t){return t<e.top?{top:t,left:e.left,right:e.right,bottom:e.bottom}:e}function upBot(e,t){return t>e.bottom?{top:e.top,left:e.left,right:e.right,bottom:t}:e}function domPosAtCoords(e,t,i){let n,o,r,s,a,l,h,c,d=false;for(let u=e.firstChild;u;u=u.nextSibling){let e=clientRectsFor(u);for(let f=0;f<e.length;f++){let p=e[f];o&&yOverlap(o,p)&&(p=upTop(upBot(p,o.bottom),o.top));let O=getdx(t,p),g=getdy(i,p);if(0==O&&0==g)return 3==u.nodeType?domPosInText(u,t,i):domPosAtCoords(u,t,i);(!n||s>g||s==g&&r>O)&&(n=u,o=p,r=O,s=g,d=!O||(O>0?f<e.length-1:f>0)),0==O?i>p.bottom&&(!h||h.bottom<p.bottom)?(a=u,h=p):i<p.top&&(!c||c.top>p.top)&&(l=u,c=p):h&&yOverlap(h,p)?h=upBot(h,p.bottom):c&&yOverlap(c,p)&&(c=upTop(c,p.top));}}if(h&&h.bottom>=i?(n=a,o=h):c&&c.top<=i&&(n=l,o=c),!n)return {node:e,offset:0};let u=Math.max(o.left,Math.min(o.right,t));return 3==n.nodeType?domPosInText(n,u,i):d&&"false"!=n.contentEditable?domPosAtCoords(n,u,i):{node:e,offset:Array.prototype.indexOf.call(e.childNodes,n)+(t>=(o.left+o.right)/2?1:0)}}function domPosInText(e,t,i){let n=e.nodeValue.length,o=-1,r=1e9,s=0;for(let a=0;a<n;a++){let n=textRange(e,a,a+1).getClientRects();for(let l=0;l<n.length;l++){let h=n[l];if(h.top==h.bottom)continue;s||(s=t-h.left);let c=(h.top>i?h.top-i:i-h.bottom)-1;if(h.left-1<=t&&h.right+1>=t&&c<r){let i=t>=(h.left+h.right)/2,n=i;if(browser.chrome||browser.gecko){textRange(e,a).getBoundingClientRect().left==h.right&&(n=!i);}if(c<=0)return {node:e,offset:a+(n?1:0)};o=a+(n?1:0),r=c;}}}return {node:e,offset:o>-1?o:s>0?e.nodeValue.length:0}}function posAtCoords(e,{x:t,y:i},n,o=-1){var r;let s,a=e.contentDOM.getBoundingClientRect(),l=a.top+e.viewState.paddingTop,{docHeight:h}=e.viewState,c=i-l;if(c<0)return 0;if(c>h)return e.state.doc.length;for(let t=e.defaultLineHeight/2,i=false;(s=e.elementAtHeight(c)).type!=BlockType.Text;)for(;!((c=o>0?s.bottom+t:s.top-t)>=0&&c<=h);){if(i)return n?null:0;i=true,o=-o;}i=l+c;let d=s.from;if(d<e.viewport.from)return 0==e.viewport.from?0:n?null:posAtCoordsImprecise(e,a,s,t,i);if(d>e.viewport.to)return e.viewport.to==e.state.doc.length?e.state.doc.length:n?null:posAtCoordsImprecise(e,a,s,t,i);let u=e.dom.ownerDocument,f=e.root.elementFromPoint?e.root:u,p=f.elementFromPoint(t,i);p&&!e.contentDOM.contains(p)&&(p=null),p||(t=Math.max(a.left+1,Math.min(a.right-1,t)),(p=f.elementFromPoint(t,i))&&!e.contentDOM.contains(p)&&(p=null));let O,g=-1;if(p&&0!=(null===(r=e.docView.nearest(p))||void 0===r?void 0:r.isEditable))if(u.caretPositionFromPoint){let e=u.caretPositionFromPoint(t,i);e&&({offsetNode:O,offset:g}=e);}else if(u.caretRangeFromPoint){let n=u.caretRangeFromPoint(t,i);n&&(({startContainer:O,startOffset:g}=n),(!e.contentDOM.contains(O)||browser.safari&&isSuspiciousSafariCaretResult(O,g,t)||browser.chrome&&isSuspiciousChromeCaretResult(O,g,t))&&(O=void 0));}if(!O||!e.docView.dom.contains(O)){let n=LineView.find(e.docView,d);if(!n)return c>s.top+s.height/2?s.to:s.from;({node:O,offset:g}=domPosAtCoords(n.dom,t,i));}return e.docView.posFromDOM(O,g)}function posAtCoordsImprecise(e,t,i,n,o){let r=Math.round((n-t.left)*e.defaultCharacterWidth);if(e.lineWrapping&&i.height>1.5*e.defaultLineHeight){r+=Math.floor((o-i.top)/e.defaultLineHeight)*e.viewState.heightOracle.lineLength;}let s=e.state.sliceDoc(i.from,i.to);return i.from+findColumn(s,r,e.state.tabSize)}function isSuspiciousSafariCaretResult(e,t,i){let n;if(3!=e.nodeType||t!=(n=e.nodeValue.length))return  false;for(let t=e.nextSibling;t;t=t.nextSibling)if(1!=t.nodeType||"BR"!=t.nodeName)return  false;return textRange(e,n-1,n).getBoundingClientRect().left>i}function isSuspiciousChromeCaretResult(e,t,i){if(0!=t)return  false;for(let t=e;;){let e=t.parentNode;if(!e||1!=e.nodeType||e.firstChild!=t)return  false;if(e.classList.contains("cm-line"))break;t=e;}return i-(1==e.nodeType?e.getBoundingClientRect():textRange(e,0,Math.max(e.nodeValue.length,1)).getBoundingClientRect()).left>5}function moveToLineBoundary(e,t,i,n){let o=e.state.doc.lineAt(t.head),r=n&&e.lineWrapping?e.coordsAtPos(t.assoc<0&&t.head>o.from?t.head-1:t.head):null;if(r){let t=e.dom.getBoundingClientRect(),n=e.textDirectionAt(o.from),s=e.posAtCoords({x:i==(n==Direction.LTR)?t.right-1:t.left+1,y:(r.top+r.bottom)/2});if(null!=s)return EditorSelection.cursor(s,i?-1:1)}let s=LineView.find(e.docView,t.head),a=s?i?s.posAtEnd:s.posAtStart:i?o.to:o.from;return EditorSelection.cursor(a,i?-1:1)}function moveByChar(e,t,i,n){let o=e.state.doc.lineAt(t.head),r=e.bidiSpans(o),s=e.textDirectionAt(o.from);for(let a=t,l=null;;){let t=moveVisually(o,r,s,a,i),h=movedOver;if(!t){if(o.number==(i?e.state.doc.lines:1))return a;h="\n",o=e.state.doc.line(o.number+(i?1:-1)),r=e.bidiSpans(o),t=EditorSelection.cursor(i?o.from:o.to);}if(l){if(!l(h))return a}else {if(!n)return t;l=n(h);}a=t;}}function byGroup(e,t,i){let n=e.state.charCategorizer(t),o=n(i);return e=>{let t=n(e);return o==CharCategory.Space&&(o=t),o==t}}function moveVertically(e,t,i,n){let o=t.head,r=i?1:-1;if(o==(i?e.state.doc.length:0))return EditorSelection.cursor(o,t.assoc);let s,a=t.goalColumn,l=e.contentDOM.getBoundingClientRect(),h=e.coordsAtPos(o),c=e.documentTop;if(h)null==a&&(a=h.left-l.left),s=r<0?h.top:h.bottom;else {let t=e.viewState.lineBlockAt(o);null==a&&(a=Math.min(l.right-l.left,e.defaultCharacterWidth*(o-t.from))),s=(r<0?t.top:t.bottom)+c;}let d=l.left+a,u=null!==n&&void 0!==n?n:e.defaultLineHeight>>1;for(let i=0;;i+=10){let n=s+(u+i)*r,h=posAtCoords(e,{x:d,y:n},false,r);if(n<l.top||n>l.bottom||(r<0?h<o:h>o))return EditorSelection.cursor(h,t.assoc,void 0,a)}}function skipAtoms(e,t,i){let n=e.state.facet(atomicRanges).map(t=>t(e));for(;;){let e=false;for(let o of n)o.between(i.from-1,i.from+1,(n,o,r)=>{i.from>n&&i.from<o&&(i=t.head>i.from?EditorSelection.cursor(n,1):EditorSelection.cursor(o,-1),e=true);});if(!e)return i}}class InputState{constructor(e){this.lastKeyCode=0,this.lastKeyTime=0,this.lastTouchTime=0,this.lastFocusTime=0,this.lastScrollTop=0,this.lastScrollLeft=0,this.chromeScrollHack=-1,this.pendingIOSKey=void 0,this.lastSelectionOrigin=null,this.lastSelectionTime=0,this.lastEscPress=0,this.lastContextMenu=0,this.scrollHandlers=[],this.registeredEvents=[],this.customHandlers=[],this.composing=-1,this.compositionFirstChange=null,this.compositionEndedAt=0,this.mouseSelection=null;for(let t in handlers){let i=handlers[t];e.contentDOM.addEventListener(t,n=>{eventBelongsToEditor(e,n)&&!this.ignoreDuringComposition(n)&&("keydown"==t&&this.keydown(e,n)||(this.mustFlushObserver(n)&&e.observer.forceFlush(),this.runCustomHandlers(t,e,n)?n.preventDefault():i(e,n)));},handlerOptions[t]),this.registeredEvents.push(t);}browser.chrome&&102==browser.chrome_version&&e.scrollDOM.addEventListener("wheel",()=>{this.chromeScrollHack<0?e.contentDOM.style.pointerEvents="none":window.clearTimeout(this.chromeScrollHack),this.chromeScrollHack=setTimeout(()=>{this.chromeScrollHack=-1,e.contentDOM.style.pointerEvents="";},100);},{passive:true}),this.notifiedFocused=e.hasFocus,browser.safari&&e.contentDOM.addEventListener("input",()=>null);}setSelectionOrigin(e){this.lastSelectionOrigin=e,this.lastSelectionTime=Date.now();}ensureHandlers(e,t){var i;let n;this.customHandlers=[];for(let o of t)if(n=null===(i=o.update(e).spec)||void 0===i?void 0:i.domEventHandlers){this.customHandlers.push({plugin:o.value,handlers:n});for(let t in n)this.registeredEvents.indexOf(t)<0&&"scroll"!=t&&(this.registeredEvents.push(t),e.contentDOM.addEventListener(t,i=>{eventBelongsToEditor(e,i)&&this.runCustomHandlers(t,e,i)&&i.preventDefault();}));}}runCustomHandlers(e,t,i){for(let n of this.customHandlers){let o=n.handlers[e];if(o)try{if(o.call(n.plugin,i,t)||i.defaultPrevented)return !0}catch(e){logException(t.state,e);}}return  false}runScrollHandlers(e,t){this.lastScrollTop=e.scrollDOM.scrollTop,this.lastScrollLeft=e.scrollDOM.scrollLeft;for(let i of this.customHandlers){let n=i.handlers.scroll;if(n)try{n.call(i.plugin,t,e);}catch(t){logException(e.state,t);}}}keydown(e,t){if(this.lastKeyCode=t.keyCode,this.lastKeyTime=Date.now(),9==t.keyCode&&Date.now()<this.lastEscPress+2e3)return  true;if(browser.android&&browser.chrome&&!t.synthetic&&(13==t.keyCode||8==t.keyCode))return e.observer.delayAndroidKey(t.key,t.keyCode),true;let i;return !(!browser.ios||t.synthetic||t.altKey||t.metaKey||!((i=PendingKeys.find(e=>e.keyCode==t.keyCode))&&!t.ctrlKey||EmacsyPendingKeys.indexOf(t.key)>-1&&t.ctrlKey&&!t.shiftKey))&&(this.pendingIOSKey=i||t,setTimeout(()=>this.flushIOSKey(e),250),true)}flushIOSKey(e){let t=this.pendingIOSKey;return !!t&&(this.pendingIOSKey=void 0,dispatchKey(e.contentDOM,t.key,t.keyCode))}ignoreDuringComposition(e){return !!/^key/.test(e.type)&&(this.composing>0||!!(browser.safari&&!browser.ios&&Date.now()-this.compositionEndedAt<100)&&(this.compositionEndedAt=0,true))}mustFlushObserver(e){return "keydown"==e.type&&229!=e.keyCode}startMouseSelection(e){this.mouseSelection&&this.mouseSelection.destroy(),this.mouseSelection=e;}update(e){this.mouseSelection&&this.mouseSelection.update(e),e.transactions.length&&(this.lastKeyCode=this.lastSelectionTime=0);}destroy(){this.mouseSelection&&this.mouseSelection.destroy();}}const PendingKeys=[{key:"Backspace",keyCode:8,inputType:"deleteContentBackward"},{key:"Enter",keyCode:13,inputType:"insertParagraph"},{key:"Delete",keyCode:46,inputType:"deleteContentForward"}],EmacsyPendingKeys="dthko",modifierCodes=[16,17,18,20,91,92,224,225];class MouseSelection{constructor(e,t,i,n){this.view=e,this.style=i,this.mustSelect=n,this.lastEvent=t;let o=e.contentDOM.ownerDocument;o.addEventListener("mousemove",this.move=this.move.bind(this)),o.addEventListener("mouseup",this.up=this.up.bind(this)),this.extend=t.shiftKey,this.multiple=e.state.facet(EditorState.allowMultipleSelections)&&addsSelectionRange(e,t),this.dragMove=dragMovesSelection(e,t),this.dragging=!(!isInPrimarySelection(e,t)||1!=getClickType(t))&&null,false===this.dragging&&(t.preventDefault(),this.select(t));}move(e){if(0==e.buttons)return this.destroy();false===this.dragging&&this.select(this.lastEvent=e);}up(e){null==this.dragging&&this.select(this.lastEvent),this.dragging||e.preventDefault(),this.destroy();}destroy(){let e=this.view.contentDOM.ownerDocument;e.removeEventListener("mousemove",this.move),e.removeEventListener("mouseup",this.up),this.view.inputState.mouseSelection=null;}select(e){let t=this.style.get(e,this.extend,this.multiple);!this.mustSelect&&t.eq(this.view.state.selection)&&t.main.assoc==this.view.state.selection.main.assoc||this.view.dispatch({selection:t,userEvent:"select.pointer",scrollIntoView:true}),this.mustSelect=false;}update(e){e.docChanged&&this.dragging&&(this.dragging=this.dragging.map(e.changes)),this.style.update(e)&&setTimeout(()=>this.select(this.lastEvent),20);}}function addsSelectionRange(e,t){let i=e.state.facet(clickAddsSelectionRange);return i.length?i[0](t):browser.mac?t.metaKey:t.ctrlKey}function dragMovesSelection(e,t){let i=e.state.facet(dragMovesSelection$1);return i.length?i[0](t):browser.mac?!t.altKey:!t.ctrlKey}function isInPrimarySelection(e,t){let{main:i}=e.state.selection;if(i.empty)return  false;let n=getSelection(e.root);if(!n||0==n.rangeCount)return  true;let o=n.getRangeAt(0).getClientRects();for(let e=0;e<o.length;e++){let i=o[e];if(i.left<=t.clientX&&i.right>=t.clientX&&i.top<=t.clientY&&i.bottom>=t.clientY)return  true}return  false}function eventBelongsToEditor(e,t){if(!t.bubbles)return  true;if(t.defaultPrevented)return  false;for(let i,n=t.target;n!=e.contentDOM;n=n.parentNode)if(!n||11==n.nodeType||(i=ContentView.get(n))&&i.ignoreEvent(t))return  false;return  true}const handlers=Object.create(null),handlerOptions=Object.create(null),brokenClipboardAPI=browser.ie&&browser.ie_version<15||browser.ios&&browser.webkit_version<604;function capturePaste(e){let t=e.dom.parentNode;if(!t)return;let i=t.appendChild(document.createElement("textarea"));i.style.cssText="position: fixed; left: -10000px; top: 10px",i.focus(),setTimeout(()=>{e.focus(),i.remove(),doPaste(e,i.value);},50);}function doPaste(e,t){let i,{state:n}=e,o=1,r=n.toText(t),s=r.lines==n.selection.ranges.length;if(null!=lastLinewiseCopy&&n.selection.ranges.every(e=>e.empty)&&lastLinewiseCopy==r.toString()){let e=-1;i=n.changeByRange(i=>{let a=n.doc.lineAt(i.from);if(a.from==e)return {range:i};e=a.from;let l=n.toText((s?r.line(o++).text:t)+n.lineBreak);return {changes:{from:a.from,insert:l},range:EditorSelection.cursor(i.from+l.length)}});}else i=s?n.changeByRange(e=>{let t=r.line(o++);return {changes:{from:e.from,to:e.to,insert:t.text},range:EditorSelection.cursor(e.from+t.length)}}):n.replaceSelection(r);e.dispatch(i,{userEvent:"input.paste",scrollIntoView:true});}function rangeForClick(e,t,i,n){if(1==n)return EditorSelection.cursor(t,i);if(2==n)return groupAt(e.state,t,i);{let i=LineView.find(e.docView,t),n=e.state.doc.lineAt(i?i.posAtEnd:t),o=i?i.posAtStart:n.from,r=i?i.posAtEnd:n.to;return r<e.state.doc.length&&r==n.to&&r++,EditorSelection.range(o,r)}}handlers.keydown=((e,t)=>{e.inputState.setSelectionOrigin("select"),27==t.keyCode?e.inputState.lastEscPress=Date.now():modifierCodes.indexOf(t.keyCode)<0&&(e.inputState.lastEscPress=0);}),handlers.touchstart=((e,t)=>{e.inputState.lastTouchTime=Date.now(),e.inputState.setSelectionOrigin("select.pointer");}),handlers.touchmove=(e=>{e.inputState.setSelectionOrigin("select.pointer");}),handlerOptions.touchstart=handlerOptions.touchmove={passive:true},handlers.mousedown=((e,t)=>{if(e.observer.flush(),e.inputState.lastTouchTime>Date.now()-2e3)return;let i=null;for(let n of e.state.facet(mouseSelectionStyle))if(i=n(e,t))break;if(i||0!=t.button||(i=basicMouseSelection(e,t)),i){let n=e.root.activeElement!=e.contentDOM;n&&e.observer.ignore(()=>focusPreventScroll(e.contentDOM)),e.inputState.startMouseSelection(new MouseSelection(e,t,i,n));}});let insideY=(e,t)=>e>=t.top&&e<=t.bottom,inside=(e,t,i)=>insideY(t,i)&&e>=i.left&&e<=i.right;function findPositionSide(e,t,i,n){let o=LineView.find(e.docView,t);if(!o)return 1;let r=t-o.posAtStart;if(0==r)return 1;if(r==o.length)return  -1;let s=o.coordsAt(r,-1);if(s&&inside(i,n,s))return  -1;let a=o.coordsAt(r,1);return a&&inside(i,n,a)?1:s&&insideY(n,s)?-1:1}function queryPos(e,t){let i=e.posAtCoords({x:t.clientX,y:t.clientY},false);return {pos:i,bias:findPositionSide(e,i,t.clientX,t.clientY)}}const BadMouseDetail=browser.ie&&browser.ie_version<=11;let lastMouseDown=null,lastMouseDownCount=0,lastMouseDownTime=0;function getClickType(e){if(!BadMouseDetail)return e.detail;let t=lastMouseDown,i=lastMouseDownTime;return lastMouseDown=e,lastMouseDownTime=Date.now(),lastMouseDownCount=!t||i>Date.now()-400&&Math.abs(t.clientX-e.clientX)<2&&Math.abs(t.clientY-e.clientY)<2?(lastMouseDownCount+1)%3:1}function basicMouseSelection(e,t){let i=queryPos(e,t),n=getClickType(t),o=e.state.selection,r=i,s=t;return {update(e){e.docChanged&&(i.pos=e.changes.mapPos(i.pos),o=o.map(e.changes),s=null);},get(t,a,l){let h;s&&t.clientX==s.clientX&&t.clientY==s.clientY?h=r:(h=r=queryPos(e,t),s=t);let c=rangeForClick(e,h.pos,h.bias,n);if(i.pos!=h.pos&&!a){let t=rangeForClick(e,i.pos,i.bias,n),o=Math.min(t.from,c.from),r=Math.max(t.to,c.to);c=o<c.from?EditorSelection.range(o,r):EditorSelection.range(r,o);}return a?o.replaceRange(o.main.extend(c.from,c.to)):l&&o.ranges.length>1&&o.ranges.some(e=>e.eq(c))?removeRange(o,c):l?o.addRange(c):EditorSelection.create([c])}}}function removeRange(e,t){for(let i=0;;i++)if(e.ranges[i].eq(t))return EditorSelection.create(e.ranges.slice(0,i).concat(e.ranges.slice(i+1)),e.mainIndex==i?0:e.mainIndex-(e.mainIndex>i?1:0))}function dropText(e,t,i,n){if(!i)return;let o=e.posAtCoords({x:t.clientX,y:t.clientY},false);t.preventDefault();let{mouseSelection:r}=e.inputState,s=n&&r&&r.dragging&&r.dragMove?{from:r.dragging.from,to:r.dragging.to}:null,a={from:o,insert:i},l=e.state.changes(s?[s,a]:a);e.focus(),e.dispatch({changes:l,selection:{anchor:l.mapPos(o,-1),head:l.mapPos(o,1)},userEvent:s?"move.drop":"input.drop"});}function captureCopy(e,t){let i=e.dom.parentNode;if(!i)return;let n=i.appendChild(document.createElement("textarea"));n.style.cssText="position: fixed; left: -10000px; top: 10px",n.value=t,n.focus(),n.selectionEnd=t.length,n.selectionStart=0,setTimeout(()=>{n.remove(),e.focus();},50);}function copiedRange(e){let t=[],i=[],n=false;for(let n of e.selection.ranges)n.empty||(t.push(e.sliceDoc(n.from,n.to)),i.push(n));if(!t.length){let o=-1;for(let{from:n}of e.selection.ranges){let r=e.doc.lineAt(n);r.number>o&&(t.push(r.text),i.push({from:r.from,to:Math.min(e.doc.length,r.to+1)})),o=r.number;}n=true;}return {text:t.join(e.lineBreak),ranges:i,linewise:n}}handlers.dragstart=((e,t)=>{let{selection:{main:i}}=e.state,{mouseSelection:n}=e.inputState;n&&(n.dragging=i),t.dataTransfer&&(t.dataTransfer.setData("Text",e.state.sliceDoc(i.from,i.to)),t.dataTransfer.effectAllowed="copyMove");}),handlers.drop=((e,t)=>{if(!t.dataTransfer)return;if(e.state.readOnly)return t.preventDefault();let i=t.dataTransfer.files;if(i&&i.length){t.preventDefault();let n=Array(i.length),o=0,r=()=>{++o==i.length&&dropText(e,t,n.filter(e=>null!=e).join(e.state.lineBreak),false);};for(let e=0;e<i.length;e++){let t=new FileReader;t.onerror=r,t.onload=(()=>{/[\x00-\x08\x0e-\x1f]{2}/.test(t.result)||(n[e]=t.result),r();}),t.readAsText(i[e]);}}else dropText(e,t,t.dataTransfer.getData("Text"),true);}),handlers.paste=((e,t)=>{if(e.state.readOnly)return t.preventDefault();e.observer.flush();let i=brokenClipboardAPI?null:t.clipboardData;i?(doPaste(e,i.getData("text/plain")),t.preventDefault()):capturePaste(e);});let lastLinewiseCopy=null;function updateForFocusChange(e){setTimeout(()=>{e.hasFocus!=e.inputState.notifiedFocused&&e.update([]);},10);}handlers.copy=handlers.cut=((e,t)=>{let{text:i,ranges:n,linewise:o}=copiedRange(e.state);if(!i&&!o)return;lastLinewiseCopy=o?i:null;let r=brokenClipboardAPI?null:t.clipboardData;r?(t.preventDefault(),r.clearData(),r.setData("text/plain",i)):captureCopy(e,i),"cut"!=t.type||e.state.readOnly||e.dispatch({changes:n,scrollIntoView:true,userEvent:"delete.cut"});}),handlers.focus=(e=>{e.inputState.lastFocusTime=Date.now(),e.scrollDOM.scrollTop||!e.inputState.lastScrollTop&&!e.inputState.lastScrollLeft||(e.scrollDOM.scrollTop=e.inputState.lastScrollTop,e.scrollDOM.scrollLeft=e.inputState.lastScrollLeft),updateForFocusChange(e);}),handlers.blur=(e=>{e.observer.clearSelectionRange(),updateForFocusChange(e);}),handlers.compositionstart=handlers.compositionupdate=(e=>{null==e.inputState.compositionFirstChange&&(e.inputState.compositionFirstChange=true),e.inputState.composing<0&&(e.inputState.composing=0);}),handlers.compositionend=(e=>{e.inputState.composing=-1,e.inputState.compositionEndedAt=Date.now(),e.inputState.compositionFirstChange=null,browser.chrome&&browser.android&&e.observer.flushSoon(),setTimeout(()=>{e.inputState.composing<0&&e.docView.compositionDeco.size&&e.update([]);},50);}),handlers.contextmenu=(e=>{e.inputState.lastContextMenu=Date.now();}),handlers.beforeinput=((e,t)=>{var i;let n;if(browser.chrome&&browser.android&&(n=PendingKeys.find(e=>e.inputType==t.inputType))&&(e.observer.delayAndroidKey(n.key,n.keyCode),"Backspace"==n.key||"Delete"==n.key)){let t=(null===(i=window.visualViewport)||void 0===i?void 0:i.height)||0;setTimeout(()=>{var i;((null===(i=window.visualViewport)||void 0===i?void 0:i.height)||0)>t+10&&e.hasFocus&&(e.contentDOM.blur(),e.focus());},100);}});const wrappingWhiteSpace=["pre-wrap","normal","pre-line","break-spaces"];class HeightOracle{constructor(e){this.lineWrapping=e,this.doc=Text.empty,this.heightSamples={},this.lineHeight=14,this.charWidth=7,this.lineLength=30,this.heightChanged=false;}heightForGap(e,t){let i=this.doc.lineAt(t).number-this.doc.lineAt(e).number+1;return this.lineWrapping&&(i+=Math.ceil((t-e-i*this.lineLength*.5)/this.lineLength)),this.lineHeight*i}heightForLine(e){if(!this.lineWrapping)return this.lineHeight;return (1+Math.max(0,Math.ceil((e-this.lineLength)/(this.lineLength-5))))*this.lineHeight}setDoc(e){return this.doc=e,this}mustRefreshForWrapping(e){return wrappingWhiteSpace.indexOf(e)>-1!=this.lineWrapping}mustRefreshForHeights(e){let t=false;for(let i=0;i<e.length;i++){let n=e[i];n<0?i++:this.heightSamples[Math.floor(10*n)]||(t=true,this.heightSamples[Math.floor(10*n)]=true);}return t}refresh(e,t,i,n,o){let r=wrappingWhiteSpace.indexOf(e)>-1,s=Math.round(t)!=Math.round(this.lineHeight)||this.lineWrapping!=r;if(this.lineWrapping=r,this.lineHeight=t,this.charWidth=i,this.lineLength=n,s){this.heightSamples={};for(let e=0;e<o.length;e++){let t=o[e];t<0?e++:this.heightSamples[Math.floor(10*t)]=true;}}return s}}class MeasuredHeights{constructor(e,t){this.from=e,this.heights=t,this.index=0;}get more(){return this.index<this.heights.length}}class BlockInfo{constructor(e,t,i,n,o){this.from=e,this.length=t,this.top=i,this.height=n,this.type=o;}get to(){return this.from+this.length}get bottom(){return this.top+this.height}join(e){let t=(Array.isArray(this.type)?this.type:[this]).concat(Array.isArray(e.type)?e.type:[e]);return new BlockInfo(this.from,this.length+e.length,this.top,this.height+e.height,t)}}var QueryType=function(e){return e[e.ByPos=0]="ByPos",e[e.ByHeight=1]="ByHeight",e[e.ByPosNoHeight=2]="ByPosNoHeight",e}(QueryType||(QueryType={}));const Epsilon=.001;class HeightMap{constructor(e,t,i=2){this.length=e,this.height=t,this.flags=i;}get outdated(){return (2&this.flags)>0}set outdated(e){this.flags=(e?2:0)|-3&this.flags;}setHeight(e,t){this.height!=t&&(Math.abs(this.height-t)>Epsilon&&(e.heightChanged=true),this.height=t);}replace(e,t,i){return HeightMap.of(i)}decomposeLeft(e,t){t.push(this);}decomposeRight(e,t){t.push(this);}applyChanges(e,t,i,n){let o=this;for(let r=n.length-1;r>=0;r--){let{fromA:s,toA:a,fromB:l,toB:h}=n[r],c=o.lineAt(s,QueryType.ByPosNoHeight,t,0,0),d=c.to>=a?c:o.lineAt(a,QueryType.ByPosNoHeight,t,0,0);for(h+=d.to-a,a=d.to;r>0&&c.from<=n[r-1].toA;)s=n[r-1].fromA,l=n[r-1].fromB,r--,s<c.from&&(c=o.lineAt(s,QueryType.ByPosNoHeight,t,0,0));l+=c.from-s,s=c.from;let u=NodeBuilder.build(i,e,l,h);o=o.replace(s,a,u);}return o.updateHeight(i,0)}static empty(){return new HeightMapText(0,0)}static of(e){if(1==e.length)return e[0];let t=0,i=e.length,n=0,o=0;for(;;)if(t==i)if(n>2*o){let o=e[t-1];o.break?e.splice(--t,1,o.left,null,o.right):e.splice(--t,1,o.left,o.right),i+=1+o.break,n-=o.size;}else {if(!(o>2*n))break;{let t=e[i];t.break?e.splice(i,1,t.left,null,t.right):e.splice(i,1,t.left,t.right),i+=2+t.break,o-=t.size;}}else if(n<o){let i=e[t++];i&&(n+=i.size);}else {let t=e[--i];t&&(o+=t.size);}let r=0;return null==e[t-1]?(r=1,t--):null==e[t]&&(r=1,i++),new HeightMapBranch(HeightMap.of(e.slice(0,t)),r,HeightMap.of(e.slice(i)))}}HeightMap.prototype.size=1;class HeightMapBlock extends HeightMap{constructor(e,t,i){super(e,t),this.type=i;}blockAt(e,t,i,n){return new BlockInfo(n,this.length,i,this.height,this.type)}lineAt(e,t,i,n,o){return this.blockAt(0,i,n,o)}forEachLine(e,t,i,n,o,r){e<=o+this.length&&t>=o&&r(this.blockAt(0,i,n,o));}updateHeight(e,t=0,i=false,n){return n&&n.from<=t&&n.more&&this.setHeight(e,n.heights[n.index++]),this.outdated=false,this}toString(){return `block(${this.length})`}}class HeightMapText extends HeightMapBlock{constructor(e,t){super(e,t,BlockType.Text),this.collapsed=0,this.widgetHeight=0;}replace(e,t,i){let n=i[0];return 1==i.length&&(n instanceof HeightMapText||n instanceof HeightMapGap&&4&n.flags)&&Math.abs(this.length-n.length)<10?(n instanceof HeightMapGap?n=new HeightMapText(n.length,this.height):n.height=this.height,this.outdated||(n.outdated=false),n):HeightMap.of(i)}updateHeight(e,t=0,i=false,n){return n&&n.from<=t&&n.more?this.setHeight(e,n.heights[n.index++]):(i||this.outdated)&&this.setHeight(e,Math.max(this.widgetHeight,e.heightForLine(this.length-this.collapsed))),this.outdated=false,this}toString(){return `line(${this.length}${this.collapsed?-this.collapsed:""}${this.widgetHeight?":"+this.widgetHeight:""})`}}class HeightMapGap extends HeightMap{constructor(e){super(e,0);}lines(e,t){let i=e.lineAt(t).number,n=e.lineAt(t+this.length).number;return {firstLine:i,lastLine:n,lineHeight:this.height/(n-i+1)}}blockAt(e,t,i,n){let{firstLine:o,lastLine:r,lineHeight:s}=this.lines(t,n),a=Math.max(0,Math.min(r-o,Math.floor((e-i)/s))),{from:l,length:h}=t.line(o+a);return new BlockInfo(l,h,i+s*a,s,BlockType.Text)}lineAt(e,t,i,n,o){if(t==QueryType.ByHeight)return this.blockAt(e,i,n,o);if(t==QueryType.ByPosNoHeight){let{from:t,to:n}=i.lineAt(e);return new BlockInfo(t,n-t,0,0,BlockType.Text)}let{firstLine:r,lineHeight:s}=this.lines(i,o),{from:a,length:l,number:h}=i.lineAt(e);return new BlockInfo(a,l,n+s*(h-r),s,BlockType.Text)}forEachLine(e,t,i,n,o,r){let{firstLine:s,lineHeight:a}=this.lines(i,o);for(let l=Math.max(e,o),h=Math.min(o+this.length,t);l<=h;){let t=i.lineAt(l);l==e&&(n+=a*(t.number-s)),r(new BlockInfo(t.from,t.length,n,a,BlockType.Text)),n+=a,l=t.to+1;}}replace(e,t,i){let n=this.length-t;if(n>0){let e=i[i.length-1];e instanceof HeightMapGap?i[i.length-1]=new HeightMapGap(e.length+n):i.push(null,new HeightMapGap(n-1));}if(e>0){let t=i[0];t instanceof HeightMapGap?i[0]=new HeightMapGap(e+t.length):i.unshift(new HeightMapGap(e-1),null);}return HeightMap.of(i)}decomposeLeft(e,t){t.push(new HeightMapGap(e-1),null);}decomposeRight(e,t){t.push(null,new HeightMapGap(this.length-e-1));}updateHeight(e,t=0,i=false,n){let o=t+this.length;if(n&&n.from<=t+this.length&&n.more){let i=[],r=Math.max(t,n.from),s=-1,a=e.heightChanged;for(n.from>t&&i.push(new HeightMapGap(n.from-t-1).updateHeight(e,t));r<=o&&n.more;){let t=e.doc.lineAt(r).length;i.length&&i.push(null);let o=n.heights[n.index++];-1==s?s=o:Math.abs(o-s)>=Epsilon&&(s=-2);let a=new HeightMapText(t,o);a.outdated=false,i.push(a),r+=t+1;}r<=o&&i.push(null,new HeightMapGap(o-r).updateHeight(e,r));let l=HeightMap.of(i);return e.heightChanged=a||s<0||Math.abs(l.height-this.height)>=Epsilon||Math.abs(s-this.lines(e.doc,t).lineHeight)>=Epsilon,l}return (i||this.outdated)&&(this.setHeight(e,e.heightForGap(t,t+this.length)),this.outdated=false),this}toString(){return `gap(${this.length})`}}class HeightMapBranch extends HeightMap{constructor(e,t,i){super(e.length+t+i.length,e.height+i.height,t|(e.outdated||i.outdated?2:0)),this.left=e,this.right=i,this.size=e.size+i.size;}get break(){return 1&this.flags}blockAt(e,t,i,n){let o=i+this.left.height;return e<o?this.left.blockAt(e,t,i,n):this.right.blockAt(e,t,o,n+this.left.length+this.break)}lineAt(e,t,i,n,o){let r=n+this.left.height,s=o+this.left.length+this.break,a=t==QueryType.ByHeight?e<r:e<s,l=a?this.left.lineAt(e,t,i,n,o):this.right.lineAt(e,t,i,r,s);if(this.break||(a?l.to<s:l.from>s))return l;let h=t==QueryType.ByPosNoHeight?QueryType.ByPosNoHeight:QueryType.ByPos;return a?l.join(this.right.lineAt(s,h,i,r,s)):this.left.lineAt(s,h,i,n,o).join(l)}forEachLine(e,t,i,n,o,r){let s=n+this.left.height,a=o+this.left.length+this.break;if(this.break)e<a&&this.left.forEachLine(e,t,i,n,o,r),t>=a&&this.right.forEachLine(e,t,i,s,a,r);else {let l=this.lineAt(a,QueryType.ByPos,i,n,o);e<l.from&&this.left.forEachLine(e,l.from-1,i,n,o,r),l.to>=e&&l.from<=t&&r(l),t>l.to&&this.right.forEachLine(l.to+1,t,i,s,a,r);}}replace(e,t,i){let n=this.left.length+this.break;if(t<n)return this.balanced(this.left.replace(e,t,i),this.right);if(e>this.left.length)return this.balanced(this.left,this.right.replace(e-n,t-n,i));let o=[];e>0&&this.decomposeLeft(e,o);let r=o.length;for(let e of i)o.push(e);if(e>0&&mergeGaps(o,r-1),t<this.length){let e=o.length;this.decomposeRight(t,o),mergeGaps(o,e);}return HeightMap.of(o)}decomposeLeft(e,t){let i=this.left.length;if(e<=i)return this.left.decomposeLeft(e,t);t.push(this.left),this.break&&e>=++i&&t.push(null),e>i&&this.right.decomposeLeft(e-i,t);}decomposeRight(e,t){let i=this.left.length,n=i+this.break;if(e>=n)return this.right.decomposeRight(e-n,t);e<i&&this.left.decomposeRight(e,t),this.break&&e<n&&t.push(null),t.push(this.right);}balanced(e,t){return e.size>2*t.size||t.size>2*e.size?HeightMap.of(this.break?[e,null,t]:[e,t]):(this.left=e,this.right=t,this.height=e.height+t.height,this.outdated=e.outdated||t.outdated,this.size=e.size+t.size,this.length=e.length+this.break+t.length,this)}updateHeight(e,t=0,i=false,n){let{left:o,right:r}=this,s=t+o.length+this.break,a=null;return n&&n.from<=t+o.length&&n.more?a=o=o.updateHeight(e,t,i,n):o.updateHeight(e,t,i),n&&n.from<=s+r.length&&n.more?a=r=r.updateHeight(e,s,i,n):r.updateHeight(e,s,i),a?this.balanced(o,r):(this.height=this.left.height+this.right.height,this.outdated=false,this)}toString(){return this.left+(this.break?" ":"-")+this.right}}function mergeGaps(e,t){let i,n;null==e[t]&&(i=e[t-1])instanceof HeightMapGap&&(n=e[t+1])instanceof HeightMapGap&&e.splice(t-1,3,new HeightMapGap(i.length+1+n.length));}const relevantWidgetHeight=5;class NodeBuilder{constructor(e,t){this.pos=e,this.oracle=t,this.nodes=[],this.lineStart=-1,this.lineEnd=-1,this.covering=null,this.writtenTo=e;}get isCovered(){return this.covering&&this.nodes[this.nodes.length-1]==this.covering}span(e,t){if(this.lineStart>-1){let e=Math.min(t,this.lineEnd),i=this.nodes[this.nodes.length-1];i instanceof HeightMapText?i.length+=e-this.pos:(e>this.pos||!this.isCovered)&&this.nodes.push(new HeightMapText(e-this.pos,-1)),this.writtenTo=e,t>e&&(this.nodes.push(null),this.writtenTo++,this.lineStart=-1);}this.pos=t;}point(e,t,i){if(e<t||i.heightRelevant){let n=i.widget?i.widget.estimatedHeight:0;n<0&&(n=this.oracle.lineHeight);let o=t-e;i.block?this.addBlock(new HeightMapBlock(o,n,i.type)):(o||n>=relevantWidgetHeight)&&this.addLineDeco(n,o);}else t>e&&this.span(e,t);this.lineEnd>-1&&this.lineEnd<this.pos&&(this.lineEnd=this.oracle.doc.lineAt(this.pos).to);}enterLine(){if(this.lineStart>-1)return;let{from:e,to:t}=this.oracle.doc.lineAt(this.pos);this.lineStart=e,this.lineEnd=t,this.writtenTo<e&&((this.writtenTo<e-1||null==this.nodes[this.nodes.length-1])&&this.nodes.push(this.blankContent(this.writtenTo,e-1)),this.nodes.push(null)),this.pos>e&&this.nodes.push(new HeightMapText(this.pos-e,-1)),this.writtenTo=this.pos;}blankContent(e,t){let i=new HeightMapGap(t-e);return this.oracle.doc.lineAt(e).to==t&&(i.flags|=4),i}ensureLine(){this.enterLine();let e=this.nodes.length?this.nodes[this.nodes.length-1]:null;if(e instanceof HeightMapText)return e;let t=new HeightMapText(0,-1);return this.nodes.push(t),t}addBlock(e){this.enterLine(),e.type!=BlockType.WidgetAfter||this.isCovered||this.ensureLine(),this.nodes.push(e),this.writtenTo=this.pos=this.pos+e.length,e.type!=BlockType.WidgetBefore&&(this.covering=e);}addLineDeco(e,t){let i=this.ensureLine();i.length+=t,i.collapsed+=t,i.widgetHeight=Math.max(i.widgetHeight,e),this.writtenTo=this.pos=this.pos+t;}finish(e){let t=0==this.nodes.length?null:this.nodes[this.nodes.length-1];!(this.lineStart>-1)||t instanceof HeightMapText||this.isCovered?(this.writtenTo<this.pos||null==t)&&this.nodes.push(this.blankContent(this.writtenTo,this.pos)):this.nodes.push(new HeightMapText(0,-1));let i=e;for(let e of this.nodes)e instanceof HeightMapText&&e.updateHeight(this.oracle,i),i+=e?e.length:1;return this.nodes}static build(e,t,i,n){let o=new NodeBuilder(i,e);return RangeSet.spans(t,i,n,o,0),o.finish(i)}}function heightRelevantDecoChanges(e,t,i){let n=new DecorationComparator;return RangeSet.compare(e,t,i,n,0),n.changes}class DecorationComparator{constructor(){this.changes=[];}compareRange(){}comparePoint(e,t,i,n){(e<t||i&&i.heightRelevant||n&&n.heightRelevant)&&addRange(e,t,this.changes,5);}}function visiblePixelRange(e,t){let i=e.getBoundingClientRect(),n=e.ownerDocument,o=n.defaultView||window,r=Math.max(0,i.left),s=Math.min(o.innerWidth,i.right),a=Math.max(0,i.top),l=Math.min(o.innerHeight,i.bottom);for(let t=e.parentNode;t&&t!=n.body;)if(1==t.nodeType){let i=t,n=window.getComputedStyle(i);if((i.scrollHeight>i.clientHeight||i.scrollWidth>i.clientWidth)&&"visible"!=n.overflow){let n=i.getBoundingClientRect();r=Math.max(r,n.left),s=Math.min(s,n.right),a=Math.max(a,n.top),l=t==e.parentNode?n.bottom:Math.min(l,n.bottom);}t="absolute"==n.position||"fixed"==n.position?i.offsetParent:i.parentNode;}else {if(11!=t.nodeType)break;t=t.host;}return {left:r-i.left,right:Math.max(r,s)-i.left,top:a-(i.top+t),bottom:Math.max(a,l)-(i.top+t)}}function fullPixelRange(e,t){let i=e.getBoundingClientRect();return {left:0,right:i.right-i.left,top:t,bottom:i.bottom-(i.top+t)}}class LineGap{constructor(e,t,i){this.from=e,this.to=t,this.size=i;}static same(e,t){if(e.length!=t.length)return  false;for(let i=0;i<e.length;i++){let n=e[i],o=t[i];if(n.from!=o.from||n.to!=o.to||n.size!=o.size)return  false}return  true}draw(e){return Decoration.replace({widget:new LineGapWidget(this.size,e)}).range(this.from,this.to)}}class LineGapWidget extends WidgetType{constructor(e,t){super(),this.size=e,this.vertical=t;}eq(e){return e.size==this.size&&e.vertical==this.vertical}toDOM(){let e=document.createElement("div");return this.vertical?e.style.height=this.size+"px":(e.style.width=this.size+"px",e.style.height="2px",e.style.display="inline-block"),e}get estimatedHeight(){return this.vertical?this.size:-1}}class ViewState{constructor(e){this.state=e,this.pixelViewport={left:0,right:window.innerWidth,top:0,bottom:0},this.inView=true,this.paddingTop=0,this.paddingBottom=0,this.contentDOMWidth=0,this.contentDOMHeight=0,this.editorHeight=0,this.editorWidth=0,this.scaler=IdScaler,this.scrollTarget=null,this.printing=false,this.mustMeasureContent=true,this.defaultTextDirection=Direction.LTR,this.visibleRanges=[],this.mustEnforceCursorAssoc=false;let t=e.facet(contentAttributes).some(e=>"function"!=typeof e&&"cm-lineWrapping"==e.class);this.heightOracle=new HeightOracle(t),this.stateDeco=e.facet(decorations).filter(e=>"function"!=typeof e),this.heightMap=HeightMap.empty().applyChanges(this.stateDeco,Text.empty,this.heightOracle.setDoc(e.doc),[new ChangedRange(0,0,0,e.doc.length)]),this.viewport=this.getViewport(0,null),this.updateViewportLines(),this.updateForViewport(),this.lineGaps=this.ensureLineGaps([]),this.lineGapDeco=Decoration.set(this.lineGaps.map(e=>e.draw(false))),this.computeVisibleRanges();}updateForViewport(){let e=[this.viewport],{main:t}=this.state.selection;for(let i=0;i<=1;i++){let n=i?t.head:t.anchor;if(!e.some(({from:e,to:t})=>n>=e&&n<=t)){let{from:t,to:i}=this.lineBlockAt(n);e.push(new Viewport(t,i));}}this.viewports=e.sort((e,t)=>e.from-t.from),this.scaler=this.heightMap.height<=7e6?IdScaler:new BigScaler(this.heightOracle.doc,this.heightMap,this.viewports);}updateViewportLines(){this.viewportLines=[],this.heightMap.forEachLine(this.viewport.from,this.viewport.to,this.state.doc,0,0,e=>{this.viewportLines.push(1==this.scaler.scale?e:scaleBlock(e,this.scaler));});}update(e,t=null){this.state=e.state;let i=this.stateDeco;this.stateDeco=this.state.facet(decorations).filter(e=>"function"!=typeof e);let n=e.changedRanges,o=ChangedRange.extendWithRanges(n,heightRelevantDecoChanges(i,this.stateDeco,e?e.changes:ChangeSet.empty(this.state.doc.length))),r=this.heightMap.height;this.heightMap=this.heightMap.applyChanges(this.stateDeco,e.startState.doc,this.heightOracle.setDoc(this.state.doc),o),this.heightMap.height!=r&&(e.flags|=2);let s=o.length?this.mapViewport(this.viewport,e.changes):this.viewport;(t&&(t.range.head<s.from||t.range.head>s.to)||!this.viewportIsAppropriate(s))&&(s=this.getViewport(0,t));let a=!e.changes.empty||2&e.flags||s.from!=this.viewport.from||s.to!=this.viewport.to;this.viewport=s,this.updateForViewport(),a&&this.updateViewportLines(),(this.lineGaps.length||this.viewport.to-this.viewport.from>4e3)&&this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps,e.changes))),e.flags|=this.computeVisibleRanges(),t&&(this.scrollTarget=t),!this.mustEnforceCursorAssoc&&e.selectionSet&&e.view.lineWrapping&&e.state.selection.main.empty&&e.state.selection.main.assoc&&!e.state.facet(nativeSelectionHidden)&&(this.mustEnforceCursorAssoc=true);}measure(e){let t=e.contentDOM,i=window.getComputedStyle(t),n=this.heightOracle,o=i.whiteSpace;this.defaultTextDirection="rtl"==i.direction?Direction.RTL:Direction.LTR;let r=this.heightOracle.mustRefreshForWrapping(o),s=r||this.mustMeasureContent||this.contentDOMHeight!=t.clientHeight;this.contentDOMHeight=t.clientHeight,this.mustMeasureContent=false;let a=0,l=0,h=parseInt(i.paddingTop)||0,c=parseInt(i.paddingBottom)||0;this.paddingTop==h&&this.paddingBottom==c||(this.paddingTop=h,this.paddingBottom=c,a|=10),this.editorWidth!=e.scrollDOM.clientWidth&&(n.lineWrapping&&(s=true),this.editorWidth=e.scrollDOM.clientWidth,a|=8);let d=(this.printing?fullPixelRange:visiblePixelRange)(t,this.paddingTop),u=d.top-this.pixelViewport.top,f=d.bottom-this.pixelViewport.bottom;this.pixelViewport=d;let p=this.pixelViewport.bottom>this.pixelViewport.top&&this.pixelViewport.right>this.pixelViewport.left;if(p!=this.inView&&(this.inView=p,p&&(s=true)),!this.inView&&!this.scrollTarget)return 0;let O=t.clientWidth;if(this.contentDOMWidth==O&&this.editorHeight==e.scrollDOM.clientHeight||(this.contentDOMWidth=O,this.editorHeight=e.scrollDOM.clientHeight,a|=8),s){let t=e.docView.measureVisibleLineHeights(this.viewport);if(n.mustRefreshForHeights(t)&&(r=true),r||n.lineWrapping&&Math.abs(O-this.contentDOMWidth)>n.charWidth){let{lineHeight:i,charWidth:s}=e.docView.measureTextSize();(r=i>0&&n.refresh(o,i,s,O/s,t))&&(e.docView.minWidth=0,a|=8);}u>0&&f>0?l=Math.max(u,f):u<0&&f<0&&(l=Math.min(u,f)),n.heightChanged=false;for(let i of this.viewports){let o=i.from==this.viewport.from?t:e.docView.measureVisibleLineHeights(i);this.heightMap=(r?HeightMap.empty().applyChanges(this.stateDeco,Text.empty,this.heightOracle,[new ChangedRange(0,0,0,e.state.doc.length)]):this.heightMap).updateHeight(n,0,r,new MeasuredHeights(i.from,o));}n.heightChanged&&(a|=2);}let g=!this.viewportIsAppropriate(this.viewport,l)||this.scrollTarget&&(this.scrollTarget.range.head<this.viewport.from||this.scrollTarget.range.head>this.viewport.to);return g&&(this.viewport=this.getViewport(l,this.scrollTarget)),this.updateForViewport(),(2&a||g)&&this.updateViewportLines(),(this.lineGaps.length||this.viewport.to-this.viewport.from>4e3)&&this.updateLineGaps(this.ensureLineGaps(r?[]:this.lineGaps,e)),a|=this.computeVisibleRanges(),this.mustEnforceCursorAssoc&&(this.mustEnforceCursorAssoc=false,e.docView.enforceCursorAssoc()),a}get visibleTop(){return this.scaler.fromDOM(this.pixelViewport.top)}get visibleBottom(){return this.scaler.fromDOM(this.pixelViewport.bottom)}getViewport(e,t){let i=.5-Math.max(-0.5,Math.min(.5,e/1e3/2)),n=this.heightMap,o=this.state.doc,{visibleTop:r,visibleBottom:s}=this,a=new Viewport(n.lineAt(r-1e3*i,QueryType.ByHeight,o,0,0).from,n.lineAt(s+1e3*(1-i),QueryType.ByHeight,o,0,0).to);if(t){let{head:e}=t.range;if(e<a.from||e>a.to){let i,r=Math.min(this.editorHeight,this.pixelViewport.bottom-this.pixelViewport.top),s=n.lineAt(e,QueryType.ByPos,o,0,0);i="center"==t.y?(s.top+s.bottom)/2-r/2:"start"==t.y||"nearest"==t.y&&e<a.from?s.top:s.bottom-r,a=new Viewport(n.lineAt(i-500,QueryType.ByHeight,o,0,0).from,n.lineAt(i+r+500,QueryType.ByHeight,o,0,0).to);}}return a}mapViewport(e,t){let i=t.mapPos(e.from,-1),n=t.mapPos(e.to,1);return new Viewport(this.heightMap.lineAt(i,QueryType.ByPos,this.state.doc,0,0).from,this.heightMap.lineAt(n,QueryType.ByPos,this.state.doc,0,0).to)}viewportIsAppropriate({from:e,to:t},i=0){if(!this.inView)return  true;let{top:n}=this.heightMap.lineAt(e,QueryType.ByPos,this.state.doc,0,0),{bottom:o}=this.heightMap.lineAt(t,QueryType.ByPos,this.state.doc,0,0),{visibleTop:r,visibleBottom:s}=this;return (0==e||n<=r-Math.max(10,Math.min(-i,250)))&&(t==this.state.doc.length||o>=s+Math.max(10,Math.min(i,250)))&&n>r-2e3&&o<s+2e3}mapLineGaps(e,t){if(!e.length||t.empty)return e;let i=[];for(let n of e)t.touchesRange(n.from,n.to)||i.push(new LineGap(t.mapPos(n.from),t.mapPos(n.to),n.size));return i}ensureLineGaps(e,t){let i=this.heightOracle.lineWrapping,n=i?1e4:2e3,o=n>>1,r=n<<1;if(this.defaultTextDirection!=Direction.LTR&&!i)return [];let s=[],a=(n,r,l,h)=>{if(r-n<o)return;let c=this.state.selection.main,d=[c.from];c.empty||d.push(c.to);for(let e of d)if(e>n&&e<r)return a(n,e-10,l,h),void a(e+10,r,l,h);let u=find(e,e=>e.from>=l.from&&e.to<=l.to&&Math.abs(e.from-n)<o&&Math.abs(e.to-r)<o&&!d.some(t=>e.from<t&&e.to>t));if(!u){if(r<l.to&&t&&i&&t.visibleRanges.some(e=>e.from<=r&&e.to>=r)){let e=t.moveToLineBoundary(EditorSelection.cursor(r),false,true).head;e>n&&(r=e);}u=new LineGap(n,r,this.gapSize(l,n,r,h));}s.push(u);};for(let e of this.viewportLines){if(e.length<r)continue;let t=lineStructure(e.from,e.to,this.stateDeco);if(t.total<r)continue;let o,s,l=this.scrollTarget?this.scrollTarget.range.head:null;if(i){let i,r,a=n/this.heightOracle.lineLength*this.heightOracle.lineHeight;if(null!=l){let n=findFraction(t,l),o=((this.visibleBottom-this.visibleTop)/2+a)/e.height;i=n-o,r=n+o;}else i=(this.visibleTop-e.top-a)/e.height,r=(this.visibleBottom-e.top+a)/e.height;o=findPosition(t,i),s=findPosition(t,r);}else {let e,i,r=t.total*this.heightOracle.charWidth,a=n*this.heightOracle.charWidth;if(null!=l){let n=findFraction(t,l),o=((this.pixelViewport.right-this.pixelViewport.left)/2+a)/r;e=n-o,i=n+o;}else e=(this.pixelViewport.left-a)/r,i=(this.pixelViewport.right+a)/r;o=findPosition(t,e),s=findPosition(t,i);}o>e.from&&a(e.from,o,e,t),s<e.to&&a(s,e.to,e,t);}return s}gapSize(e,t,i,n){let o=findFraction(n,i)-findFraction(n,t);return this.heightOracle.lineWrapping?e.height*o:n.total*this.heightOracle.charWidth*o}updateLineGaps(e){LineGap.same(e,this.lineGaps)||(this.lineGaps=e,this.lineGapDeco=Decoration.set(e.map(e=>e.draw(this.heightOracle.lineWrapping))));}computeVisibleRanges(){let e=this.stateDeco;this.lineGaps.length&&(e=e.concat(this.lineGapDeco));let t=[];RangeSet.spans(e,this.viewport.from,this.viewport.to,{span(e,i){t.push({from:e,to:i});},point(){}},20);let i=t.length!=this.visibleRanges.length||this.visibleRanges.some((e,i)=>e.from!=t[i].from||e.to!=t[i].to);return this.visibleRanges=t,i?4:0}lineBlockAt(e){return e>=this.viewport.from&&e<=this.viewport.to&&this.viewportLines.find(t=>t.from<=e&&t.to>=e)||scaleBlock(this.heightMap.lineAt(e,QueryType.ByPos,this.state.doc,0,0),this.scaler)}lineBlockAtHeight(e){return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(e),QueryType.ByHeight,this.state.doc,0,0),this.scaler)}elementAtHeight(e){return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(e),this.state.doc,0,0),this.scaler)}get docHeight(){return this.scaler.toDOM(this.heightMap.height)}get contentHeight(){return this.docHeight+this.paddingTop+this.paddingBottom}}class Viewport{constructor(e,t){this.from=e,this.to=t;}}function lineStructure(e,t,i){let n=[],o=e,r=0;return RangeSet.spans(i,e,t,{span(){},point(e,t){e>o&&(n.push({from:o,to:e}),r+=e-o),o=t;}},20),o<t&&(n.push({from:o,to:t}),r+=t-o),{total:r,ranges:n}}function findPosition({total:e,ranges:t},i){if(i<=0)return t[0].from;if(i>=1)return t[t.length-1].to;let n=Math.floor(e*i);for(let e=0;;e++){let{from:i,to:o}=t[e],r=o-i;if(n<=r)return i+n;n-=r;}}function findFraction(e,t){let i=0;for(let{from:n,to:o}of e.ranges){if(t<=o){i+=t-n;break}i+=o-n;}return i/e.total}function find(e,t){for(let i of e)if(t(i))return i}const IdScaler={toDOM:e=>e,fromDOM:e=>e,scale:1};class BigScaler{constructor(e,t,i){let n=0,o=0,r=0;this.viewports=i.map(({from:i,to:o})=>{let r=t.lineAt(i,QueryType.ByPos,e,0,0).top,s=t.lineAt(o,QueryType.ByPos,e,0,0).bottom;return n+=s-r,{from:i,to:o,top:r,bottom:s,domTop:0,domBottom:0}}),this.scale=(7e6-n)/(t.height-n);for(let e of this.viewports)e.domTop=r+(e.top-o)*this.scale,r=e.domBottom=e.domTop+(e.bottom-e.top),o=e.bottom;}toDOM(e){for(let t=0,i=0,n=0;;t++){let o=t<this.viewports.length?this.viewports[t]:null;if(!o||e<o.top)return n+(e-i)*this.scale;if(e<=o.bottom)return o.domTop+(e-o.top);i=o.bottom,n=o.domBottom;}}fromDOM(e){for(let t=0,i=0,n=0;;t++){let o=t<this.viewports.length?this.viewports[t]:null;if(!o||e<o.domTop)return i+(e-n)/this.scale;if(e<=o.domBottom)return o.top+(e-o.domTop);i=o.bottom,n=o.domBottom;}}}function scaleBlock(e,t){if(1==t.scale)return e;let i=t.toDOM(e.top),n=t.toDOM(e.bottom);return new BlockInfo(e.from,e.length,i,n-i,Array.isArray(e.type)?e.type.map(e=>scaleBlock(e,t)):e.type)}const theme=Facet.define({combine:e=>e.join(" ")}),darkTheme=Facet.define({combine:e=>e.indexOf(true)>-1}),baseThemeID=StyleModule.newName(),baseLightID=StyleModule.newName(),baseDarkID=StyleModule.newName(),lightDarkIDs={"&light":"."+baseLightID,"&dark":"."+baseDarkID};function buildTheme(e,t,i){return new StyleModule(t,{finish:t=>/&/.test(t)?t.replace(/&\w*/,t=>{if("&"==t)return e;if(!i||!i[t])throw new RangeError(`Unsupported selector: ${t}`);return i[t]}):e+" "+t})}const baseTheme$1=buildTheme("."+baseThemeID,{"&.cm-editor":{position:"relative !important",boxSizing:"border-box","&.cm-focused":{outline:"1px dotted #212121"},display:"flex !important",flexDirection:"column"},".cm-scroller":{display:"flex !important",alignItems:"flex-start !important",fontFamily:"monospace",lineHeight:1.4,height:"100%",overflowX:"auto",position:"relative",zIndex:0},".cm-content":{margin:0,flexGrow:2,flexShrink:0,minHeight:"100%",display:"block",whiteSpace:"pre",wordWrap:"normal",boxSizing:"border-box",padding:"4px 0",outline:"none","&[contenteditable=true]":{WebkitUserModify:"read-write-plaintext-only"}},".cm-lineWrapping":{whiteSpace_fallback:"pre-wrap",whiteSpace:"break-spaces",wordBreak:"break-word",overflowWrap:"anywhere",flexShrink:1},"&light .cm-content":{caretColor:"black"},"&dark .cm-content":{caretColor:"white"},".cm-line":{display:"block",padding:"0 2px 0 6px"},".cm-layer":{contain:"size style","& > *":{position:"absolute"}},"&light .cm-selectionBackground":{background:"#d9d9d9"},"&dark .cm-selectionBackground":{background:"#222"},"&light.cm-focused .cm-selectionBackground":{background:"#d7d4f0"},"&dark.cm-focused .cm-selectionBackground":{background:"#233"},".cm-cursorLayer":{pointerEvents:"none"},"&.cm-focused .cm-cursorLayer":{animation:"steps(1) cm-blink 1.2s infinite"},"@keyframes cm-blink":{"0%":{},"50%":{opacity:0},"100%":{}},"@keyframes cm-blink2":{"0%":{},"50%":{opacity:0},"100%":{}},".cm-cursor, .cm-dropCursor":{borderLeft:"1.2px solid black",marginLeft:"-0.6px",pointerEvents:"none"},".cm-cursor":{display:"none"},"&dark .cm-cursor":{borderLeftColor:"#444"},"&.cm-focused .cm-cursor":{display:"block"},"&light .cm-activeLine":{backgroundColor:"#cceeff44"},"&dark .cm-activeLine":{backgroundColor:"#99eeff33"},"&light .cm-specialChar":{color:"red"},"&dark .cm-specialChar":{color:"#f78"},".cm-gutters":{flexShrink:0,display:"flex",height:"100%",boxSizing:"border-box",left:0,zIndex:200},"&light .cm-gutters":{backgroundColor:"#f5f5f5",color:"#6c6c6c",borderRight:"1px solid #ddd"},"&dark .cm-gutters":{backgroundColor:"#333338",color:"#ccc"},".cm-gutter":{display:"flex !important",flexDirection:"column",flexShrink:0,boxSizing:"border-box",minHeight:"100%",overflow:"hidden"},".cm-gutterElement":{boxSizing:"border-box"},".cm-lineNumbers .cm-gutterElement":{padding:"0 3px 0 5px",minWidth:"20px",textAlign:"right",whiteSpace:"nowrap"},"&light .cm-activeLineGutter":{backgroundColor:"#e2f2ff"},"&dark .cm-activeLineGutter":{backgroundColor:"#222227"},".cm-panels":{boxSizing:"border-box",position:"sticky",left:0,right:0},"&light .cm-panels":{backgroundColor:"#f5f5f5",color:"black"},"&light .cm-panels-top":{borderBottom:"1px solid #ddd"},"&light .cm-panels-bottom":{borderTop:"1px solid #ddd"},"&dark .cm-panels":{backgroundColor:"#333338",color:"white"},".cm-tab":{display:"inline-block",overflow:"hidden",verticalAlign:"bottom"},".cm-widgetBuffer":{verticalAlign:"text-top",height:"1em",width:0,display:"inline"},".cm-placeholder":{color:"#888",display:"inline-block",verticalAlign:"top"},".cm-button":{verticalAlign:"middle",color:"inherit",fontSize:"70%",padding:".2em 1em",borderRadius:"1px"},"&light .cm-button":{backgroundImage:"linear-gradient(#eff1f5, #d9d9df)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#b4b4b4, #d0d3d6)"}},"&dark .cm-button":{backgroundImage:"linear-gradient(#393939, #111)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#111, #333)"}},".cm-textfield":{verticalAlign:"middle",color:"inherit",fontSize:"70%",border:"1px solid silver",padding:".2em .5em"},"&light .cm-textfield":{backgroundColor:"white"},"&dark .cm-textfield":{border:"1px solid #555",backgroundColor:"inherit"}},lightDarkIDs);class DOMChange{constructor(e,t,i,n){this.typeOver=n,this.bounds=null,this.text="";let{impreciseHead:o,impreciseAnchor:r}=e.docView;if(e.state.readOnly&&t>-1)this.newSel=null;else if(t>-1&&(this.bounds=e.docView.domBoundsAround(t,i,0))){let t=o||r?[]:selectionPoints(e),i=new DOMReader(t,e.state);i.readRange(this.bounds.startDOM,this.bounds.endDOM),this.text=i.text,this.newSel=selectionFromPoints(t,this.bounds.from);}else {let t=e.observer.selectionRange,i=o&&o.node==t.focusNode&&o.offset==t.focusOffset||!contains(e.contentDOM,t.focusNode)?e.state.selection.main.head:e.docView.posFromDOM(t.focusNode,t.focusOffset),n=r&&r.node==t.anchorNode&&r.offset==t.anchorOffset||!contains(e.contentDOM,t.anchorNode)?e.state.selection.main.anchor:e.docView.posFromDOM(t.anchorNode,t.anchorOffset);this.newSel=EditorSelection.single(n,i);}}}function applyDOMChange(e,t){let i,{newSel:n}=t,o=e.state.selection.main;if(t.bounds){let{from:n,to:r}=t.bounds,s=o.from,a=null;(8===e.inputState.lastKeyCode&&e.inputState.lastKeyTime>Date.now()-100||browser.android&&t.text.length<r-n)&&(s=o.to,a="end");let l=findDiff(e.state.doc.sliceString(n,r,LineBreakPlaceholder),t.text,s-n,a);l&&(browser.chrome&&13==e.inputState.lastKeyCode&&l.toB==l.from+2&&t.text.slice(l.from,l.toB)==LineBreakPlaceholder+LineBreakPlaceholder&&l.toB--,i={from:n+l.from,to:n+l.toA,insert:Text.of(t.text.slice(l.from,l.toB).split(LineBreakPlaceholder))});}else !n||e.hasFocus&&e.state.facet(editable)&&!n.main.eq(o)||(n=null);if(!i&&!n)return  false;if(!i&&t.typeOver&&!o.empty&&n&&n.main.empty?i={from:o.from,to:o.to,insert:e.state.doc.slice(o.from,o.to)}:i&&i.from>=o.from&&i.to<=o.to&&(i.from!=o.from||i.to!=o.to)&&o.to-o.from-(i.to-i.from)<=4?i={from:o.from,to:o.to,insert:e.state.doc.slice(o.from,i.from).append(i.insert).append(e.state.doc.slice(i.to,o.to))}:(browser.mac||browser.android)&&i&&i.from==i.to&&i.from==o.head-1&&/^\. ?$/.test(i.insert.toString())?(n&&2==i.insert.length&&(n=EditorSelection.single(n.main.anchor-1,n.main.head-1)),i={from:o.from,to:o.to,insert:Text.of([" "])}):browser.chrome&&i&&i.from==i.to&&i.from==o.head&&"\n "==i.insert.toString()&&e.lineWrapping&&(n&&(n=EditorSelection.single(n.main.anchor-1,n.main.head-1)),i={from:o.from,to:o.to,insert:Text.of([" "])}),i){let t=e.state;if(browser.ios&&e.inputState.flushIOSKey(e))return  true;if(browser.android&&(i.from==o.from&&i.to==o.to&&1==i.insert.length&&2==i.insert.lines&&dispatchKey(e.contentDOM,"Enter",13)||i.from==o.from-1&&i.to==o.to&&0==i.insert.length&&dispatchKey(e.contentDOM,"Backspace",8)||i.from==o.from&&i.to==o.to+1&&0==i.insert.length&&dispatchKey(e.contentDOM,"Delete",46)))return  true;let r,s=i.insert.toString();if(e.state.facet(inputHandler).some(t=>t(e,i.from,i.to,s)))return  true;if(e.inputState.composing>=0&&e.inputState.composing++,i.from>=o.from&&i.to<=o.to&&i.to-i.from>=(o.to-o.from)/3&&(!n||n.main.empty&&n.main.from==i.from+i.insert.length)&&e.inputState.composing<0){let n=o.from<i.from?t.sliceDoc(o.from,i.from):"",s=o.to>i.to?t.sliceDoc(i.to,o.to):"";r=t.replaceSelection(e.state.toText(n+i.insert.sliceString(0,void 0,e.state.lineBreak)+s));}else {let s=t.changes(i),a=n&&!t.selection.main.eq(n.main)&&n.main.to<=s.newLength?n.main:void 0;if(t.selection.ranges.length>1&&e.inputState.composing>=0&&i.to<=o.to&&i.to>=o.to-10){let n=e.state.sliceDoc(i.from,i.to),l=compositionSurroundingNode(e)||e.state.doc.lineAt(o.head),h=o.to-i.to,c=o.to-o.from;r=t.changeByRange(r=>{if(r.from==o.from&&r.to==o.to)return {changes:s,range:a||r.map(s)};let d=r.to-h,u=d-n.length;if(r.to-r.from!=c||e.state.sliceDoc(u,d)!=n||l&&r.to>=l.from&&r.from<=l.to)return {range:r};let f=t.changes({from:u,to:d,insert:i.insert}),p=r.to-o.to;return {changes:f,range:a?EditorSelection.range(Math.max(0,a.anchor+p),Math.max(0,a.head+p)):r.map(f)}});}else r={changes:s,selection:a&&t.selection.replaceRange(a)};}let a="input.type";return e.composing&&(a+=".compose",e.inputState.compositionFirstChange&&(a+=".start",e.inputState.compositionFirstChange=false)),e.dispatch(r,{scrollIntoView:true,userEvent:a}),true}if(n&&!n.main.eq(o)){let t=false,i="select";return e.inputState.lastSelectionTime>Date.now()-50&&("select"==e.inputState.lastSelectionOrigin&&(t=true),i=e.inputState.lastSelectionOrigin),e.dispatch({selection:n,scrollIntoView:t,userEvent:i}),true}return  false}function findDiff(e,t,i,n){let o=Math.min(e.length,t.length),r=0;for(;r<o&&e.charCodeAt(r)==t.charCodeAt(r);)r++;if(r==o&&e.length==t.length)return null;let s=e.length,a=t.length;for(;s>0&&a>0&&e.charCodeAt(s-1)==t.charCodeAt(a-1);)s--,a--;if("end"==n){i-=s+Math.max(0,r-Math.min(s,a))-r;}if(s<r&&e.length<t.length){a=(r-=i<=r&&i>=s?r-i:0)+(a-s),s=r;}else if(a<r){s=(r-=i<=r&&i>=a?r-i:0)+(s-a),a=r;}return {from:r,toA:s,toB:a}}function selectionPoints(e){let t=[];if(e.root.activeElement!=e.contentDOM)return t;let{anchorNode:i,anchorOffset:n,focusNode:o,focusOffset:r}=e.observer.selectionRange;return i&&(t.push(new DOMPoint(i,n)),o==i&&r==n||t.push(new DOMPoint(o,r))),t}function selectionFromPoints(e,t){if(0==e.length)return null;let i=e[0].pos,n=2==e.length?e[1].pos:i;return i>-1&&n>-1?EditorSelection.single(i+t,n+t):null}const observeOptions={childList:true,characterData:true,subtree:true,attributes:true,characterDataOldValue:true},useCharData=browser.ie&&browser.ie_version<=11;class DOMObserver{constructor(e){this.view=e,this.active=false,this.selectionRange=new DOMSelectionState,this.selectionChanged=false,this.delayedFlush=-1,this.resizeTimeout=-1,this.queue=[],this.delayedAndroidKey=null,this.flushingAndroidKey=-1,this.lastChange=0,this.scrollTargets=[],this.intersection=null,this.resize=null,this.intersecting=false,this.gapIntersection=null,this.gaps=[],this.parentCheck=-1,this.dom=e.contentDOM,this.observer=new MutationObserver(t=>{for(let e of t)this.queue.push(e);(browser.ie&&browser.ie_version<=11||browser.ios&&e.composing)&&t.some(e=>"childList"==e.type&&e.removedNodes.length||"characterData"==e.type&&e.oldValue.length>e.target.nodeValue.length)?this.flushSoon():this.flush();}),useCharData&&(this.onCharData=(e=>{this.queue.push({target:e.target,type:"characterData",oldValue:e.prevValue}),this.flushSoon();})),this.onSelectionChange=this.onSelectionChange.bind(this),this.onResize=this.onResize.bind(this),this.onPrint=this.onPrint.bind(this),this.onScroll=this.onScroll.bind(this),"function"==typeof ResizeObserver&&(this.resize=new ResizeObserver(()=>{var e;(null===(e=this.view.docView)||void 0===e?void 0:e.lastUpdate)<Date.now()-75&&this.onResize();}),this.resize.observe(e.scrollDOM)),this.addWindowListeners(this.win=e.win),this.start(),"function"==typeof IntersectionObserver&&(this.intersection=new IntersectionObserver(e=>{this.parentCheck<0&&(this.parentCheck=setTimeout(this.listenForScroll.bind(this),1e3)),e.length>0&&e[e.length-1].intersectionRatio>0!=this.intersecting&&(this.intersecting=!this.intersecting,this.intersecting!=this.view.inView&&this.onScrollChanged(document.createEvent("Event")));},{}),this.intersection.observe(this.dom),this.gapIntersection=new IntersectionObserver(e=>{e.length>0&&e[e.length-1].intersectionRatio>0&&this.onScrollChanged(document.createEvent("Event"));},{})),this.listenForScroll(),this.readSelectionRange();}onScrollChanged(e){this.view.inputState.runScrollHandlers(this.view,e),this.intersecting&&this.view.measure();}onScroll(e){this.intersecting&&this.flush(false),this.onScrollChanged(e);}onResize(){this.resizeTimeout<0&&(this.resizeTimeout=setTimeout(()=>{this.resizeTimeout=-1,this.view.requestMeasure();},50));}onPrint(){this.view.viewState.printing=true,this.view.measure(),setTimeout(()=>{this.view.viewState.printing=false,this.view.requestMeasure();},500);}updateGaps(e){if(this.gapIntersection&&(e.length!=this.gaps.length||this.gaps.some((t,i)=>t!=e[i]))){this.gapIntersection.disconnect();for(let t of e)this.gapIntersection.observe(t);this.gaps=e;}}onSelectionChange(e){let t=this.selectionChanged;if(!this.readSelectionRange()||this.delayedAndroidKey)return;let{view:i}=this,n=this.selectionRange;if(i.state.facet(editable)?i.root.activeElement!=this.dom:!hasSelection(i.dom,n))return;let o=n.anchorNode&&i.docView.nearest(n.anchorNode);o&&o.ignoreEvent(e)?t||(this.selectionChanged=false):(browser.ie&&browser.ie_version<=11||browser.android&&browser.chrome)&&!i.state.selection.main.empty&&n.focusNode&&isEquivalentPosition(n.focusNode,n.focusOffset,n.anchorNode,n.anchorOffset)?this.flushSoon():this.flush(false);}readSelectionRange(){let{view:e}=this,t=browser.safari&&11==e.root.nodeType&&deepActiveElement(this.dom.ownerDocument)==this.dom&&safariSelectionRangeHack(this.view)||getSelection(e.root);if(!t||this.selectionRange.eq(t))return  false;let i=hasSelection(this.dom,t);return i&&!this.selectionChanged&&e.inputState.lastFocusTime>Date.now()-200&&e.inputState.lastTouchTime<Date.now()-300&&atElementStart(this.dom,t)?(this.view.inputState.lastFocusTime=0,e.docView.updateSelection(),false):(this.selectionRange.setRange(t),i&&(this.selectionChanged=true),true)}setSelectionRange(e,t){this.selectionRange.set(e.node,e.offset,t.node,t.offset),this.selectionChanged=false;}clearSelectionRange(){this.selectionRange.set(null,0,null,0);}listenForScroll(){this.parentCheck=-1;let e=0,t=null;for(let i=this.dom;i;)if(1==i.nodeType)!t&&e<this.scrollTargets.length&&this.scrollTargets[e]==i?e++:t||(t=this.scrollTargets.slice(0,e)),t&&t.push(i),i=i.assignedSlot||i.parentNode;else {if(11!=i.nodeType)break;i=i.host;}if(e<this.scrollTargets.length&&!t&&(t=this.scrollTargets.slice(0,e)),t){for(let e of this.scrollTargets)e.removeEventListener("scroll",this.onScroll);for(let e of this.scrollTargets=t)e.addEventListener("scroll",this.onScroll);}}ignore(e){if(!this.active)return e();try{return this.stop(),e()}finally{this.start(),this.clear();}}start(){this.active||(this.observer.observe(this.dom,observeOptions),useCharData&&this.dom.addEventListener("DOMCharacterDataModified",this.onCharData),this.active=true);}stop(){this.active&&(this.active=false,this.observer.disconnect(),useCharData&&this.dom.removeEventListener("DOMCharacterDataModified",this.onCharData));}clear(){this.processRecords(),this.queue.length=0,this.selectionChanged=false;}delayAndroidKey(e,t){var i;if(!this.delayedAndroidKey){let e=()=>{let e=this.delayedAndroidKey;e&&(this.clearDelayedAndroidKey(),!this.flush()&&e.force&&dispatchKey(this.dom,e.key,e.keyCode));};this.flushingAndroidKey=this.view.win.requestAnimationFrame(e);}this.delayedAndroidKey&&"Enter"!=e||(this.delayedAndroidKey={key:e,keyCode:t,force:this.lastChange<Date.now()-50||!!(null===(i=this.delayedAndroidKey)||void 0===i?void 0:i.force)});}clearDelayedAndroidKey(){this.win.cancelAnimationFrame(this.flushingAndroidKey),this.delayedAndroidKey=null,this.flushingAndroidKey=-1;}flushSoon(){this.delayedFlush<0&&(this.delayedFlush=this.view.win.requestAnimationFrame(()=>{this.delayedFlush=-1,this.flush();}));}forceFlush(){this.delayedFlush>=0&&(this.view.win.cancelAnimationFrame(this.delayedFlush),this.delayedFlush=-1),this.flush();}processRecords(){let e=this.queue;for(let t of this.observer.takeRecords())e.push(t);e.length&&(this.queue=[]);let t=-1,i=-1,n=false;for(let o of e){let e=this.readMutation(o);e&&(e.typeOver&&(n=true),-1==t?({from:t,to:i}=e):(t=Math.min(e.from,t),i=Math.max(e.to,i)));}return {from:t,to:i,typeOver:n}}readChange(){let{from:e,to:t,typeOver:i}=this.processRecords(),n=this.selectionChanged&&hasSelection(this.dom,this.selectionRange);return e<0&&!n?null:(e>-1&&(this.lastChange=Date.now()),this.view.inputState.lastFocusTime=0,this.selectionChanged=false,new DOMChange(this.view,e,t,i))}flush(e=true){if(this.delayedFlush>=0||this.delayedAndroidKey)return  false;e&&this.readSelectionRange();let t=this.readChange();if(!t)return  false;let i=this.view.state,n=applyDOMChange(this.view,t);return this.view.state==i&&this.view.update([]),n}readMutation(e){let t=this.view.docView.nearest(e.target);if(!t||t.ignoreMutation(e))return null;if(t.markDirty("attributes"==e.type),"attributes"==e.type&&(t.dirty|=4),"childList"==e.type){let i=findChild(t,e.previousSibling||e.target.previousSibling,-1),n=findChild(t,e.nextSibling||e.target.nextSibling,1);return {from:i?t.posAfter(i):t.posAtStart,to:n?t.posBefore(n):t.posAtEnd,typeOver:false}}return "characterData"==e.type?{from:t.posAtStart,to:t.posAtEnd,typeOver:e.target.nodeValue==e.oldValue}:null}setWindow(e){e!=this.win&&(this.removeWindowListeners(this.win),this.win=e,this.addWindowListeners(this.win));}addWindowListeners(e){e.addEventListener("resize",this.onResize),e.addEventListener("beforeprint",this.onPrint),e.addEventListener("scroll",this.onScroll),e.document.addEventListener("selectionchange",this.onSelectionChange);}removeWindowListeners(e){e.removeEventListener("scroll",this.onScroll),e.removeEventListener("resize",this.onResize),e.removeEventListener("beforeprint",this.onPrint),e.document.removeEventListener("selectionchange",this.onSelectionChange);}destroy(){var e,t,i;this.stop(),null===(e=this.intersection)||void 0===e||e.disconnect(),null===(t=this.gapIntersection)||void 0===t||t.disconnect(),null===(i=this.resize)||void 0===i||i.disconnect();for(let e of this.scrollTargets)e.removeEventListener("scroll",this.onScroll);this.removeWindowListeners(this.win),clearTimeout(this.parentCheck),clearTimeout(this.resizeTimeout),this.win.cancelAnimationFrame(this.delayedFlush),this.win.cancelAnimationFrame(this.flushingAndroidKey);}}function findChild(e,t,i){for(;t;){let n=ContentView.get(t);if(n&&n.parent==e)return n;let o=t.parentNode;t=o!=e.dom?o:i>0?t.nextSibling:t.previousSibling;}return null}function safariSelectionRangeHack(e){let t=null;function i(e){e.preventDefault(),e.stopImmediatePropagation(),t=e.getTargetRanges()[0];}if(e.contentDOM.addEventListener("beforeinput",i,true),e.dom.ownerDocument.execCommand("indent"),e.contentDOM.removeEventListener("beforeinput",i,true),!t)return null;let n=t.startContainer,o=t.startOffset,r=t.endContainer,s=t.endOffset,a=e.docView.domAtPos(e.state.selection.main.anchor);return isEquivalentPosition(a.node,a.offset,r,s)&&([n,o,r,s]=[r,s,n,o]),{anchorNode:n,anchorOffset:o,focusNode:r,focusOffset:s}}class EditorView{constructor(e={}){this.plugins=[],this.pluginMap=new Map,this.editorAttrs={},this.contentAttrs={},this.bidiCache=[],this.destroyed=false,this.updateState=2,this.measureScheduled=-1,this.measureRequests=[],this.contentDOM=document.createElement("div"),this.scrollDOM=document.createElement("div"),this.scrollDOM.tabIndex=-1,this.scrollDOM.className="cm-scroller",this.scrollDOM.appendChild(this.contentDOM),this.announceDOM=document.createElement("div"),this.announceDOM.style.cssText="position: absolute; top: -10000px",this.announceDOM.setAttribute("aria-live","polite"),this.dom=document.createElement("div"),this.dom.appendChild(this.announceDOM),this.dom.appendChild(this.scrollDOM),this._dispatch=e.dispatch||(e=>this.update([e])),this.dispatch=this.dispatch.bind(this),this._root=e.root||getRoot(e.parent)||document,this.viewState=new ViewState(e.state||EditorState.create(e)),this.plugins=this.state.facet(viewPlugin).map(e=>new PluginInstance(e));for(let e of this.plugins)e.update(this);this.observer=new DOMObserver(this),this.inputState=new InputState(this),this.inputState.ensureHandlers(this,this.plugins),this.docView=new DocView(this),this.mountStyles(),this.updateAttrs(),this.updateState=0,this.requestMeasure(),e.parent&&e.parent.appendChild(this.dom);}get state(){return this.viewState.state}get viewport(){return this.viewState.viewport}get visibleRanges(){return this.viewState.visibleRanges}get inView(){return this.viewState.inView}get composing(){return this.inputState.composing>0}get compositionStarted(){return this.inputState.composing>=0}get root(){return this._root}get win(){return this.dom.ownerDocument.defaultView||window}dispatch(...e){this._dispatch(1==e.length&&e[0]instanceof Transaction?e[0]:this.state.update(...e));}update(e){if(0!=this.updateState)throw new Error("Calls to EditorView.update are not allowed while an update is in progress");let t,i=false,n=false,o=this.state;for(let t of e){if(t.startState!=o)throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");o=t.state;}if(this.destroyed)return void(this.viewState.state=o);let r=this.observer.delayedAndroidKey,s=null;if(r?(this.observer.clearDelayedAndroidKey(),((s=this.observer.readChange())&&!this.state.doc.eq(o.doc)||!this.state.selection.eq(o.selection))&&(s=null)):this.observer.clear(),o.facet(EditorState.phrases)!=this.state.facet(EditorState.phrases))return this.setState(o);t=ViewUpdate.create(this,o,e);let a=this.viewState.scrollTarget;try{this.updateState=2;for(let t of e){if(a&&(a=a.map(t.changes)),t.scrollIntoView){let{main:e}=t.state.selection;a=new ScrollTarget(e.empty?e:EditorSelection.cursor(e.head,e.head>e.anchor?-1:1));}for(let e of t.effects)e.is(scrollIntoView)&&(a=e.value);}this.viewState.update(t,a),this.bidiCache=CachedOrder.update(this.bidiCache,t.changes),t.empty||(this.updatePlugins(t),this.inputState.update(t)),i=this.docView.update(t),this.state.facet(styleModule)!=this.styleModules&&this.mountStyles(),n=this.updateAttrs(),this.showAnnouncements(e),this.docView.updateSelection(i,e.some(e=>e.isUserEvent("select.pointer")));}finally{this.updateState=0;}if(t.startState.facet(theme)!=t.state.facet(theme)&&(this.viewState.mustMeasureContent=true),(i||n||a||this.viewState.mustEnforceCursorAssoc||this.viewState.mustMeasureContent)&&this.requestMeasure(),!t.empty)for(let e of this.state.facet(updateListener))e(t);s&&!applyDOMChange(this,s)&&r.force&&dispatchKey(this.contentDOM,r.key,r.keyCode);}setState(e){if(0!=this.updateState)throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");if(this.destroyed)return void(this.viewState.state=e);this.updateState=2;let t=this.hasFocus;try{for(let e of this.plugins)e.destroy(this);this.viewState=new ViewState(e),this.plugins=e.facet(viewPlugin).map(e=>new PluginInstance(e)),this.pluginMap.clear();for(let e of this.plugins)e.update(this);this.docView=new DocView(this),this.inputState.ensureHandlers(this,this.plugins),this.mountStyles(),this.updateAttrs(),this.bidiCache=[];}finally{this.updateState=0;}t&&this.focus(),this.requestMeasure();}updatePlugins(e){let t=e.startState.facet(viewPlugin),i=e.state.facet(viewPlugin);if(t!=i){let n=[];for(let o of i){let i=t.indexOf(o);if(i<0)n.push(new PluginInstance(o));else {let t=this.plugins[i];t.mustUpdate=e,n.push(t);}}for(let t of this.plugins)t.mustUpdate!=e&&t.destroy(this);this.plugins=n,this.pluginMap.clear(),this.inputState.ensureHandlers(this,this.plugins);}else for(let t of this.plugins)t.mustUpdate=e;for(let e=0;e<this.plugins.length;e++)this.plugins[e].update(this);}measure(e=true){if(this.destroyed)return;this.measureScheduled>-1&&cancelAnimationFrame(this.measureScheduled),this.measureScheduled=0,e&&this.observer.forceFlush();let t=null,{scrollHeight:i,scrollTop:n,clientHeight:o}=this.scrollDOM,r=n>i-o-4?i:n;try{for(let e=0;;e++){this.updateState=1;let i=this.viewport,n=this.viewState.lineBlockAtHeight(r),o=this.viewState.measure(this);if(!o&&!this.measureRequests.length&&null==this.viewState.scrollTarget)break;if(e>5){console.warn(this.measureRequests.length?"Measure loop restarted more than 5 times":"Viewport failed to stabilize");break}let s=[];4&o||([this.measureRequests,s]=[s,this.measureRequests]);let a=s.map(e=>{try{return e.read(this)}catch(e){return logException(this.state,e),BadMeasure}}),l=ViewUpdate.create(this,this.state,[]),h=!1,c=!1;l.flags|=o,t?t.flags|=o:t=l,this.updateState=2,l.empty||(this.updatePlugins(l),this.inputState.update(l),this.updateAttrs(),h=this.docView.update(l));for(let e=0;e<s.length;e++)if(a[e]!=BadMeasure)try{let t=s[e];t.write&&t.write(a[e],this);}catch(e){logException(this.state,e);}if(this.viewState.editorHeight)if(this.viewState.scrollTarget)this.docView.scrollIntoView(this.viewState.scrollTarget),this.viewState.scrollTarget=null,c=!0;else {let e=this.viewState.lineBlockAt(n.from).top-n.top;(e>1||e<-1)&&(this.scrollDOM.scrollTop+=e,c=!0);}if(h&&this.docView.updateSelection(!0),this.viewport.from==i.from&&this.viewport.to==i.to&&!c&&0==this.measureRequests.length)break}}finally{this.updateState=0,this.measureScheduled=-1;}if(t&&!t.empty)for(let e of this.state.facet(updateListener))e(t);}get themeClasses(){return baseThemeID+" "+(this.state.facet(darkTheme)?baseDarkID:baseLightID)+" "+this.state.facet(theme)}updateAttrs(){let e=attrsFromFacet(this,editorAttributes,{class:"cm-editor"+(this.hasFocus?" cm-focused ":" ")+this.themeClasses}),t={spellcheck:"false",autocorrect:"off",autocapitalize:"off",translate:"no",contenteditable:this.state.facet(editable)?"true":"false",class:"cm-content",style:`${browser.tabSize}: ${this.state.tabSize}`,role:"textbox","aria-multiline":"true"};this.state.readOnly&&(t["aria-readonly"]="true"),attrsFromFacet(this,contentAttributes,t);let i=this.observer.ignore(()=>{let i=updateAttrs(this.contentDOM,this.contentAttrs,t),n=updateAttrs(this.dom,this.editorAttrs,e);return i||n});return this.editorAttrs=e,this.contentAttrs=t,i}showAnnouncements(e){let t=true;for(let i of e)for(let e of i.effects)if(e.is(EditorView.announce)){t&&(this.announceDOM.textContent=""),t=false,this.announceDOM.appendChild(document.createElement("div")).textContent=e.value;}}mountStyles(){this.styleModules=this.state.facet(styleModule),StyleModule.mount(this.root,this.styleModules.concat(baseTheme$1).reverse());}readMeasured(){if(2==this.updateState)throw new Error("Reading the editor layout isn't allowed during an update");0==this.updateState&&this.measureScheduled>-1&&this.measure(false);}requestMeasure(e){if(this.measureScheduled<0&&(this.measureScheduled=this.win.requestAnimationFrame(()=>this.measure())),e){if(null!=e.key)for(let t=0;t<this.measureRequests.length;t++)if(this.measureRequests[t].key===e.key)return void(this.measureRequests[t]=e);this.measureRequests.push(e);}}plugin(e){let t=this.pluginMap.get(e);return (void 0===t||t&&t.spec!=e)&&this.pluginMap.set(e,t=this.plugins.find(t=>t.spec==e)||null),t&&t.update(this).value}get documentTop(){return this.contentDOM.getBoundingClientRect().top+this.viewState.paddingTop}get documentPadding(){return {top:this.viewState.paddingTop,bottom:this.viewState.paddingBottom}}elementAtHeight(e){return this.readMeasured(),this.viewState.elementAtHeight(e)}lineBlockAtHeight(e){return this.readMeasured(),this.viewState.lineBlockAtHeight(e)}get viewportLineBlocks(){return this.viewState.viewportLines}lineBlockAt(e){return this.viewState.lineBlockAt(e)}get contentHeight(){return this.viewState.contentHeight}moveByChar(e,t,i){return skipAtoms(this,e,moveByChar(this,e,t,i))}moveByGroup(e,t){return skipAtoms(this,e,moveByChar(this,e,t,t=>byGroup(this,e.head,t)))}moveToLineBoundary(e,t,i=true){return moveToLineBoundary(this,e,t,i)}moveVertically(e,t,i){return skipAtoms(this,e,moveVertically(this,e,t,i))}domAtPos(e){return this.docView.domAtPos(e)}posAtDOM(e,t=0){return this.docView.posFromDOM(e,t)}posAtCoords(e,t=true){return this.readMeasured(),posAtCoords(this,e,t)}coordsAtPos(e,t=1){this.readMeasured();let i=this.docView.coordsAt(e,t);if(!i||i.left==i.right)return i;let n=this.state.doc.lineAt(e),o=this.bidiSpans(n);return flattenRect(i,o[BidiSpan.find(o,e-n.from,-1,t)].dir==Direction.LTR==t>0)}get defaultCharacterWidth(){return this.viewState.heightOracle.charWidth}get defaultLineHeight(){return this.viewState.heightOracle.lineHeight}get textDirection(){return this.viewState.defaultTextDirection}textDirectionAt(e){return !this.state.facet(perLineTextDirection)||e<this.viewport.from||e>this.viewport.to?this.textDirection:(this.readMeasured(),this.docView.textDirectionAt(e))}get lineWrapping(){return this.viewState.heightOracle.lineWrapping}bidiSpans(e){if(e.length>MaxBidiLine)return trivialOrder(e.length);let t=this.textDirectionAt(e.from);for(let i of this.bidiCache)if(i.from==e.from&&i.dir==t)return i.order;let i=computeOrder(e.text,t);return this.bidiCache.push(new CachedOrder(e.from,e.to,t,i)),i}get hasFocus(){var e;return (this.dom.ownerDocument.hasFocus()||browser.safari&&(null===(e=this.inputState)||void 0===e?void 0:e.lastContextMenu)>Date.now()-3e4)&&this.root.activeElement==this.contentDOM}focus(){this.observer.ignore(()=>{focusPreventScroll(this.contentDOM),this.docView.updateSelection();});}setRoot(e){this._root!=e&&(this._root=e,this.observer.setWindow((9==e.nodeType?e:e.ownerDocument).defaultView||window),this.mountStyles());}destroy(){for(let e of this.plugins)e.destroy(this);this.plugins=[],this.inputState.destroy(),this.dom.remove(),this.observer.destroy(),this.measureScheduled>-1&&cancelAnimationFrame(this.measureScheduled),this.destroyed=true;}static scrollIntoView(e,t={}){return scrollIntoView.of(new ScrollTarget("number"==typeof e?EditorSelection.cursor(e):e,t.y,t.x,t.yMargin,t.xMargin))}static domEventHandlers(e){return ViewPlugin.define(()=>({}),{eventHandlers:e})}static theme(e,t){let i=StyleModule.newName(),n=[theme.of(i),styleModule.of(buildTheme(`.${i}`,e))];return t&&t.dark&&n.push(darkTheme.of(true)),n}static baseTheme(e){return Prec.lowest(styleModule.of(buildTheme("."+baseThemeID,e,lightDarkIDs)))}static findFromDOM(e){var t;let i=e.querySelector(".cm-content"),n=i&&ContentView.get(i)||ContentView.get(e);return (null===(t=null===n||void 0===n?void 0:n.rootView)||void 0===t?void 0:t.view)||null}}EditorView.styleModule=styleModule,EditorView.inputHandler=inputHandler,EditorView.perLineTextDirection=perLineTextDirection,EditorView.exceptionSink=exceptionSink,EditorView.updateListener=updateListener,EditorView.editable=editable,EditorView.mouseSelectionStyle=mouseSelectionStyle,EditorView.dragMovesSelection=dragMovesSelection$1,EditorView.clickAddsSelectionRange=clickAddsSelectionRange,EditorView.decorations=decorations,EditorView.atomicRanges=atomicRanges,EditorView.scrollMargins=scrollMargins,EditorView.darkTheme=darkTheme,EditorView.contentAttributes=contentAttributes,EditorView.editorAttributes=editorAttributes,EditorView.lineWrapping=EditorView.contentAttributes.of({class:"cm-lineWrapping"}),EditorView.announce=StateEffect.define();const MaxBidiLine=4096,BadMeasure={};class CachedOrder{constructor(e,t,i,n){this.from=e,this.to=t,this.dir=i,this.order=n;}static update(e,t){if(t.empty)return e;let i=[],n=e.length?e[e.length-1].dir:Direction.LTR;for(let o=Math.max(0,e.length-10);o<e.length;o++){let r=e[o];r.dir!=n||t.touchesRange(r.from,r.to)||i.push(new CachedOrder(t.mapPos(r.from,1),t.mapPos(r.to,-1),r.dir,r.order));}return i}}function attrsFromFacet(e,t,i){for(let n=e.state.facet(t),o=n.length-1;o>=0;o--){let t=n[o],r="function"==typeof t?t(e):t;r&&combineAttrs(r,i);}return i}const currentPlatform=browser.mac?"mac":browser.windows?"win":browser.linux?"linux":"key";function normalizeKeyName(e,t){const i=e.split(/-(?!$)/);let n,o,r,s,a=i[i.length-1];"Space"==a&&(a=" ");for(let e=0;e<i.length-1;++e){const a=i[e];if(/^(cmd|meta|m)$/i.test(a))s=true;else if(/^a(lt)?$/i.test(a))n=true;else if(/^(c|ctrl|control)$/i.test(a))o=true;else if(/^s(hift)?$/i.test(a))r=true;else {if(!/^mod$/i.test(a))throw new Error("Unrecognized modifier name: "+a);"mac"==t?s=true:o=true;}}return n&&(a="Alt-"+a),o&&(a="Ctrl-"+a),s&&(a="Meta-"+a),r&&(a="Shift-"+a),a}function modifiers(e,t,i){return t.altKey&&(e="Alt-"+e),t.ctrlKey&&(e="Ctrl-"+e),t.metaKey&&(e="Meta-"+e),false!==i&&t.shiftKey&&(e="Shift-"+e),e}const handleKeyEvents=Prec.default(EditorView.domEventHandlers({keydown:(e,t)=>runHandlers(getKeymap(t.state),e,t,"editor")})),keymap=Facet.define({enables:handleKeyEvents}),Keymaps=new WeakMap;function getKeymap(e){let t=e.facet(keymap),i=Keymaps.get(t);return i||Keymaps.set(t,i=buildKeymap(t.reduce((e,t)=>e.concat(t),[]))),i}let storedPrefix=null;const PrefixTimeout=4e3;function buildKeymap(e,t=currentPlatform){let i=Object.create(null),n=Object.create(null),o=(e,t)=>{let i=n[e];if(null==i)n[e]=t;else if(i!=t)throw new Error("Key binding "+e+" is used both as a regular binding and as a multi-stroke prefix")},r=(e,n,r,s)=>{var a,l;let h=i[e]||(i[e]=Object.create(null)),c=n.split(/ (?!$)/).map(e=>normalizeKeyName(e,t));for(let t=1;t<c.length;t++){let i=c.slice(0,t).join(" ");o(i,true),h[i]||(h[i]={preventDefault:true,run:[t=>{let n=storedPrefix={view:t,prefix:i,scope:e};return setTimeout(()=>{storedPrefix==n&&(storedPrefix=null);},PrefixTimeout),true}]});}let d=c.join(" ");o(d,false);let u=h[d]||(h[d]={preventDefault:false,run:(null===(l=null===(a=h._any)||void 0===a?void 0:a.run)||void 0===l?void 0:l.slice())||[]});r&&u.run.push(r),s&&(u.preventDefault=true);};for(let n of e){let e=n.scope?n.scope.split(" "):["editor"];if(n.any)for(let t of e){let e=i[t]||(i[t]=Object.create(null));e._any||(e._any={preventDefault:false,run:[]});for(let t in e)e[t].run.push(n.any);}let o=n[t]||n.key;if(o)for(let t of e)r(t,o,n.run,n.preventDefault),n.shift&&r(t,"Shift-"+o,n.shift,n.preventDefault);}return i}function runHandlers(e,t,i,n){let o=keyName(t),r=codePointSize(codePointAt(o,0))==o.length&&" "!=o,s="",a=false;storedPrefix&&storedPrefix.view==i&&storedPrefix.scope==n&&(s=storedPrefix.prefix+" ",(a=modifierCodes.indexOf(t.keyCode)<0)&&(storedPrefix=null));let l,h,c=new Set,d=e=>{if(e){for(let n of e.run)if(!c.has(n)&&(c.add(n),n(i,t)))return  true;e.preventDefault&&(a=true);}return  false},u=e[n];if(u){if(d(u[s+modifiers(o,t,!r)]))return  true;if(r&&(t.altKey||t.metaKey||t.ctrlKey)&&(l=base[t.keyCode])&&l!=o){if(d(u[s+modifiers(l,t,true)]))return  true;if(t.shiftKey&&(h=shift[t.keyCode])!=o&&h!=l&&d(u[s+modifiers(h,t,false)]))return  true}else if(r&&t.shiftKey&&d(u[s+modifiers(o,t,true)]))return  true;if(d(u._any))return  true}return a}class RectangleMarker{constructor(e,t,i,n,o){this.className=e,this.left=t,this.top=i,this.width=n,this.height=o;}draw(){let e=document.createElement("div");return e.className=this.className,this.adjust(e),e}update(e,t){return t.className==this.className&&(this.adjust(e),true)}adjust(e){e.style.left=this.left+"px",e.style.top=this.top+"px",this.width>=0&&(e.style.width=this.width+"px"),e.style.height=this.height+"px";}eq(e){return this.left==e.left&&this.top==e.top&&this.width==e.width&&this.height==e.height&&this.className==e.className}}function sameMarker(e,t){return e.constructor==t.constructor&&e.eq(t)}class LayerView{constructor(e,t){this.view=e,this.layer=t,this.drawn=[],this.measureReq={read:this.measure.bind(this),write:this.draw.bind(this)},this.dom=e.scrollDOM.appendChild(document.createElement("div")),this.dom.classList.add("cm-layer"),t.above&&this.dom.classList.add("cm-layer-above"),t.class&&this.dom.classList.add(t.class),this.dom.setAttribute("aria-hidden","true"),this.setOrder(e.state),e.requestMeasure(this.measureReq),t.mount&&t.mount(this.dom,e);}update(e){e.startState.facet(layerOrder)!=e.state.facet(layerOrder)&&this.setOrder(e.state),(this.layer.update(e,this.dom)||e.geometryChanged)&&e.view.requestMeasure(this.measureReq);}setOrder(e){let t=0,i=e.facet(layerOrder);for(;t<i.length&&i[t]!=this.layer;)t++;this.dom.style.zIndex=String((this.layer.above?150:-1)-t);}measure(){return this.layer.markers(this.view)}draw(e){if(e.length!=this.drawn.length||e.some((e,t)=>!sameMarker(e,this.drawn[t]))){let t=this.dom.firstChild,i=0;for(let n of e)n.update&&t&&n.constructor&&this.drawn[i].constructor&&n.update(t,this.drawn[i])?(t=t.nextSibling,i++):this.dom.insertBefore(n.draw(),t);for(;t;){let e=t.nextSibling;t.remove(),t=e;}this.drawn=e;}}destroy(){this.dom.remove();}}const layerOrder=Facet.define();function layer(e){return [ViewPlugin.define(t=>new LayerView(t,e)),layerOrder.of(e)]}const CanHidePrimary=!browser.ios,selectionConfig=Facet.define({combine:e=>combineConfig(e,{cursorBlinkRate:1200,drawRangeCursor:true},{cursorBlinkRate:(e,t)=>Math.min(e,t),drawRangeCursor:(e,t)=>e||t})});function drawSelection(e={}){return [selectionConfig.of(e),cursorLayer,selectionLayer,hideNativeSelection,nativeSelectionHidden.of(true)]}function configChanged(e){return e.startState.facet(selectionConfig)!=e.startState.facet(selectionConfig)}const cursorLayer=layer({above:true,markers(e){let{state:t}=e,i=t.facet(selectionConfig),n=[];for(let o of t.selection.ranges){let r=o==t.selection.main;if(o.empty?!r||CanHidePrimary:i.drawRangeCursor){let t=measureCursor(e,o,r);t&&n.push(t);}}return n},update(e,t){e.transactions.some(e=>e.scrollIntoView)&&(t.style.animationName="cm-blink"==t.style.animationName?"cm-blink2":"cm-blink");let i=configChanged(e);return i&&setBlinkRate(e.state,t),e.docChanged||e.selectionSet||i},mount(e,t){setBlinkRate(t.state,e);},class:"cm-cursorLayer"});function setBlinkRate(e,t){t.style.animationDuration=e.facet(selectionConfig).cursorBlinkRate+"ms";}const selectionLayer=layer({above:false,markers:e=>e.state.selection.ranges.map(t=>t.empty?[]:measureRange(e,t)).reduce((e,t)=>e.concat(t)),update:(e,t)=>e.docChanged||e.selectionSet||e.viewportChanged||configChanged(e),class:"cm-selectionLayer"}),themeSpec={".cm-line":{"& ::selection":{backgroundColor:"transparent !important"},"&::selection":{backgroundColor:"transparent !important"}}};CanHidePrimary&&(themeSpec[".cm-line"].caretColor="transparent !important");const hideNativeSelection=Prec.highest(EditorView.theme(themeSpec));function getBase(e){let t=e.scrollDOM.getBoundingClientRect();return {left:(e.textDirection==Direction.LTR?t.left:t.right-e.scrollDOM.clientWidth)-e.scrollDOM.scrollLeft,top:t.top-e.scrollDOM.scrollTop}}function wrappedLine(e,t,i){let n=EditorSelection.cursor(t);return {from:Math.max(i.from,e.moveToLineBoundary(n,false,true).from),to:Math.min(i.to,e.moveToLineBoundary(n,true,true).from),type:BlockType.Text}}function blockAt(e,t){let i=e.lineBlockAt(t);if(Array.isArray(i.type))for(let e of i.type)if(e.to>t||e.to==t&&(e.to==i.to||e.type==BlockType.Text))return e;return i}function measureRange(e,t){if(t.to<=e.viewport.from||t.from>=e.viewport.to)return [];let i=Math.max(t.from,e.viewport.from),n=Math.min(t.to,e.viewport.to),o=e.textDirection==Direction.LTR,r=e.contentDOM,s=r.getBoundingClientRect(),a=getBase(e),l=window.getComputedStyle(r.firstChild),h=s.left+parseInt(l.paddingLeft)+Math.min(0,parseInt(l.textIndent)),c=s.right-parseInt(l.paddingRight),d=blockAt(e,i),u=blockAt(e,n),f=d.type==BlockType.Text?d:null,p=u.type==BlockType.Text?u:null;if(e.lineWrapping&&(f&&(f=wrappedLine(e,i,f)),p&&(p=wrappedLine(e,n,p))),f&&p&&f.from==p.from)return g(m(t.from,t.to,f));{let i=f?m(t.from,null,f):S(d,false),n=p?m(null,t.to,p):S(u,true),o=[];return (f||d).to<(p||u).from-1?o.push(O(h,i.bottom,c,n.top)):i.bottom<n.top&&e.elementAtHeight((i.bottom+n.top)/2).type==BlockType.Text&&(i.bottom=n.top=(i.bottom+n.top)/2),g(i).concat(o).concat(g(n))}function O(e,t,i,n){return new RectangleMarker("cm-selectionBackground",e-a.left,t-a.top-.01,i-e,n-t+.01)}function g({top:e,bottom:t,horizontal:i}){let n=[];for(let o=0;o<i.length;o+=2)n.push(O(i[o],e,i[o+1],t));return n}function m(t,i,n){let r=1e9,s=-1e9,a=[];function l(t,i,l,d,u){let f=e.coordsAtPos(t,t==n.to?-2:2),p=e.coordsAtPos(l,l==n.from?2:-2);r=Math.min(f.top,p.top,r),s=Math.max(f.bottom,p.bottom,s),u==Direction.LTR?a.push(o&&i?h:f.left,o&&d?c:p.right):a.push(!o&&d?h:p.left,!o&&i?c:f.right);}let d=null!==t&&void 0!==t?t:n.from,u=null!==i&&void 0!==i?i:n.to;for(let n of e.visibleRanges)if(n.to>d&&n.from<u)for(let o=Math.max(n.from,d),r=Math.min(n.to,u);;){let n=e.state.doc.lineAt(o);for(let s of e.bidiSpans(n)){let e=s.from+n.from,a=s.to+n.from;if(e>=r)break;a>o&&l(Math.max(e,o),null==t&&e<=d,Math.min(a,r),null==i&&a>=u,s.dir);}if((o=n.to+1)>=r)break}return 0==a.length&&l(d,null==t,u,null==i,e.textDirection),{top:r,bottom:s,horizontal:a}}function S(e,t){let i=s.top+(t?e.top:e.bottom);return {top:i,bottom:i,horizontal:[]}}}function measureCursor(e,t,i){let n=e.coordsAtPos(t.head,t.assoc||1);if(!n)return null;let o=getBase(e);return new RectangleMarker(i?"cm-cursor cm-cursor-primary":"cm-cursor cm-cursor-secondary",n.left-o.left,n.top-o.top,-1,n.bottom-n.top)}const setDropCursorPos=StateEffect.define({map:(e,t)=>null==e?null:t.mapPos(e)}),dropCursorPos=StateField.define({create:()=>null,update:(e,t)=>(null!=e&&(e=t.changes.mapPos(e)),t.effects.reduce((e,t)=>t.is(setDropCursorPos)?t.value:e,e))});ViewPlugin.fromClass(class{constructor(e){this.view=e,this.cursor=null,this.measureReq={read:this.readPos.bind(this),write:this.drawCursor.bind(this)};}update(e){var t;let i=e.state.field(dropCursorPos);null==i?null!=this.cursor&&(null===(t=this.cursor)||void 0===t||t.remove(),this.cursor=null):(this.cursor||(this.cursor=this.view.scrollDOM.appendChild(document.createElement("div")),this.cursor.className="cm-dropCursor"),(e.startState.field(dropCursorPos)!=i||e.docChanged||e.geometryChanged)&&this.view.requestMeasure(this.measureReq));}readPos(){let e=this.view.state.field(dropCursorPos),t=null!=e&&this.view.coordsAtPos(e);if(!t)return null;let i=this.view.scrollDOM.getBoundingClientRect();return {left:t.left-i.left+this.view.scrollDOM.scrollLeft,top:t.top-i.top+this.view.scrollDOM.scrollTop,height:t.bottom-t.top}}drawCursor(e){this.cursor&&(e?(this.cursor.style.left=e.left+"px",this.cursor.style.top=e.top+"px",this.cursor.style.height=e.height+"px"):this.cursor.style.left="-100000px");}destroy(){this.cursor&&this.cursor.remove();}setDropPos(e){this.view.state.field(dropCursorPos)!=e&&this.view.dispatch({effects:setDropCursorPos.of(e)});}},{eventHandlers:{dragover(e){this.setDropPos(this.view.posAtCoords({x:e.clientX,y:e.clientY}));},dragleave(e){e.target!=this.view.contentDOM&&this.view.contentDOM.contains(e.relatedTarget)||this.setDropPos(null);},dragend(){this.setDropPos(null);},drop(){this.setDropPos(null);}}});function iterMatches(e,t,i,n,o){t.lastIndex=0;for(let r,s=e.iterRange(i,n),a=i;!s.next().done;a+=s.value.length)if(!s.lineBreak)for(;r=t.exec(s.value);)o(a+r.index,r);}function matchRanges(e,t){let i=e.visibleRanges;if(1==i.length&&i[0].from==e.viewport.from&&i[0].to==e.viewport.to)return i;let n=[];for(let{from:o,to:r}of i)o=Math.max(e.state.doc.lineAt(o).from,o-t),r=Math.min(e.state.doc.lineAt(r).to,r+t),n.length&&n[n.length-1].to>=o?n[n.length-1].to=r:n.push({from:o,to:r});return n}class MatchDecorator{constructor(e){const{regexp:t,decoration:i,decorate:n,boundary:o,maxLength:r=1e3}=e;if(!t.global)throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");if(this.regexp=t,n)this.addMatch=((e,t,i,o)=>n(o,i,i+e[0].length,e,t));else if("function"==typeof i)this.addMatch=((e,t,n,o)=>{let r=i(e,t,n);r&&o(n,n+e[0].length,r);});else {if(!i)throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");this.addMatch=((e,t,n,o)=>o(n,n+e[0].length,i));}this.boundary=o,this.maxLength=r;}createDeco(e){let t=new RangeSetBuilder,i=t.add.bind(t);for(let{from:t,to:n}of matchRanges(e,this.maxLength))iterMatches(e.state.doc,this.regexp,t,n,(t,n)=>this.addMatch(n,e,t,i));return t.finish()}updateDeco(e,t){let i=1e9,n=-1;return e.docChanged&&e.changes.iterChanges((t,o,r,s)=>{s>e.view.viewport.from&&r<e.view.viewport.to&&(i=Math.min(r,i),n=Math.max(s,n));}),e.viewportChanged||n-i>1e3?this.createDeco(e.view):n>-1?this.updateRange(e.view,t.map(e.changes),i,n):t}updateRange(e,t,i,n){for(let o of e.visibleRanges){let r=Math.max(o.from,i),s=Math.min(o.to,n);if(s>r){let i=e.state.doc.lineAt(r),n=i.to<s?e.state.doc.lineAt(s):i,a=Math.max(o.from,i.from),l=Math.min(o.to,n.to);if(this.boundary){for(;r>i.from;r--)if(this.boundary.test(i.text[r-1-i.from])){a=r;break}for(;s<n.to;s++)if(this.boundary.test(n.text[s-n.from])){l=s;break}}let h,c=[],d=(e,t,i)=>c.push(i.range(e,t));if(i==n)for(this.regexp.lastIndex=a-i.from;(h=this.regexp.exec(i.text))&&h.index<l-i.from;)this.addMatch(h,e,h.index+i.from,d);else iterMatches(e.state.doc,this.regexp,a,l,(t,i)=>this.addMatch(i,e,t,d));t=t.update({filterFrom:a,filterTo:l,filter:(e,t)=>e<a||t>l,add:c});}}return t}}const UnicodeRegexpSupport=null!=/x/.unicode?"gu":"g",Specials=new RegExp("[\0-\b\n--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\ufeff￹-￼]",UnicodeRegexpSupport),Names={0:"null",7:"bell",8:"backspace",10:"newline",11:"vertical tab",13:"carriage return",27:"escape",8203:"zero width space",8204:"zero width non-joiner",8205:"zero width joiner",8206:"left-to-right mark",8207:"right-to-left mark",8232:"line separator",8237:"left-to-right override",8238:"right-to-left override",8294:"left-to-right isolate",8295:"right-to-left isolate",8297:"pop directional isolate",8233:"paragraph separator",65279:"zero width no-break space",65532:"object replacement"};let _supportsTabSize=null;function supportsTabSize(){var e;if(null==_supportsTabSize&&"undefined"!=typeof document&&document.body){let t=document.body.style;_supportsTabSize=null!=(null!==(e=t.tabSize)&&void 0!==e?e:t.MozTabSize);}return _supportsTabSize||false}const specialCharConfig=Facet.define({combine(e){let t=combineConfig(e,{render:null,specialChars:Specials,addSpecialChars:null});return (t.replaceTabs=!supportsTabSize())&&(t.specialChars=new RegExp("\t|"+t.specialChars.source,UnicodeRegexpSupport)),t.addSpecialChars&&(t.specialChars=new RegExp(t.specialChars.source+"|"+t.addSpecialChars.source,UnicodeRegexpSupport)),t}});function highlightSpecialChars(e={}){return [specialCharConfig.of(e),specialCharPlugin()]}let _plugin=null;function specialCharPlugin(){return _plugin||(_plugin=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.decorations=Decoration.none,this.decorationCache=Object.create(null),this.decorator=this.makeDecorator(e.state.facet(specialCharConfig)),this.decorations=this.decorator.createDeco(e);}makeDecorator(e){return new MatchDecorator({regexp:e.specialChars,decoration:(t,i,n)=>{let{doc:o}=i.state,r=codePointAt(t[0],0);if(9==r){let e=o.lineAt(n),t=i.state.tabSize,r=countColumn(e.text,t,n-e.from);return Decoration.replace({widget:new TabWidget((t-r%t)*this.view.defaultCharacterWidth)})}return this.decorationCache[r]||(this.decorationCache[r]=Decoration.replace({widget:new SpecialCharWidget(e,r)}))},boundary:e.replaceTabs?void 0:/[^]/})}update(e){let t=e.state.facet(specialCharConfig);e.startState.facet(specialCharConfig)!=t?(this.decorator=this.makeDecorator(t),this.decorations=this.decorator.createDeco(e.view)):this.decorations=this.decorator.updateDeco(e,this.decorations);}},{decorations:e=>e.decorations}))}const DefaultPlaceholder="•";function placeholder$1(e){return e>=32?DefaultPlaceholder:10==e?"␤":String.fromCharCode(9216+e)}class SpecialCharWidget extends WidgetType{constructor(e,t){super(),this.options=e,this.code=t;}eq(e){return e.code==this.code}toDOM(e){let t=placeholder$1(this.code),i=e.state.phrase("Control character")+" "+(Names[this.code]||"0x"+this.code.toString(16)),n=this.options.render&&this.options.render(this.code,i,t);if(n)return n;let o=document.createElement("span");return o.textContent=t,o.title=i,o.setAttribute("aria-label",i),o.className="cm-specialChar",o}ignoreEvent(){return  false}}class TabWidget extends WidgetType{constructor(e){super(),this.width=e;}eq(e){return e.width==this.width}toDOM(){let e=document.createElement("span");return e.textContent="\t",e.className="cm-tab",e.style.width=this.width+"px",e}ignoreEvent(){return  false}}ViewPlugin.fromClass(class{constructor(){this.height=1e3,this.attrs={style:"padding-bottom: 1000px"};}update(e){let{view:t}=e,i=t.viewState.editorHeight-t.defaultLineHeight-t.documentPadding.top-.5;i!=this.height&&(this.height=i,this.attrs={style:`padding-bottom: ${i}px`});}});const lineDeco=Decoration.line({class:"cm-activeLine"});ViewPlugin.fromClass(class{constructor(e){this.decorations=this.getDeco(e);}update(e){(e.docChanged||e.selectionSet)&&(this.decorations=this.getDeco(e.view));}getDeco(e){let t=-1,i=[];for(let n of e.state.selection.ranges){let o=e.lineBlockAt(n.head);o.from>t&&(i.push(lineDeco.range(o.from)),t=o.from);}return Decoration.set(i)}},{decorations:e=>e.decorations});const Outside="-10000px";class TooltipViewManager{constructor(e,t,i){this.facet=t,this.createTooltipView=i,this.input=e.state.facet(t),this.tooltips=this.input.filter(e=>e),this.tooltipViews=this.tooltips.map(i);}update(e){var t;let i=e.state.facet(this.facet),n=i.filter(e=>e);if(i===this.input){for(let t of this.tooltipViews)t.update&&t.update(e);return  false}let o=[];for(let t=0;t<n.length;t++){let i=n[t],r=-1;if(i){for(let e=0;e<this.tooltips.length;e++){let t=this.tooltips[e];t&&t.create==i.create&&(r=e);}if(r<0)o[t]=this.createTooltipView(i);else {let i=o[t]=this.tooltipViews[r];i.update&&i.update(e);}}}for(let e of this.tooltipViews)o.indexOf(e)<0&&(e.dom.remove(),null===(t=e.destroy)||void 0===t||t.call(e));return this.input=i,this.tooltips=n,this.tooltipViews=o,true}}function windowSpace(e){let{win:t}=e;return {top:0,left:0,bottom:t.innerHeight,right:t.innerWidth}}const tooltipConfig=Facet.define({combine:e=>{var t,i,n;return {position:browser.ios?"absolute":(null===(t=e.find(e=>e.position))||void 0===t?void 0:t.position)||"fixed",parent:(null===(i=e.find(e=>e.parent))||void 0===i?void 0:i.parent)||null,tooltipSpace:(null===(n=e.find(e=>e.tooltipSpace))||void 0===n?void 0:n.tooltipSpace)||windowSpace}}}),tooltipPlugin=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.inView=true,this.lastTransaction=0,this.measureTimeout=-1;let t=e.state.facet(tooltipConfig);this.position=t.position,this.parent=t.parent,this.classes=e.themeClasses,this.createContainer(),this.measureReq={read:this.readMeasure.bind(this),write:this.writeMeasure.bind(this),key:this},this.manager=new TooltipViewManager(e,showTooltip,e=>this.createTooltip(e)),this.intersectionObserver="function"==typeof IntersectionObserver?new IntersectionObserver(e=>{Date.now()>this.lastTransaction-50&&e.length>0&&e[e.length-1].intersectionRatio<1&&this.measureSoon();},{threshold:[1]}):null,this.observeIntersection(),e.win.addEventListener("resize",this.measureSoon=this.measureSoon.bind(this)),this.maybeMeasure();}createContainer(){this.parent?(this.container=document.createElement("div"),this.container.style.position="relative",this.container.className=this.view.themeClasses,this.parent.appendChild(this.container)):this.container=this.view.dom;}observeIntersection(){if(this.intersectionObserver){this.intersectionObserver.disconnect();for(let e of this.manager.tooltipViews)this.intersectionObserver.observe(e.dom);}}measureSoon(){this.measureTimeout<0&&(this.measureTimeout=setTimeout(()=>{this.measureTimeout=-1,this.maybeMeasure();},50));}update(e){e.transactions.length&&(this.lastTransaction=Date.now());let t=this.manager.update(e);t&&this.observeIntersection();let i=t||e.geometryChanged,n=e.state.facet(tooltipConfig);if(n.position!=this.position){this.position=n.position;for(let e of this.manager.tooltipViews)e.dom.style.position=this.position;i=true;}if(n.parent!=this.parent){this.parent&&this.container.remove(),this.parent=n.parent,this.createContainer();for(let e of this.manager.tooltipViews)this.container.appendChild(e.dom);i=true;}else this.parent&&this.view.themeClasses!=this.classes&&(this.classes=this.container.className=this.view.themeClasses);i&&this.maybeMeasure();}createTooltip(e){let t=e.create(this.view);if(t.dom.classList.add("cm-tooltip"),e.arrow&&!t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")){let e=document.createElement("div");e.className="cm-tooltip-arrow",t.dom.appendChild(e);}return t.dom.style.position=this.position,t.dom.style.top=Outside,this.container.appendChild(t.dom),t.mount&&t.mount(this.view),t}destroy(){var e,t;this.view.win.removeEventListener("resize",this.measureSoon);for(let t of this.manager.tooltipViews)t.dom.remove(),null===(e=t.destroy)||void 0===e||e.call(t);null===(t=this.intersectionObserver)||void 0===t||t.disconnect(),clearTimeout(this.measureTimeout);}readMeasure(){let e=this.view.dom.getBoundingClientRect();return {editor:e,parent:this.parent?this.container.getBoundingClientRect():e,pos:this.manager.tooltips.map((e,t)=>{let i=this.manager.tooltipViews[t];return i.getCoords?i.getCoords(e.pos):this.view.coordsAtPos(e.pos)}),size:this.manager.tooltipViews.map(({dom:e})=>e.getBoundingClientRect()),space:this.view.state.facet(tooltipConfig).tooltipSpace(this.view)}}writeMeasure(e){let{editor:t,space:i}=e,n=[];for(let o=0;o<this.manager.tooltips.length;o++){let r=this.manager.tooltips[o],s=this.manager.tooltipViews[o],{dom:a}=s,l=e.pos[o],h=e.size[o];if(!l||l.bottom<=Math.max(t.top,i.top)||l.top>=Math.min(t.bottom,i.bottom)||l.right<Math.max(t.left,i.left)-.1||l.left>Math.min(t.right,i.right)+.1){a.style.top=Outside;continue}let c=r.arrow?s.dom.querySelector(".cm-tooltip-arrow"):null,d=c?7:0,u=h.right-h.left,f=h.bottom-h.top,p=s.offset||noOffset,O=this.view.textDirection==Direction.LTR,g=h.width>i.right-i.left?O?i.left:i.right-h.width:O?Math.min(l.left-(c?14:0)+p.x,i.right-u):Math.max(i.left,l.left-u+(c?14:0)-p.x),m=!!r.above;!r.strictSide&&(m?l.top-(h.bottom-h.top)-p.y<i.top:l.bottom+(h.bottom-h.top)+p.y>i.bottom)&&m==i.bottom-l.bottom>l.top-i.top&&(m=!m);let S=(m?l.top-i.top:i.bottom-l.bottom)-d;if(S<f&&false!==s.resize){if(S<this.view.defaultLineHeight){a.style.top=Outside;continue}a.style.height=(f=S)+"px";}else a.style.height&&(a.style.height="");let b=m?l.top-f-d-p.y:l.bottom+d+p.y,y=g+u;if(true!==s.overlap)for(let e of n)e.left<y&&e.right>g&&e.top<b+f&&e.bottom>b&&(b=m?e.top-f-2-d:e.bottom+d+2);"absolute"==this.position?(a.style.top=b-e.parent.top+"px",a.style.left=g-e.parent.left+"px"):(a.style.top=b+"px",a.style.left=g+"px"),c&&(c.style.left=`${l.left+(O?p.x:-p.x)-(g+14-7)}px`),true!==s.overlap&&n.push({left:g,top:b,right:y,bottom:b+f}),a.classList.toggle("cm-tooltip-above",m),a.classList.toggle("cm-tooltip-below",!m),s.positioned&&s.positioned(e.space);}}maybeMeasure(){if(this.manager.tooltips.length&&(this.view.inView&&this.view.requestMeasure(this.measureReq),this.inView!=this.view.inView&&(this.inView=this.view.inView,!this.inView)))for(let e of this.manager.tooltipViews)e.dom.style.top=Outside;}},{eventHandlers:{scroll(){this.maybeMeasure();}}}),baseTheme=EditorView.baseTheme({".cm-tooltip":{zIndex:100,boxSizing:"border-box"},"&light .cm-tooltip":{border:"1px solid #bbb",backgroundColor:"#f5f5f5"},"&light .cm-tooltip-section:not(:first-child)":{borderTop:"1px solid #bbb"},"&dark .cm-tooltip":{backgroundColor:"#333338",color:"white"},".cm-tooltip-arrow":{height:"7px",width:"14px",position:"absolute",zIndex:-1,overflow:"hidden","&:before, &:after":{content:"''",position:"absolute",width:0,height:0,borderLeft:"7px solid transparent",borderRight:"7px solid transparent"},".cm-tooltip-above &":{bottom:"-7px","&:before":{borderTop:"7px solid #bbb"},"&:after":{borderTop:"7px solid #f5f5f5",bottom:"1px"}},".cm-tooltip-below &":{top:"-7px","&:before":{borderBottom:"7px solid #bbb"},"&:after":{borderBottom:"7px solid #f5f5f5",top:"1px"}}},"&dark .cm-tooltip .cm-tooltip-arrow":{"&:before":{borderTopColor:"#333338",borderBottomColor:"#333338"},"&:after":{borderTopColor:"transparent",borderBottomColor:"transparent"}}}),noOffset={x:0,y:0},showTooltip=Facet.define({enables:[tooltipPlugin,baseTheme]}),showHoverTooltip=Facet.define();class HoverTooltipHost{constructor(e){this.view=e,this.mounted=false,this.dom=document.createElement("div"),this.dom.classList.add("cm-tooltip-hover"),this.manager=new TooltipViewManager(e,showHoverTooltip,e=>this.createHostedView(e));}static create(e){return new HoverTooltipHost(e)}createHostedView(e){let t=e.create(this.view);return t.dom.classList.add("cm-tooltip-section"),this.dom.appendChild(t.dom),this.mounted&&t.mount&&t.mount(this.view),t}mount(e){for(let t of this.manager.tooltipViews)t.mount&&t.mount(e);this.mounted=true;}positioned(e){for(let t of this.manager.tooltipViews)t.positioned&&t.positioned(e);}update(e){this.manager.update(e);}}const showHoverTooltipHost=showTooltip.compute([showHoverTooltip],e=>{let t=e.facet(showHoverTooltip).filter(e=>e);return 0===t.length?null:{pos:Math.min(...t.map(e=>e.pos)),end:Math.max(...t.filter(e=>null!=e.end).map(e=>e.end)),create:HoverTooltipHost.create,above:t[0].above,arrow:t.some(e=>e.arrow)}});class HoverPlugin{constructor(e,t,i,n,o){this.view=e,this.source=t,this.field=i,this.setHover=n,this.hoverTime=o,this.hoverTimeout=-1,this.restartTimeout=-1,this.pending=null,this.lastMove={x:0,y:0,target:e.dom,time:0},this.checkHover=this.checkHover.bind(this),e.dom.addEventListener("mouseleave",this.mouseleave=this.mouseleave.bind(this)),e.dom.addEventListener("mousemove",this.mousemove=this.mousemove.bind(this));}update(){this.pending&&(this.pending=null,clearTimeout(this.restartTimeout),this.restartTimeout=setTimeout(()=>this.startHover(),20));}get active(){return this.view.state.field(this.field)}checkHover(){if(this.hoverTimeout=-1,this.active)return;let e=Date.now()-this.lastMove.time;e<this.hoverTime?this.hoverTimeout=setTimeout(this.checkHover,this.hoverTime-e):this.startHover();}startHover(){clearTimeout(this.restartTimeout);let{lastMove:e}=this,t=this.view.contentDOM.contains(e.target)?this.view.posAtCoords(e):null;if(null==t)return;let i=this.view.coordsAtPos(t);if(null==i||e.y<i.top||e.y>i.bottom||e.x<i.left-this.view.defaultCharacterWidth||e.x>i.right+this.view.defaultCharacterWidth)return;let n=this.view.bidiSpans(this.view.state.doc.lineAt(t)).find(e=>e.from<=t&&e.to>=t),o=n&&n.dir==Direction.RTL?-1:1,r=this.source(this.view,t,e.x<i.left?-o:o);if(null===r||void 0===r?void 0:r.then){let e=this.pending={pos:t};r.then(t=>{this.pending==e&&(this.pending=null,t&&this.view.dispatch({effects:this.setHover.of(t)}));},e=>logException(this.view.state,e,"hover tooltip"));}else r&&this.view.dispatch({effects:this.setHover.of(r)});}mousemove(e){var t;this.lastMove={x:e.clientX,y:e.clientY,target:e.target,time:Date.now()},this.hoverTimeout<0&&(this.hoverTimeout=setTimeout(this.checkHover,this.hoverTime));let i=this.active;if(i&&!isInTooltip(this.lastMove.target)||this.pending){let{pos:n}=i||this.pending,o=null!==(t=null===i||void 0===i?void 0:i.end)&&void 0!==t?t:n;(n==o?this.view.posAtCoords(this.lastMove)==n:isOverRange(this.view,n,o,e.clientX,e.clientY,6))||(this.view.dispatch({effects:this.setHover.of(null)}),this.pending=null);}}mouseleave(e){clearTimeout(this.hoverTimeout),this.hoverTimeout=-1,this.active&&!isInTooltip(e.relatedTarget)&&this.view.dispatch({effects:this.setHover.of(null)});}destroy(){clearTimeout(this.hoverTimeout),this.view.dom.removeEventListener("mouseleave",this.mouseleave),this.view.dom.removeEventListener("mousemove",this.mousemove);}}function isInTooltip(e){for(let t=e;t;t=t.parentNode)if(1==t.nodeType&&t.classList.contains("cm-tooltip"))return  true;return  false}function isOverRange(e,t,i,n,o,r){let s=document.createRange(),a=e.domAtPos(t),l=e.domAtPos(i);s.setEnd(l.node,l.offset),s.setStart(a.node,a.offset);let h=s.getClientRects();s.detach();for(let e=0;e<h.length;e++){let t=h[e];if(Math.max(t.top-o,o-t.bottom,t.left-n,n-t.right)<=r)return  true}return  false}function hoverTooltip(e,t={}){let i=StateEffect.define(),n=StateField.define({create:()=>null,update(e,n){if(e&&(t.hideOnChange&&(n.docChanged||n.selection)||t.hideOn&&t.hideOn(n,e)))return null;if(e&&n.docChanged){let t=n.changes.mapPos(e.pos,-1,MapMode.TrackDel);if(null==t)return null;let i=Object.assign(Object.create(null),e);i.pos=t,null!=e.end&&(i.end=n.changes.mapPos(e.end)),e=i;}for(let t of n.effects)t.is(i)&&(e=t.value),t.is(closeHoverTooltipEffect)&&(e=null);return e},provide:e=>showHoverTooltip.from(e)});return [n,ViewPlugin.define(o=>new HoverPlugin(o,e,n,i,t.hoverTime||300)),showHoverTooltipHost]}function getTooltip(e,t){let i=e.plugin(tooltipPlugin);if(!i)return null;let n=i.manager.tooltips.indexOf(t);return n<0?null:i.manager.tooltipViews[n]}const closeHoverTooltipEffect=StateEffect.define();closeHoverTooltipEffect.of(null);const panelConfig=Facet.define({combine(e){let t,i;for(let n of e)t=t||n.topContainer,i=i||n.bottomContainer;return {topContainer:t,bottomContainer:i}}}),panelPlugin=ViewPlugin.fromClass(class{constructor(e){this.input=e.state.facet(showPanel),this.specs=this.input.filter(e=>e),this.panels=this.specs.map(t=>t(e));let t=e.state.facet(panelConfig);this.top=new PanelGroup(e,true,t.topContainer),this.bottom=new PanelGroup(e,false,t.bottomContainer),this.top.sync(this.panels.filter(e=>e.top)),this.bottom.sync(this.panels.filter(e=>!e.top));for(let e of this.panels)e.dom.classList.add("cm-panel"),e.mount&&e.mount();}update(e){let t=e.state.facet(panelConfig);this.top.container!=t.topContainer&&(this.top.sync([]),this.top=new PanelGroup(e.view,true,t.topContainer)),this.bottom.container!=t.bottomContainer&&(this.bottom.sync([]),this.bottom=new PanelGroup(e.view,false,t.bottomContainer)),this.top.syncClasses(),this.bottom.syncClasses();let i=e.state.facet(showPanel);if(i!=this.input){let t=i.filter(e=>e),n=[],o=[],r=[],s=[];for(let i of t){let t,a=this.specs.indexOf(i);a<0?(t=i(e.view),s.push(t)):(t=this.panels[a]).update&&t.update(e),n.push(t),(t.top?o:r).push(t);}this.specs=t,this.panels=n,this.top.sync(o),this.bottom.sync(r);for(let e of s)e.dom.classList.add("cm-panel"),e.mount&&e.mount();}else for(let t of this.panels)t.update&&t.update(e);}destroy(){this.top.sync([]),this.bottom.sync([]);}},{provide:e=>EditorView.scrollMargins.of(t=>{let i=t.plugin(e);return i&&{top:i.top.scrollMargin(),bottom:i.bottom.scrollMargin()}})});class PanelGroup{constructor(e,t,i){this.view=e,this.top=t,this.container=i,this.dom=void 0,this.classes="",this.panels=[],this.syncClasses();}sync(e){for(let t of this.panels)t.destroy&&e.indexOf(t)<0&&t.destroy();this.panels=e,this.syncDOM();}syncDOM(){if(0==this.panels.length)return void(this.dom&&(this.dom.remove(),this.dom=void 0));if(!this.dom){this.dom=document.createElement("div"),this.dom.className=this.top?"cm-panels cm-panels-top":"cm-panels cm-panels-bottom",this.dom.style[this.top?"top":"bottom"]="0";let e=this.container||this.view.dom;e.insertBefore(this.dom,this.top?e.firstChild:null);}let e=this.dom.firstChild;for(let t of this.panels)if(t.dom.parentNode==this.dom){for(;e!=t.dom;)e=rm(e);e=e.nextSibling;}else this.dom.insertBefore(t.dom,e);for(;e;)e=rm(e);}scrollMargin(){return !this.dom||this.container?0:Math.max(0,this.top?this.dom.getBoundingClientRect().bottom-Math.max(0,this.view.scrollDOM.getBoundingClientRect().top):Math.min(innerHeight,this.view.scrollDOM.getBoundingClientRect().bottom)-this.dom.getBoundingClientRect().top)}syncClasses(){if(this.container&&this.classes!=this.view.themeClasses){for(let e of this.classes.split(" "))e&&this.container.classList.remove(e);for(let e of (this.classes=this.view.themeClasses).split(" "))e&&this.container.classList.add(e);}}}function rm(e){let t=e.nextSibling;return e.remove(),t}const showPanel=Facet.define({enables:panelPlugin});class GutterMarker extends RangeValue{compare(e){return this==e||this.constructor==e.constructor&&this.eq(e)}eq(e){return  false}destroy(e){}}GutterMarker.prototype.elementClass="",GutterMarker.prototype.toDOM=void 0,GutterMarker.prototype.mapMode=MapMode.TrackBefore,GutterMarker.prototype.startSide=GutterMarker.prototype.endSide=-1,GutterMarker.prototype.point=true;const gutterLineClass=Facet.define(),defaults={class:"",renderEmptyElements:false,elementStyle:"",markers:()=>RangeSet.empty,lineMarker:()=>null,lineMarkerChange:null,initialSpacer:null,updateSpacer:null,domEventHandlers:{}},activeGutters=Facet.define();function gutter(e){return [gutters(),activeGutters.of(Object.assign(Object.assign({},defaults),e))]}const unfixGutters=Facet.define({combine:e=>e.some(e=>e)});function gutters(e){let t=[gutterView];return t}const gutterView=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.prevViewport=e.viewport,this.dom=document.createElement("div"),this.dom.className="cm-gutters",this.dom.setAttribute("aria-hidden","true"),this.dom.style.minHeight=this.view.contentHeight+"px",this.gutters=e.state.facet(activeGutters).map(t=>new SingleGutterView(e,t));for(let e of this.gutters)this.dom.appendChild(e.dom);this.fixed=!e.state.facet(unfixGutters),this.fixed&&(this.dom.style.position="sticky"),this.syncGutters(false),e.scrollDOM.insertBefore(this.dom,e.contentDOM);}update(e){if(this.updateGutters(e)){let t=this.prevViewport,i=e.view.viewport,n=Math.min(t.to,i.to)-Math.max(t.from,i.from);this.syncGutters(n<.8*(i.to-i.from));}e.geometryChanged&&(this.dom.style.minHeight=this.view.contentHeight+"px"),this.view.state.facet(unfixGutters)!=!this.fixed&&(this.fixed=!this.fixed,this.dom.style.position=this.fixed?"sticky":""),this.prevViewport=e.view.viewport;}syncGutters(e){let t=this.dom.nextSibling;e&&this.dom.remove();let i=RangeSet.iter(this.view.state.facet(gutterLineClass),this.view.viewport.from),n=[],o=this.gutters.map(e=>new UpdateContext(e,this.view.viewport,-this.view.documentPadding.top));for(let e of this.view.viewportLineBlocks){let t;if(Array.isArray(e.type)){for(let i of e.type)if(i.type==BlockType.Text){t=i;break}}else t=e.type==BlockType.Text?e:void 0;if(t){n.length&&(n=[]),advanceCursor(i,n,e.from);for(let e of o)e.line(this.view,t,n);}}for(let e of o)e.finish();e&&this.view.scrollDOM.insertBefore(this.dom,t);}updateGutters(e){let t=e.startState.facet(activeGutters),i=e.state.facet(activeGutters),n=e.docChanged||e.heightChanged||e.viewportChanged||!RangeSet.eq(e.startState.facet(gutterLineClass),e.state.facet(gutterLineClass),e.view.viewport.from,e.view.viewport.to);if(t==i)for(let t of this.gutters)t.update(e)&&(n=true);else {n=true;let o=[];for(let n of i){let i=t.indexOf(n);i<0?o.push(new SingleGutterView(this.view,n)):(this.gutters[i].update(e),o.push(this.gutters[i]));}for(let e of this.gutters)e.dom.remove(),o.indexOf(e)<0&&e.destroy();for(let e of o)this.dom.appendChild(e.dom);this.gutters=o;}return n}destroy(){for(let e of this.gutters)e.destroy();this.dom.remove();}},{provide:e=>EditorView.scrollMargins.of(t=>{let i=t.plugin(e);return i&&0!=i.gutters.length&&i.fixed?t.textDirection==Direction.LTR?{left:i.dom.offsetWidth}:{right:i.dom.offsetWidth}:null})});function asArray$1(e){return Array.isArray(e)?e:[e]}function advanceCursor(e,t,i){for(;e.value&&e.from<=i;)e.from==i&&t.push(e.value),e.next();}class UpdateContext{constructor(e,t,i){this.gutter=e,this.height=i,this.localMarkers=[],this.i=0,this.cursor=RangeSet.iter(e.markers,t.from);}line(e,t,i){this.localMarkers.length&&(this.localMarkers=[]),advanceCursor(this.cursor,this.localMarkers,t.from);let n=i.length?this.localMarkers.concat(i):this.localMarkers,o=this.gutter.config.lineMarker(e,t,n);o&&n.unshift(o);let r=this.gutter;if(0==n.length&&!r.config.renderEmptyElements)return;let s=t.top-this.height;if(this.i==r.elements.length){let i=new GutterElement(e,t.height,s,n);r.elements.push(i),r.dom.appendChild(i.dom);}else r.elements[this.i].update(e,t.height,s,n);this.height=t.bottom,this.i++;}finish(){let e=this.gutter;for(;e.elements.length>this.i;){let t=e.elements.pop();e.dom.removeChild(t.dom),t.destroy();}}}class SingleGutterView{constructor(e,t){this.view=e,this.config=t,this.elements=[],this.spacer=null,this.dom=document.createElement("div"),this.dom.className="cm-gutter"+(this.config.class?" "+this.config.class:"");for(let i in t.domEventHandlers)this.dom.addEventListener(i,n=>{let o=e.lineBlockAtHeight(n.clientY-e.documentTop);t.domEventHandlers[i](e,o,n)&&n.preventDefault();});this.markers=asArray$1(t.markers(e)),t.initialSpacer&&(this.spacer=new GutterElement(e,0,0,[t.initialSpacer(e)]),this.dom.appendChild(this.spacer.dom),this.spacer.dom.style.cssText+="visibility: hidden; pointer-events: none");}update(e){let t=this.markers;if(this.markers=asArray$1(this.config.markers(e.view)),this.spacer&&this.config.updateSpacer){let t=this.config.updateSpacer(this.spacer.markers[0],e);t!=this.spacer.markers[0]&&this.spacer.update(e.view,0,0,[t]);}let i=e.view.viewport;return !RangeSet.eq(this.markers,t,i.from,i.to)||!!this.config.lineMarkerChange&&this.config.lineMarkerChange(e)}destroy(){for(let e of this.elements)e.destroy();}}class GutterElement{constructor(e,t,i,n){this.height=-1,this.above=0,this.markers=[],this.dom=document.createElement("div"),this.dom.className="cm-gutterElement",this.update(e,t,i,n);}update(e,t,i,n){this.height!=t&&(this.dom.style.height=(this.height=t)+"px"),this.above!=i&&(this.dom.style.marginTop=(this.above=i)?i+"px":""),sameMarkers(this.markers,n)||this.setMarkers(e,n);}setMarkers(e,t){let i="cm-gutterElement",n=this.dom.firstChild;for(let o=0,r=0;;){let s=r,a=o<t.length?t[o++]:null,l=false;if(a){let e=a.elementClass;e&&(i+=" "+e);for(let e=r;e<this.markers.length;e++)if(this.markers[e].compare(a)){s=e,l=true;break}}else s=this.markers.length;for(;r<s;){let e=this.markers[r++];if(e.toDOM){e.destroy(n);let t=n.nextSibling;n.remove(),n=t;}}if(!a)break;a.toDOM&&(l?n=n.nextSibling:this.dom.insertBefore(a.toDOM(e),n)),l&&r++;}this.dom.className=i,this.markers=t;}destroy(){this.setMarkers(null,[]);}}function sameMarkers(e,t){if(e.length!=t.length)return  false;for(let i=0;i<e.length;i++)if(!e[i].compare(t[i]))return  false;return  true}const lineNumberMarkers=Facet.define(),lineNumberConfig=Facet.define({combine:e=>combineConfig(e,{formatNumber:String,domEventHandlers:{}},{domEventHandlers(e,t){let i=Object.assign({},e);for(let e in t){let n=i[e],o=t[e];i[e]=n?(e,t,i)=>n(e,t,i)||o(e,t,i):o;}return i}})});class NumberMarker extends GutterMarker{constructor(e){super(),this.number=e;}eq(e){return this.number==e.number}toDOM(){return document.createTextNode(this.number)}}function formatNumber(e,t){return e.state.facet(lineNumberConfig).formatNumber(t,e.state)}const lineNumberGutter=activeGutters.compute([lineNumberConfig],e=>({class:"cm-lineNumbers",renderEmptyElements:false,markers:e=>e.state.facet(lineNumberMarkers),lineMarker:(e,t,i)=>i.some(e=>e.toDOM)?null:new NumberMarker(formatNumber(e,e.state.doc.lineAt(t.from).number)),lineMarkerChange:e=>e.startState.facet(lineNumberConfig)!=e.state.facet(lineNumberConfig),initialSpacer:e=>new NumberMarker(formatNumber(e,maxLineNumber(e.state.doc.lines))),updateSpacer(e,t){let i=formatNumber(t.view,maxLineNumber(t.view.state.doc.lines));return i==e.number?e:new NumberMarker(i)},domEventHandlers:e.facet(lineNumberConfig).domEventHandlers}));function lineNumbers(e={}){return [lineNumberConfig.of(e),gutters(),lineNumberGutter]}function maxLineNumber(e){let t=9;for(;t<e;)t=10*t+9;return t}const activeLineGutterMarker=new class extends GutterMarker{constructor(){super(...arguments),this.elementClass="cm-activeLineGutter";}},activeLineGutterHighlighter=gutterLineClass.compute(["selection"],e=>{let t=[],i=-1;for(let n of e.selection.ranges){let o=e.doc.lineAt(n.head).from;o>i&&(i=o,t.push(activeLineGutterMarker.range(o)));}return RangeSet.of(t)});function highlightActiveLineGutter(){return activeLineGutterHighlighter}const DefaultBufferLength=1024;let nextPropID=0;class Range$1{constructor(e,t){this.from=e,this.to=t;}}class NodeProp{constructor(e={}){this.id=nextPropID++,this.perNode=!!e.perNode,this.deserialize=e.deserialize||(()=>{throw new Error("This node type doesn't define a deserialize function")});}add(e){if(this.perNode)throw new RangeError("Can't add per-node props to node types");return "function"!=typeof e&&(e=NodeType.match(e)),t=>{let i=e(t);return void 0===i?null:[this,i]}}}NodeProp.closedBy=new NodeProp({deserialize:e=>e.split(" ")}),NodeProp.openedBy=new NodeProp({deserialize:e=>e.split(" ")}),NodeProp.group=new NodeProp({deserialize:e=>e.split(" ")}),NodeProp.contextHash=new NodeProp({perNode:true}),NodeProp.lookAhead=new NodeProp({perNode:true}),NodeProp.mounted=new NodeProp({perNode:true});const noProps=Object.create(null);class NodeType{constructor(e,t,i,n=0){this.name=e,this.props=t,this.id=i,this.flags=n;}static define(e){let t=e.props&&e.props.length?Object.create(null):noProps,i=(e.top?1:0)|(e.skipped?2:0)|(e.error?4:0)|(null==e.name?8:0),n=new NodeType(e.name||"",t,e.id,i);if(e.props)for(let i of e.props)if(Array.isArray(i)||(i=i(n)),i){if(i[0].perNode)throw new RangeError("Can't store a per-node prop on a node type");t[i[0].id]=i[1];}return n}prop(e){return this.props[e.id]}get isTop(){return (1&this.flags)>0}get isSkipped(){return (2&this.flags)>0}get isError(){return (4&this.flags)>0}get isAnonymous(){return (8&this.flags)>0}is(e){if("string"==typeof e){if(this.name==e)return  true;let t=this.prop(NodeProp.group);return !!t&&t.indexOf(e)>-1}return this.id==e}static match(e){let t=Object.create(null);for(let i in e)for(let n of i.split(" "))t[n]=e[i];return e=>{for(let i=e.prop(NodeProp.group),n=-1;n<(i?i.length:0);n++){let o=t[n<0?e.name:i[n]];if(o)return o}}}}NodeType.none=new NodeType("",Object.create(null),0,8);class NodeSet{constructor(e){this.types=e;for(let t=0;t<e.length;t++)if(e[t].id!=t)throw new RangeError("Node type ids should correspond to array positions when creating a node set")}extend(...e){let t=[];for(let i of this.types){let n=null;for(let t of e){let e=t(i);e&&(n||(n=Object.assign({},i.props)),n[e[0].id]=e[1]);}t.push(n?new NodeType(i.name,n,i.id,i.flags):i);}return new NodeSet(t)}}const CachedNode=new WeakMap,CachedInnerNode=new WeakMap;var IterMode;!function(e){e[e.ExcludeBuffers=1]="ExcludeBuffers",e[e.IncludeAnonymous=2]="IncludeAnonymous",e[e.IgnoreMounts=4]="IgnoreMounts",e[e.IgnoreOverlays=8]="IgnoreOverlays";}(IterMode||(IterMode={}));class Tree{constructor(e,t,i,n,o){if(this.type=e,this.children=t,this.positions=i,this.length=n,this.props=null,o&&o.length){this.props=Object.create(null);for(let[e,t]of o)this.props["number"==typeof e?e:e.id]=t;}}toString(){let e=this.prop(NodeProp.mounted);if(e&&!e.overlay)return e.tree.toString();let t="";for(let e of this.children){let i=e.toString();i&&(t&&(t+=","),t+=i);}return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+(t.length?"("+t+")":""):t}cursor(e=0){return new TreeCursor(this.topNode,e)}cursorAt(e,t=0,i=0){let n=CachedNode.get(this)||this.topNode,o=new TreeCursor(n);return o.moveTo(e,t),CachedNode.set(this,o._tree),o}get topNode(){return new TreeNode(this,0,0,null)}resolve(e,t=0){let i=resolveNode(CachedNode.get(this)||this.topNode,e,t,false);return CachedNode.set(this,i),i}resolveInner(e,t=0){let i=resolveNode(CachedInnerNode.get(this)||this.topNode,e,t,true);return CachedInnerNode.set(this,i),i}iterate(e){let{enter:t,leave:i,from:n=0,to:o=this.length}=e;for(let r=this.cursor((e.mode||0)|IterMode.IncludeAnonymous);;){let e=false;if(r.from<=o&&r.to>=n&&(r.type.isAnonymous||false!==t(r))){if(r.firstChild())continue;e=true;}for(;e&&i&&!r.type.isAnonymous&&i(r),!r.nextSibling();){if(!r.parent())return;e=true;}}}prop(e){return e.perNode?this.props?this.props[e.id]:void 0:this.type.prop(e)}get propValues(){let e=[];if(this.props)for(let t in this.props)e.push([+t,this.props[t]]);return e}balance(e={}){return this.children.length<=8?this:balanceRange(NodeType.none,this.children,this.positions,0,this.children.length,0,this.length,(e,t,i)=>new Tree(this.type,e,t,i,this.propValues),e.makeTree||((e,t,i)=>new Tree(NodeType.none,e,t,i)))}static build(e){return buildTree(e)}}Tree.empty=new Tree(NodeType.none,[],[],0);class FlatBufferCursor{constructor(e,t){this.buffer=e,this.index=t;}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4;}fork(){return new FlatBufferCursor(this.buffer,this.index)}}class TreeBuffer{constructor(e,t,i){this.buffer=e,this.length=t,this.set=i;}get type(){return NodeType.none}toString(){let e=[];for(let t=0;t<this.buffer.length;)e.push(this.childString(t)),t=this.buffer[t+3];return e.join(",")}childString(e){let t=this.buffer[e],i=this.buffer[e+3],n=this.set.types[t],o=n.name;if(/\W/.test(o)&&!n.isError&&(o=JSON.stringify(o)),i==(e+=4))return o;let r=[];for(;e<i;)r.push(this.childString(e)),e=this.buffer[e+3];return o+"("+r.join(",")+")"}findChild(e,t,i,n,o){let{buffer:r}=this,s=-1;for(let a=e;a!=t&&!(checkSide(o,n,r[a+1],r[a+2])&&(s=a,i>0));a=r[a+3]);return s}slice(e,t,i){let n=this.buffer,o=new Uint16Array(t-e),r=0;for(let s=e,a=0;s<t;){o[a++]=n[s++],o[a++]=n[s++]-i;let t=o[a++]=n[s++]-i;o[a++]=n[s++]-e,r=Math.max(r,t);}return new TreeBuffer(o,r,this.set)}}function checkSide(e,t,i,n){switch(e){case  -2:return i<t;case  -1:return n>=t&&i<t;case 0:return i<t&&n>t;case 1:return i<=t&&n>t;case 2:return n>t;case 4:return  true}}function enterUnfinishedNodesBefore(e,t){let i=e.childBefore(t);for(;i;){let t=i.lastChild;if(!t||t.to!=i.to)break;t.type.isError&&t.from==t.to?(e=i,i=t.prevSibling):i=t;}return e}function resolveNode(e,t,i,n){for(var o;e.from==e.to||(i<1?e.from>=t:e.from>t)||(i>-1?e.to<=t:e.to<t);){let t=!n&&e instanceof TreeNode&&e.index<0?null:e.parent;if(!t)return e;e=t;}let r=n?0:IterMode.IgnoreOverlays;if(n)for(let n=e,s=n.parent;s;s=(n=s).parent)n instanceof TreeNode&&n.index<0&&(null===(o=s.enter(t,i,r))||void 0===o?void 0:o.from)!=n.from&&(e=s);for(;;){let n=e.enter(t,i,r);if(!n)return e;e=n;}}class TreeNode{constructor(e,t,i,n){this._tree=e,this.from=t,this.index=i,this._parent=n;}get type(){return this._tree.type}get name(){return this._tree.type.name}get to(){return this.from+this._tree.length}nextChild(e,t,i,n,o=0){for(let r=this;;){for(let{children:s,positions:a}=r._tree,l=t>0?s.length:-1;e!=l;e+=t){let l=s[e],h=a[e]+r.from;if(checkSide(n,i,h,h+l.length))if(l instanceof TreeBuffer){if(o&IterMode.ExcludeBuffers)continue;let s=l.findChild(0,l.buffer.length,t,i-h,n);if(s>-1)return new BufferNode(new BufferContext(r,l,e,h),null,s)}else if(o&IterMode.IncludeAnonymous||!l.type.isAnonymous||hasChild(l)){let s;if(!(o&IterMode.IgnoreMounts)&&l.props&&(s=l.prop(NodeProp.mounted))&&!s.overlay)return new TreeNode(s.tree,h,e,r);let a=new TreeNode(l,h,e,r);return o&IterMode.IncludeAnonymous||!a.type.isAnonymous?a:a.nextChild(t<0?l.children.length-1:0,t,i,n)}}if(o&IterMode.IncludeAnonymous||!r.type.isAnonymous)return null;if(e=r.index>=0?r.index+t:t<0?-1:r._parent._tree.children.length,!(r=r._parent))return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this._tree.children.length-1,-1,0,4)}childAfter(e){return this.nextChild(0,1,e,2)}childBefore(e){return this.nextChild(this._tree.children.length-1,-1,e,-2)}enter(e,t,i=0){let n;if(!(i&IterMode.IgnoreOverlays)&&(n=this._tree.prop(NodeProp.mounted))&&n.overlay){let i=e-this.from;for(let{from:e,to:o}of n.overlay)if((t>0?e<=i:e<i)&&(t<0?o>=i:o>i))return new TreeNode(n.tree,n.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,e,t,i)}nextSignificantParent(){let e=this;for(;e.type.isAnonymous&&e._parent;)e=e._parent;return e}get parent(){return this._parent?this._parent.nextSignificantParent():null}get nextSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index-1,-1,0,4):null}cursor(e=0){return new TreeCursor(this,e)}get tree(){return this._tree}toTree(){return this._tree}resolve(e,t=0){return resolveNode(this,e,t,false)}resolveInner(e,t=0){return resolveNode(this,e,t,true)}enterUnfinishedNodesBefore(e){return enterUnfinishedNodesBefore(this,e)}getChild(e,t=null,i=null){let n=getChildren(this,e,t,i);return n.length?n[0]:null}getChildren(e,t=null,i=null){return getChildren(this,e,t,i)}toString(){return this._tree.toString()}get node(){return this}matchContext(e){return matchNodeContext(this,e)}}function getChildren(e,t,i,n){let o=e.cursor(),r=[];if(!o.firstChild())return r;if(null!=i)for(;!o.type.is(i);)if(!o.nextSibling())return r;for(;;){if(null!=n&&o.type.is(n))return r;if(o.type.is(t)&&r.push(o.node),!o.nextSibling())return null==n?r:[]}}function matchNodeContext(e,t,i=t.length-1){for(let n=e.parent;i>=0;n=n.parent){if(!n)return  false;if(!n.type.isAnonymous){if(t[i]&&t[i]!=n.name)return  false;i--;}}return  true}class BufferContext{constructor(e,t,i,n){this.parent=e,this.buffer=t,this.index=i,this.start=n;}}class BufferNode{get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}constructor(e,t,i){this.context=e,this._parent=t,this.index=i,this.type=e.buffer.set.types[e.buffer.buffer[i]];}child(e,t,i){let{buffer:n}=this.context,o=n.findChild(this.index+4,n.buffer[this.index+3],e,t-this.context.start,i);return o<0?null:new BufferNode(this.context,this,o)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(e){return this.child(1,e,2)}childBefore(e){return this.child(-1,e,-2)}enter(e,t,i=0){if(i&IterMode.ExcludeBuffers)return null;let{buffer:n}=this.context,o=n.findChild(this.index+4,n.buffer[this.index+3],t>0?1:-1,e-this.context.start,t);return o<0?null:new BufferNode(this.context,this,o)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(e){return this._parent?null:this.context.parent.nextChild(this.context.index+e,e,0,4)}get nextSibling(){let{buffer:e}=this.context,t=e.buffer[this.index+3];return t<(this._parent?e.buffer[this._parent.index+3]:e.buffer.length)?new BufferNode(this.context,this._parent,t):this.externalSibling(1)}get prevSibling(){let{buffer:e}=this.context,t=this._parent?this._parent.index+4:0;return this.index==t?this.externalSibling(-1):new BufferNode(this.context,this._parent,e.findChild(t,this.index,-1,0,4))}cursor(e=0){return new TreeCursor(this,e)}get tree(){return null}toTree(){let e=[],t=[],{buffer:i}=this.context,n=this.index+4,o=i.buffer[this.index+3];if(o>n){let r=i.buffer[this.index+1];e.push(i.slice(n,o,r)),t.push(0);}return new Tree(this.type,e,t,this.to-this.from)}resolve(e,t=0){return resolveNode(this,e,t,false)}resolveInner(e,t=0){return resolveNode(this,e,t,true)}enterUnfinishedNodesBefore(e){return enterUnfinishedNodesBefore(this,e)}toString(){return this.context.buffer.childString(this.index)}getChild(e,t=null,i=null){let n=getChildren(this,e,t,i);return n.length?n[0]:null}getChildren(e,t=null,i=null){return getChildren(this,e,t,i)}get node(){return this}matchContext(e){return matchNodeContext(this,e)}}class TreeCursor{get name(){return this.type.name}constructor(e,t=0){if(this.mode=t,this.buffer=null,this.stack=[],this.index=0,this.bufferNode=null,e instanceof TreeNode)this.yieldNode(e);else {this._tree=e.context.parent,this.buffer=e.context;for(let t=e._parent;t;t=t._parent)this.stack.unshift(t.index);this.bufferNode=e,this.yieldBuf(e.index);}}yieldNode(e){return !!e&&(this._tree=e,this.type=e.type,this.from=e.from,this.to=e.to,true)}yieldBuf(e,t){this.index=e;let{start:i,buffer:n}=this.buffer;return this.type=t||n.set.types[n.buffer[e]],this.from=i+n.buffer[e+1],this.to=i+n.buffer[e+2],true}yield(e){return !!e&&(e instanceof TreeNode?(this.buffer=null,this.yieldNode(e)):(this.buffer=e.context,this.yieldBuf(e.index,e.type)))}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this._tree.toString()}enterChild(e,t,i){if(!this.buffer)return this.yield(this._tree.nextChild(e<0?this._tree._tree.children.length-1:0,e,t,i,this.mode));let{buffer:n}=this.buffer,o=n.findChild(this.index+4,n.buffer[this.index+3],e,t-this.buffer.start,i);return !(o<0)&&(this.stack.push(this.index),this.yieldBuf(o))}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(e){return this.enterChild(1,e,2)}childBefore(e){return this.enterChild(-1,e,-2)}enter(e,t,i=this.mode){return this.buffer?!(i&IterMode.ExcludeBuffers)&&this.enterChild(1,e,t):this.yield(this._tree.enter(e,t,i))}parent(){if(!this.buffer)return this.yieldNode(this.mode&IterMode.IncludeAnonymous?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let e=this.mode&IterMode.IncludeAnonymous?this.buffer.parent:this.buffer.parent.nextSignificantParent();return this.buffer=null,this.yieldNode(e)}sibling(e){if(!this.buffer)return !!this._tree._parent&&this.yield(this._tree.index<0?null:this._tree._parent.nextChild(this._tree.index+e,e,0,4,this.mode));let{buffer:t}=this.buffer,i=this.stack.length-1;if(e<0){let e=i<0?0:this.stack[i]+4;if(this.index!=e)return this.yieldBuf(t.findChild(e,this.index,-1,0,4))}else {let e=t.buffer[this.index+3];if(e<(i<0?t.buffer.length:t.buffer[this.stack[i]+3]))return this.yieldBuf(e)}return i<0&&this.yield(this.buffer.parent.nextChild(this.buffer.index+e,e,0,4,this.mode))}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(e){let t,i,{buffer:n}=this;if(n){if(e>0){if(this.index<n.buffer.buffer.length)return  false}else for(let e=0;e<this.index;e++)if(n.buffer.buffer[e+3]<this.index)return  false;({index:t,parent:i}=n);}else ({index:t,_parent:i}=this._tree);for(;i;({index:t,_parent:i}=i))if(t>-1)for(let n=t+e,o=e<0?-1:i._tree.children.length;n!=o;n+=e){let e=i._tree.children[n];if(this.mode&IterMode.IncludeAnonymous||e instanceof TreeBuffer||!e.type.isAnonymous||hasChild(e))return  false}return  true}move(e,t){if(t&&this.enterChild(e,0,4))return  true;for(;;){if(this.sibling(e))return  true;if(this.atLastNode(e)||!this.parent())return  false}}next(e=true){return this.move(1,e)}prev(e=true){return this.move(-1,e)}moveTo(e,t=0){for(;(this.from==this.to||(t<1?this.from>=e:this.from>e)||(t>-1?this.to<=e:this.to<e))&&this.parent(););for(;this.enterChild(1,e,t););return this}get node(){if(!this.buffer)return this._tree;let e=this.bufferNode,t=null,i=0;if(e&&e.context==this.buffer)e:for(let n=this.index,o=this.stack.length;o>=0;){for(let r=e;r;r=r._parent)if(r.index==n){if(n==this.index)return r;t=r,i=o+1;break e}n=this.stack[--o];}for(let e=i;e<this.stack.length;e++)t=new BufferNode(this.buffer,t,this.stack[e]);return this.bufferNode=new BufferNode(this.buffer,t,this.index)}get tree(){return this.buffer?null:this._tree._tree}iterate(e,t){for(let i=0;;){let n=false;if(this.type.isAnonymous||false!==e(this)){if(this.firstChild()){i++;continue}this.type.isAnonymous||(n=true);}for(;n&&t&&t(this),n=this.type.isAnonymous,!this.nextSibling();){if(!i)return;this.parent(),i--,n=true;}}}matchContext(e){if(!this.buffer)return matchNodeContext(this.node,e);let{buffer:t}=this.buffer,{types:i}=t.set;for(let n=e.length-1,o=this.stack.length-1;n>=0;o--){if(o<0)return matchNodeContext(this.node,e,n);let r=i[t.buffer[this.stack[o]]];if(!r.isAnonymous){if(e[n]&&e[n]!=r.name)return  false;n--;}}return  true}}function hasChild(e){return e.children.some(e=>e instanceof TreeBuffer||!e.type.isAnonymous||hasChild(e))}function buildTree(e){var t;let{buffer:i,nodeSet:n,maxBufferLength:o=DefaultBufferLength,reused:r=[],minRepeatType:s=n.types.length}=e,a=Array.isArray(i)?new FlatBufferCursor(i,i.length):i,l=n.types,h=0,c=0;function d(e,t,i,O,g){let{id:m,start:S,end:b,size:y}=a,w=c;for(;y<0;){if(a.next(),-1==y){let t=r[m];return i.push(t),void O.push(S-e)}if(-3==y)return void(h=m);if(-4==y)return void(c=m);throw new RangeError(`Unrecognized record size: ${y}`)}let v,Q,k=l[m],x=S-e;if(b-S<=o&&(Q=function(e,t){let i=a.fork(),n=0,r=0,l=0,h=i.end-o,c={size:0,start:0,skip:0};e:for(let o=i.pos-e;i.pos>o;){let e=i.size;if(i.id==t&&e>=0){c.size=n,c.start=r,c.skip=l,l+=4,n+=4,i.next();continue}let a=i.pos-e;if(e<0||a<o||i.start<h)break;let d=i.id>=s?4:0,u=i.start;for(i.next();i.pos>a;){if(i.size<0){if(-3!=i.size)break e;d+=4;}else i.id>=s&&(d+=4);i.next();}r=u,n+=e,l+=d;}(t<0||n==e)&&(c.size=n,c.start=r,c.skip=l);return c.size>4?c:void 0}(a.pos-t,g))){let t=new Uint16Array(Q.size-Q.skip),i=a.pos-Q.size,o=t.length;for(;a.pos>i;)o=p(Q.start,t,o);v=new TreeBuffer(t,b-Q.start,n),x=Q.start-e;}else {let e=a.pos-y;a.next();let t=[],i=[],n=m>=s?m:-1,r=0,l=b;for(;a.pos>e;)n>=0&&a.id==n&&a.size>=0?(a.end<=l-o&&(u(t,i,S,r,a.end,l,n,w),r=t.length,l=a.end),a.next()):d(S,e,t,i,n);if(n>=0&&r>0&&r<t.length&&u(t,i,S,r,S,l,n,w),t.reverse(),i.reverse(),n>-1&&r>0){let e=function(e){return (t,i,n)=>{let o,r,s=0,a=t.length-1;if(a>=0&&(o=t[a])instanceof Tree){if(!a&&o.type==e&&o.length==n)return o;(r=o.prop(NodeProp.lookAhead))&&(s=i[a]+o.length+r);}return f(e,t,i,n,s)}}(k);v=balanceRange(k,t,i,0,t.length,0,b-S,e,e);}else v=f(k,t,i,b-S,w-b);}i.push(v),O.push(x);}function u(e,t,i,o,r,s,a,l){let h=[],c=[];for(;e.length>o;)h.push(e.pop()),c.push(t.pop()+i-r);e.push(f(n.types[a],h,c,s-r,l-s)),t.push(r-i);}function f(e,t,i,n,o=0,r){if(h){let e=[NodeProp.contextHash,h];r=r?[e].concat(r):[e];}if(o>25){let e=[NodeProp.lookAhead,o];r=r?[e].concat(r):[e];}return new Tree(e,t,i,n,r)}function p(e,t,i){let{id:n,start:o,end:r,size:l}=a;if(a.next(),l>=0&&n<s){let s=i;if(l>4){let n=a.pos-(l-4);for(;a.pos>n;)i=p(e,t,i);}t[--i]=s,t[--i]=r-e,t[--i]=o-e,t[--i]=n;}else  -3==l?h=n:-4==l&&(c=n);return i}let O=[],g=[];for(;a.pos>0;)d(e.start||0,e.bufferStart||0,O,g,-1);let m=null!==(t=e.length)&&void 0!==t?t:O.length?g[0]+O[0].length:0;return new Tree(l[e.topID],O.reverse(),g.reverse(),m)}const nodeSizeCache=new WeakMap;function nodeSize(e,t){if(!e.isAnonymous||t instanceof TreeBuffer||t.type!=e)return 1;let i=nodeSizeCache.get(t);if(null==i){i=1;for(let n of t.children){if(n.type!=e||!(n instanceof Tree)){i=1;break}i+=nodeSize(e,n);}nodeSizeCache.set(t,i);}return i}function balanceRange(e,t,i,n,o,r,s,a,l){let h=0;for(let i=n;i<o;i++)h+=nodeSize(e,t[i]);let c=Math.ceil(1.5*h/8),d=[],u=[];return function t(i,n,o,s,a){for(let h=o;h<s;){let o=h,f=n[h],p=nodeSize(e,i[h]);for(h++;h<s;h++){let t=nodeSize(e,i[h]);if(p+t>=c)break;p+=t;}if(h==o+1){if(p>c){let e=i[o];t(e.children,e.positions,0,e.children.length,n[o]+a);continue}d.push(i[o]);}else {let t=n[h-1]+i[h-1].length-f;d.push(balanceRange(e,i,n,o,h,f,t,null,l));}u.push(f+a-r);}}(t,i,n,o,0),(a||l)(d,u,s)}class TreeFragment{constructor(e,t,i,n,o=false,r=false){this.from=e,this.to=t,this.tree=i,this.offset=n,this.open=(o?1:0)|(r?2:0);}get openStart(){return (1&this.open)>0}get openEnd(){return (2&this.open)>0}static addTree(e,t=[],i=false){let n=[new TreeFragment(0,e.length,e,0,false,i)];for(let i of t)i.to>e.length&&n.push(i);return n}static applyChanges(e,t,i=128){if(!t.length)return e;let n=[],o=1,r=e.length?e[0]:null;for(let s=0,a=0,l=0;;s++){let h=s<t.length?t[s]:null,c=h?h.fromA:1e9;if(c-a>=i)for(;r&&r.from<c;){let t=r;if(a>=t.from||c<=t.to||l){let e=Math.max(t.from,a)-l,i=Math.min(t.to,c)-l;t=e>=i?null:new TreeFragment(e,i,t.tree,t.offset+l,s>0,!!h);}if(t&&n.push(t),r.to>c)break;r=o<e.length?e[o++]:null;}if(!h)break;a=h.toA,l=h.toA-h.toB;}return n}}class Parser{startParse(e,t,i){return "string"==typeof e&&(e=new StringInput(e)),i=i?i.length?i.map(e=>new Range$1(e.from,e.to)):[new Range$1(0,0)]:[new Range$1(0,e.length)],this.createParse(e,t||[],i)}parse(e,t,i){let n=this.startParse(e,t,i);for(;;){let e=n.advance();if(e)return e}}}class StringInput{constructor(e){this.string=e;}get length(){return this.string.length}chunk(e){return this.string.slice(e)}get lineChunks(){return  false}read(e,t){return this.string.slice(e,t)}}new NodeProp({perNode:true});let nextTagID=0;class Tag{constructor(e,t,i){this.set=e,this.base=t,this.modified=i,this.id=nextTagID++;}static define(e){if(null===e||void 0===e?void 0:e.base)throw new Error("Can not derive from a modified tag");let t=new Tag([],null,[]);if(t.set.push(t),e)for(let i of e.set)t.set.push(i);return t}static defineModifier(){let e=new Modifier;return t=>t.modified.indexOf(e)>-1?t:Modifier.get(t.base||t,t.modified.concat(e).sort((e,t)=>e.id-t.id))}}let nextModifierID=0;class Modifier{constructor(){this.instances=[],this.id=nextModifierID++;}static get(e,t){if(!t.length)return e;let i=t[0].instances.find(i=>i.base==e&&sameArray$1(t,i.modified));if(i)return i;let n=[],o=new Tag(n,e,t);for(let e of t)e.instances.push(o);let r=powerSet(t);for(let t of e.set)if(!t.modified.length)for(let e of r)n.push(Modifier.get(t,e));return o}}function sameArray$1(e,t){return e.length==t.length&&e.every((e,i)=>e==t[i])}function powerSet(e){let t=[[]];for(let i=0;i<e.length;i++)for(let n=0,o=t.length;n<o;n++)t.push(t[n].concat(e[i]));return t.sort((e,t)=>t.length-e.length)}function styleTags(e){let t=Object.create(null);for(let i in e){let n=e[i];Array.isArray(n)||(n=[n]);for(let e of i.split(" "))if(e){let i=[],o=2,r=e;for(let t=0;;){if("..."==r&&t>0&&t+3==e.length){o=1;break}let n=/^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(r);if(!n)throw new RangeError("Invalid path: "+e);if(i.push("*"==n[0]?"":'"'==n[0][0]?JSON.parse(n[0]):n[0]),(t+=n[0].length)==e.length)break;let s=e[t++];if(t==e.length&&"!"==s){o=0;break}if("/"!=s)throw new RangeError("Invalid path: "+e);r=e.slice(t);}let s=i.length-1,a=i[s];if(!a)throw new RangeError("Invalid path: "+e);let l=new Rule(n,o,s>0?i.slice(0,s):null);t[a]=l.sort(t[a]);}}return ruleNodeProp.add(t)}const ruleNodeProp=new NodeProp;class Rule{constructor(e,t,i,n){this.tags=e,this.mode=t,this.context=i,this.next=n;}get opaque(){return 0==this.mode}get inherit(){return 1==this.mode}sort(e){return !e||e.depth<this.depth?(this.next=e,this):(e.next=this.sort(e.next),e)}get depth(){return this.context?this.context.length:0}}function tagHighlighter(e,t){let i=Object.create(null);for(let t of e)if(Array.isArray(t.tag))for(let e of t.tag)i[e.id]=t.class;else i[t.tag.id]=t.class;let{scope:n,all:o=null}=t||{};return {style:e=>{let t=o;for(let n of e)for(let e of n.set){let n=i[e.id];if(n){t=t?t+" "+n:n;break}}return t},scope:n}}function highlightTags(e,t){let i=null;for(let n of e){let e=n.style(t);e&&(i=i?i+" "+e:e);}return i}function highlightTree(e,t,i,n=0,o=e.length){let r=new HighlightBuilder(n,Array.isArray(t)?t:[t],i);r.highlightRange(e.cursor(),n,o,"",r.highlighters),r.flush(o);}Rule.empty=new Rule([],2,null);class HighlightBuilder{constructor(e,t,i){this.at=e,this.highlighters=t,this.span=i,this.class="";}startSpan(e,t){t!=this.class&&(this.flush(e),e>this.at&&(this.at=e),this.class=t);}flush(e){e>this.at&&this.class&&this.span(this.at,e,this.class);}highlightRange(e,t,i,n,o){let{type:r,from:s,to:a}=e;if(s>=i||a<=t)return;r.isTop&&(o=this.highlighters.filter(e=>!e.scope||e.scope(r)));let l=n,h=getStyleTags(e)||Rule.empty,c=highlightTags(o,h.tags);if(c&&(l&&(l+=" "),l+=c,1==h.mode&&(n+=(n?" ":"")+c)),this.startSpan(e.from,l),h.opaque)return;let d=e.tree&&e.tree.prop(NodeProp.mounted);if(d&&d.overlay){let r=e.node.enter(d.overlay[0].from+s,1),h=this.highlighters.filter(e=>!e.scope||e.scope(d.tree.type)),c=e.firstChild();for(let u=0,f=s;;u++){let p=u<d.overlay.length?d.overlay[u]:null,O=p?p.from+s:a,g=Math.max(t,f),m=Math.min(i,O);if(g<m&&c)for(;e.from<m&&(this.highlightRange(e,g,m,n,o),this.startSpan(Math.min(m,e.to),l),!(e.to>=O)&&e.nextSibling()););if(!p||O>i)break;(f=p.to+s)>t&&(this.highlightRange(r.cursor(),Math.max(t,p.from+s),Math.min(i,f),n,h),this.startSpan(f,l));}c&&e.parent();}else if(e.firstChild()){do{if(!(e.to<=t)){if(e.from>=i)break;this.highlightRange(e,t,i,n,o),this.startSpan(Math.min(i,e.to),l);}}while(e.nextSibling());e.parent();}}}function getStyleTags(e){let t=e.type.prop(ruleNodeProp);for(;t&&t.context&&!e.matchContext(t.context);)t=t.next;return t||null}const t=Tag.define,comment=t(),name$1=t(),typeName=t(name$1),propertyName=t(name$1),literal=t(),string=t(literal),number=t(literal),content=t(),heading=t(content),keyword=t(),operator=t(),punctuation=t(),bracket=t(punctuation),meta=t(),tags={comment:comment,lineComment:t(comment),blockComment:t(comment),docComment:t(comment),name:name$1,variableName:t(name$1),typeName:typeName,tagName:t(typeName),propertyName:propertyName,attributeName:t(propertyName),className:t(name$1),labelName:t(name$1),namespace:t(name$1),macroName:t(name$1),literal:literal,string:string,docString:t(string),character:t(string),attributeValue:t(string),number:number,integer:t(number),float:t(number),bool:t(literal),regexp:t(literal),escape:t(literal),color:t(literal),url:t(literal),keyword:keyword,self:t(keyword),null:t(keyword),atom:t(keyword),unit:t(keyword),modifier:t(keyword),operatorKeyword:t(keyword),controlKeyword:t(keyword),definitionKeyword:t(keyword),moduleKeyword:t(keyword),operator:operator,derefOperator:t(operator),arithmeticOperator:t(operator),logicOperator:t(operator),bitwiseOperator:t(operator),compareOperator:t(operator),updateOperator:t(operator),definitionOperator:t(operator),typeOperator:t(operator),controlOperator:t(operator),punctuation:punctuation,separator:t(punctuation),bracket:bracket,angleBracket:t(bracket),squareBracket:t(bracket),paren:t(bracket),brace:t(bracket),content:content,heading:heading,heading1:t(heading),heading2:t(heading),heading3:t(heading),heading4:t(heading),heading5:t(heading),heading6:t(heading),contentSeparator:t(content),list:t(content),quote:t(content),emphasis:t(content),strong:t(content),link:t(content),monospace:t(content),strikethrough:t(content),inserted:t(),deleted:t(),changed:t(),invalid:t(),meta:meta,documentMeta:t(meta),annotation:t(meta),processingInstruction:t(meta),definition:Tag.defineModifier(),constant:Tag.defineModifier(),function:Tag.defineModifier(),standard:Tag.defineModifier(),local:Tag.defineModifier(),special:Tag.defineModifier()};tagHighlighter([{tag:tags.link,class:"tok-link"},{tag:tags.heading,class:"tok-heading"},{tag:tags.emphasis,class:"tok-emphasis"},{tag:tags.strong,class:"tok-strong"},{tag:tags.keyword,class:"tok-keyword"},{tag:tags.atom,class:"tok-atom"},{tag:tags.bool,class:"tok-bool"},{tag:tags.url,class:"tok-url"},{tag:tags.labelName,class:"tok-labelName"},{tag:tags.inserted,class:"tok-inserted"},{tag:tags.deleted,class:"tok-deleted"},{tag:tags.literal,class:"tok-literal"},{tag:tags.string,class:"tok-string"},{tag:tags.number,class:"tok-number"},{tag:[tags.regexp,tags.escape,tags.special(tags.string)],class:"tok-string2"},{tag:tags.variableName,class:"tok-variableName"},{tag:tags.local(tags.variableName),class:"tok-variableName tok-local"},{tag:tags.definition(tags.variableName),class:"tok-variableName tok-definition"},{tag:tags.special(tags.variableName),class:"tok-variableName2"},{tag:tags.definition(tags.propertyName),class:"tok-propertyName tok-definition"},{tag:tags.typeName,class:"tok-typeName"},{tag:tags.namespace,class:"tok-namespace"},{tag:tags.className,class:"tok-className"},{tag:tags.macroName,class:"tok-macroName"},{tag:tags.propertyName,class:"tok-propertyName"},{tag:tags.operator,class:"tok-operator"},{tag:tags.comment,class:"tok-comment"},{tag:tags.meta,class:"tok-meta"},{tag:tags.invalid,class:"tok-invalid"},{tag:tags.punctuation,class:"tok-punctuation"}]);var _a;const languageDataProp=new NodeProp;function defineLanguageFacet(e){return Facet.define({combine:e?t=>t.concat(e):void 0})}class Language{constructor(e,t,i=[],n=""){this.data=e,this.name=n,EditorState.prototype.hasOwnProperty("tree")||Object.defineProperty(EditorState.prototype,"tree",{get(){return syntaxTree(this)}}),this.parser=t,this.extension=[language.of(this),EditorState.languageData.of((e,t,i)=>e.facet(languageDataFacetAt(e,t,i)))].concat(i);}isActiveAt(e,t,i=-1){return languageDataFacetAt(e,t,i)==this.data}findRegions(e){let t=e.facet(language);if((null===t||void 0===t?void 0:t.data)==this.data)return [{from:0,to:e.doc.length}];if(!t||!t.allowsNesting)return [];let i=[],n=(e,t)=>{if(e.prop(languageDataProp)==this.data)return void i.push({from:t,to:t+e.length});let o=e.prop(NodeProp.mounted);if(o){if(o.tree.prop(languageDataProp)==this.data){if(o.overlay)for(let e of o.overlay)i.push({from:e.from+t,to:e.to+t});else i.push({from:t,to:t+e.length});return}if(o.overlay){let e=i.length;if(n(o.tree,o.overlay[0].from+t),i.length>e)return}}for(let i=0;i<e.children.length;i++){let o=e.children[i];o instanceof Tree&&n(o,e.positions[i]+t);}};return n(syntaxTree(e),0),i}get allowsNesting(){return  true}}function languageDataFacetAt(e,t,i){let n=e.facet(language);if(!n)return null;let o=n.data;if(n.allowsNesting)for(let n=syntaxTree(e).topNode;n;n=n.enter(t,i,IterMode.ExcludeBuffers))o=n.type.prop(languageDataProp)||o;return o}Language.setState=StateEffect.define();class LRLanguage extends Language{constructor(e,t,i){super(e,t,[],i),this.parser=t;}static define(e){let t=defineLanguageFacet(e.languageData);return new LRLanguage(t,e.parser.configure({props:[languageDataProp.add(e=>e.isTop?t:void 0)]}),e.name)}configure(e,t){return new LRLanguage(this.data,this.parser.configure(e),t||this.name)}get allowsNesting(){return this.parser.hasWrappers()}}function syntaxTree(e){let t=e.field(Language.state,false);return t?t.tree:Tree.empty}class DocInput{constructor(e,t=e.length){this.doc=e,this.length=t,this.cursorPos=0,this.string="",this.cursor=e.iter();}syncTo(e){return this.string=this.cursor.next(e-this.cursorPos).value,this.cursorPos=e+this.string.length,this.cursorPos-this.string.length}chunk(e){return this.syncTo(e),this.string}get lineChunks(){return  true}read(e,t){let i=this.cursorPos-this.string.length;return e<i||t>=this.cursorPos?this.doc.sliceString(e,t):this.string.slice(e-i,t-i)}}let currentContext=null;class ParseContext{constructor(e,t,i=[],n,o,r,s,a){this.parser=e,this.state=t,this.fragments=i,this.tree=n,this.treeLen=o,this.viewport=r,this.skipped=s,this.scheduleOn=a,this.parse=null,this.tempSkipped=[];}static create(e,t,i){return new ParseContext(e,t,[],Tree.empty,0,i,[],null)}startParse(){return this.parser.startParse(new DocInput(this.state.doc),this.fragments)}work(e,t){return null!=t&&t>=this.state.doc.length&&(t=void 0),this.tree!=Tree.empty&&this.isDone(null!==t&&void 0!==t?t:this.state.doc.length)?(this.takeTree(),true):this.withContext(()=>{var i;if("number"==typeof e){let t=Date.now()+e;e=(()=>Date.now()>t);}for(this.parse||(this.parse=this.startParse()),null!=t&&(null==this.parse.stoppedAt||this.parse.stoppedAt>t)&&t<this.state.doc.length&&this.parse.stopAt(t);;){let n=this.parse.advance();if(n){if(this.fragments=this.withoutTempSkipped(TreeFragment.addTree(n,this.fragments,null!=this.parse.stoppedAt)),this.treeLen=null!==(i=this.parse.stoppedAt)&&void 0!==i?i:this.state.doc.length,this.tree=n,this.parse=null,!(this.treeLen<(null!==t&&void 0!==t?t:this.state.doc.length)))return  true;this.parse=this.startParse();}if(e())return  false}})}takeTree(){let e,t;this.parse&&(e=this.parse.parsedPos)>=this.treeLen&&((null==this.parse.stoppedAt||this.parse.stoppedAt>e)&&this.parse.stopAt(e),this.withContext(()=>{for(;!(t=this.parse.advance()););}),this.treeLen=e,this.tree=t,this.fragments=this.withoutTempSkipped(TreeFragment.addTree(this.tree,this.fragments,true)),this.parse=null);}withContext(e){let t=currentContext;currentContext=this;try{return e()}finally{currentContext=t;}}withoutTempSkipped(e){for(let t;t=this.tempSkipped.pop();)e=cutFragments(e,t.from,t.to);return e}changes(e,t){let{fragments:i,tree:n,treeLen:o,viewport:r,skipped:s}=this;if(this.takeTree(),!e.empty){let t=[];if(e.iterChangedRanges((e,i,n,o)=>t.push({fromA:e,toA:i,fromB:n,toB:o})),i=TreeFragment.applyChanges(i,t),n=Tree.empty,o=0,r={from:e.mapPos(r.from,-1),to:e.mapPos(r.to,1)},this.skipped.length){s=[];for(let t of this.skipped){let i=e.mapPos(t.from,1),n=e.mapPos(t.to,-1);i<n&&s.push({from:i,to:n});}}}return new ParseContext(this.parser,t,i,n,o,r,s,this.scheduleOn)}updateViewport(e){if(this.viewport.from==e.from&&this.viewport.to==e.to)return  false;this.viewport=e;let t=this.skipped.length;for(let t=0;t<this.skipped.length;t++){let{from:i,to:n}=this.skipped[t];i<e.to&&n>e.from&&(this.fragments=cutFragments(this.fragments,i,n),this.skipped.splice(t--,1));}return !(this.skipped.length>=t)&&(this.reset(),true)}reset(){this.parse&&(this.takeTree(),this.parse=null);}skipUntilInView(e,t){this.skipped.push({from:e,to:t});}static getSkippingParser(e){return new class extends Parser{createParse(t,i,n){let o=n[0].from,r=n[n.length-1].to;return {parsedPos:o,advance(){let t=currentContext;if(t){for(let e of n)t.tempSkipped.push(e);e&&(t.scheduleOn=t.scheduleOn?Promise.all([t.scheduleOn,e]):e);}return this.parsedPos=r,new Tree(NodeType.none,[],[],r-o)},stoppedAt:null,stopAt(){}}}}}isDone(e){e=Math.min(e,this.state.doc.length);let t=this.fragments;return this.treeLen>=e&&t.length&&0==t[0].from&&t[0].to>=e}static get(){return currentContext}}function cutFragments(e,t,i){return TreeFragment.applyChanges(e,[{fromA:t,toA:i,fromB:t,toB:i}])}class LanguageState{constructor(e){this.context=e,this.tree=e.tree;}apply(e){if(!e.docChanged&&this.tree==this.context.tree)return this;let t=this.context.changes(e.changes,e.state),i=this.context.treeLen==e.startState.doc.length?void 0:Math.max(e.changes.mapPos(this.context.treeLen),t.viewport.to);return t.work(20,i)||t.takeTree(),new LanguageState(t)}static init(e){let t=Math.min(3e3,e.doc.length),i=ParseContext.create(e.facet(language).parser,e,{from:0,to:t});return i.work(20,t)||i.takeTree(),new LanguageState(i)}}Language.state=StateField.define({create:LanguageState.init,update(e,t){for(let e of t.effects)if(e.is(Language.setState))return e.value;return t.startState.facet(language)!=t.state.facet(language)?LanguageState.init(t.state):e.apply(t)}});let requestIdle=e=>{let t=setTimeout(()=>e(),500);return ()=>clearTimeout(t)};"undefined"!=typeof requestIdleCallback&&(requestIdle=(e=>{let t=-1,i=setTimeout(()=>{t=requestIdleCallback(e,{timeout:400});},100);return ()=>t<0?clearTimeout(i):cancelIdleCallback(t)}));const isInputPending="undefined"!=typeof navigator&&(null===(_a=navigator.scheduling)||void 0===_a?void 0:_a.isInputPending)?()=>navigator.scheduling.isInputPending():null,parseWorker=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.working=null,this.workScheduled=0,this.chunkEnd=-1,this.chunkBudget=-1,this.work=this.work.bind(this),this.scheduleWork();}update(e){let t=this.view.state.field(Language.state).context;(t.updateViewport(e.view.viewport)||this.view.viewport.to>t.treeLen)&&this.scheduleWork(),e.docChanged&&(this.view.hasFocus&&(this.chunkBudget+=50),this.scheduleWork()),this.checkAsyncSchedule(t);}scheduleWork(){if(this.working)return;let{state:e}=this.view,t=e.field(Language.state);t.tree==t.context.tree&&t.context.isDone(e.doc.length)||(this.working=requestIdle(this.work));}work(e){this.working=null;let t=Date.now();if(this.chunkEnd<t&&(this.chunkEnd<0||this.view.hasFocus)&&(this.chunkEnd=t+3e4,this.chunkBudget=3e3),this.chunkBudget<=0)return;let{state:i,viewport:{to:n}}=this.view,o=i.field(Language.state);if(o.tree==o.context.tree&&o.context.isDone(n+1e5))return;let r=Date.now()+Math.min(this.chunkBudget,100,e&&!isInputPending?Math.max(25,e.timeRemaining()-5):1e9),s=o.context.treeLen<n&&i.doc.length>n+1e3,a=o.context.work(()=>isInputPending&&isInputPending()||Date.now()>r,n+(s?0:1e5));this.chunkBudget-=Date.now()-t,(a||this.chunkBudget<=0)&&(o.context.takeTree(),this.view.dispatch({effects:Language.setState.of(new LanguageState(o.context))})),this.chunkBudget>0&&(!a||s)&&this.scheduleWork(),this.checkAsyncSchedule(o.context);}checkAsyncSchedule(e){e.scheduleOn&&(this.workScheduled++,e.scheduleOn.then(()=>this.scheduleWork()).catch(e=>logException(this.view.state,e)).then(()=>this.workScheduled--),e.scheduleOn=null);}destroy(){this.working&&this.working();}isWorking(){return !!(this.working||this.workScheduled>0)}},{eventHandlers:{focus(){this.scheduleWork();}}}),language=Facet.define({combine:e=>e.length?e[0]:null,enables:e=>[Language.state,parseWorker,EditorView.contentAttributes.compute([e],t=>{let i=t.facet(e);return i&&i.name?{"data-language":i.name}:{}})]}),indentService=Facet.define(),indentUnit=Facet.define({combine:e=>{if(!e.length)return "  ";if(!/^(?: +|\t+)$/.test(e[0]))throw new Error("Invalid indent unit: "+JSON.stringify(e[0]));return e[0]}});function getIndentUnit(e){let t=e.facet(indentUnit);return 9==t.charCodeAt(0)?e.tabSize*t.length:t.length}function indentString(e,t){let i="",n=e.tabSize;if(9==e.facet(indentUnit).charCodeAt(0))for(;t>=n;)i+="\t",t-=n;for(let e=0;e<t;e++)i+=" ";return i}function getIndentation(e,t){e instanceof EditorState&&(e=new IndentContext(e));for(let i of e.state.facet(indentService)){let n=i(e,t);if(void 0!==n)return n}let i=syntaxTree(e.state);return i?syntaxIndentation(e,i,t):null}class IndentContext{constructor(e,t={}){this.state=e,this.options=t,this.unit=getIndentUnit(e);}lineAt(e,t=1){let i=this.state.doc.lineAt(e),{simulateBreak:n,simulateDoubleBreak:o}=this.options;return null!=n&&n>=i.from&&n<=i.to?o&&n==e?{text:"",from:e}:(t<0?n<e:n<=e)?{text:i.text.slice(n-i.from),from:n}:{text:i.text.slice(0,n-i.from),from:i.from}:i}textAfterPos(e,t=1){if(this.options.simulateDoubleBreak&&e==this.options.simulateBreak)return "";let{text:i,from:n}=this.lineAt(e,t);return i.slice(e-n,Math.min(i.length,e+100-n))}column(e,t=1){let{text:i,from:n}=this.lineAt(e,t),o=this.countColumn(i,e-n),r=this.options.overrideIndentation?this.options.overrideIndentation(n):-1;return r>-1&&(o+=r-this.countColumn(i,i.search(/\S|$/))),o}countColumn(e,t=e.length){return countColumn(e,this.state.tabSize,t)}lineIndent(e,t=1){let{text:i,from:n}=this.lineAt(e,t),o=this.options.overrideIndentation;if(o){let e=o(n);if(e>-1)return e}return this.countColumn(i,i.search(/\S|$/))}get simulatedBreak(){return this.options.simulateBreak||null}}const indentNodeProp=new NodeProp;function syntaxIndentation(e,t,i){return indentFrom(t.resolveInner(i).enterUnfinishedNodesBefore(i),i,e)}function ignoreClosed(e){return e.pos==e.options.simulateBreak&&e.options.simulateDoubleBreak}function indentStrategy(e){let t=e.type.prop(indentNodeProp);if(t)return t;let i,n=e.firstChild;if(n&&(i=n.type.prop(NodeProp.closedBy))){let t=e.lastChild,n=t&&i.indexOf(t.name)>-1;return e=>delimitedStrategy(e,true,1,void 0,n&&!ignoreClosed(e)?t.from:void 0)}return null==e.parent?topIndent:null}function indentFrom(e,t,i){for(;e;e=e.parent){let n=indentStrategy(e);if(n)return n(TreeIndentContext.create(i,t,e))}return null}function topIndent(){return 0}class TreeIndentContext extends IndentContext{constructor(e,t,i){super(e.state,e.options),this.base=e,this.pos=t,this.node=i;}static create(e,t,i){return new TreeIndentContext(e,t,i)}get textAfter(){return this.textAfterPos(this.pos)}get baseIndent(){let e=this.state.doc.lineAt(this.node.from);for(;;){let t=this.node.resolve(e.from);for(;t.parent&&t.parent.from==t.from;)t=t.parent;if(isParent(t,this.node))break;e=this.state.doc.lineAt(t.from);}return this.lineIndent(e.from)}continue(){let e=this.node.parent;return e?indentFrom(e,this.pos,this.base):0}}function isParent(e,t){for(let i=t;i;i=i.parent)if(e==i)return  true;return  false}function bracketedAligned(e){let t=e.node,i=t.childAfter(t.from),n=t.lastChild;if(!i)return null;let o=e.options.simulateBreak,r=e.state.doc.lineAt(i.from),s=null==o||o<=r.from?r.to:Math.min(r.to,o);for(let e=i.to;;){let o=t.childAfter(e);if(!o||o==n)return null;if(!o.type.isSkipped)return o.from<s?i:null;e=o.to;}}function delimitedIndent({closing:e,align:t=true,units:i=1}){return n=>delimitedStrategy(n,t,i,e)}function delimitedStrategy(e,t,i,n,o){let r=e.textAfter,s=r.match(/^\s*/)[0].length,a=n&&r.slice(s,s+n.length)==n||o==e.pos+s,l=t?bracketedAligned(e):null;return l?a?e.column(l.from):e.column(l.to):e.baseIndent+(a?0:e.unit*i)}const flatIndent=e=>e.baseIndent;function continuedIndent({except:e,units:t=1}={}){return i=>{let n=e&&e.test(i.textAfter);return i.baseIndent+(n?0:t*i.unit)}}const DontIndentBeyond=200;function indentOnInput(){return EditorState.transactionFilter.of(e=>{if(!e.docChanged||!e.isUserEvent("input.type")&&!e.isUserEvent("input.complete"))return e;let t=e.startState.languageDataAt("indentOnInput",e.startState.selection.main.head);if(!t.length)return e;let i=e.newDoc,{head:n}=e.newSelection.main,o=i.lineAt(n);if(n>o.from+DontIndentBeyond)return e;let r=i.sliceString(o.from,n);if(!t.some(e=>e.test(r)))return e;let{state:s}=e,a=-1,l=[];for(let{head:e}of s.selection.ranges){let t=s.doc.lineAt(e);if(t.from==a)continue;a=t.from;let i=getIndentation(s,t.from);if(null==i)continue;let n=/^\s*/.exec(t.text)[0],o=indentString(s,i);n!=o&&l.push({from:t.from,to:t.from+n.length,insert:o});}return l.length?[e,{changes:l,sequential:true}]:e})}const foldService=Facet.define(),foldNodeProp=new NodeProp;function foldInside(e){let t=e.firstChild,i=e.lastChild;return t&&t.to<i.from?{from:t.to,to:i.type.isError?e.to:i.from}:null}function syntaxFolding(e,t,i){let n=syntaxTree(e);if(n.length<i)return null;let o=null;for(let r=n.resolveInner(i,1);r;r=r.parent){if(r.to<=i||r.from>i)continue;if(o&&r.from<t)break;let s=r.type.prop(foldNodeProp);if(s&&(r.to<n.length-50||n.length==e.doc.length||!isUnfinished(r))){let n=s(r,e);n&&n.from<=i&&n.from>=t&&n.to>i&&(o=n);}}return o}function isUnfinished(e){let t=e.lastChild;return t&&t.to==e.to&&t.type.isError}function foldable(e,t,i){for(let n of e.facet(foldService)){let o=n(e,t,i);if(o)return o}return syntaxFolding(e,t,i)}function mapRange(e,t){let i=t.mapPos(e.from,1),n=t.mapPos(e.to,-1);return i>=n?void 0:{from:i,to:n}}const foldEffect=StateEffect.define({map:mapRange}),unfoldEffect=StateEffect.define({map:mapRange});function selectedLines(e){let t=[];for(let{head:i}of e.state.selection.ranges)t.some(e=>e.from<=i&&e.to>=i)||t.push(e.lineBlockAt(i));return t}const foldState=StateField.define({create:()=>Decoration.none,update(e,t){e=e.map(t.changes);for(let i of t.effects)i.is(foldEffect)&&!foldExists(e,i.value.from,i.value.to)?e=e.update({add:[foldWidget.range(i.value.from,i.value.to)]}):i.is(unfoldEffect)&&(e=e.update({filter:(e,t)=>i.value.from!=e||i.value.to!=t,filterFrom:i.value.from,filterTo:i.value.to}));if(t.selection){let i=false,{head:n}=t.selection.main;e.between(n,n,(e,t)=>{e<n&&t>n&&(i=true);}),i&&(e=e.update({filterFrom:n,filterTo:n,filter:(e,t)=>t<=n||e>=n}));}return e},provide:e=>EditorView.decorations.from(e),toJSON(e,t){let i=[];return e.between(0,t.doc.length,(e,t)=>{i.push(e,t);}),i},fromJSON(e){if(!Array.isArray(e)||e.length%2)throw new RangeError("Invalid JSON for fold state");let t=[];for(let i=0;i<e.length;){let n=e[i++],o=e[i++];if("number"!=typeof n||"number"!=typeof o)throw new RangeError("Invalid JSON for fold state");t.push(foldWidget.range(n,o));}return Decoration.set(t,true)}});function findFold(e,t,i){var n;let o=null;return null===(n=e.field(foldState,false))||void 0===n||n.between(t,i,(e,t)=>{(!o||o.from>e)&&(o={from:e,to:t});}),o}function foldExists(e,t,i){let n=false;return e.between(t,t,(e,o)=>{e==t&&o==i&&(n=true);}),n}function maybeEnable(e,t){return e.field(foldState,false)?t:t.concat(StateEffect.appendConfig.of(codeFolding()))}const foldCode=e=>{for(let t of selectedLines(e)){let i=foldable(e.state,t.from,t.to);if(i)return e.dispatch({effects:maybeEnable(e.state,[foldEffect.of(i),announceFold(e,i)])}),true}return  false},unfoldCode=e=>{if(!e.state.field(foldState,false))return  false;let t=[];for(let i of selectedLines(e)){let n=findFold(e.state,i.from,i.to);n&&t.push(unfoldEffect.of(n),announceFold(e,n,false));}return t.length&&e.dispatch({effects:t}),t.length>0};function announceFold(e,t,i=true){let n=e.state.doc.lineAt(t.from).number,o=e.state.doc.lineAt(t.to).number;return EditorView.announce.of(`${e.state.phrase(i?"Folded lines":"Unfolded lines")} ${n} ${e.state.phrase("to")} ${o}.`)}const foldAll=e=>{let{state:t}=e,i=[];for(let n=0;n<t.doc.length;){let o=e.lineBlockAt(n),r=foldable(t,o.from,o.to);r&&i.push(foldEffect.of(r)),n=(r?e.lineBlockAt(r.to):o).to+1;}return i.length&&e.dispatch({effects:maybeEnable(e.state,i)}),!!i.length},unfoldAll=e=>{let t=e.state.field(foldState,false);if(!t||!t.size)return  false;let i=[];return t.between(0,e.state.doc.length,(e,t)=>{i.push(unfoldEffect.of({from:e,to:t}));}),e.dispatch({effects:i}),true},foldKeymap=[{key:"Ctrl-Shift-[",mac:"Cmd-Alt-[",run:foldCode},{key:"Ctrl-Shift-]",mac:"Cmd-Alt-]",run:unfoldCode},{key:"Ctrl-Alt-[",run:foldAll},{key:"Ctrl-Alt-]",run:unfoldAll}],defaultConfig={placeholderDOM:null,placeholderText:"…"},foldConfig=Facet.define({combine:e=>combineConfig(e,defaultConfig)});function codeFolding(e){let t=[foldState,baseTheme$1$1];return t}const foldWidget=Decoration.replace({widget:new class extends WidgetType{toDOM(e){let{state:t}=e,i=t.facet(foldConfig),n=t=>{let i=e.lineBlockAt(e.posAtDOM(t.target)),n=findFold(e.state,i.from,i.to);n&&e.dispatch({effects:unfoldEffect.of(n)}),t.preventDefault();};if(i.placeholderDOM)return i.placeholderDOM(e,n);let o=document.createElement("span");return o.textContent=i.placeholderText,o.setAttribute("aria-label",t.phrase("folded code")),o.title=t.phrase("unfold"),o.className="cm-foldPlaceholder",o.onclick=n,o}}}),foldGutterDefaults={openText:"⌄",closedText:"›",markerDOM:null,domEventHandlers:{},foldingChanged:()=>false};class FoldMarker extends GutterMarker{constructor(e,t){super(),this.config=e,this.open=t;}eq(e){return this.config==e.config&&this.open==e.open}toDOM(e){if(this.config.markerDOM)return this.config.markerDOM(this.open);let t=document.createElement("span");return t.textContent=this.open?this.config.openText:this.config.closedText,t.title=e.state.phrase(this.open?"Fold line":"Unfold line"),t}}function foldGutter(e={}){let t=Object.assign(Object.assign({},foldGutterDefaults),e),i=new FoldMarker(t,true),n=new FoldMarker(t,false),o=ViewPlugin.fromClass(class{constructor(e){this.from=e.viewport.from,this.markers=this.buildMarkers(e);}update(e){(e.docChanged||e.viewportChanged||e.startState.facet(language)!=e.state.facet(language)||e.startState.field(foldState,false)!=e.state.field(foldState,false)||syntaxTree(e.startState)!=syntaxTree(e.state)||t.foldingChanged(e))&&(this.markers=this.buildMarkers(e.view));}buildMarkers(e){let t=new RangeSetBuilder;for(let o of e.viewportLineBlocks){let r=findFold(e.state,o.from,o.to)?n:foldable(e.state,o.from,o.to)?i:null;r&&t.add(o.from,o.from,r);}return t.finish()}}),{domEventHandlers:r}=t;return [o,gutter({class:"cm-foldGutter",markers(e){var t;return (null===(t=e.plugin(o))||void 0===t?void 0:t.markers)||RangeSet.empty},initialSpacer:()=>new FoldMarker(t,false),domEventHandlers:Object.assign(Object.assign({},r),{click:(e,t,i)=>{if(r.click&&r.click(e,t,i))return  true;let n=findFold(e.state,t.from,t.to);if(n)return e.dispatch({effects:unfoldEffect.of(n)}),true;let o=foldable(e.state,t.from,t.to);return !!o&&(e.dispatch({effects:foldEffect.of(o)}),true)}})}),codeFolding()]}const baseTheme$1$1=EditorView.baseTheme({".cm-foldPlaceholder":{backgroundColor:"#eee",border:"1px solid #ddd",color:"#888",borderRadius:".2em",margin:"0 1px",padding:"0 1px",cursor:"pointer"},".cm-foldGutter span":{padding:"0 1px",cursor:"pointer"}});class HighlightStyle{constructor(e,t){let i;function n(e){let t=StyleModule.newName();return (i||(i=Object.create(null)))["."+t]=e,t}this.specs=e;const o="string"==typeof t.all?t.all:t.all?n(t.all):void 0,r=t.scope;this.scope=r instanceof Language?e=>e.prop(languageDataProp)==r.data:r?e=>e==r:void 0,this.style=tagHighlighter(e.map(e=>({tag:e.tag,class:e.class||n(Object.assign({},e,{tag:null}))})),{all:o}).style,this.module=i?new StyleModule(i):null,this.themeType=t.themeType;}static define(e,t){return new HighlightStyle(e,t||{})}}const highlighterFacet=Facet.define(),fallbackHighlighter=Facet.define({combine:e=>e.length?[e[0]]:null});function getHighlighters(e){let t=e.facet(highlighterFacet);return t.length?t:e.facet(fallbackHighlighter)}function syntaxHighlighting(e,t){let i,n=[treeHighlighter];return e instanceof HighlightStyle&&(e.module&&n.push(EditorView.styleModule.of(e.module)),i=e.themeType),(null===t||void 0===t?void 0:t.fallback)?n.push(fallbackHighlighter.of(e)):i?n.push(highlighterFacet.computeN([EditorView.darkTheme],t=>t.facet(EditorView.darkTheme)==("dark"==i)?[e]:[])):n.push(highlighterFacet.of(e)),n}class TreeHighlighter{constructor(e){this.markCache=Object.create(null),this.tree=syntaxTree(e.state),this.decorations=this.buildDeco(e,getHighlighters(e.state));}update(e){let t=syntaxTree(e.state),i=getHighlighters(e.state),n=i!=getHighlighters(e.startState);t.length<e.view.viewport.to&&!n&&t.type==this.tree.type?this.decorations=this.decorations.map(e.changes):(t!=this.tree||e.viewportChanged||n)&&(this.tree=t,this.decorations=this.buildDeco(e.view,i));}buildDeco(e,t){if(!t||!this.tree.length)return Decoration.none;let i=new RangeSetBuilder;for(let{from:n,to:o}of e.visibleRanges)highlightTree(this.tree,t,(e,t,n)=>{i.add(e,t,this.markCache[n]||(this.markCache[n]=Decoration.mark({class:n})));},n,o);return i.finish()}}const treeHighlighter=Prec.high(ViewPlugin.fromClass(TreeHighlighter,{decorations:e=>e.decorations})),defaultHighlightStyle=HighlightStyle.define([{tag:tags.meta,color:"#7a757a"},{tag:tags.link,textDecoration:"underline"},{tag:tags.heading,textDecoration:"underline",fontWeight:"bold"},{tag:tags.emphasis,fontStyle:"italic"},{tag:tags.strong,fontWeight:"bold"},{tag:tags.strikethrough,textDecoration:"line-through"},{tag:tags.keyword,color:"#708"},{tag:[tags.atom,tags.bool,tags.url,tags.contentSeparator,tags.labelName],color:"#219"},{tag:[tags.literal,tags.inserted],color:"#164"},{tag:[tags.string,tags.deleted],color:"#a11"},{tag:[tags.regexp,tags.escape,tags.special(tags.string)],color:"#e40"},{tag:tags.definition(tags.variableName),color:"#00f"},{tag:tags.local(tags.variableName),color:"#30a"},{tag:[tags.typeName,tags.namespace],color:"#085"},{tag:tags.className,color:"#167"},{tag:[tags.special(tags.variableName),tags.macroName],color:"#256"},{tag:tags.definition(tags.propertyName),color:"#00c"},{tag:tags.comment,color:"#940"},{tag:tags.invalid,color:"#f00"}]),baseTheme$2=EditorView.baseTheme({"&.cm-focused .cm-matchingBracket":{backgroundColor:"#328c8252"},"&.cm-focused .cm-nonmatchingBracket":{backgroundColor:"#bb555544"}}),DefaultScanDist=1e4,DefaultBrackets="()[]{}",bracketMatchingConfig=Facet.define({combine:e=>combineConfig(e,{afterCursor:true,brackets:DefaultBrackets,maxScanDistance:DefaultScanDist,renderMatch:defaultRenderMatch})}),matchingMark=Decoration.mark({class:"cm-matchingBracket"}),nonmatchingMark=Decoration.mark({class:"cm-nonmatchingBracket"});function defaultRenderMatch(e){let t=[],i=e.matched?matchingMark:nonmatchingMark;return t.push(i.range(e.start.from,e.start.to)),e.end&&t.push(i.range(e.end.from,e.end.to)),t}const bracketMatchingState=StateField.define({create:()=>Decoration.none,update(e,t){if(!t.docChanged&&!t.selection)return e;let i=[],n=t.state.facet(bracketMatchingConfig);for(let e of t.state.selection.ranges){if(!e.empty)continue;let o=matchBrackets(t.state,e.head,-1,n)||e.head>0&&matchBrackets(t.state,e.head-1,1,n)||n.afterCursor&&(matchBrackets(t.state,e.head,1,n)||e.head<t.state.doc.length&&matchBrackets(t.state,e.head+1,-1,n));o&&(i=i.concat(n.renderMatch(o,t.state)));}return Decoration.set(i,true)},provide:e=>EditorView.decorations.from(e)}),bracketMatchingUnique=[bracketMatchingState,baseTheme$2];function bracketMatching(e={}){return [bracketMatchingConfig.of(e),bracketMatchingUnique]}function matchingNodes(e,t,i){let n=e.prop(t<0?NodeProp.openedBy:NodeProp.closedBy);if(n)return n;if(1==e.name.length){let n=i.indexOf(e.name);if(n>-1&&n%2==(t<0?1:0))return [i[n+t]]}return null}function matchBrackets(e,t,i,n={}){let o=n.maxScanDistance||DefaultScanDist,r=n.brackets||DefaultBrackets,s=syntaxTree(e),a=s.resolveInner(t,i);for(let n=a;n;n=n.parent){let o=matchingNodes(n.type,i,r);if(o&&n.from<n.to)return matchMarkedBrackets(e,t,i,n,o,r)}return matchPlainBrackets(e,t,i,s,a.type,o,r)}function matchMarkedBrackets(e,t,i,n,o,r){let s=n.parent,a={from:n.from,to:n.to},l=0,h=null===s||void 0===s?void 0:s.cursor();if(h&&(i<0?h.childBefore(n.from):h.childAfter(n.to)))do{if(i<0?h.to<=n.from:h.from>=n.to){if(0==l&&o.indexOf(h.type.name)>-1&&h.from<h.to)return {start:a,end:{from:h.from,to:h.to},matched:true};if(matchingNodes(h.type,i,r))l++;else if(matchingNodes(h.type,-i,r)){if(0==l)return {start:a,end:h.from==h.to?void 0:{from:h.from,to:h.to},matched:false};l--;}}}while(i<0?h.prevSibling():h.nextSibling());return {start:a,matched:false}}function matchPlainBrackets(e,t,i,n,o,r,s){let a=i<0?e.sliceDoc(t-1,t):e.sliceDoc(t,t+1),l=s.indexOf(a);if(l<0||l%2==0!=i>0)return null;let h={from:i<0?t-1:t,to:i>0?t+1:t},c=e.doc.iterRange(t,i>0?e.doc.length:0),d=0;for(let e=0;!c.next().done&&e<=r;){let r=c.value;i<0&&(e+=r.length);let a=t+e*i;for(let e=i>0?0:r.length-1,t=i>0?r.length:-1;e!=t;e+=i){let t=s.indexOf(r[e]);if(!(t<0||n.resolveInner(a+e,1).type!=o))if(t%2==0==i>0)d++;else {if(1==d)return {start:h,end:{from:a+e,to:a+e+1},matched:t>>1==l>>1};d--;}}i>0&&(e+=r.length);}return c.done?{start:h,matched:false}:null}const noTokens=Object.create(null),typeArray=[NodeType.none];new NodeSet(typeArray);const warned=[],defaultTable=Object.create(null);for(let[e,t]of [["variable","variableName"],["variable-2","variableName.special"],["string-2","string.special"],["def","variableName.definition"],["tag","tagName"],["attribute","attributeName"],["type","typeName"],["builtin","variableName.standard"],["qualifier","modifier"],["error","invalid"],["header","heading"],["property","propertyName"]])defaultTable[e]=createTokenType(noTokens,t);class TokenTable{constructor(e){this.extra=e,this.table=Object.assign(Object.create(null),defaultTable);}resolve(e){return e?this.table[e]||(this.table[e]=createTokenType(this.extra,e)):0}}new TokenTable(noTokens);function warnForPart(e,t){warned.indexOf(e)>-1||(warned.push(e),console.warn(t));}function createTokenType(e,t){let i=null;for(let n of t.split(".")){let t=e[n]||tags[n];t?"function"==typeof t?i?i=t(i):warnForPart(n,`Modifier ${n} used at start of tag`):i?warnForPart(n,`Tag ${n} used as modifier`):i=t:warnForPart(n,`Unknown highlighting tag ${n}`);}if(!i)return 0;let n=t.replace(/ /g,"_"),o=NodeType.define({id:typeArray.length,name:n,props:[styleTags({[n]:i})]});return typeArray.push(o),o.id}const toggleComment=e=>{let t=getConfig(e.state);return t.line?toggleLineComment(e):!!t.block&&toggleBlockCommentByLine(e)};function command(e,t){return ({state:i,dispatch:n})=>{if(i.readOnly)return  false;let o=e(t,i);return !!o&&(n(i.update(o)),true)}}const toggleLineComment=command(changeLineComment,0),toggleBlockComment=command(changeBlockComment,0),toggleBlockCommentByLine=command((e,t)=>changeBlockComment(e,t,selectedLineRanges(t)),0);function getConfig(e,t=e.selection.main.head){let i=e.languageDataAt("commentTokens",t);return i.length?i[0]:{}}const SearchMargin=50;function findBlockComment(e,{open:t,close:i},n,o){let r,s,a=e.sliceDoc(n-SearchMargin,n),l=e.sliceDoc(o,o+SearchMargin),h=/\s*$/.exec(a)[0].length,c=/^\s*/.exec(l)[0].length,d=a.length-h;if(a.slice(d-t.length,d)==t&&l.slice(c,c+i.length)==i)return {open:{pos:n-h,margin:h&&1},close:{pos:o+c,margin:c&&1}};o-n<=2*SearchMargin?r=s=e.sliceDoc(n,o):(r=e.sliceDoc(n,n+SearchMargin),s=e.sliceDoc(o-SearchMargin,o));let u=/^\s*/.exec(r)[0].length,f=/\s*$/.exec(s)[0].length,p=s.length-f-i.length;return r.slice(u,u+t.length)==t&&s.slice(p,p+i.length)==i?{open:{pos:n+u+t.length,margin:/\s/.test(r.charAt(u+t.length))?1:0},close:{pos:o-f-i.length,margin:/\s/.test(s.charAt(p-1))?1:0}}:null}function selectedLineRanges(e){let t=[];for(let i of e.selection.ranges){let n=e.doc.lineAt(i.from),o=i.to<=n.to?n:e.doc.lineAt(i.to),r=t.length-1;r>=0&&t[r].to>n.from?t[r].to=o.to:t.push({from:n.from,to:o.to});}return t}function changeBlockComment(e,t,i=t.selection.ranges){let n=i.map(e=>getConfig(t,e.from).block);if(!n.every(e=>e))return null;let o=i.map((e,i)=>findBlockComment(t,n[i],e.from,e.to));if(2!=e&&!o.every(e=>e))return {changes:t.changes(i.map((e,t)=>o[t]?[]:[{from:e.from,insert:n[t].open+" "},{from:e.to,insert:" "+n[t].close}]))};if(1!=e&&o.some(e=>e)){let e=[];for(let t,i=0;i<o.length;i++)if(t=o[i]){let o=n[i],{open:r,close:s}=t;e.push({from:r.pos-o.open.length,to:r.pos+r.margin},{from:s.pos-s.margin,to:s.pos+o.close.length});}return {changes:e}}return null}function changeLineComment(e,t,i=t.selection.ranges){let n=[],o=-1;for(let{from:e,to:r}of i){let i=n.length,s=1e9;for(let i=e;i<=r;){let a=t.doc.lineAt(i);if(a.from>o&&(e==r||r>a.from)){o=a.from;let e=getConfig(t,i).line;if(!e)continue;let r=/^\s*/.exec(a.text)[0].length,l=r==a.length,h=a.text.slice(r,r+e.length)==e?r:-1;r<a.text.length&&r<s&&(s=r),n.push({line:a,comment:h,token:e,indent:r,empty:l,single:false});}i=a.to+1;}if(s<1e9)for(let e=i;e<n.length;e++)n[e].indent<n[e].line.text.length&&(n[e].indent=s);n.length==i+1&&(n[i].single=true);}if(2!=e&&n.some(e=>e.comment<0&&(!e.empty||e.single))){let e=[];for(let{line:t,token:i,indent:o,empty:r,single:s}of n)!s&&r||e.push({from:t.from+o,insert:i+" "});let i=t.changes(e);return {changes:i,selection:t.selection.map(i,1)}}if(1!=e&&n.some(e=>e.comment>=0)){let e=[];for(let{line:t,comment:i,token:o}of n)if(i>=0){let n=t.from+i,r=n+o.length;" "==t.text[r-t.from]&&r++,e.push({from:n,to:r});}return {changes:e}}return null}const fromHistory=Annotation.define(),isolateHistory=Annotation.define(),invertedEffects=Facet.define(),historyConfig=Facet.define({combine:e=>combineConfig(e,{minDepth:100,newGroupDelay:500},{minDepth:Math.max,newGroupDelay:Math.min})});function changeEnd(e){let t=0;return e.iterChangedRanges((e,i)=>t=i),t}const historyField_=StateField.define({create:()=>HistoryState.empty,update(e,t){let i=t.state.facet(historyConfig),n=t.annotation(fromHistory);if(n){let o=t.docChanged?EditorSelection.single(changeEnd(t.changes)):void 0,r=HistEvent.fromTransaction(t,o),s=n.side,a=0==s?e.undone:e.done;return a=r?updateBranch(a,a.length,i.minDepth,r):addSelection(a,t.startState.selection),new HistoryState(0==s?n.rest:a,0==s?a:n.rest)}let o=t.annotation(isolateHistory);if("full"!=o&&"before"!=o||(e=e.isolate()),false===t.annotation(Transaction.addToHistory))return t.changes.empty?e:e.addMapping(t.changes.desc);let r=HistEvent.fromTransaction(t),s=t.annotation(Transaction.time),a=t.annotation(Transaction.userEvent);return r?e=e.addChanges(r,s,a,i.newGroupDelay,i.minDepth):t.selection&&(e=e.addSelection(t.startState.selection,s,a,i.newGroupDelay)),"full"!=o&&"after"!=o||(e=e.isolate()),e},toJSON:e=>({done:e.done.map(e=>e.toJSON()),undone:e.undone.map(e=>e.toJSON())}),fromJSON:e=>new HistoryState(e.done.map(HistEvent.fromJSON),e.undone.map(HistEvent.fromJSON))});function history(e={}){return [historyField_,historyConfig.of(e),EditorView.domEventHandlers({beforeinput(e,t){let i="historyUndo"==e.inputType?undo:"historyRedo"==e.inputType?redo:null;return !!i&&(e.preventDefault(),i(t))}})]}function cmd(e,t){return function({state:i,dispatch:n}){if(!t&&i.readOnly)return  false;let o=i.field(historyField_,false);if(!o)return  false;let r=o.pop(e,i,t);return !!r&&(n(r),true)}}const undo=cmd(0,false),redo=cmd(1,false),undoSelection=cmd(0,true),redoSelection=cmd(1,true);class HistEvent{constructor(e,t,i,n,o){this.changes=e,this.effects=t,this.mapped=i,this.startSelection=n,this.selectionsAfter=o;}setSelAfter(e){return new HistEvent(this.changes,this.effects,this.mapped,this.startSelection,e)}toJSON(){var e,t,i;return {changes:null===(e=this.changes)||void 0===e?void 0:e.toJSON(),mapped:null===(t=this.mapped)||void 0===t?void 0:t.toJSON(),startSelection:null===(i=this.startSelection)||void 0===i?void 0:i.toJSON(),selectionsAfter:this.selectionsAfter.map(e=>e.toJSON())}}static fromJSON(e){return new HistEvent(e.changes&&ChangeSet.fromJSON(e.changes),[],e.mapped&&ChangeDesc.fromJSON(e.mapped),e.startSelection&&EditorSelection.fromJSON(e.startSelection),e.selectionsAfter.map(EditorSelection.fromJSON))}static fromTransaction(e,t){let i=none$1;for(let t of e.startState.facet(invertedEffects)){let n=t(e);n.length&&(i=i.concat(n));}return !i.length&&e.changes.empty?null:new HistEvent(e.changes.invert(e.startState.doc),i,void 0,t||e.startState.selection,none$1)}static selection(e){return new HistEvent(void 0,none$1,void 0,void 0,e)}}function updateBranch(e,t,i,n){let o=t+1>i+20?t-i-1:0,r=e.slice(o,t);return r.push(n),r}function isAdjacent(e,t){let i=[],n=false;return e.iterChangedRanges((e,t)=>i.push(e,t)),t.iterChangedRanges((e,t,o,r)=>{for(let e=0;e<i.length;){let t=i[e++],s=i[e++];r>=t&&o<=s&&(n=true);}}),n}function eqSelectionShape(e,t){return e.ranges.length==t.ranges.length&&0===e.ranges.filter((e,i)=>e.empty!=t.ranges[i].empty).length}function conc(e,t){return e.length?t.length?e.concat(t):e:t}const none$1=[],MaxSelectionsPerEvent=200;function addSelection(e,t){if(e.length){let i=e[e.length-1],n=i.selectionsAfter.slice(Math.max(0,i.selectionsAfter.length-MaxSelectionsPerEvent));return n.length&&n[n.length-1].eq(t)?e:(n.push(t),updateBranch(e,e.length-1,1e9,i.setSelAfter(n)))}return [HistEvent.selection([t])]}function popSelection(e){let t=e[e.length-1],i=e.slice();return i[e.length-1]=t.setSelAfter(t.selectionsAfter.slice(0,t.selectionsAfter.length-1)),i}function addMappingToBranch(e,t){if(!e.length)return e;let i=e.length,n=none$1;for(;i;){let o=mapEvent(e[i-1],t,n);if(o.changes&&!o.changes.empty||o.effects.length){let t=e.slice(0,i);return t[i-1]=o,t}t=o.mapped,i--,n=o.selectionsAfter;}return n.length?[HistEvent.selection(n)]:none$1}function mapEvent(e,t,i){let n=conc(e.selectionsAfter.length?e.selectionsAfter.map(e=>e.map(t)):none$1,i);if(!e.changes)return HistEvent.selection(n);let o=e.changes.map(t),r=t.mapDesc(e.changes,true),s=e.mapped?e.mapped.composeDesc(r):r;return new HistEvent(o,StateEffect.mapEffects(e.effects,t),s,e.startSelection.map(r),n)}const joinableUserEvent=/^(input\.type|delete)($|\.)/;class HistoryState{constructor(e,t,i=0,n){this.done=e,this.undone=t,this.prevTime=i,this.prevUserEvent=n;}isolate(){return this.prevTime?new HistoryState(this.done,this.undone):this}addChanges(e,t,i,n,o){let r=this.done,s=r[r.length-1];return r=s&&s.changes&&!s.changes.empty&&e.changes&&(!i||joinableUserEvent.test(i))&&(!s.selectionsAfter.length&&t-this.prevTime<n&&isAdjacent(s.changes,e.changes)||"input.type.compose"==i)?updateBranch(r,r.length-1,o,new HistEvent(e.changes.compose(s.changes),conc(e.effects,s.effects),s.mapped,s.startSelection,none$1)):updateBranch(r,r.length,o,e),new HistoryState(r,none$1,t,i)}addSelection(e,t,i,n){let o=this.done.length?this.done[this.done.length-1].selectionsAfter:none$1;return o.length>0&&t-this.prevTime<n&&i==this.prevUserEvent&&i&&/^select($|\.)/.test(i)&&eqSelectionShape(o[o.length-1],e)?this:new HistoryState(addSelection(this.done,e),this.undone,t,i)}addMapping(e){return new HistoryState(addMappingToBranch(this.done,e),addMappingToBranch(this.undone,e),this.prevTime,this.prevUserEvent)}pop(e,t,i){let n=0==e?this.done:this.undone;if(0==n.length)return null;let o=n[n.length-1];if(i&&o.selectionsAfter.length)return t.update({selection:o.selectionsAfter[o.selectionsAfter.length-1],annotations:fromHistory.of({side:e,rest:popSelection(n)}),userEvent:0==e?"select.undo":"select.redo",scrollIntoView:true});if(o.changes){let i=1==n.length?none$1:n.slice(0,n.length-1);return o.mapped&&(i=addMappingToBranch(i,o.mapped)),t.update({changes:o.changes,selection:o.startSelection,effects:o.effects,annotations:fromHistory.of({side:e,rest:i}),filter:false,userEvent:0==e?"undo":"redo",scrollIntoView:true})}return null}}HistoryState.empty=new HistoryState(none$1,none$1);const historyKeymap=[{key:"Mod-z",run:undo,preventDefault:true},{key:"Mod-y",mac:"Mod-Shift-z",run:redo,preventDefault:true},{linux:"Ctrl-Shift-z",run:redo,preventDefault:true},{key:"Mod-u",run:undoSelection,preventDefault:true},{key:"Alt-u",mac:"Mod-Shift-u",run:redoSelection,preventDefault:true}];function updateSel(e,t){return EditorSelection.create(e.ranges.map(t),e.mainIndex)}function setSel(e,t){return e.update({selection:t,scrollIntoView:true,userEvent:"select"})}function moveSel({state:e,dispatch:t},i){let n=updateSel(e.selection,i);return !n.eq(e.selection)&&(t(setSel(e,n)),true)}function rangeEnd(e,t){return EditorSelection.cursor(t?e.to:e.from)}function cursorByChar(e,t){return moveSel(e,i=>i.empty?e.moveByChar(i,t):rangeEnd(i,t))}function ltrAtCursor(e){return e.textDirectionAt(e.state.selection.main.head)==Direction.LTR}const cursorCharLeft=e=>cursorByChar(e,!ltrAtCursor(e)),cursorCharRight=e=>cursorByChar(e,ltrAtCursor(e));function cursorByGroup(e,t){return moveSel(e,i=>i.empty?e.moveByGroup(i,t):rangeEnd(i,t))}const cursorGroupLeft=e=>cursorByGroup(e,!ltrAtCursor(e)),cursorGroupRight=e=>cursorByGroup(e,ltrAtCursor(e));function interestingNode(e,t,i){if(t.type.prop(i))return  true;let n=t.to-t.from;return n&&(n>2||/[^\s,.;:]/.test(e.sliceDoc(t.from,t.to)))||t.firstChild}function moveBySyntax(e,t,i){let n,o,r=syntaxTree(e).resolveInner(t.head),s=i?NodeProp.closedBy:NodeProp.openedBy;for(let n=t.head;;){let t=i?r.childAfter(n):r.childBefore(n);if(!t)break;interestingNode(e,t,s)?r=t:n=i?t.to:t.from;}return o=r.type.prop(s)&&(n=i?matchBrackets(e,r.from,1):matchBrackets(e,r.to,-1))&&n.matched?i?n.end.to:n.end.from:i?r.to:r.from,EditorSelection.cursor(o,i?-1:1)}const cursorSyntaxLeft=e=>moveSel(e,t=>moveBySyntax(e.state,t,!ltrAtCursor(e))),cursorSyntaxRight=e=>moveSel(e,t=>moveBySyntax(e.state,t,ltrAtCursor(e)));function cursorByLine(e,t){return moveSel(e,i=>{if(!i.empty)return rangeEnd(i,t);let n=e.moveVertically(i,t);return n.head!=i.head?n:e.moveToLineBoundary(i,t)})}const cursorLineUp=e=>cursorByLine(e,false),cursorLineDown=e=>cursorByLine(e,true);function pageHeight(e){return Math.max(e.defaultLineHeight,Math.min(e.dom.clientHeight,innerHeight)-5)}function cursorByPage(e,t){let{state:i}=e,n=updateSel(i.selection,i=>i.empty?e.moveVertically(i,t,pageHeight(e)):rangeEnd(i,t));if(n.eq(i.selection))return  false;let o,r=e.coordsAtPos(i.selection.main.head),s=e.scrollDOM.getBoundingClientRect();return r&&r.top>s.top&&r.bottom<s.bottom&&r.top-s.top<=e.scrollDOM.scrollHeight-e.scrollDOM.scrollTop-e.scrollDOM.clientHeight&&(o=EditorView.scrollIntoView(n.main.head,{y:"start",yMargin:r.top-s.top})),e.dispatch(setSel(i,n),{effects:o}),true}const cursorPageUp=e=>cursorByPage(e,false),cursorPageDown=e=>cursorByPage(e,true);function moveByLineBoundary(e,t,i){let n=e.lineBlockAt(t.head),o=e.moveToLineBoundary(t,i);if(o.head==t.head&&o.head!=(i?n.to:n.from)&&(o=e.moveToLineBoundary(t,i,false)),!i&&o.head==n.from&&n.length){let i=/^\s*/.exec(e.state.sliceDoc(n.from,Math.min(n.from+100,n.to)))[0].length;i&&t.head!=n.from+i&&(o=EditorSelection.cursor(n.from+i));}return o}const cursorLineBoundaryForward=e=>moveSel(e,t=>moveByLineBoundary(e,t,true)),cursorLineBoundaryBackward=e=>moveSel(e,t=>moveByLineBoundary(e,t,false)),cursorLineBoundaryLeft=e=>moveSel(e,t=>moveByLineBoundary(e,t,!ltrAtCursor(e))),cursorLineBoundaryRight=e=>moveSel(e,t=>moveByLineBoundary(e,t,ltrAtCursor(e))),cursorLineStart=e=>moveSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).from,1)),cursorLineEnd=e=>moveSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).to,-1));function toMatchingBracket(e,t,i){let n=false,o=updateSel(e.selection,t=>{let o=matchBrackets(e,t.head,-1)||matchBrackets(e,t.head,1)||t.head>0&&matchBrackets(e,t.head-1,1)||t.head<e.doc.length&&matchBrackets(e,t.head+1,-1);if(!o||!o.end)return t;n=true;let r=o.start.from==t.head?o.end.to:o.end.from;return EditorSelection.cursor(r)});return !!n&&(t(setSel(e,o)),true)}const cursorMatchingBracket=({state:e,dispatch:t})=>toMatchingBracket(e,t);function extendSel(e,t){let i=updateSel(e.state.selection,e=>{let i=t(e);return EditorSelection.range(e.anchor,i.head,i.goalColumn)});return !i.eq(e.state.selection)&&(e.dispatch(setSel(e.state,i)),true)}function selectByChar(e,t){return extendSel(e,i=>e.moveByChar(i,t))}const selectCharLeft=e=>selectByChar(e,!ltrAtCursor(e)),selectCharRight=e=>selectByChar(e,ltrAtCursor(e));function selectByGroup(e,t){return extendSel(e,i=>e.moveByGroup(i,t))}const selectGroupLeft=e=>selectByGroup(e,!ltrAtCursor(e)),selectGroupRight=e=>selectByGroup(e,ltrAtCursor(e)),selectSyntaxLeft=e=>extendSel(e,t=>moveBySyntax(e.state,t,!ltrAtCursor(e))),selectSyntaxRight=e=>extendSel(e,t=>moveBySyntax(e.state,t,ltrAtCursor(e)));function selectByLine(e,t){return extendSel(e,i=>e.moveVertically(i,t))}const selectLineUp=e=>selectByLine(e,false),selectLineDown=e=>selectByLine(e,true);function selectByPage(e,t){return extendSel(e,i=>e.moveVertically(i,t,pageHeight(e)))}const selectPageUp=e=>selectByPage(e,false),selectPageDown=e=>selectByPage(e,true),selectLineBoundaryForward=e=>extendSel(e,t=>moveByLineBoundary(e,t,true)),selectLineBoundaryBackward=e=>extendSel(e,t=>moveByLineBoundary(e,t,false)),selectLineBoundaryLeft=e=>extendSel(e,t=>moveByLineBoundary(e,t,!ltrAtCursor(e))),selectLineBoundaryRight=e=>extendSel(e,t=>moveByLineBoundary(e,t,ltrAtCursor(e))),selectLineStart=e=>extendSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).from)),selectLineEnd=e=>extendSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).to)),cursorDocStart=({state:e,dispatch:t})=>(t(setSel(e,{anchor:0})),true),cursorDocEnd=({state:e,dispatch:t})=>(t(setSel(e,{anchor:e.doc.length})),true),selectDocStart=({state:e,dispatch:t})=>(t(setSel(e,{anchor:e.selection.main.anchor,head:0})),true),selectDocEnd=({state:e,dispatch:t})=>(t(setSel(e,{anchor:e.selection.main.anchor,head:e.doc.length})),true),selectAll=({state:e,dispatch:t})=>(t(e.update({selection:{anchor:0,head:e.doc.length},userEvent:"select"})),true),selectLine=({state:e,dispatch:t})=>{let i=selectedLineBlocks(e).map(({from:t,to:i})=>EditorSelection.range(t,Math.min(i+1,e.doc.length)));return t(e.update({selection:EditorSelection.create(i),userEvent:"select"})),true},selectParentSyntax=({state:e,dispatch:t})=>{let i=updateSel(e.selection,t=>{var i;let n=syntaxTree(e).resolveInner(t.head,1);for(;!(n.from<t.from&&n.to>=t.to||n.to>t.to&&n.from<=t.from)&&(null===(i=n.parent)||void 0===i?void 0:i.parent);)n=n.parent;return EditorSelection.range(n.to,n.from)});return t(setSel(e,i)),true},simplifySelection=({state:e,dispatch:t})=>{let i=e.selection,n=null;return i.ranges.length>1?n=EditorSelection.create([i.main]):i.main.empty||(n=EditorSelection.create([EditorSelection.cursor(i.main.head)])),!!n&&(t(setSel(e,n)),true)};function deleteBy(e,t){if(e.state.readOnly)return  false;let i="delete.selection",{state:n}=e,o=n.changeByRange(n=>{let{from:o,to:r}=n;if(o==r){let n=t(o);n<o?(i="delete.backward",n=skipAtomic(e,n,false)):n>o&&(i="delete.forward",n=skipAtomic(e,n,true)),o=Math.min(o,n),r=Math.max(r,n);}else o=skipAtomic(e,o,false),r=skipAtomic(e,r,true);return o==r?{range:n}:{changes:{from:o,to:r},range:EditorSelection.cursor(o)}});return !o.changes.empty&&(e.dispatch(n.update(o,{scrollIntoView:true,userEvent:i,effects:"delete.selection"==i?EditorView.announce.of(n.phrase("Selection deleted")):void 0})),true)}function skipAtomic(e,t,i){if(e instanceof EditorView)for(let n of e.state.facet(EditorView.atomicRanges).map(t=>t(e)))n.between(t,t,(e,n)=>{e<t&&n>t&&(t=i?n:e);});return t}const deleteByChar=(e,t)=>deleteBy(e,i=>{let n,o,{state:r}=e,s=r.doc.lineAt(i);if(!t&&i>s.from&&i<s.from+200&&!/[^ \t]/.test(n=s.text.slice(0,i-s.from))){if("\t"==n[n.length-1])return i-1;let e=countColumn(n,r.tabSize)%getIndentUnit(r)||getIndentUnit(r);for(let t=0;t<e&&" "==n[n.length-1-t];t++)i--;o=i;}else (o=findClusterBreak(s.text,i-s.from,t,t)+s.from)==i&&s.number!=(t?r.doc.lines:1)&&(o+=t?1:-1);return o}),deleteCharBackward=e=>deleteByChar(e,false),deleteCharForward=e=>deleteByChar(e,true),deleteByGroup=(e,t)=>deleteBy(e,i=>{let n=i,{state:o}=e,r=o.doc.lineAt(n),s=o.charCategorizer(n);for(let e=null;;){if(n==(t?r.to:r.from)){n==i&&r.number!=(t?o.doc.lines:1)&&(n+=t?1:-1);break}let a=findClusterBreak(r.text,n-r.from,t)+r.from,l=r.text.slice(Math.min(n,a)-r.from,Math.max(n,a)-r.from),h=s(l);if(null!=e&&h!=e)break;" "==l&&n==i||(e=h),n=a;}return n}),deleteGroupBackward=e=>deleteByGroup(e,false),deleteGroupForward=e=>deleteByGroup(e,true),deleteToLineEnd=e=>deleteBy(e,t=>{let i=e.lineBlockAt(t).to;return t<i?i:Math.min(e.state.doc.length,t+1)}),deleteToLineStart=e=>deleteBy(e,t=>{let i=e.lineBlockAt(t).from;return t>i?i:Math.max(0,t-1)}),splitLine=({state:e,dispatch:t})=>{if(e.readOnly)return  false;let i=e.changeByRange(e=>({changes:{from:e.from,to:e.to,insert:Text.of(["",""])},range:EditorSelection.cursor(e.from)}));return t(e.update(i,{scrollIntoView:true,userEvent:"input"})),true},transposeChars=({state:e,dispatch:t})=>{if(e.readOnly)return  false;let i=e.changeByRange(t=>{if(!t.empty||0==t.from||t.from==e.doc.length)return {range:t};let i=t.from,n=e.doc.lineAt(i),o=i==n.from?i-1:findClusterBreak(n.text,i-n.from,false)+n.from,r=i==n.to?i+1:findClusterBreak(n.text,i-n.from,true)+n.from;return {changes:{from:o,to:r,insert:e.doc.slice(i,r).append(e.doc.slice(o,i))},range:EditorSelection.cursor(r)}});return !i.changes.empty&&(t(e.update(i,{scrollIntoView:true,userEvent:"move.character"})),true)};function selectedLineBlocks(e){let t=[],i=-1;for(let n of e.selection.ranges){let o=e.doc.lineAt(n.from),r=e.doc.lineAt(n.to);if(n.empty||n.to!=r.from||(r=e.doc.lineAt(n.to-1)),i>=o.number){let e=t[t.length-1];e.to=r.to,e.ranges.push(n);}else t.push({from:o.from,to:r.to,ranges:[n]});i=r.number+1;}return t}function moveLine(e,t,i){if(e.readOnly)return  false;let n=[],o=[];for(let t of selectedLineBlocks(e)){if(i?t.to==e.doc.length:0==t.from)continue;let r=e.doc.lineAt(i?t.to+1:t.from-1),s=r.length+1;if(i){n.push({from:t.to,to:r.to},{from:t.from,insert:r.text+e.lineBreak});for(let i of t.ranges)o.push(EditorSelection.range(Math.min(e.doc.length,i.anchor+s),Math.min(e.doc.length,i.head+s)));}else {n.push({from:r.from,to:t.from},{from:t.to,insert:e.lineBreak+r.text});for(let e of t.ranges)o.push(EditorSelection.range(e.anchor-s,e.head-s));}}return !!n.length&&(t(e.update({changes:n,scrollIntoView:true,selection:EditorSelection.create(o,e.selection.mainIndex),userEvent:"move.line"})),true)}const moveLineUp=({state:e,dispatch:t})=>moveLine(e,t,false),moveLineDown=({state:e,dispatch:t})=>moveLine(e,t,true);function copyLine(e,t,i){if(e.readOnly)return  false;let n=[];for(let t of selectedLineBlocks(e))i?n.push({from:t.from,insert:e.doc.slice(t.from,t.to)+e.lineBreak}):n.push({from:t.to,insert:e.lineBreak+e.doc.slice(t.from,t.to)});return t(e.update({changes:n,scrollIntoView:true,userEvent:"input.copyline"})),true}const copyLineUp=({state:e,dispatch:t})=>copyLine(e,t,false),copyLineDown=({state:e,dispatch:t})=>copyLine(e,t,true),deleteLine=e=>{if(e.state.readOnly)return  false;let{state:t}=e,i=t.changes(selectedLineBlocks(t).map(({from:e,to:i})=>(e>0?e--:i<t.doc.length&&i++,{from:e,to:i}))),n=updateSel(t.selection,t=>e.moveVertically(t,true)).map(i);return e.dispatch({changes:i,selection:n,scrollIntoView:true,userEvent:"delete.line"}),true};function isBetweenBrackets(e,t){if(/\(\)|\[\]|\{\}/.test(e.sliceDoc(t-1,t+1)))return {from:t,to:t};let i,n=syntaxTree(e).resolveInner(t),o=n.childBefore(t),r=n.childAfter(t);return o&&r&&o.to<=t&&r.from>=t&&(i=o.type.prop(NodeProp.closedBy))&&i.indexOf(r.name)>-1&&e.doc.lineAt(o.to).from==e.doc.lineAt(r.from).from?{from:o.to,to:r.from}:null}const insertNewlineAndIndent=newlineAndIndent(false),insertBlankLine=newlineAndIndent(true);function newlineAndIndent(e){return ({state:t,dispatch:i})=>{if(t.readOnly)return  false;let n=t.changeByRange(i=>{let{from:n,to:o}=i,r=t.doc.lineAt(n),s=!e&&n==o&&isBetweenBrackets(t,n);e&&(n=o=(o<=r.to?r:t.doc.lineAt(o)).to);let a=new IndentContext(t,{simulateBreak:n,simulateDoubleBreak:!!s}),l=getIndentation(a,n);for(null==l&&(l=/^\s*/.exec(t.doc.lineAt(n).text)[0].length);o<r.to&&/\s/.test(r.text[o-r.from]);)o++;s?({from:n,to:o}=s):n>r.from&&n<r.from+100&&!/\S/.test(r.text.slice(0,n))&&(n=r.from);let h=["",indentString(t,l)];return s&&h.push(indentString(t,a.lineIndent(r.from,-1))),{changes:{from:n,to:o,insert:Text.of(h)},range:EditorSelection.cursor(n+1+h[1].length)}});return i(t.update(n,{scrollIntoView:true,userEvent:"input"})),true}}function changeBySelectedLine(e,t){let i=-1;return e.changeByRange(n=>{let o=[];for(let r=n.from;r<=n.to;){let s=e.doc.lineAt(r);s.number>i&&(n.empty||n.to>s.from)&&(t(s,o,n),i=s.number),r=s.to+1;}let r=e.changes(o);return {changes:o,range:EditorSelection.range(r.mapPos(n.anchor,1),r.mapPos(n.head,1))}})}const indentSelection=({state:e,dispatch:t})=>{if(e.readOnly)return  false;let i=Object.create(null),n=new IndentContext(e,{overrideIndentation:e=>{let t=i[e];return null==t?-1:t}}),o=changeBySelectedLine(e,(t,o,r)=>{let s=getIndentation(n,t.from);if(null==s)return;/\S/.test(t.text)||(s=0);let a=/^\s*/.exec(t.text)[0],l=indentString(e,s);(a!=l||r.from<t.from+a.length)&&(i[t.from]=s,o.push({from:t.from,to:t.from+a.length,insert:l}));});return o.changes.empty||t(e.update(o,{userEvent:"indent"})),true},indentMore=({state:e,dispatch:t})=>!e.readOnly&&(t(e.update(changeBySelectedLine(e,(t,i)=>{i.push({from:t.from,insert:e.facet(indentUnit)});}),{userEvent:"input.indent"})),true),indentLess=({state:e,dispatch:t})=>!e.readOnly&&(t(e.update(changeBySelectedLine(e,(t,i)=>{let n=/^\s*/.exec(t.text)[0];if(!n)return;let o=countColumn(n,e.tabSize),r=0,s=indentString(e,Math.max(0,o-getIndentUnit(e)));for(;r<n.length&&r<s.length&&n.charCodeAt(r)==s.charCodeAt(r);)r++;i.push({from:t.from+r,to:t.from+n.length,insert:s.slice(r)});}),{userEvent:"delete.dedent"})),true),emacsStyleKeymap=[{key:"Ctrl-b",run:cursorCharLeft,shift:selectCharLeft,preventDefault:true},{key:"Ctrl-f",run:cursorCharRight,shift:selectCharRight},{key:"Ctrl-p",run:cursorLineUp,shift:selectLineUp},{key:"Ctrl-n",run:cursorLineDown,shift:selectLineDown},{key:"Ctrl-a",run:cursorLineStart,shift:selectLineStart},{key:"Ctrl-e",run:cursorLineEnd,shift:selectLineEnd},{key:"Ctrl-d",run:deleteCharForward},{key:"Ctrl-h",run:deleteCharBackward},{key:"Ctrl-k",run:deleteToLineEnd},{key:"Ctrl-Alt-h",run:deleteGroupBackward},{key:"Ctrl-o",run:splitLine},{key:"Ctrl-t",run:transposeChars},{key:"Ctrl-v",run:cursorPageDown}],standardKeymap=[{key:"ArrowLeft",run:cursorCharLeft,shift:selectCharLeft,preventDefault:true},{key:"Mod-ArrowLeft",mac:"Alt-ArrowLeft",run:cursorGroupLeft,shift:selectGroupLeft,preventDefault:true},{mac:"Cmd-ArrowLeft",run:cursorLineBoundaryLeft,shift:selectLineBoundaryLeft,preventDefault:true},{key:"ArrowRight",run:cursorCharRight,shift:selectCharRight,preventDefault:true},{key:"Mod-ArrowRight",mac:"Alt-ArrowRight",run:cursorGroupRight,shift:selectGroupRight,preventDefault:true},{mac:"Cmd-ArrowRight",run:cursorLineBoundaryRight,shift:selectLineBoundaryRight,preventDefault:true},{key:"ArrowUp",run:cursorLineUp,shift:selectLineUp,preventDefault:true},{mac:"Cmd-ArrowUp",run:cursorDocStart,shift:selectDocStart},{mac:"Ctrl-ArrowUp",run:cursorPageUp,shift:selectPageUp},{key:"ArrowDown",run:cursorLineDown,shift:selectLineDown,preventDefault:true},{mac:"Cmd-ArrowDown",run:cursorDocEnd,shift:selectDocEnd},{mac:"Ctrl-ArrowDown",run:cursorPageDown,shift:selectPageDown},{key:"PageUp",run:cursorPageUp,shift:selectPageUp},{key:"PageDown",run:cursorPageDown,shift:selectPageDown},{key:"Home",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward,preventDefault:true},{key:"Mod-Home",run:cursorDocStart,shift:selectDocStart},{key:"End",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward,preventDefault:true},{key:"Mod-End",run:cursorDocEnd,shift:selectDocEnd},{key:"Enter",run:insertNewlineAndIndent},{key:"Mod-a",run:selectAll},{key:"Backspace",run:deleteCharBackward,shift:deleteCharBackward},{key:"Delete",run:deleteCharForward},{key:"Mod-Backspace",mac:"Alt-Backspace",run:deleteGroupBackward},{key:"Mod-Delete",mac:"Alt-Delete",run:deleteGroupForward},{mac:"Mod-Backspace",run:deleteToLineStart},{mac:"Mod-Delete",run:deleteToLineEnd}].concat(emacsStyleKeymap.map(e=>({mac:e.key,run:e.run,shift:e.shift}))),defaultKeymap=[{key:"Alt-ArrowLeft",mac:"Ctrl-ArrowLeft",run:cursorSyntaxLeft,shift:selectSyntaxLeft},{key:"Alt-ArrowRight",mac:"Ctrl-ArrowRight",run:cursorSyntaxRight,shift:selectSyntaxRight},{key:"Alt-ArrowUp",run:moveLineUp},{key:"Shift-Alt-ArrowUp",run:copyLineUp},{key:"Alt-ArrowDown",run:moveLineDown},{key:"Shift-Alt-ArrowDown",run:copyLineDown},{key:"Escape",run:simplifySelection},{key:"Mod-Enter",run:insertBlankLine},{key:"Alt-l",mac:"Ctrl-l",run:selectLine},{key:"Mod-i",run:selectParentSyntax,preventDefault:true},{key:"Mod-[",run:indentLess},{key:"Mod-]",run:indentMore},{key:"Mod-Alt-\\",run:indentSelection},{key:"Shift-Mod-k",run:deleteLine},{key:"Shift-Mod-\\",run:cursorMatchingBracket},{key:"Mod-/",run:toggleComment},{key:"Alt-A",run:toggleBlockComment}].concat(standardKeymap),indentWithTab={key:"Tab",run:indentMore,shift:indentLess};class CompletionContext{constructor(e,t,i){this.state=e,this.pos=t,this.explicit=i,this.abortListeners=[];}tokenBefore(e){let t=syntaxTree(this.state).resolveInner(this.pos,-1);for(;t&&e.indexOf(t.name)<0;)t=t.parent;return t?{from:t.from,to:this.pos,text:this.state.sliceDoc(t.from,this.pos),type:t.type}:null}matchBefore(e){let t=this.state.doc.lineAt(this.pos),i=Math.max(t.from,this.pos-250),n=t.text.slice(i-t.from,this.pos-t.from),o=n.search(ensureAnchor(e,false));return o<0?null:{from:i+o,to:this.pos,text:n.slice(o)}}get aborted(){return null==this.abortListeners}addEventListener(e,t){"abort"==e&&this.abortListeners&&this.abortListeners.push(t);}}function toSet(e){let t=Object.keys(e).join(""),i=/\w/.test(t);return i&&(t=t.replace(/\w/g,"")),`[${i?"\\w":""}${t.replace(/[^\w\s]/g,"\\$&")}]`}function prefixMatch(e){let t=Object.create(null),i=Object.create(null);for(let{label:n}of e){t[n[0]]=true;for(let e=1;e<n.length;e++)i[n[e]]=true;}let n=toSet(t)+toSet(i)+"*$";return [new RegExp("^"+n),new RegExp(n)]}function completeFromList(e){let t=e.map(e=>"string"==typeof e?{label:e}:e),[i,n]=t.every(e=>/^\w+$/.test(e.label))?[/\w*$/,/\w+$/]:prefixMatch(t);return e=>{let o=e.matchBefore(n);return o||e.explicit?{from:o?o.from:e.pos,options:t,validFor:i}:null}}class Option{constructor(e,t,i){this.completion=e,this.source=t,this.match=i;}}function cur(e){return e.selection.main.head}function ensureAnchor(e,t){var i;let{source:n}=e,o=t&&"^"!=n[0],r="$"!=n[n.length-1];return o||r?new RegExp(`${o?"^":""}(?:${n})${r?"$":""}`,null!==(i=e.flags)&&void 0!==i?i:e.ignoreCase?"i":""):e}const pickedCompletion=Annotation.define();function insertCompletionText(e,t,i,n){return Object.assign(Object.assign({},e.changeByRange(o=>{if(o==e.selection.main)return {changes:{from:i,to:n,insert:t},range:EditorSelection.cursor(i+t.length)};let r=n-i;return !o.empty||r&&e.sliceDoc(o.from-r,o.from)!=e.sliceDoc(i,n)?{range:o}:{changes:{from:o.from-r,to:o.from,insert:t},range:EditorSelection.cursor(o.from-r+t.length)}})),{userEvent:"input.complete"})}function applyCompletion(e,t){const i=t.completion.apply||t.completion.label;let n=t.source;"string"==typeof i?e.dispatch(Object.assign(Object.assign({},insertCompletionText(e.state,i,n.from,n.to)),{annotations:pickedCompletion.of(t.completion)})):i(e,t.completion,n.from,n.to);}const SourceCache=new WeakMap;function asSource(e){if(!Array.isArray(e))return e;let t=SourceCache.get(e);return t||SourceCache.set(e,t=completeFromList(e)),t}class FuzzyMatcher{constructor(e){this.pattern=e,this.chars=[],this.folded=[],this.any=[],this.precise=[],this.byWord=[];for(let t=0;t<e.length;){let i=codePointAt(e,t),n=codePointSize(i);this.chars.push(i);let o=e.slice(t,t+n),r=o.toUpperCase();this.folded.push(codePointAt(r==o?o.toLowerCase():r,0)),t+=n;}this.astral=e.length!=this.chars.length;}match(e){if(0==this.pattern.length)return [0];if(e.length<this.pattern.length)return null;let{chars:t,folded:i,any:n,precise:o,byWord:r}=this;if(1==t.length){let n=codePointAt(e,0);return n==t[0]?[0,0,codePointSize(n)]:n==i[0]?[-200,0,codePointSize(n)]:null}let s=e.indexOf(this.pattern);if(0==s)return [0,0,this.pattern.length];let a=t.length,l=0;if(s<0){for(let o=0,r=Math.min(e.length,200);o<r&&l<a;){let r=codePointAt(e,o);r!=t[l]&&r!=i[l]||(n[l++]=o),o+=codePointSize(r);}if(l<a)return null}let h=0,c=0,d=false,u=0,f=-1,p=-1,O=/[a-z]/.test(e),g=true;for(let n=0,l=Math.min(e.length,200),m=0;n<l&&c<a;){let l=codePointAt(e,n);s<0&&(h<a&&l==t[h]&&(o[h++]=n),u<a&&(l==t[u]||l==i[u]?(0==u&&(f=n),p=n+1,u++):u=0));let S,b=l<255?l>=48&&l<=57||l>=97&&l<=122?2:l>=65&&l<=90?1:0:(S=fromCodePoint(l))!=S.toLowerCase()?1:S!=S.toUpperCase()?2:0;(!n||1==b&&O||0==m&&0!=b)&&(t[c]==l||i[c]==l&&(d=true)?r[c++]=n:r.length&&(g=false)),m=b,n+=codePointSize(l);}return c==a&&0==r[0]&&g?this.result((d?-200:0)-100,r,e):u==a&&0==f?[-200-e.length,0,p]:s>-1?[-700-e.length,s,s+this.pattern.length]:u==a?[-900-e.length,f,p]:c==a?this.result((d?-200:0)-100-700+(g?0:-1100),r,e):2==t.length?null:this.result((n[0]?-700:0)-200-1100,n,e)}result(e,t,i){let n=[e-i.length],o=1;for(let e of t){let t=e+(this.astral?codePointSize(codePointAt(i,e)):1);o>1&&n[o-1]==e?n[o-1]=t:(n[o++]=e,n[o++]=t);}return n}}const completionConfig=Facet.define({combine:e=>combineConfig(e,{activateOnTyping:true,selectOnOpen:true,override:null,closeOnBlur:true,maxRenderedOptions:100,defaultKeymap:true,optionClass:()=>"",aboveCursor:false,icons:true,addToOptions:[],compareCompletions:(e,t)=>e.label.localeCompare(t.label),interactionDelay:75},{defaultKeymap:(e,t)=>e&&t,closeOnBlur:(e,t)=>e&&t,icons:(e,t)=>e&&t,optionClass:(e,t)=>i=>joinClass(e(i),t(i)),addToOptions:(e,t)=>e.concat(t)})});function joinClass(e,t){return e?t?e+" "+t:e:t}function optionContent(e){let t=e.addToOptions.slice();return e.icons&&t.push({render(e){let t=document.createElement("div");return t.classList.add("cm-completionIcon"),e.type&&t.classList.add(...e.type.split(/\s+/g).map(e=>"cm-completionIcon-"+e)),t.setAttribute("aria-hidden","true"),t},position:20}),t.push({render(e,t,i){let n=document.createElement("span");n.className="cm-completionLabel";let{label:o}=e,r=0;for(let e=1;e<i.length;){let t=i[e++],s=i[e++];t>r&&n.appendChild(document.createTextNode(o.slice(r,t)));let a=n.appendChild(document.createElement("span"));a.appendChild(document.createTextNode(o.slice(t,s))),a.className="cm-completionMatchedText",r=s;}return r<o.length&&n.appendChild(document.createTextNode(o.slice(r))),n},position:50},{render(e){if(!e.detail)return null;let t=document.createElement("span");return t.className="cm-completionDetail",t.textContent=e.detail,t},position:80}),t.sort((e,t)=>e.position-t.position).map(e=>e.render)}function rangeAroundSelected(e,t,i){if(e<=i)return {from:0,to:e};if(t<0&&(t=0),t<=e>>1){let e=Math.floor(t/i);return {from:e*i,to:(e+1)*i}}let n=Math.floor((e-t)/i);return {from:e-(n+1)*i,to:e-n*i}}class CompletionTooltip{constructor(e,t){this.view=e,this.stateField=t,this.info=null,this.placeInfo={read:()=>this.measureInfo(),write:e=>this.positionInfo(e),key:this},this.space=null;let i=e.state.field(t),{options:n,selected:o}=i.open,r=e.state.facet(completionConfig);this.optionContent=optionContent(r),this.optionClass=r.optionClass,this.range=rangeAroundSelected(n.length,o,r.maxRenderedOptions),this.dom=document.createElement("div"),this.dom.className="cm-tooltip-autocomplete",this.dom.addEventListener("mousedown",t=>{for(let i,o=t.target;o&&o!=this.dom;o=o.parentNode)if("LI"==o.nodeName&&(i=/-(\d+)$/.exec(o.id))&&+i[1]<n.length)return applyCompletion(e,n[+i[1]]),void t.preventDefault()}),this.list=this.dom.appendChild(this.createListBox(n,i.id,this.range)),this.list.addEventListener("scroll",()=>{this.info&&this.view.requestMeasure(this.placeInfo);});}mount(){this.updateSel();}update(e){var t,i,n;let o=e.state.field(this.stateField),r=e.startState.field(this.stateField);o!=r&&(this.updateSel(),(null===(t=o.open)||void 0===t?void 0:t.disabled)!=(null===(i=r.open)||void 0===i?void 0:i.disabled)&&this.dom.classList.toggle("cm-tooltip-autocomplete-disabled",!!(null===(n=o.open)||void 0===n?void 0:n.disabled)));}positioned(e){this.space=e,this.info&&this.view.requestMeasure(this.placeInfo);}updateSel(){let e=this.view.state.field(this.stateField),t=e.open;if((t.selected>-1&&t.selected<this.range.from||t.selected>=this.range.to)&&(this.range=rangeAroundSelected(t.options.length,t.selected,this.view.state.facet(completionConfig).maxRenderedOptions),this.list.remove(),this.list=this.dom.appendChild(this.createListBox(t.options,e.id,this.range)),this.list.addEventListener("scroll",()=>{this.info&&this.view.requestMeasure(this.placeInfo);})),this.updateSelectedOption(t.selected)){this.info&&(this.info.remove(),this.info=null);let{completion:i}=t.options[t.selected],{info:n}=i;if(!n)return;let o="string"==typeof n?document.createTextNode(n):n(i);if(!o)return;"then"in o?o.then(t=>{t&&this.view.state.field(this.stateField,false)==e&&this.addInfoPane(t);}).catch(e=>logException(this.view.state,e,"completion info")):this.addInfoPane(o);}}addInfoPane(e){let t=this.info=document.createElement("div");t.className="cm-tooltip cm-completionInfo",t.appendChild(e),this.dom.appendChild(t),this.view.requestMeasure(this.placeInfo);}updateSelectedOption(e){let t=null;for(let i=this.list.firstChild,n=this.range.from;i;i=i.nextSibling,n++)n==e?i.hasAttribute("aria-selected")||(i.setAttribute("aria-selected","true"),t=i):i.hasAttribute("aria-selected")&&i.removeAttribute("aria-selected");return t&&scrollIntoView$1(this.list,t),t}measureInfo(){let e=this.dom.querySelector("[aria-selected]");if(!e||!this.info)return null;let t=this.dom.getBoundingClientRect(),i=this.info.getBoundingClientRect(),n=e.getBoundingClientRect(),o=this.space;if(!o){let e=this.dom.ownerDocument.defaultView||window;o={left:0,top:0,right:e.innerWidth,bottom:e.innerHeight};}if(n.top>Math.min(o.bottom,t.bottom)-10||n.bottom<Math.max(o.top,t.top)+10)return null;let r,s=this.view.textDirection==Direction.RTL,a=s,l=false,h="",c="",d=t.left-o.left,u=o.right-t.right;if(a&&d<Math.min(i.width,u)?a=false:!a&&u<Math.min(i.width,d)&&(a=true),i.width<=(a?d:u))h=Math.max(o.top,Math.min(n.top,o.bottom-i.height))-t.top+"px",r=Math.min(400,a?d:u)+"px";else {l=true,r=Math.min(400,(s?t.right:o.right-t.left)-30)+"px";let e=o.bottom-t.bottom;e>=i.height||e>t.top?h=n.bottom-t.top+"px":c=t.bottom-n.top+"px";}return {top:h,bottom:c,maxWidth:r,class:l?s?"left-narrow":"right-narrow":a?"left":"right"}}positionInfo(e){this.info&&(e?(this.info.style.top=e.top,this.info.style.bottom=e.bottom,this.info.style.maxWidth=e.maxWidth,this.info.className="cm-tooltip cm-completionInfo cm-completionInfo-"+e.class):this.info.style.top="-1e6px");}createListBox(e,t,i){const n=document.createElement("ul");n.id=t,n.setAttribute("role","listbox"),n.setAttribute("aria-expanded","true"),n.setAttribute("aria-label",this.view.state.phrase("Completions"));for(let o=i.from;o<i.to;o++){let{completion:i,match:r}=e[o];const s=n.appendChild(document.createElement("li"));s.id=t+"-"+o,s.setAttribute("role","option");let a=this.optionClass(i);a&&(s.className=a);for(let e of this.optionContent){let t=e(i,this.view.state,r);t&&s.appendChild(t);}}return i.from&&n.classList.add("cm-completionListIncompleteTop"),i.to<e.length&&n.classList.add("cm-completionListIncompleteBottom"),n}}function completionTooltip(e){return t=>new CompletionTooltip(t,e)}function scrollIntoView$1(e,t){let i=e.getBoundingClientRect(),n=t.getBoundingClientRect();n.top<i.top?e.scrollTop-=i.top-n.top:n.bottom>i.bottom&&(e.scrollTop+=n.bottom-i.bottom);}function score(e){return 100*(e.boost||0)+(e.apply?10:0)+(e.info?5:0)+(e.type?1:0)}function sortOptions(e,t){let i=[],n=0;for(let o of e)if(o.hasResult())if(false===o.result.filter){let e=o.result.getMatch;for(let t of o.result.options){let r=[1e9-n++];if(e)for(let i of e(t))r.push(i);i.push(new Option(t,o,r));}}else {let e,n=new FuzzyMatcher(t.sliceDoc(o.from,o.to));for(let t of o.result.options)(e=n.match(t.label))&&(null!=t.boost&&(e[0]+=t.boost),i.push(new Option(t,o,e)));}let o=[],r=null,s=t.facet(completionConfig).compareCompletions;for(let e of i.sort((e,t)=>t.match[0]-e.match[0]||s(e.completion,t.completion)))!r||r.label!=e.completion.label||r.detail!=e.completion.detail||null!=r.type&&null!=e.completion.type&&r.type!=e.completion.type||r.apply!=e.completion.apply?o.push(e):score(e.completion)>score(r)&&(o[o.length-1]=e),r=e.completion;return o}class CompletionDialog{constructor(e,t,i,n,o,r){this.options=e,this.attrs=t,this.tooltip=i,this.timestamp=n,this.selected=o,this.disabled=r;}setSelected(e,t){return e==this.selected||e>=this.options.length?this:new CompletionDialog(this.options,makeAttrs(t,e),this.tooltip,this.timestamp,e,this.disabled)}static build(e,t,i,n,o){let r=sortOptions(e,t);if(!r.length)return n&&e.some(e=>1==e.state)?new CompletionDialog(n.options,n.attrs,n.tooltip,n.timestamp,n.selected,true):null;let s=t.facet(completionConfig).selectOnOpen?0:-1;if(n&&n.selected!=s&&-1!=n.selected){let e=n.options[n.selected].completion;for(let t=0;t<r.length;t++)if(r[t].completion==e){s=t;break}}return new CompletionDialog(r,makeAttrs(i,s),{pos:e.reduce((e,t)=>t.hasResult()?Math.min(e,t.from):e,1e8),create:completionTooltip(completionState),above:o.aboveCursor},n?n.timestamp:Date.now(),s,false)}map(e){return new CompletionDialog(this.options,this.attrs,Object.assign(Object.assign({},this.tooltip),{pos:e.mapPos(this.tooltip.pos)}),this.timestamp,this.selected,this.disabled)}}class CompletionState{constructor(e,t,i){this.active=e,this.id=t,this.open=i;}static start(){return new CompletionState(none$2,"cm-ac-"+Math.floor(2e6*Math.random()).toString(36),null)}update(e){let{state:t}=e,i=t.facet(completionConfig),n=(i.override||t.languageDataAt("autocomplete",cur(t)).map(asSource)).map(t=>{return (this.active.find(e=>e.source==t)||new ActiveSource(t,this.active.some(e=>0!=e.state)?1:0)).update(e,i)});n.length==this.active.length&&n.every((e,t)=>e==this.active[t])&&(n=this.active);let o=this.open;e.selection||n.some(t=>t.hasResult()&&e.changes.touchesRange(t.from,t.to))||!sameResults(n,this.active)?o=CompletionDialog.build(n,t,this.id,this.open,i):o&&o.disabled&&!n.some(e=>1==e.state)?o=null:o&&e.docChanged&&(o=o.map(e.changes)),!o&&n.every(e=>1!=e.state)&&n.some(e=>e.hasResult())&&(n=n.map(e=>e.hasResult()?new ActiveSource(e.source,0):e));for(let t of e.effects)t.is(setSelectedEffect)&&(o=o&&o.setSelected(t.value,this.id));return n==this.active&&o==this.open?this:new CompletionState(n,this.id,o)}get tooltip(){return this.open?this.open.tooltip:null}get attrs(){return this.open?this.open.attrs:baseAttrs}}function sameResults(e,t){if(e==t)return  true;for(let i=0,n=0;;){for(;i<e.length&&!e[i].hasResult;)i++;for(;n<t.length&&!t[n].hasResult;)n++;let o=i==e.length,r=n==t.length;if(o||r)return o==r;if(e[i++].result!=t[n++].result)return  false}}const baseAttrs={"aria-autocomplete":"list"};function makeAttrs(e,t){let i={"aria-autocomplete":"list","aria-haspopup":"listbox","aria-controls":e};return t>-1&&(i["aria-activedescendant"]=e+"-"+t),i}const none$2=[];function getUserEvent(e){return e.isUserEvent("input.type")?"input":e.isUserEvent("delete.backward")?"delete":null}class ActiveSource{constructor(e,t,i=-1){this.source=e,this.state=t,this.explicitPos=i;}hasResult(){return  false}update(e,t){let i=getUserEvent(e),n=this;i?n=n.handleUserEvent(e,i,t):e.docChanged?n=n.handleChange(e):e.selection&&0!=n.state&&(n=new ActiveSource(n.source,0));for(let t of e.effects)if(t.is(startCompletionEffect))n=new ActiveSource(n.source,1,t.value?cur(e.state):-1);else if(t.is(closeCompletionEffect))n=new ActiveSource(n.source,0);else if(t.is(setActiveEffect))for(let e of t.value)e.source==n.source&&(n=e);return n}handleUserEvent(e,t,i){return "delete"!=t&&i.activateOnTyping?new ActiveSource(this.source,1):this.map(e.changes)}handleChange(e){return e.changes.touchesRange(cur(e.startState))?new ActiveSource(this.source,0):this.map(e.changes)}map(e){return e.empty||this.explicitPos<0?this:new ActiveSource(this.source,this.state,e.mapPos(this.explicitPos))}}class ActiveResult extends ActiveSource{constructor(e,t,i,n,o){super(e,2,t),this.result=i,this.from=n,this.to=o;}hasResult(){return  true}handleUserEvent(e,t,i){var n;let o=e.changes.mapPos(this.from),r=e.changes.mapPos(this.to,1),s=cur(e.state);if((this.explicitPos<0?s<=o:s<this.from)||s>r||"delete"==t&&cur(e.startState)==this.from)return new ActiveSource(this.source,"input"==t&&i.activateOnTyping?1:0);let a,l=this.explicitPos<0?-1:e.changes.mapPos(this.explicitPos);return checkValid(this.result.validFor,e.state,o,r)?new ActiveResult(this.source,l,this.result,o,r):this.result.update&&(a=this.result.update(this.result,o,r,new CompletionContext(e.state,s,l>=0)))?new ActiveResult(this.source,l,a,a.from,null!==(n=a.to)&&void 0!==n?n:cur(e.state)):new ActiveSource(this.source,1,l)}handleChange(e){return e.changes.touchesRange(this.from,this.to)?new ActiveSource(this.source,0):this.map(e.changes)}map(e){return e.empty?this:new ActiveResult(this.source,this.explicitPos<0?-1:e.mapPos(this.explicitPos),this.result,e.mapPos(this.from),e.mapPos(this.to,1))}}function checkValid(e,t,i,n){if(!e)return  false;let o=t.sliceDoc(i,n);return "function"==typeof e?e(o,i,n,t):ensureAnchor(e,true).test(o)}const startCompletionEffect=StateEffect.define(),closeCompletionEffect=StateEffect.define(),setActiveEffect=StateEffect.define({map:(e,t)=>e.map(e=>e.map(t))}),setSelectedEffect=StateEffect.define(),completionState=StateField.define({create:()=>CompletionState.start(),update:(e,t)=>e.update(t),provide:e=>[showTooltip.from(e,e=>e.tooltip),EditorView.contentAttributes.from(e,e=>e.attrs)]});function moveCompletionSelection(e,t="option"){return i=>{let n=i.state.field(completionState,false);if(!n||!n.open||n.open.disabled||Date.now()-n.open.timestamp<i.state.facet(completionConfig).interactionDelay)return  false;let o,r=1;"page"==t&&(o=getTooltip(i,n.open.tooltip))&&(r=Math.max(2,Math.floor(o.dom.offsetHeight/o.dom.querySelector("li").offsetHeight)-1));let{length:s}=n.open.options,a=n.open.selected>-1?n.open.selected+r*(e?1:-1):e?0:s-1;return a<0?a="page"==t?0:s-1:a>=s&&(a="page"==t?s-1:0),i.dispatch({effects:setSelectedEffect.of(a)}),true}}const acceptCompletion=e=>{let t=e.state.field(completionState,false);return !(e.state.readOnly||!t||!t.open||t.open.selected<0||Date.now()-t.open.timestamp<e.state.facet(completionConfig).interactionDelay)&&(t.open.disabled||applyCompletion(e,t.open.options[t.open.selected]),true)},startCompletion=e=>{return !!e.state.field(completionState,false)&&(e.dispatch({effects:startCompletionEffect.of(true)}),true)},closeCompletion=e=>{let t=e.state.field(completionState,false);return !(!t||!t.active.some(e=>0!=e.state))&&(e.dispatch({effects:closeCompletionEffect.of(null)}),true)};class RunningQuery{constructor(e,t){this.active=e,this.context=t,this.time=Date.now(),this.updates=[],this.done=void 0;}}ViewPlugin.fromClass(class{constructor(e){this.view=e,this.debounceUpdate=-1,this.running=[],this.debounceAccept=-1,this.composing=0;for(let t of e.state.field(completionState).active)1==t.state&&this.startQuery(t);}update(e){let t=e.state.field(completionState);if(!e.selectionSet&&!e.docChanged&&e.startState.field(completionState)==t)return;let i=e.transactions.some(e=>(e.selection||e.docChanged)&&!getUserEvent(e));for(let t=0;t<this.running.length;t++){let n=this.running[t];if(i||n.updates.length+e.transactions.length>50&&Date.now()-n.time>1e3){for(let e of n.context.abortListeners)try{e();}catch(e){logException(this.view.state,e);}n.context.abortListeners=null,this.running.splice(t--,1);}else n.updates.push(...e.transactions);}if(this.debounceUpdate>-1&&clearTimeout(this.debounceUpdate),this.debounceUpdate=t.active.some(e=>1==e.state&&!this.running.some(t=>t.active.source==e.source))?setTimeout(()=>this.startUpdate(),50):-1,0!=this.composing)for(let t of e.transactions)"input"==getUserEvent(t)?this.composing=2:2==this.composing&&t.selection&&(this.composing=3);}startUpdate(){this.debounceUpdate=-1;let{state:e}=this.view,t=e.field(completionState);for(let e of t.active)1!=e.state||this.running.some(t=>t.active.source==e.source)||this.startQuery(e);}startQuery(e){let{state:t}=this.view,i=cur(t),n=new CompletionContext(t,i,e.explicitPos==i),o=new RunningQuery(e,n);this.running.push(o),Promise.resolve(e.source(n)).then(e=>{o.context.aborted||(o.done=e||null,this.scheduleAccept());},e=>{this.view.dispatch({effects:closeCompletionEffect.of(null)}),logException(this.view.state,e);});}scheduleAccept(){this.running.every(e=>void 0!==e.done)?this.accept():this.debounceAccept<0&&(this.debounceAccept=setTimeout(()=>this.accept(),50));}accept(){var e;this.debounceAccept>-1&&clearTimeout(this.debounceAccept),this.debounceAccept=-1;let t=[],i=this.view.state.facet(completionConfig);for(let n=0;n<this.running.length;n++){let o=this.running[n];if(void 0===o.done)continue;if(this.running.splice(n--,1),o.done){let n=new ActiveResult(o.active.source,o.active.explicitPos,o.done,o.done.from,null!==(e=o.done.to)&&void 0!==e?e:cur(o.updates.length?o.updates[0].startState:this.view.state));for(let e of o.updates)n=n.update(e,i);if(n.hasResult()){t.push(n);continue}}let r=this.view.state.field(completionState).active.find(e=>e.source==o.active.source);if(r&&1==r.state)if(null==o.done){let e=new ActiveSource(o.active.source,0);for(let t of o.updates)e=e.update(t,i);1!=e.state&&t.push(e);}else this.startQuery(r);}t.length&&this.view.dispatch({effects:setActiveEffect.of(t)});}},{eventHandlers:{blur(){let e=this.view.state.field(completionState,false);e&&e.tooltip&&this.view.state.facet(completionConfig).closeOnBlur&&this.view.dispatch({effects:closeCompletionEffect.of(null)});},compositionstart(){this.composing=1;},compositionend(){3==this.composing&&setTimeout(()=>this.view.dispatch({effects:startCompletionEffect.of(false)}),20),this.composing=0;}}});const baseTheme$3=EditorView.baseTheme({".cm-tooltip.cm-tooltip-autocomplete":{"& > ul":{fontFamily:"monospace",whiteSpace:"nowrap",overflow:"hidden auto",maxWidth_fallback:"700px",maxWidth:"min(700px, 95vw)",minWidth:"250px",maxHeight:"10em",height:"100%",listStyle:"none",margin:0,padding:0,"& > li":{overflowX:"hidden",textOverflow:"ellipsis",cursor:"pointer",padding:"1px 3px",lineHeight:1.2}}},"&light .cm-tooltip-autocomplete ul li[aria-selected]":{background:"#17c",color:"white"},"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]":{background:"#777"},"&dark .cm-tooltip-autocomplete ul li[aria-selected]":{background:"#347",color:"white"},"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]":{background:"#444"},".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after":{content:'"···"',opacity:.5,display:"block",textAlign:"center"},".cm-tooltip.cm-completionInfo":{position:"absolute",padding:"3px 9px",width:"max-content",maxWidth:"400px",boxSizing:"border-box"},".cm-completionInfo.cm-completionInfo-left":{right:"100%"},".cm-completionInfo.cm-completionInfo-right":{left:"100%"},".cm-completionInfo.cm-completionInfo-left-narrow":{right:"30px"},".cm-completionInfo.cm-completionInfo-right-narrow":{left:"30px"},"&light .cm-snippetField":{backgroundColor:"#00000022"},"&dark .cm-snippetField":{backgroundColor:"#ffffff22"},".cm-snippetFieldPosition":{verticalAlign:"text-top",width:0,height:"1.15em",display:"inline-block",margin:"0 -0.7px -.7em",borderLeft:"1.4px dotted #888"},".cm-completionMatchedText":{textDecoration:"underline"},".cm-completionDetail":{marginLeft:"0.5em",fontStyle:"italic"},".cm-completionIcon":{fontSize:"90%",width:".8em",display:"inline-block",textAlign:"center",paddingRight:".6em",opacity:"0.6",boxSizing:"content-box"},".cm-completionIcon-function, .cm-completionIcon-method":{"&:after":{content:"'ƒ'"}},".cm-completionIcon-class":{"&:after":{content:"'○'"}},".cm-completionIcon-interface":{"&:after":{content:"'◌'"}},".cm-completionIcon-variable":{"&:after":{content:"'𝑥'"}},".cm-completionIcon-constant":{"&:after":{content:"'𝐶'"}},".cm-completionIcon-type":{"&:after":{content:"'𝑡'"}},".cm-completionIcon-enum":{"&:after":{content:"'∪'"}},".cm-completionIcon-property":{"&:after":{content:"'□'"}},".cm-completionIcon-keyword":{"&:after":{content:"'🔑︎'"}},".cm-completionIcon-namespace":{"&:after":{content:"'▢'"}},".cm-completionIcon-text":{"&:after":{content:"'abc'",fontSize:"50%",verticalAlign:"middle"}}});class FieldPos{constructor(e,t,i,n){this.field=e,this.line=t,this.from=i,this.to=n;}}class FieldRange{constructor(e,t,i){this.field=e,this.from=t,this.to=i;}map(e){let t=e.mapPos(this.from,-1,MapMode.TrackDel),i=e.mapPos(this.to,1,MapMode.TrackDel);return null==t||null==i?null:new FieldRange(this.field,t,i)}}class Snippet{constructor(e,t){this.lines=e,this.fieldPositions=t;}instantiate(e,t){let i=[],n=[t],o=e.doc.lineAt(t),r=/^\s*/.exec(o.text)[0];for(let o of this.lines){if(i.length){let i=r,s=/^\t*/.exec(o)[0].length;for(let t=0;t<s;t++)i+=e.facet(indentUnit);n.push(t+i.length-s),o=i+o.slice(s);}i.push(o),t+=o.length+1;}return {text:i,ranges:this.fieldPositions.map(e=>new FieldRange(e.field,n[e.line]+e.from,n[e.line]+e.to))}}static parse(e){let t,i=[],n=[],o=[];for(let r of e.split(/\r\n?|\n/)){for(;t=/[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(r);){let e=t[1]?+t[1]:null,s=t[2]||t[3]||"",a=-1;for(let t=0;t<i.length;t++)(null!=e?i[t].seq==e:s&&i[t].name==s)&&(a=t);if(a<0){let t=0;for(;t<i.length&&(null==e||null!=i[t].seq&&i[t].seq<e);)t++;i.splice(t,0,{seq:e,name:s}),a=t;for(let e of o)e.field>=a&&e.field++;}o.push(new FieldPos(a,n.length,t.index,t.index+s.length)),r=r.slice(0,t.index)+s+r.slice(t.index+t[0].length);}for(let e;e=/\\([{}])/.exec(r);){r=r.slice(0,e.index)+e[1]+r.slice(e.index+e[0].length);for(let t of o)t.line==n.length&&t.from>e.index&&(t.from--,t.to--);}n.push(r);}return new Snippet(n,o)}}let fieldMarker=Decoration.widget({widget:new class extends WidgetType{toDOM(){let e=document.createElement("span");return e.className="cm-snippetFieldPosition",e}ignoreEvent(){return  false}}}),fieldRange=Decoration.mark({class:"cm-snippetField"});class ActiveSnippet{constructor(e,t){this.ranges=e,this.active=t,this.deco=Decoration.set(e.map(e=>(e.from==e.to?fieldMarker:fieldRange).range(e.from,e.to)));}map(e){let t=[];for(let i of this.ranges){let n=i.map(e);if(!n)return null;t.push(n);}return new ActiveSnippet(t,this.active)}selectionInsideField(e){return e.ranges.every(e=>this.ranges.some(t=>t.field==this.active&&t.from<=e.from&&t.to>=e.to))}}const setActive=StateEffect.define({map:(e,t)=>e&&e.map(t)}),moveToField=StateEffect.define(),snippetState=StateField.define({create:()=>null,update(e,t){for(let i of t.effects){if(i.is(setActive))return i.value;if(i.is(moveToField)&&e)return new ActiveSnippet(e.ranges,i.value)}return e&&t.docChanged&&(e=e.map(t.changes)),e&&t.selection&&!e.selectionInsideField(t.selection)&&(e=null),e},provide:e=>EditorView.decorations.from(e,e=>e?e.deco:Decoration.none)});function fieldSelection(e,t){return EditorSelection.create(e.filter(e=>e.field==t).map(e=>EditorSelection.range(e.from,e.to)))}function snippet(e){let t=Snippet.parse(e);return (e,i,n,o)=>{let{text:r,ranges:s}=t.instantiate(e.state,n),a={changes:{from:n,to:o,insert:Text.of(r)},scrollIntoView:true};if(s.length&&(a.selection=fieldSelection(s,0)),s.length>1){let t=new ActiveSnippet(s,0),i=a.effects=[setActive.of(t)];void 0===e.state.field(snippetState,false)&&i.push(StateEffect.appendConfig.of([snippetState,addSnippetKeymap,snippetPointerHandler,baseTheme$3]));}e.dispatch(e.state.update(a));}}function moveField(e){return ({state:t,dispatch:i})=>{let n=t.field(snippetState,false);if(!n||e<0&&0==n.active)return  false;let o=n.active+e,r=e>0&&!n.ranges.some(t=>t.field==o+e);return i(t.update({selection:fieldSelection(n.ranges,o),effects:setActive.of(r?null:new ActiveSnippet(n.ranges,o))})),true}}const clearSnippet=({state:e,dispatch:t})=>{return !!e.field(snippetState,false)&&(t(e.update({effects:setActive.of(null)})),true)},nextSnippetField=moveField(1),prevSnippetField=moveField(-1),defaultSnippetKeymap=[{key:"Tab",run:nextSnippetField,shift:prevSnippetField},{key:"Escape",run:clearSnippet}],snippetKeymap=Facet.define({combine:e=>e.length?e[0]:defaultSnippetKeymap}),addSnippetKeymap=Prec.highest(keymap.compute([snippetKeymap],e=>e.facet(snippetKeymap)));function snippetCompletion(e,t){return Object.assign(Object.assign({},t),{apply:snippet(e)})}const snippetPointerHandler=EditorView.domEventHandlers({mousedown(e,t){let i,n=t.state.field(snippetState,false);if(!n||null==(i=t.posAtCoords({x:e.clientX,y:e.clientY})))return  false;let o=n.ranges.find(e=>e.from<=i&&e.to>=i);return !(!o||o.field==n.active)&&(t.dispatch({selection:fieldSelection(n.ranges,o.field),effects:setActive.of(n.ranges.some(e=>e.field>o.field)?new ActiveSnippet(n.ranges,o.field):null)}),true)}}),defaults$1={brackets:["(","[","{","'",'"'],before:")]}:;>",stringPrefixes:[]},closeBracketEffect=StateEffect.define({map(e,t){let i=t.mapPos(e,-1,MapMode.TrackAfter);return null==i?void 0:i}}),skipBracketEffect=StateEffect.define({map:(e,t)=>t.mapPos(e)}),closedBracket=new class extends RangeValue{};closedBracket.startSide=1,closedBracket.endSide=-1;const bracketState=StateField.define({create:()=>RangeSet.empty,update(e,t){if(t.selection){let i=t.state.doc.lineAt(t.selection.main.head).from,n=t.startState.doc.lineAt(t.startState.selection.main.head).from;i!=t.changes.mapPos(n,-1)&&(e=RangeSet.empty);}e=e.map(t.changes);for(let i of t.effects)i.is(closeBracketEffect)?e=e.update({add:[closedBracket.range(i.value,i.value+1)]}):i.is(skipBracketEffect)&&(e=e.update({filter:e=>e!=i.value}));return e}});function closeBrackets(){return [inputHandler$1,bracketState]}const definedClosing="()[]{}<>";function closing(e){for(let t=0;t<definedClosing.length;t+=2)if(definedClosing.charCodeAt(t)==e)return definedClosing.charAt(t+1);return fromCodePoint(e<128?e:e+1)}function config(e,t){return e.languageDataAt("closeBrackets",t)[0]||defaults$1}const android="object"==typeof navigator&&/Android\b/.test(navigator.userAgent),inputHandler$1=EditorView.inputHandler.of((e,t,i,n)=>{if((android?e.composing:e.compositionStarted)||e.state.readOnly)return  false;let o=e.state.selection.main;if(n.length>2||2==n.length&&1==codePointSize(codePointAt(n,0))||t!=o.from||i!=o.to)return  false;let r=insertBracket(e.state,n);return !!r&&(e.dispatch(r),true)}),deleteBracketPair=({state:e,dispatch:t})=>{if(e.readOnly)return  false;let i=config(e,e.selection.main.head).brackets||defaults$1.brackets,n=null,o=e.changeByRange(t=>{if(t.empty){let n=prevChar(e.doc,t.head);for(let o of i)if(o==n&&nextChar(e.doc,t.head)==closing(codePointAt(o,0)))return {changes:{from:t.head-o.length,to:t.head+o.length},range:EditorSelection.cursor(t.head-o.length)}}return {range:n=t}});return n||t(e.update(o,{scrollIntoView:true,userEvent:"delete.backward"})),!n},closeBracketsKeymap=[{key:"Backspace",run:deleteBracketPair}];function insertBracket(e,t){let i=config(e,e.selection.main.head),n=i.brackets||defaults$1.brackets;for(let o of n){let r=closing(codePointAt(o,0));if(t==o)return r==o?handleSame(e,o,n.indexOf(o+o+o)>-1,i):handleOpen(e,o,r,i.before||defaults$1.before);if(t==r&&closedBracketAt(e,e.selection.main.from))return handleClose(e,o,r)}return null}function closedBracketAt(e,t){let i=false;return e.field(bracketState).between(0,e.doc.length,e=>{e==t&&(i=true);}),i}function nextChar(e,t){let i=e.sliceString(t,t+2);return i.slice(0,codePointSize(codePointAt(i,0)))}function prevChar(e,t){let i=e.sliceString(t-2,t);return codePointSize(codePointAt(i,0))==i.length?i:i.slice(1)}function handleOpen(e,t,i,n){let o=null,r=e.changeByRange(r=>{if(!r.empty)return {changes:[{insert:t,from:r.from},{insert:i,from:r.to}],effects:closeBracketEffect.of(r.to+t.length),range:EditorSelection.range(r.anchor+t.length,r.head+t.length)};let s=nextChar(e.doc,r.head);return !s||/\s/.test(s)||n.indexOf(s)>-1?{changes:{insert:t+i,from:r.head},effects:closeBracketEffect.of(r.head+t.length),range:EditorSelection.cursor(r.head+t.length)}:{range:o=r}});return o?null:e.update(r,{scrollIntoView:true,userEvent:"input.type"})}function handleClose(e,t,i){let n=null,o=e.selection.ranges.map(t=>t.empty&&nextChar(e.doc,t.head)==i?EditorSelection.cursor(t.head+i.length):n=t);return n?null:e.update({selection:EditorSelection.create(o,e.selection.mainIndex),scrollIntoView:true,effects:e.selection.ranges.map(({from:e})=>skipBracketEffect.of(e))})}function handleSame(e,t,i,n){let o=n.stringPrefixes||defaults$1.stringPrefixes,r=null,s=e.changeByRange(n=>{if(!n.empty)return {changes:[{insert:t,from:n.from},{insert:t,from:n.to}],effects:closeBracketEffect.of(n.to+t.length),range:EditorSelection.range(n.anchor+t.length,n.head+t.length)};let s,a=n.head,l=nextChar(e.doc,a);if(l==t){if(nodeStart(e,a))return {changes:{insert:t+t,from:a},effects:closeBracketEffect.of(a+t.length),range:EditorSelection.cursor(a+t.length)};if(closedBracketAt(e,a)){let n=i&&e.sliceDoc(a,a+3*t.length)==t+t+t;return {range:EditorSelection.cursor(a+t.length*(n?3:1)),effects:skipBracketEffect.of(a)}}}else {if(i&&e.sliceDoc(a-2*t.length,a)==t+t&&(s=canStartStringAt(e,a-2*t.length,o))>-1&&nodeStart(e,s))return {changes:{insert:t+t+t+t,from:a},effects:closeBracketEffect.of(a+t.length),range:EditorSelection.cursor(a+t.length)};if(e.charCategorizer(a)(l)!=CharCategory.Word&&canStartStringAt(e,a,o)>-1&&!probablyInString(e,a,t,o))return {changes:{insert:t+t,from:a},effects:closeBracketEffect.of(a+t.length),range:EditorSelection.cursor(a+t.length)}}return {range:r=n}});return r?null:e.update(s,{scrollIntoView:true,userEvent:"input.type"})}function nodeStart(e,t){let i=syntaxTree(e).resolveInner(t+1);return i.parent&&i.from==t}function probablyInString(e,t,i,n){let o=syntaxTree(e).resolveInner(t,-1),r=n.reduce((e,t)=>Math.max(e,t.length),0);for(let s=0;s<5;s++){let s=e.sliceDoc(o.from,Math.min(o.to,o.from+i.length+r)),a=s.indexOf(i);if(!a||a>-1&&n.indexOf(s.slice(0,a))>-1){let t=o.firstChild;for(;t&&t.from==o.from&&t.to-t.from>i.length+a;){if(e.sliceDoc(t.to-i.length,t.to)==i)return  false;t=t.firstChild;}return  true}let l=o.to==t&&o.parent;if(!l)break;o=l;}return  false}function canStartStringAt(e,t,i){let n=e.charCategorizer(t);if(n(e.sliceDoc(t-1,t))!=CharCategory.Word)return t;for(let o of i){let i=t-o.length;if(e.sliceDoc(i,t)==o&&n(e.sliceDoc(i-1,i))!=CharCategory.Word)return i}return  -1}const completionKeymap=[{key:"Ctrl-Space",run:startCompletion},{key:"Escape",run:closeCompletion},{key:"ArrowDown",run:moveCompletionSelection(true)},{key:"ArrowUp",run:moveCompletionSelection(false)},{key:"PageDown",run:moveCompletionSelection(true,"page")},{key:"PageUp",run:moveCompletionSelection(false,"page")},{key:"Enter",run:acceptCompletion}];Prec.highest(keymap.computeN([completionConfig],e=>e.facet(completionConfig).defaultKeymap?[completionKeymap]:[]));function crelt(){var e=arguments[0];"string"==typeof e&&(e=document.createElement(e));var t=1,i=arguments[1];if(i&&"object"==typeof i&&null==i.nodeType&&!Array.isArray(i)){for(var n in i)if(Object.prototype.hasOwnProperty.call(i,n)){var o=i[n];"string"==typeof o?e.setAttribute(n,o):null!=o&&(e[n]=o);}t++;}for(;t<arguments.length;t++)add(e,arguments[t]);return e}function add(e,t){if("string"==typeof t)e.appendChild(document.createTextNode(t));else if(null==t);else if(null!=t.nodeType)e.appendChild(t);else {if(!Array.isArray(t))throw new RangeError("Unsupported child node: "+t);for(var i=0;i<t.length;i++)add(e,t[i]);}}class SelectedDiagnostic{constructor(e,t,i){this.from=e,this.to=t,this.diagnostic=i;}}class LintState{constructor(e,t,i){this.diagnostics=e,this.panel=t,this.selected=i;}static init(e,t,i){let n=e,o=i.facet(lintConfig).markerFilter;o&&(n=o(n));let r=Decoration.set(n.map(e=>e.from==e.to||e.from==e.to-1&&i.doc.lineAt(e.from).to==e.from?Decoration.widget({widget:new DiagnosticWidget(e),diagnostic:e}).range(e.from):Decoration.mark({attributes:{class:"cm-lintRange cm-lintRange-"+e.severity},diagnostic:e}).range(e.from,e.to)),true);return new LintState(r,t,findDiagnostic(r))}}function findDiagnostic(e,t=null,i=0){let n=null;return e.between(i,1e9,(e,i,{spec:o})=>{if(!t||o.diagnostic==t)return n=new SelectedDiagnostic(e,i,o.diagnostic),false}),n}function hideTooltip(e,t){return !(!e.effects.some(e=>e.is(setDiagnosticsEffect))&&!e.changes.touchesRange(t.pos))}function maybeEnableLint(e,t){return e.field(lintState,false)?t:t.concat(StateEffect.appendConfig.of([lintState,EditorView.decorations.compute([lintState],e=>{let{selected:t,panel:i}=e.field(lintState);return t&&i&&t.from!=t.to?Decoration.set([activeMark.range(t.from,t.to)]):Decoration.none}),hoverTooltip(lintTooltip,{hideOn:hideTooltip}),baseTheme$4]))}function setDiagnostics(e,t){return {effects:maybeEnableLint(e,[setDiagnosticsEffect.of(t)])}}const setDiagnosticsEffect=StateEffect.define(),togglePanel=StateEffect.define(),movePanelSelection=StateEffect.define(),lintState=StateField.define({create:()=>new LintState(Decoration.none,null,null),update(e,t){if(t.docChanged){let i=e.diagnostics.map(t.changes),n=null;if(e.selected){let o=t.changes.mapPos(e.selected.from,1);n=findDiagnostic(i,e.selected.diagnostic,o)||findDiagnostic(i,null,o);}e=new LintState(i,e.panel,n);}for(let i of t.effects)i.is(setDiagnosticsEffect)?e=LintState.init(i.value,e.panel,t.state):i.is(togglePanel)?e=new LintState(e.diagnostics,i.value?LintPanel.open:null,e.selected):i.is(movePanelSelection)&&(e=new LintState(e.diagnostics,e.panel,i.value));return e},provide:e=>[showPanel.from(e,e=>e.panel),EditorView.decorations.from(e,e=>e.diagnostics)]}),activeMark=Decoration.mark({class:"cm-lintRange cm-lintRange-active"});function lintTooltip(e,t,i){let{diagnostics:n}=e.state.field(lintState),o=[],r=2e8,s=0;n.between(t-(i<0?1:0),t+(i>0?1:0),(e,n,{spec:a})=>{t>=e&&t<=n&&(e==n||(t>e||i>0)&&(t<n||i<0))&&(o.push(a.diagnostic),r=Math.min(e,r),s=Math.max(n,s));});let a=e.state.facet(lintConfig).tooltipFilter;return a&&(o=a(o)),o.length?{pos:r,end:s,above:e.state.doc.lineAt(r).to<s,create:()=>({dom:diagnosticsTooltip(e,o)})}:null}function diagnosticsTooltip(e,t){return crelt("ul",{class:"cm-tooltip-lint"},t.map(t=>renderDiagnostic(e,t,false)))}const closeLintPanel=e=>{let t=e.state.field(lintState,false);return !(!t||!t.panel)&&(e.dispatch({effects:togglePanel.of(false)}),true)},lintPlugin=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.timeout=-1,this.set=true;let{delay:t}=e.state.facet(lintConfig);this.lintTime=Date.now()+t,this.run=this.run.bind(this),this.timeout=setTimeout(this.run,t);}run(){let e=Date.now();if(e<this.lintTime-10)setTimeout(this.run,this.lintTime-e);else {this.set=false;let{state:e}=this.view,{sources:t}=e.facet(lintConfig);Promise.all(t.map(e=>Promise.resolve(e(this.view)))).then(t=>{let i=t.reduce((e,t)=>e.concat(t));this.view.state.doc==e.doc&&this.view.dispatch(setDiagnostics(this.view.state,i));},e=>{logException(this.view.state,e);});}}update(e){let t=e.state.facet(lintConfig);(e.docChanged||t!=e.startState.facet(lintConfig))&&(this.lintTime=Date.now()+t.delay,this.set||(this.set=true,this.timeout=setTimeout(this.run,t.delay)));}force(){this.set&&(this.lintTime=Date.now(),this.run());}destroy(){clearTimeout(this.timeout);}}),lintConfig=Facet.define({combine:e=>Object.assign({sources:e.map(e=>e.source)},combineConfig(e.map(e=>e.config),{delay:750,markerFilter:null,tooltipFilter:null})),enables:lintPlugin});function linter(e,t={}){return lintConfig.of({source:e,config:t})}function assignKeys(e){let t=[];if(e)e:for(let{name:i}of e){for(let e=0;e<i.length;e++){let n=i[e];if(/[a-zA-Z]/.test(n)&&!t.some(e=>e.toLowerCase()==n.toLowerCase())){t.push(n);continue e}}t.push("");}return t}function renderDiagnostic(e,t,i){var n;let o=i?assignKeys(t.actions):[];return crelt("li",{class:"cm-diagnostic cm-diagnostic-"+t.severity},crelt("span",{class:"cm-diagnosticText"},t.renderMessage?t.renderMessage():t.message),null===(n=t.actions)||void 0===n?void 0:n.map((i,n)=>{let r=n=>{n.preventDefault();let o=findDiagnostic(e.state.field(lintState).diagnostics,t);o&&i.apply(e,o.from,o.to);},{name:s}=i,a=o[n]?s.indexOf(o[n]):-1,l=a<0?s:[s.slice(0,a),crelt("u",s.slice(a,a+1)),s.slice(a+1)];return crelt("button",{type:"button",class:"cm-diagnosticAction",onclick:r,onmousedown:r,"aria-label":` Action: ${s}${a<0?"":` (access key "${o[n]})"`}.`},l)}),t.source&&crelt("div",{class:"cm-diagnosticSource"},t.source))}class DiagnosticWidget extends WidgetType{constructor(e){super(),this.diagnostic=e;}eq(e){return e.diagnostic==this.diagnostic}toDOM(){return crelt("span",{class:"cm-lintPoint cm-lintPoint-"+this.diagnostic.severity})}}class PanelItem{constructor(e,t){this.diagnostic=t,this.id="item_"+Math.floor(4294967295*Math.random()).toString(16),this.dom=renderDiagnostic(e,t,true),this.dom.id=this.id,this.dom.setAttribute("role","option");}}class LintPanel{constructor(e){this.view=e,this.items=[];this.list=crelt("ul",{tabIndex:0,role:"listbox","aria-label":this.view.state.phrase("Diagnostics"),onkeydown:t=>{if(27==t.keyCode)closeLintPanel(this.view),this.view.focus();else if(38==t.keyCode||33==t.keyCode)this.moveSelection((this.selectedIndex-1+this.items.length)%this.items.length);else if(40==t.keyCode||34==t.keyCode)this.moveSelection((this.selectedIndex+1)%this.items.length);else if(36==t.keyCode)this.moveSelection(0);else if(35==t.keyCode)this.moveSelection(this.items.length-1);else if(13==t.keyCode)this.view.focus();else {if(!(t.keyCode>=65&&t.keyCode<=90&&this.selectedIndex>=0))return;{let{diagnostic:i}=this.items[this.selectedIndex],n=assignKeys(i.actions);for(let o=0;o<n.length;o++)if(n[o].toUpperCase().charCodeAt(0)==t.keyCode){let t=findDiagnostic(this.view.state.field(lintState).diagnostics,i);t&&i.actions[o].apply(e,t.from,t.to);}}}t.preventDefault();},onclick:e=>{for(let t=0;t<this.items.length;t++)this.items[t].dom.contains(e.target)&&this.moveSelection(t);}}),this.dom=crelt("div",{class:"cm-panel-lint"},this.list,crelt("button",{type:"button",name:"close","aria-label":this.view.state.phrase("close"),onclick:()=>closeLintPanel(this.view)},"×")),this.update();}get selectedIndex(){let e=this.view.state.field(lintState).selected;if(!e)return  -1;for(let t=0;t<this.items.length;t++)if(this.items[t].diagnostic==e.diagnostic)return t;return  -1}update(){let{diagnostics:e,selected:t}=this.view.state.field(lintState),i=0,n=false,o=null;for(e.between(0,this.view.state.doc.length,(e,r,{spec:s})=>{let a,l=-1;for(let e=i;e<this.items.length;e++)if(this.items[e].diagnostic==s.diagnostic){l=e;break}l<0?(a=new PanelItem(this.view,s.diagnostic),this.items.splice(i,0,a),n=true):(a=this.items[l],l>i&&(this.items.splice(i,l-i),n=true)),t&&a.diagnostic==t.diagnostic?a.dom.hasAttribute("aria-selected")||(a.dom.setAttribute("aria-selected","true"),o=a):a.dom.hasAttribute("aria-selected")&&a.dom.removeAttribute("aria-selected"),i++;});i<this.items.length&&!(1==this.items.length&&this.items[0].diagnostic.from<0);)n=true,this.items.pop();0==this.items.length&&(this.items.push(new PanelItem(this.view,{from:-1,to:-1,severity:"info",message:this.view.state.phrase("No diagnostics")})),n=true),o?(this.list.setAttribute("aria-activedescendant",o.id),this.view.requestMeasure({key:this,read:()=>({sel:o.dom.getBoundingClientRect(),panel:this.list.getBoundingClientRect()}),write:({sel:e,panel:t})=>{e.top<t.top?this.list.scrollTop-=t.top-e.top:e.bottom>t.bottom&&(this.list.scrollTop+=e.bottom-t.bottom);}})):this.selectedIndex<0&&this.list.removeAttribute("aria-activedescendant"),n&&this.sync();}sync(){let e=this.list.firstChild;function t(){let t=e;e=t.nextSibling,t.remove();}for(let i of this.items)if(i.dom.parentNode==this.list){for(;e!=i.dom;)t();e=i.dom.nextSibling;}else this.list.insertBefore(i.dom,e);for(;e;)t();}moveSelection(e){if(this.selectedIndex<0)return;let t=findDiagnostic(this.view.state.field(lintState).diagnostics,this.items[e].diagnostic);t&&this.view.dispatch({selection:{anchor:t.from,head:t.to},scrollIntoView:true,effects:movePanelSelection.of(t)});}static open(e){return new LintPanel(e)}}function svg(e,t='viewBox="0 0 40 40"'){return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(e)}</svg>')`}function underline(e){return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${e}" fill="none" stroke-width=".7"/>`,'width="6" height="3"')}const baseTheme$4=EditorView.baseTheme({".cm-diagnostic":{padding:"3px 6px 3px 8px",marginLeft:"-1px",display:"block",whiteSpace:"pre-wrap"},".cm-diagnostic-error":{borderLeft:"5px solid #d11"},".cm-diagnostic-warning":{borderLeft:"5px solid orange"},".cm-diagnostic-info":{borderLeft:"5px solid #999"},".cm-diagnosticAction":{font:"inherit",border:"none",padding:"2px 4px",backgroundColor:"#444",color:"white",borderRadius:"3px",marginLeft:"8px"},".cm-diagnosticSource":{fontSize:"70%",opacity:.7},".cm-lintRange":{backgroundPosition:"left bottom",backgroundRepeat:"repeat-x",paddingBottom:"0.7px"},".cm-lintRange-error":{backgroundImage:underline("#d11")},".cm-lintRange-warning":{backgroundImage:underline("orange")},".cm-lintRange-info":{backgroundImage:underline("#999")},".cm-lintRange-active":{backgroundColor:"#ffdd9980"},".cm-tooltip-lint":{padding:0,margin:0},".cm-lintPoint":{position:"relative","&:after":{content:'""',position:"absolute",bottom:0,left:"-2px",borderLeft:"3px solid transparent",borderRight:"3px solid transparent",borderBottom:"4px solid #d11"}},".cm-lintPoint-warning":{"&:after":{borderBottomColor:"orange"}},".cm-lintPoint-info":{"&:after":{borderBottomColor:"#999"}},".cm-panel.cm-panel-lint":{position:"relative","& ul":{maxHeight:"100px",overflowY:"auto","& [aria-selected]":{backgroundColor:"#ddd","& u":{textDecoration:"underline"}},"&:focus [aria-selected]":{background_fallback:"#bdf",backgroundColor:"Highlight",color_fallback:"white",color:"HighlightText"},"& u":{textDecoration:"none"},padding:0,margin:0},"& [name=close]":{position:"absolute",top:"0",right:"2px",background:"inherit",border:"none",font:"inherit",padding:0,margin:0}}});class LintGutterMarker extends GutterMarker{constructor(e){super(),this.diagnostics=e,this.severity=e.reduce((e,t)=>{let i=t.severity;return "error"==i||"warning"==i&&"info"==e?i:e},"info");}toDOM(e){let t=document.createElement("div");t.className="cm-lint-marker cm-lint-marker-"+this.severity;let i=this.diagnostics,n=e.state.facet(lintGutterConfig).tooltipFilter;return n&&(i=n(i)),i.length&&(t.onmouseover=(()=>gutterMarkerMouseOver(e,t,i))),t}}function trackHoverOn(e,t){let i=n=>{let o=t.getBoundingClientRect();if(!(n.clientX>o.left-10&&n.clientX<o.right+10&&n.clientY>o.top-10&&n.clientY<o.bottom+10)){for(let e=n.target;e;e=e.parentNode)if(1==e.nodeType&&e.classList.contains("cm-tooltip-lint"))return;window.removeEventListener("mousemove",i),e.state.field(lintGutterTooltip)&&e.dispatch({effects:setLintGutterTooltip.of(null)});}};window.addEventListener("mousemove",i);}function gutterMarkerMouseOver(e,t,i){function n(){let n=e.elementAtHeight(t.getBoundingClientRect().top+5-e.documentTop);e.coordsAtPos(n.from)&&e.dispatch({effects:setLintGutterTooltip.of({pos:n.from,above:false,create:()=>({dom:diagnosticsTooltip(e,i),getCoords:()=>t.getBoundingClientRect()})})}),t.onmouseout=t.onmousemove=null,trackHoverOn(e,t);}let{hoverTime:o}=e.state.facet(lintGutterConfig),r=setTimeout(n,o);t.onmouseout=(()=>{clearTimeout(r),t.onmouseout=t.onmousemove=null;}),t.onmousemove=(()=>{clearTimeout(r),r=setTimeout(n,o);});}function markersForDiagnostics(e,t){let i=Object.create(null);for(let n of t){let t=e.lineAt(n.from);(i[t.from]||(i[t.from]=[])).push(n);}let n=[];for(let e in i)n.push(new LintGutterMarker(i[e]).range(+e));return RangeSet.of(n,true)}const lintGutterExtension=gutter({class:"cm-gutter-lint",markers:e=>e.state.field(lintGutterMarkers)}),lintGutterMarkers=StateField.define({create:()=>RangeSet.empty,update(e,t){e=e.map(t.changes);let i=t.state.facet(lintGutterConfig).markerFilter;for(let n of t.effects)if(n.is(setDiagnosticsEffect)){let o=n.value;i&&(o=i(o||[])),e=markersForDiagnostics(t.state.doc,o.slice(0));}return e}}),setLintGutterTooltip=StateEffect.define(),lintGutterTooltip=StateField.define({create:()=>null,update:(e,t)=>(e&&t.docChanged&&(e=hideTooltip(t,e)?null:Object.assign(Object.assign({},e),{pos:t.changes.mapPos(e.pos)})),t.effects.reduce((e,t)=>t.is(setLintGutterTooltip)?t.value:e,e)),provide:e=>showTooltip.from(e)}),lintGutterTheme=EditorView.baseTheme({".cm-gutter-lint":{width:"1.4em","& .cm-gutterElement":{padding:".2em"}},".cm-lint-marker":{width:"1em",height:"1em"},".cm-lint-marker-info":{content:svg('<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>')},".cm-lint-marker-warning":{content:svg('<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>')},".cm-lint-marker-error":{content:svg('<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>')}}),lintGutterConfig=Facet.define({combine:e=>combineConfig(e,{hoverTime:300,markerFilter:null,tooltipFilter:null})});function lintGutter(e={}){return [lintGutterConfig.of(e),lintGutterMarkers,lintGutterExtension,lintGutterTheme,lintGutterTooltip]}const green="#a6e22c",red="#f92472",cyan="#67d8ef",invalid="#ff0000",ivory="#f8f8f2",stone="#75715e",yellow="#e7db75",whiskey="#d19a66",violet="#ae81ff",cursor="#FFFFFF",oneDarkTheme=EditorView.theme({"&":{color:ivory,backgroundColor:"#282923",fontSize:"15px",lineHeight:"16px",fontFamily:"Consolas, Menlo, Courier, monospace"},"& ::-webkit-scrollbar":{width:"15px",height:"15px"},"& ::-webkit-scrollbar-track":{background:"none"},"& ::-webkit-scrollbar-thumb":{backgroundColor:"#555652",width:"7px",border:"4px solid #282923"},"& ::-webkit-scrollbar-corner":{backgroundColor:"rgba(0,0,0,0)"},".cm-content":{caretColor:cursor},"&.cm-editor":{height:"100%",width:"100%",fontSize:"15px",fontFamily:"Consolas, Menlo, Courier, monospace"},".cm-scroller":{lineHeight:"19px"},".cm-cursor, .cm-dropCursor":{borderLeftColor:cursor},"&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection":{backgroundColor:"#3b3b32"},".cm-panels":{backgroundColor:"#21252b",color:ivory},".cm-panels.cm-panels-top":{borderBottom:"2px solid black"},".cm-panels.cm-panels-bottom":{borderTop:"2px solid black"},".cm-searchMatch":{backgroundColor:"#72a1ff59"},".cm-searchMatch.cm-searchMatch-selected":{backgroundColor:"#6199ff2f"},".cm-activeLine":{backgroundColor:"#6699ff0b"},".cm-selectionMatch":{backgroundColor:"#aafe661a"},"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket":{backgroundColor:"#bad0f847"},".cm-gutters":{backgroundColor:"#282923",color:"#90918b",border:"none"},".cm-activeLineGutter":{color:"#dadad3",backgroundColor:"#3e3d32"},".cm-foldPlaceholder":{backgroundColor:"transparent",border:"none",color:"#ddd"},".cm-tooltip":{border:"none",backgroundColor:"#353a42"},".cm-tooltip .cm-tooltip-arrow:before":{borderTopColor:"transparent",borderBottomColor:"transparent"},".cm-tooltip .cm-tooltip-arrow:after":{borderTopColor:"#353a42",borderBottomColor:"#353a42"},".cm-tooltip-autocomplete":{"& > ul > li[aria-selected]":{backgroundColor:"#3e3d32",color:ivory}}},{dark:true}),oneDarkHighlightStyle=HighlightStyle.define([{tag:tags.keyword,color:cyan},{tag:[tags.name,tags.deleted,tags.character,tags.macroName],color:green},{tag:[tags.propertyName,tags.punctuation],color:ivory},{tag:[tags.function(tags.variableName),tags.labelName],color:cyan},{tag:[tags.color,tags.constant(tags.name),tags.standard(tags.name)],color:whiskey},{tag:[tags.definition(tags.name),tags.separator],color:ivory},{tag:[tags.typeName,tags.className,tags.number,tags.changed,tags.annotation,tags.modifier,tags.self,tags.namespace],color:violet},{tag:[tags.logicOperator,tags.arithmeticOperator,tags.bitwiseOperator,tags.typeOperator],color:red},{tag:[tags.meta,tags.comment],color:stone},{tag:tags.strong,fontWeight:"bold"},{tag:tags.emphasis,fontStyle:"italic"},{tag:tags.strikethrough,textDecoration:"line-through"},{tag:tags.link,color:stone,textDecoration:"underline"},{tag:tags.heading,fontWeight:"bold",color:green},{tag:[tags.atom,tags.bool,tags.special(tags.variableName)],color:violet},{tag:[tags.processingInstruction,tags.string,tags.inserted],color:yellow},{tag:tags.invalid,color:invalid}]),oneDark=[oneDarkTheme,syntaxHighlighting(oneDarkHighlightStyle)];class Stack{constructor(e,t,i,n,o,r,s,a,l,h=0,c){this.p=e,this.stack=t,this.state=i,this.reducePos=n,this.pos=o,this.score=r,this.buffer=s,this.bufferBase=a,this.curContext=l,this.lookAhead=h,this.parent=c;}toString(){return `[${this.stack.filter((e,t)=>t%3==0).concat(this.state)}]@${this.pos}${this.score?"!"+this.score:""}`}static start(e,t,i=0){let n=e.parser.context;return new Stack(e,[],t,i,i,0,[],0,n?new StackContext(n,n.start):null,0,null)}get context(){return this.curContext?this.curContext.context:null}pushState(e,t){this.stack.push(this.state,t,this.bufferBase+this.buffer.length),this.state=e;}reduce(e){let t=e>>19,i=65535&e,{parser:n}=this.p,o=n.dynamicPrecedence(i);if(o&&(this.score+=o),0==t)return this.pushState(n.getGoto(this.state,i,true),this.reducePos),i<n.minRepeatTerm&&this.storeNode(i,this.reducePos,this.reducePos,4,true),void this.reduceContext(i,this.reducePos);let r=this.stack.length-3*(t-1)-(262144&e?6:0),s=this.stack[r-2],a=this.stack[r-1],l=this.bufferBase+this.buffer.length-a;if(i<n.minRepeatTerm||131072&e){let e=n.stateFlag(this.state,1)?this.pos:this.reducePos;this.storeNode(i,s,e,l+4,true);}if(262144&e)this.state=this.stack[r];else {let e=this.stack[r-3];this.state=n.getGoto(e,i,true);}for(;this.stack.length>r;)this.stack.pop();this.reduceContext(i,s);}storeNode(e,t,i,n=4,o=false){if(0==e&&(!this.stack.length||this.stack[this.stack.length-1]<this.buffer.length+this.bufferBase)){let e=this,n=this.buffer.length;if(0==n&&e.parent&&(n=e.bufferBase-e.parent.bufferBase,e=e.parent),n>0&&0==e.buffer[n-4]&&e.buffer[n-1]>-1){if(t==i)return;if(e.buffer[n-2]>=t)return void(e.buffer[n-2]=i)}}if(o&&this.pos!=i){let o=this.buffer.length;if(o>0&&0!=this.buffer[o-4])for(;o>0&&this.buffer[o-2]>i;)this.buffer[o]=this.buffer[o-4],this.buffer[o+1]=this.buffer[o-3],this.buffer[o+2]=this.buffer[o-2],this.buffer[o+3]=this.buffer[o-1],o-=4,n>4&&(n-=4);this.buffer[o]=e,this.buffer[o+1]=t,this.buffer[o+2]=i,this.buffer[o+3]=n;}else this.buffer.push(e,t,i,n);}shift(e,t,i){let n=this.pos;if(131072&e)this.pushState(65535&e,this.pos);else if(0==(262144&e)){let o=e,{parser:r}=this.p;(i>this.pos||t<=r.maxNode)&&(this.pos=i,r.stateFlag(o,1)||(this.reducePos=i)),this.pushState(o,n),this.shiftContext(t,n),t<=r.maxNode&&this.buffer.push(t,n,i,4);}else this.pos=i,this.shiftContext(t,n),t<=this.p.parser.maxNode&&this.buffer.push(t,n,i,4);}apply(e,t,i){65536&e?this.reduce(e):this.shift(e,t,i);}useNode(e,t){let i=this.p.reused.length-1;(i<0||this.p.reused[i]!=e)&&(this.p.reused.push(e),i++);let n=this.pos;this.reducePos=this.pos=n+e.length,this.pushState(t,n),this.buffer.push(i,n,this.reducePos,-1),this.curContext&&this.updateContext(this.curContext.tracker.reuse(this.curContext.context,e,this,this.p.stream.reset(this.pos-e.length)));}split(){let e=this,t=e.buffer.length;for(;t>0&&e.buffer[t-2]>e.reducePos;)t-=4;let i=e.buffer.slice(t),n=e.bufferBase+t;for(;e&&n==e.bufferBase;)e=e.parent;return new Stack(this.p,this.stack.slice(),this.state,this.reducePos,this.pos,this.score,i,n,this.curContext,this.lookAhead,e)}recoverByDelete(e,t){let i=e<=this.p.parser.maxNode;i&&this.storeNode(e,this.pos,t,4),this.storeNode(0,this.pos,t,i?8:4),this.pos=this.reducePos=t,this.score-=190;}canShift(e){for(let t=new SimulatedStack(this);;){let i=this.p.parser.stateSlot(t.state,4)||this.p.parser.hasAction(t.state,e);if(0==i)return  false;if(0==(65536&i))return  true;t.reduce(i);}}recoverByInsert(e){if(this.stack.length>=300)return [];let t=this.p.parser.nextStates(this.state);if(t.length>8||this.stack.length>=120){let i=[];for(let n,o=0;o<t.length;o+=2)(n=t[o+1])!=this.state&&this.p.parser.hasAction(n,e)&&i.push(t[o],n);if(this.stack.length<120)for(let e=0;i.length<8&&e<t.length;e+=2){let n=t[e+1];i.some((e,t)=>1&t&&e==n)||i.push(t[e],n);}t=i;}let i=[];for(let e=0;e<t.length&&i.length<4;e+=2){let n=t[e+1];if(n==this.state)continue;let o=this.split();o.pushState(n,this.pos),o.storeNode(0,o.pos,o.pos,4,true),o.shiftContext(t[e],this.pos),o.score-=200,i.push(o);}return i}forceReduce(){let e=this.p.parser.stateSlot(this.state,5);if(0==(65536&e))return  false;let{parser:t}=this.p;if(!t.validAction(this.state,e)){let i=e>>19,n=65535&e,o=this.stack.length-3*i;if(o<0||t.getGoto(this.stack[o],n,false)<0)return  false;this.storeNode(0,this.reducePos,this.reducePos,4,true),this.score-=100;}return this.reducePos=this.pos,this.reduce(e),true}forceAll(){for(;!this.p.parser.stateFlag(this.state,2);)if(!this.forceReduce()){this.storeNode(0,this.pos,this.pos,4,true);break}return this}get deadEnd(){if(3!=this.stack.length)return  false;let{parser:e}=this.p;return 65535==e.data[e.stateSlot(this.state,1)]&&!e.stateSlot(this.state,4)}restart(){this.state=this.stack[0],this.stack.length=0;}sameState(e){if(this.state!=e.state||this.stack.length!=e.stack.length)return  false;for(let t=0;t<this.stack.length;t+=3)if(this.stack[t]!=e.stack[t])return  false;return  true}get parser(){return this.p.parser}dialectEnabled(e){return this.p.parser.dialect.flags[e]}shiftContext(e,t){this.curContext&&this.updateContext(this.curContext.tracker.shift(this.curContext.context,e,this,this.p.stream.reset(t)));}reduceContext(e,t){this.curContext&&this.updateContext(this.curContext.tracker.reduce(this.curContext.context,e,this,this.p.stream.reset(t)));}emitContext(){let e=this.buffer.length-1;(e<0||-3!=this.buffer[e])&&this.buffer.push(this.curContext.hash,this.reducePos,this.reducePos,-3);}emitLookAhead(){let e=this.buffer.length-1;(e<0||-4!=this.buffer[e])&&this.buffer.push(this.lookAhead,this.reducePos,this.reducePos,-4);}updateContext(e){if(e!=this.curContext.context){let t=new StackContext(this.curContext.tracker,e);t.hash!=this.curContext.hash&&this.emitContext(),this.curContext=t;}}setLookAhead(e){e>this.lookAhead&&(this.emitLookAhead(),this.lookAhead=e);}close(){this.curContext&&this.curContext.tracker.strict&&this.emitContext(),this.lookAhead>0&&this.emitLookAhead();}}class StackContext{constructor(e,t){this.tracker=e,this.context=t,this.hash=e.strict?e.hash(t):0;}}var Recover;!function(e){e[e.Insert=200]="Insert",e[e.Delete=190]="Delete",e[e.Reduce=100]="Reduce",e[e.MaxNext=4]="MaxNext",e[e.MaxInsertStackDepth=300]="MaxInsertStackDepth",e[e.DampenInsertStackDepth=120]="DampenInsertStackDepth";}(Recover||(Recover={}));class SimulatedStack{constructor(e){this.start=e,this.state=e.state,this.stack=e.stack,this.base=this.stack.length;}reduce(e){let t=65535&e,i=e>>19;0==i?(this.stack==this.start.stack&&(this.stack=this.stack.slice()),this.stack.push(this.state,0,0),this.base+=3):this.base-=3*(i-1);let n=this.start.p.parser.getGoto(this.stack[this.base-3],t,true);this.state=n;}}class StackBufferCursor{constructor(e,t,i){this.stack=e,this.pos=t,this.index=i,this.buffer=e.buffer,0==this.index&&this.maybeNext();}static create(e,t=e.bufferBase+e.buffer.length){return new StackBufferCursor(e,t,t-e.bufferBase)}maybeNext(){let e=this.stack.parent;null!=e&&(this.index=this.stack.bufferBase-e.bufferBase,this.stack=e,this.buffer=e.buffer);}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}next(){this.index-=4,this.pos-=4,0==this.index&&this.maybeNext();}fork(){return new StackBufferCursor(this.stack,this.pos,this.index)}}class CachedToken{constructor(){this.start=-1,this.value=-1,this.end=-1,this.extended=-1,this.lookAhead=0,this.mask=0,this.context=0;}}const nullToken=new CachedToken;class InputStream{constructor(e,t){this.input=e,this.ranges=t,this.chunk="",this.chunkOff=0,this.chunk2="",this.chunk2Pos=0,this.next=-1,this.token=nullToken,this.rangeIndex=0,this.pos=this.chunkPos=t[0].from,this.range=t[0],this.end=t[t.length-1].to,this.readNext();}resolveOffset(e,t){let i=this.range,n=this.rangeIndex,o=this.pos+e;for(;o<i.from;){if(!n)return null;let e=this.ranges[--n];o-=i.from-e.to,i=e;}for(;t<0?o>i.to:o>=i.to;){if(n==this.ranges.length-1)return null;let e=this.ranges[++n];o+=e.from-i.to,i=e;}return o}clipPos(e){if(e>=this.range.from&&e<this.range.to)return e;for(let t of this.ranges)if(t.to>e)return Math.max(e,t.from);return this.end}peek(e){let t,i,n=this.chunkOff+e;if(n>=0&&n<this.chunk.length)t=this.pos+e,i=this.chunk.charCodeAt(n);else {let n=this.resolveOffset(e,1);if(null==n)return  -1;if((t=n)>=this.chunk2Pos&&t<this.chunk2Pos+this.chunk2.length)i=this.chunk2.charCodeAt(t-this.chunk2Pos);else {let e=this.rangeIndex,n=this.range;for(;n.to<=t;)n=this.ranges[++e];this.chunk2=this.input.chunk(this.chunk2Pos=t),t+this.chunk2.length>n.to&&(this.chunk2=this.chunk2.slice(0,n.to-t)),i=this.chunk2.charCodeAt(0);}}return t>=this.token.lookAhead&&(this.token.lookAhead=t+1),i}acceptToken(e,t=0){let i=t?this.resolveOffset(t,-1):this.pos;if(null==i||i<this.token.start)throw new RangeError("Token end out of bounds");this.token.value=e,this.token.end=i;}getChunk(){if(this.pos>=this.chunk2Pos&&this.pos<this.chunk2Pos+this.chunk2.length){let{chunk:e,chunkPos:t}=this;this.chunk=this.chunk2,this.chunkPos=this.chunk2Pos,this.chunk2=e,this.chunk2Pos=t,this.chunkOff=this.pos-this.chunkPos;}else {this.chunk2=this.chunk,this.chunk2Pos=this.chunkPos;let e=this.input.chunk(this.pos),t=this.pos+e.length;this.chunk=t>this.range.to?e.slice(0,this.range.to-this.pos):e,this.chunkPos=this.pos,this.chunkOff=0;}}readNext(){return this.chunkOff>=this.chunk.length&&(this.getChunk(),this.chunkOff==this.chunk.length)?this.next=-1:this.next=this.chunk.charCodeAt(this.chunkOff)}advance(e=1){for(this.chunkOff+=e;this.pos+e>=this.range.to;){if(this.rangeIndex==this.ranges.length-1)return this.setDone();e-=this.range.to-this.pos,this.range=this.ranges[++this.rangeIndex],this.pos=this.range.from;}return this.pos+=e,this.pos>=this.token.lookAhead&&(this.token.lookAhead=this.pos+1),this.readNext()}setDone(){return this.pos=this.chunkPos=this.end,this.range=this.ranges[this.rangeIndex=this.ranges.length-1],this.chunk="",this.next=-1}reset(e,t){if(t?(this.token=t,t.start=e,t.lookAhead=e+1,t.value=t.extended=-1):this.token=nullToken,this.pos!=e){if(this.pos=e,e==this.end)return this.setDone(),this;for(;e<this.range.from;)this.range=this.ranges[--this.rangeIndex];for(;e>=this.range.to;)this.range=this.ranges[++this.rangeIndex];e>=this.chunkPos&&e<this.chunkPos+this.chunk.length?this.chunkOff=e-this.chunkPos:(this.chunk="",this.chunkOff=0),this.readNext();}return this}read(e,t){if(e>=this.chunkPos&&t<=this.chunkPos+this.chunk.length)return this.chunk.slice(e-this.chunkPos,t-this.chunkPos);if(e>=this.chunk2Pos&&t<=this.chunk2Pos+this.chunk2.length)return this.chunk2.slice(e-this.chunk2Pos,t-this.chunk2Pos);if(e>=this.range.from&&t<=this.range.to)return this.input.read(e,t);let i="";for(let n of this.ranges){if(n.from>=t)break;n.to>e&&(i+=this.input.read(Math.max(n.from,e),Math.min(n.to,t)));}return i}}class TokenGroup{constructor(e,t){this.data=e,this.id=t;}token(e,t){readToken$1(this.data,e,t,this.id);}}TokenGroup.prototype.contextual=TokenGroup.prototype.fallback=TokenGroup.prototype.extend=false;class ExternalTokenizer{constructor(e,t={}){this.token=e,this.contextual=!!t.contextual,this.fallback=!!t.fallback,this.extend=!!t.extend;}}function readToken$1(e,t,i,n){let o=0,r=1<<n,{parser:s}=i.p,{dialect:a}=s;e:for(;0!=(r&e[o]);){let i=e[o+1];for(let n=o+3;n<i;n+=2)if((e[n+1]&r)>0){let i=e[n];if(a.allows(i)&&(-1==t.token.value||t.token.value==i||s.overrides(i,t.token.value))){t.acceptToken(i);break}}let n=t.next,l=0,h=e[o+2];if(!(t.next<0&&h>l&&65535==e[i+3*h-3]&&65535==e[i+3*h-3])){for(;l<h;){let r=l+h>>1,s=i+r+(r<<1),a=e[s],c=e[s+1]||65536;if(n<a)h=r;else {if(!(n>=c)){o=e[s+2],t.advance();continue e}l=r+1;}}break}o=e[i+3*h-1];}}function decodeArray(e,t=Uint16Array){if("string"!=typeof e)return e;let i=null;for(let n=0,o=0;n<e.length;){let r=0;for(;;){let t=e.charCodeAt(n++),i=false;if(126==t){r=65535;break}t>=92&&t--,t>=34&&t--;let o=t-32;if(o>=46&&(o-=46,i=true),r+=o,i)break;r*=46;}i?i[o++]=r:i=new t(r);}return i}const verbose="undefined"!=typeof process&&process.env&&/\bparse\b/.test(process.env.LOG);let stackIDs=null;var Safety,Rec;function cutAt(e,t,i){let n=e.cursor(IterMode.IncludeAnonymous);for(n.moveTo(t);;)if(!(i<0?n.childBefore(t):n.childAfter(t)))for(;;){if((i<0?n.to<t:n.from>t)&&!n.type.isError)return i<0?Math.max(0,Math.min(n.to-1,t-25)):Math.min(e.length,Math.max(n.from+1,t+25));if(i<0?n.prevSibling():n.nextSibling())break;if(!n.parent())return i<0?0:e.length}}!function(e){e[e.Margin=25]="Margin";}(Safety||(Safety={}));class FragmentCursor$1{constructor(e,t){this.fragments=e,this.nodeSet=t,this.i=0,this.fragment=null,this.safeFrom=-1,this.safeTo=-1,this.trees=[],this.start=[],this.index=[],this.nextFragment();}nextFragment(){let e=this.fragment=this.i==this.fragments.length?null:this.fragments[this.i++];if(e){for(this.safeFrom=e.openStart?cutAt(e.tree,e.from+e.offset,1)-e.offset:e.from,this.safeTo=e.openEnd?cutAt(e.tree,e.to+e.offset,-1)-e.offset:e.to;this.trees.length;)this.trees.pop(),this.start.pop(),this.index.pop();this.trees.push(e.tree),this.start.push(-e.offset),this.index.push(0),this.nextStart=this.safeFrom;}else this.nextStart=1e9;}nodeAt(e){if(e<this.nextStart)return null;for(;this.fragment&&this.safeTo<=e;)this.nextFragment();if(!this.fragment)return null;for(;;){let t=this.trees.length-1;if(t<0)return this.nextFragment(),null;let i=this.trees[t],n=this.index[t];if(n==i.children.length){this.trees.pop(),this.start.pop(),this.index.pop();continue}let o=i.children[n],r=this.start[t]+i.positions[n];if(r>e)return this.nextStart=r,null;if(o instanceof Tree){if(r==e){if(r<this.safeFrom)return null;let e=r+o.length;if(e<=this.safeTo){let t=o.prop(NodeProp.lookAhead);if(!t||e+t<this.fragment.to)return o}}this.index[t]++,r+o.length>=Math.max(this.safeFrom,e)&&(this.trees.push(o),this.start.push(r),this.index.push(0));}else this.index[t]++,this.nextStart=r+o.length;}}}class TokenCache{constructor(e,t){this.stream=t,this.tokens=[],this.mainToken=null,this.actions=[],this.tokens=e.tokenizers.map(e=>new CachedToken);}getActions(e){let t=0,i=null,{parser:n}=e.p,{tokenizers:o}=n,r=n.stateSlot(e.state,3),s=e.curContext?e.curContext.hash:0,a=0;for(let n=0;n<o.length;n++){if(0==(1<<n&r))continue;let l=o[n],h=this.tokens[n];if((!i||l.fallback)&&((l.contextual||h.start!=e.pos||h.mask!=r||h.context!=s)&&(this.updateCachedToken(h,l,e),h.mask=r,h.context=s),h.lookAhead>h.end+25&&(a=Math.max(h.lookAhead,a)),0!=h.value)){let n=t;if(h.extended>-1&&(t=this.addActions(e,h.extended,h.end,t)),t=this.addActions(e,h.value,h.end,t),!l.extend&&(i=h,t>n))break}}for(;this.actions.length>t;)this.actions.pop();return a&&e.setLookAhead(a),i||e.pos!=this.stream.end||((i=new CachedToken).value=e.p.parser.eofTerm,i.start=i.end=e.pos,t=this.addActions(e,i.value,i.end,t)),this.mainToken=i,this.actions}getMainToken(e){if(this.mainToken)return this.mainToken;let t=new CachedToken,{pos:i,p:n}=e;return t.start=i,t.end=Math.min(i+1,n.stream.end),t.value=i==n.stream.end?n.parser.eofTerm:0,t}updateCachedToken(e,t,i){let n=this.stream.clipPos(i.pos);if(t.token(this.stream.reset(n,e),i),e.value>-1){let{parser:t}=i.p;for(let n=0;n<t.specialized.length;n++)if(t.specialized[n]==e.value){let o=t.specializers[n](this.stream.read(e.start,e.end),i);if(o>=0&&i.p.parser.dialect.allows(o>>1)){0==(1&o)?e.value=o>>1:e.extended=o>>1;break}}}else e.value=0,e.end=this.stream.clipPos(n+1);}putAction(e,t,i,n){for(let t=0;t<n;t+=3)if(this.actions[t]==e)return n;return this.actions[n++]=e,this.actions[n++]=t,this.actions[n++]=i,n}addActions(e,t,i,n){let{state:o}=e,{parser:r}=e.p,{data:s}=r;for(let e=0;e<2;e++)for(let a=r.stateSlot(o,e?2:1);;a+=3){if(65535==s[a]){if(1!=s[a+1]){0==n&&2==s[a+1]&&(n=this.putAction(pair(s,a+2),t,i,n));break}a=pair(s,a+2);}s[a]==t&&(n=this.putAction(pair(s,a+1),t,i,n));}return n}}!function(e){e[e.Distance=5]="Distance",e[e.MaxRemainingPerStep=3]="MaxRemainingPerStep",e[e.MinBufferLengthPrune=500]="MinBufferLengthPrune",e[e.ForceReduceLimit=10]="ForceReduceLimit",e[e.CutDepth=15e3]="CutDepth",e[e.CutTo=9e3]="CutTo";}(Rec||(Rec={}));class Parse$1{constructor(e,t,i,n){this.parser=e,this.input=t,this.ranges=n,this.recovering=0,this.nextStackID=9812,this.minStackPos=0,this.reused=[],this.stoppedAt=null,this.stream=new InputStream(t,n),this.tokens=new TokenCache(e,this.stream),this.topTerm=e.top[1];let{from:o}=n[0];this.stacks=[Stack.start(this,e.top[0],o)],this.fragments=i.length&&this.stream.end-o>4*e.bufferLength?new FragmentCursor$1(i,e.nodeSet):null;}get parsedPos(){return this.minStackPos}advance(){let e,t,i=this.stacks,n=this.minStackPos,o=this.stacks=[];for(let r=0;r<i.length;r++){let s=i[r];for(;;){if(this.tokens.mainToken=null,s.pos>n)o.push(s);else {if(this.advanceStack(s,o,i))continue;{e||(e=[],t=[]),e.push(s);let i=this.tokens.getMainToken(s);t.push(i.value,i.end);}}break}}if(!o.length){let t=e&&findFinished(e);if(t)return this.stackToTree(t);if(this.parser.strict)throw verbose&&e&&console.log("Stuck with token "+(this.tokens.mainToken?this.parser.getName(this.tokens.mainToken.value):"none")),new SyntaxError("No parse at "+n);this.recovering||(this.recovering=5);}if(this.recovering&&e){let i=null!=this.stoppedAt&&e[0].pos>this.stoppedAt?e[0]:this.runRecovery(e,t,o);if(i)return this.stackToTree(i.forceAll())}if(this.recovering){let e=1==this.recovering?1:3*this.recovering;if(o.length>e)for(o.sort((e,t)=>t.score-e.score);o.length>e;)o.pop();o.some(e=>e.reducePos>n)&&this.recovering--;}else if(o.length>1)e:for(let e=0;e<o.length-1;e++){let t=o[e];for(let i=e+1;i<o.length;i++){let n=o[i];if(t.sameState(n)||t.buffer.length>500&&n.buffer.length>500){if(!((t.score-n.score||t.buffer.length-n.buffer.length)>0)){o.splice(e--,1);continue e}o.splice(i--,1);}}}this.minStackPos=o[0].pos;for(let e=1;e<o.length;e++)o[e].pos<this.minStackPos&&(this.minStackPos=o[e].pos);return null}stopAt(e){if(null!=this.stoppedAt&&this.stoppedAt<e)throw new RangeError("Can't move stoppedAt forward");this.stoppedAt=e;}advanceStack(e,t,i){let n=e.pos,{parser:o}=this,r=verbose?this.stackID(e)+" -> ":"";if(null!=this.stoppedAt&&n>this.stoppedAt)return e.forceReduce()?e:null;if(this.fragments){let t=e.curContext&&e.curContext.tracker.strict,i=t?e.curContext.hash:0;for(let s=this.fragments.nodeAt(n);s;){let n=this.parser.nodeSet.types[s.type.id]==s.type?o.getGoto(e.state,s.type.id):-1;if(n>-1&&s.length&&(!t||(s.prop(NodeProp.contextHash)||0)==i))return e.useNode(s,n),verbose&&console.log(r+this.stackID(e)+` (via reuse of ${o.getName(s.type.id)})`),true;if(!(s instanceof Tree)||0==s.children.length||s.positions[0]>0)break;let a=s.children[0];if(!(a instanceof Tree&&0==s.positions[0]))break;s=a;}}let s=o.stateSlot(e.state,4);if(s>0)return e.reduce(s),verbose&&console.log(r+this.stackID(e)+` (via always-reduce ${o.getName(65535&s)})`),true;if(e.stack.length>=15e3)for(;e.stack.length>9e3&&e.forceReduce(););let a=this.tokens.getActions(e);for(let s=0;s<a.length;){let l=a[s++],h=a[s++],c=a[s++],d=s==a.length||!i,u=d?e:e.split();if(u.apply(l,h,c),verbose&&console.log(r+this.stackID(u)+` (via ${0==(65536&l)?"shift":`reduce of ${o.getName(65535&l)}`} for ${o.getName(h)} @ ${n}${u==e?"":", split"})`),d)return  true;u.pos>n?t.push(u):i.push(u);}return  false}advanceFully(e,t){let i=e.pos;for(;;){if(!this.advanceStack(e,null,null))return  false;if(e.pos>i)return pushStackDedup(e,t),true}}runRecovery(e,t,i){let n=null,o=false;for(let r=0;r<e.length;r++){let s=e[r],a=t[r<<1],l=t[1+(r<<1)],h=verbose?this.stackID(s)+" -> ":"";if(s.deadEnd){if(o)continue;if(o=true,s.restart(),verbose&&console.log(h+this.stackID(s)+" (restarted)"),this.advanceFully(s,i))continue}let c=s.split(),d=h;for(let e=0;c.forceReduce()&&e<10;e++){if(verbose&&console.log(d+this.stackID(c)+" (via force-reduce)"),this.advanceFully(c,i))break;verbose&&(d=this.stackID(c)+" -> ");}for(let e of s.recoverByInsert(a))verbose&&console.log(h+this.stackID(e)+" (via recover-insert)"),this.advanceFully(e,i);this.stream.end>s.pos?(l==s.pos&&(l++,a=0),s.recoverByDelete(a,l),verbose&&console.log(h+this.stackID(s)+` (via recover-delete ${this.parser.getName(a)})`),pushStackDedup(s,i)):(!n||n.score<s.score)&&(n=s);}return n}stackToTree(e){return e.close(),Tree.build({buffer:StackBufferCursor.create(e),nodeSet:this.parser.nodeSet,topID:this.topTerm,maxBufferLength:this.parser.bufferLength,reused:this.reused,start:this.ranges[0].from,length:e.pos-this.ranges[0].from,minRepeatType:this.parser.minRepeatTerm})}stackID(e){let t=(stackIDs||(stackIDs=new WeakMap)).get(e);return t||stackIDs.set(e,t=String.fromCodePoint(this.nextStackID++)),t+e}}function pushStackDedup(e,t){for(let i=0;i<t.length;i++){let n=t[i];if(n.pos==e.pos&&n.sameState(e))return void(t[i].score<e.score&&(t[i]=e))}t.push(e);}class Dialect{constructor(e,t,i){this.source=e,this.flags=t,this.disabled=i;}allows(e){return !this.disabled||0==this.disabled[e]}}const id=e=>e;class ContextTracker{constructor(e){this.start=e.start,this.shift=e.shift||id,this.reduce=e.reduce||id,this.reuse=e.reuse||id,this.hash=e.hash||(()=>0),this.strict=false!==e.strict;}}class LRParser extends Parser{constructor(e){if(super(),this.wrappers=[],14!=e.version)throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);let t=e.nodeNames.split(" ");this.minRepeatTerm=t.length;for(let i=0;i<e.repeatNodeCount;i++)t.push("");let i=Object.keys(e.topRules).map(t=>e.topRules[t][1]),n=[];for(let e=0;e<t.length;e++)n.push([]);function o(e,t,i){n[e].push([t,t.deserialize(String(i))]);}if(e.nodeProps)for(let t of e.nodeProps){let e=t[0];"string"==typeof e&&(e=NodeProp[e]);for(let i=1;i<t.length;){let n=t[i++];if(n>=0)o(n,e,t[i++]);else {let r=t[i+-n];for(let s=-n;s>0;s--)o(t[i++],e,r);i++;}}}this.nodeSet=new NodeSet(t.map((t,o)=>NodeType.define({name:o>=this.minRepeatTerm?void 0:t,id:o,props:n[o],top:i.indexOf(o)>-1,error:0==o,skipped:e.skippedNodes&&e.skippedNodes.indexOf(o)>-1}))),e.propSources&&(this.nodeSet=this.nodeSet.extend(...e.propSources)),this.strict=false,this.bufferLength=DefaultBufferLength;let r=decodeArray(e.tokenData);this.context=e.context,this.specializerSpecs=e.specialized||[],this.specialized=new Uint16Array(this.specializerSpecs.length);for(let e=0;e<this.specializerSpecs.length;e++)this.specialized[e]=this.specializerSpecs[e].term;this.specializers=this.specializerSpecs.map(getSpecializer),this.states=decodeArray(e.states,Uint32Array),this.data=decodeArray(e.stateData),this.goto=decodeArray(e.goto),this.maxTerm=e.maxTerm,this.tokenizers=e.tokenizers.map(e=>"number"==typeof e?new TokenGroup(r,e):e),this.topRules=e.topRules,this.dialects=e.dialects||{},this.dynamicPrecedences=e.dynamicPrecedences||null,this.tokenPrecTable=e.tokenPrec,this.termNames=e.termNames||null,this.maxNode=this.nodeSet.types.length-1,this.dialect=this.parseDialect(),this.top=this.topRules[Object.keys(this.topRules)[0]];}createParse(e,t,i){let n=new Parse$1(this,e,t,i);for(let o of this.wrappers)n=o(n,e,t,i);return n}getGoto(e,t,i=false){let n=this.goto;if(t>=n[0])return  -1;for(let o=n[t+1];;){let t=n[o++],r=1&t,s=n[o++];if(r&&i)return s;for(let i=o+(t>>1);o<i;o++)if(n[o]==e)return s;if(r)return  -1}}hasAction(e,t){let i=this.data;for(let n=0;n<2;n++)for(let o,r=this.stateSlot(e,n?2:1);;r+=3){if(65535==(o=i[r])){if(1!=i[r+1]){if(2==i[r+1])return pair(i,r+2);break}o=i[r=pair(i,r+2)];}if(o==t||0==o)return pair(i,r+1)}return 0}stateSlot(e,t){return this.states[6*e+t]}stateFlag(e,t){return (this.stateSlot(e,0)&t)>0}validAction(e,t){if(t==this.stateSlot(e,4))return  true;for(let i=this.stateSlot(e,1);;i+=3){if(65535==this.data[i]){if(1!=this.data[i+1])return  false;i=pair(this.data,i+2);}if(t==pair(this.data,i+1))return  true}}nextStates(e){let t=[];for(let i=this.stateSlot(e,1);;i+=3){if(65535==this.data[i]){if(1!=this.data[i+1])break;i=pair(this.data,i+2);}if(0==(1&this.data[i+2])){let e=this.data[i+1];t.some((t,i)=>1&i&&t==e)||t.push(this.data[i],e);}}return t}overrides(e,t){let i=findOffset(this.data,this.tokenPrecTable,t);return i<0||findOffset(this.data,this.tokenPrecTable,e)<i}configure(e){let t=Object.assign(Object.create(LRParser.prototype),this);if(e.props&&(t.nodeSet=this.nodeSet.extend(...e.props)),e.top){let i=this.topRules[e.top];if(!i)throw new RangeError(`Invalid top rule name ${e.top}`);t.top=i;}return e.tokenizers&&(t.tokenizers=this.tokenizers.map(t=>{let i=e.tokenizers.find(e=>e.from==t);return i?i.to:t})),e.specializers&&(t.specializers=this.specializers.slice(),t.specializerSpecs=this.specializerSpecs.map((i,n)=>{let o=e.specializers.find(e=>e.from==i.external);if(!o)return i;let r=Object.assign(Object.assign({},i),{external:o.to});return t.specializers[n]=getSpecializer(r),r})),e.contextTracker&&(t.context=e.contextTracker),e.dialect&&(t.dialect=this.parseDialect(e.dialect)),null!=e.strict&&(t.strict=e.strict),e.wrap&&(t.wrappers=t.wrappers.concat(e.wrap)),null!=e.bufferLength&&(t.bufferLength=e.bufferLength),t}hasWrappers(){return this.wrappers.length>0}getName(e){return this.termNames?this.termNames[e]:String(e<=this.maxNode&&this.nodeSet.types[e].name||e)}get eofTerm(){return this.maxNode+1}get topNode(){return this.nodeSet.types[this.top[1]]}dynamicPrecedence(e){let t=this.dynamicPrecedences;return null==t?0:t[e]||0}parseDialect(e){let t=Object.keys(this.dialects),i=t.map(()=>false);if(e)for(let n of e.split(" ")){let e=t.indexOf(n);e>=0&&(i[e]=true);}let n=null;for(let e=0;e<t.length;e++)if(!i[e])for(let i,o=this.dialects[t[e]];65535!=(i=this.data[o++]);)(n||(n=new Uint8Array(this.maxTerm+1)))[i]=1;return new Dialect(e,i,n)}static deserialize(e){return new LRParser(e)}}function pair(e,t){return e[t]|e[t+1]<<16}function findOffset(e,t,i){for(let n,o=t;65535!=(n=e[o]);o++)if(n==i)return o-t;return  -1}function findFinished(e){let t=null;for(let i of e){let e=i.p.stoppedAt;(i.pos==i.p.stream.end||null!=e&&i.pos>e)&&i.p.parser.stateFlag(i.state,2)&&(!t||t.score<i.score)&&(t=i);}return t}function getSpecializer(e){if(e.external){let t=e.extend?1:0;return (i,n)=>e.external(i,n)<<1|t}return e.get}const space=[9,10,11,12,13,32,133,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288],trackNewline=new ContextTracker({start:false,shift:(e,t)=>5==t||6==t||299==t?e:300==t,strict:false}),insertSemicolon=new ExternalTokenizer((e,t)=>{let{next:i}=e;(125==i||-1==i||t.context)&&t.canShift(297)&&e.acceptToken(297);},{contextual:true,fallback:true}),noSemicolon=new ExternalTokenizer((e,t)=>{let i,{next:n}=e;space.indexOf(n)>-1||(47!=n||47!=(i=e.peek(1))&&42!=i)&&125!=n&&59!=n&&-1!=n&&!t.context&&t.canShift(294)&&e.acceptToken(294);},{contextual:true}),incdecToken=new ExternalTokenizer((e,t)=>{let{next:i}=e;if((43==i||45==i)&&(e.advance(),i==e.next)){e.advance();let i=!t.context&&t.canShift(2);e.acceptToken(i?2:3);}},{contextual:true}),template=new ExternalTokenizer(e=>{for(let t=false,i=0;;i++){let{next:n}=e;if(n<0){i&&e.acceptToken(295);break}if(96==n){i?e.acceptToken(295):e.acceptToken(296,1);break}if(123==n&&t){1==i?e.acceptToken(4,1):e.acceptToken(295,-1);break}if(10==n&&i){e.advance(),e.acceptToken(295);break}92==n&&e.advance(),t=36==n,e.advance();}}),tsExtends=new ExternalTokenizer((e,t)=>{if(101==e.next&&t.dialectEnabled(1)){e.advance();for(let t=0;t<6;t++){if(e.next!="xtends".charCodeAt(t))return;e.advance();}e.next>=57&&e.next<=65||e.next>=48&&e.next<=90||95==e.next||e.next>=97&&e.next<=122||e.next>160||e.acceptToken(1);}}),jsHighlight=styleTags({"get set async static":tags.modifier,"for while do if else switch try catch finally return throw break continue default case":tags.controlKeyword,"in of await yield void typeof delete instanceof":tags.operatorKeyword,"let var const function class extends":tags.definitionKeyword,"import export from":tags.moduleKeyword,"with debugger as new":tags.keyword,TemplateString:tags.special(tags.string),super:tags.atom,BooleanLiteral:tags.bool,this:tags.self,null:tags.null,Star:tags.modifier,VariableName:tags.variableName,"CallExpression/VariableName TaggedTemplateExpression/VariableName":tags.function(tags.variableName),VariableDefinition:tags.definition(tags.variableName),Label:tags.labelName,PropertyName:tags.propertyName,PrivatePropertyName:tags.special(tags.propertyName),"CallExpression/MemberExpression/PropertyName":tags.function(tags.propertyName),"FunctionDeclaration/VariableDefinition":tags.function(tags.definition(tags.variableName)),"ClassDeclaration/VariableDefinition":tags.definition(tags.className),PropertyDefinition:tags.definition(tags.propertyName),PrivatePropertyDefinition:tags.definition(tags.special(tags.propertyName)),UpdateOp:tags.updateOperator,LineComment:tags.lineComment,BlockComment:tags.blockComment,Number:tags.number,String:tags.string,ArithOp:tags.arithmeticOperator,LogicOp:tags.logicOperator,BitOp:tags.bitwiseOperator,CompareOp:tags.compareOperator,RegExp:tags.regexp,Equals:tags.definitionOperator,Arrow:tags.function(tags.punctuation),": Spread":tags.punctuation,"( )":tags.paren,"[ ]":tags.squareBracket,"{ }":tags.brace,"InterpolationStart InterpolationEnd":tags.special(tags.brace),".":tags.derefOperator,", ;":tags.separator,"@":tags.meta,TypeName:tags.typeName,TypeDefinition:tags.definition(tags.typeName),"type enum interface implements namespace module declare":tags.definitionKeyword,"abstract global Privacy readonly override":tags.modifier,"is keyof unique infer":tags.operatorKeyword,JSXAttributeValue:tags.attributeValue,JSXText:tags.content,"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag":tags.angleBracket,"JSXIdentifier JSXNameSpacedName":tags.tagName,"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName":tags.attributeName,"JSXBuiltin/JSXIdentifier":tags.standard(tags.tagName)}),spec_identifier={__proto__:null,export:18,as:23,from:29,default:32,async:37,function:38,this:50,true:58,false:58,null:68,void:72,typeof:76,super:92,new:126,await:143,yield:145,delete:146,class:156,extends:158,public:213,private:213,protected:213,readonly:215,instanceof:234,satisfies:237,in:238,const:240,import:272,keyof:327,unique:331,infer:337,is:373,abstract:393,implements:395,type:397,let:400,var:402,interface:409,enum:413,namespace:419,module:421,declare:425,global:429,for:450,of:459,while:462,with:466,do:470,if:474,else:476,switch:480,case:486,try:492,catch:496,finally:500,return:504,throw:508,break:512,continue:516,debugger:520},spec_word={__proto__:null,async:113,get:115,set:117,public:175,private:175,protected:175,static:177,abstract:179,override:181,readonly:187,accessor:189,new:377},spec_LessThan={__proto__:null,"<":133},parser=LRParser.deserialize({version:14,states:"$CWO`QdOOO$}QdOOO)WQ(C|O'#ChO)_OWO'#DYO+jQdO'#D_O+zQdO'#DjO$}QdO'#DtO.OQdO'#DzOOQ(C['#ET'#ETO.fQ`O'#EQOOQO'#IW'#IWO.nQ`O'#GgOOQO'#Ee'#EeO.yQ`O'#EdO/OQ`O'#EdO1QQ(C|O'#JQO3nQ(C|O'#JRO4_Q`O'#FSO4dQ!bO'#FkOOQ(C['#F['#F[O4oO#tO'#F[O4}Q&jO'#FrO6bQ`O'#FqOOQ(C['#JR'#JROOQ(CW'#JQ'#JQOOQS'#Jk'#JkO6gQ`O'#H{O6lQ(ChO'#H|OOQS'#Iu'#IuOOQS'#IO'#IOQ`QdOOO$}QdO'#DlO6tQ`O'#GgO6yQ&jO'#CmO7XQ`O'#EcO7dQ`O'#EnO7iQ&jO'#FZO8TQ`O'#GgO8YQ`O'#GkO8eQ`O'#GkO8sQ`O'#GnO8sQ`O'#GoO8sQ`O'#GqO6tQ`O'#GtO9dQ`O'#GwO:uQ`O'#CdO;VQ`O'#HUO;_Q`O'#H[O;_Q`O'#H^O`QdO'#H`O;_Q`O'#HbO;_Q`O'#HeO;dQ`O'#HkO;iQ(CjO'#HqO$}QdO'#HsO;tQ(CjO'#HuO<PQ(CjO'#HwO6lQ(ChO'#HyO<[Q(C|O'#ChO<xQ,UO'#DdQOQ`OOO=mQaO'#D{O6yQ&jO'#EcO={Q`O'#EcO>WQpO'#FZO$}QdO'#DZOOOW'#IQ'#IQO>`OWO,59tOOQ(C[,59t,59tO>kQdO'#IRO?OQ`O'#JSOAQQtO'#JSO)jQdO'#JSOAXQ`O,59yOAoQ`O'#EeOA|Q`O'#J`OBXQ`O'#J_OBXQ`O'#J_OBaQ`O,5;ROBfQ`O'#J^OOQ(C[,5:U,5:UOBmQdO,5:UODnQ(C|O,5:`OE_Q`O,5:fOEdQ`O'#J[OF^Q(ChO'#J]O8YQ`O'#J[OFeQ`O'#J[OFmQ`O,5;QOFrQ`O'#J[OOQ(C]'#Ch'#ChO$}QdO'#DzOGfQpO,5:lOOQO'#JX'#JXOOQO-E<U-E<UO6tQ`O,5=ROG|Q`O,5=ROHRQdO,5;OOJRQ&jO'#E`OKcQ`O,5;OOLxQ&jO'#DnOMPQdO'#DsOMZQ,UO,5;XOMcQ,UO,5;XO$}QdO,5;XOOQS'#Ez'#EzOOQS'#E|'#E|O$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YOOQS'#FQ'#FQOMqQdO,5;kOOQ(C[,5;p,5;pOOQ(C[,5;q,5;qO! qQ`O,5;qOOQ(C[,5;r,5;rO$}QdO'#I^O! yQ(ChO,5<_OJRQ&jO,5;YO!!hQ&jO,5;YO$}QdO,5;nO!!oQ!bO'#FaO!#lQ!bO'#JdO!#WQ!bO'#JdO!#sQ!bO'#JdOOQO'#Jd'#JdO!$XQ!bO,5;yOOOO,5<V,5<VO!$jQdO'#FmOOOO'#I]'#I]O4oO#tO,5;vO!$qQ!bO'#FoOOQ(C[,5;v,5;vO!%bQ7]O'#CsOOQ(C]'#Cv'#CvO!%uQ`O'#CvO!%zOWO'#CzO!&hQ&kO,5<[O!&oQ`O,5<^O!(RQMhO'#F|O!(`Q`O'#F}O!(eQ`O'#F}O!(jQMhO'#GRO!)iQ,UO'#GVO!*_Q7]O'#I}OOQ(C]'#I}'#I}O!+eQaO'#I|O!+sQ`O'#I{O!+{Q`O'#CrOOQ(C]'#Ct'#CtOOQ(C]'#C}'#C}OOQ(C]'#DP'#DPO.iQ`O'#DROKhQ&jO'#FtOKhQ&jO'#FvO!,TQ`O'#FxO!,YQ`O'#FyO!(eQ`O'#GPOKhQ&jO'#GUO!,_Q`O'#EfO!,yQ`O,5<]O`QdO,5>gOOQS'#Ix'#IxOOQS,5>h,5>hOOQS-E;|-E;|O!.xQ(C|O,5:WOOQ(CX'#Cp'#CpO!/lQ&kO,5=ROOQO'#Cf'#CfO!/}Q(ChO'#IyO6bQ`O'#IyO;dQ`O,59XO!0`Q!bO,59XO!0hQ&jO,59XO6yQ&jO,59XO!0sQ`O,5;OO!0{Q`O'#HTO!1ZQ`O'#JoO$}QdO,5;sO!1cQ,UO,5;uO!1hQ`O,5=nO!1mQ`O,5=nO!1rQ`O,5=nO6lQ(ChO,5=nO!2QQ`O'#EgO!2wQ,UO'#EhOOQ(CW'#J^'#J^O!3OQ(ChO'#JlO6lQ(ChO,5=VO8sQ`O,5=]OOQP'#Cs'#CsO!3ZQ!bO,5=YO!3cQ!cO,5=ZO!3nQ`O,5=]O!3sQpO,5=`O;dQ`O'#GyO6tQ`O'#G{O!3{Q`O'#G{O6yQ&jO'#HOO!4QQ`O'#HOOOQS,5=c,5=cO!4VQ`O'#HPO!4_Q`O'#CmO!4dQ`O,59OO!4nQ`O,59OO!6sQdO,59OOOQS,59O,59OO!7QQ(ChO,59OO$}QdO,59OO!7]QdO'#HWOOQS'#HX'#HXOOQS'#HY'#HYO`QdO,5=pO!7mQ`O,5=pO`QdO,5=vO`QdO,5=xO!7rQ`O,5=zO`QdO,5=|O!7wQ`O,5>PO!7|QdO,5>VOOQS,5>],5>]O$}QdO,5>]O6lQ(ChO,5>_OOQS,5>a,5>aO!<QQ`O,5>aOOQS,5>c,5>cO!<QQ`O,5>cOOQS,5>e,5>eO!<VQ!bO'#DWOOQ(CW'#JU'#JUO$}QdO'#JUO!<tQ!bO'#JUO!=cQ!bO'#DeO!=tQ,UO'#DeO!@PQdO'#DeO!@WQ`O'#JTO!@`Q`O,5:OO!@eQ`O'#EiO!@sQ`O'#JaO!@{Q`O,5;SO!AcQ,UO'#DeO!AmQ,UO'#EOOOQ(C[,5:g,5:gO$}QdO,5:gOJRQ&jO,5:gO!BjQaO,5:gO;dQ`O,5:}O!0`Q!bO,5:}O!0hQ&jO,5:}O6yQ&jO,5:}O!BuQpO,59uOOOW-E<O-E<OOOQ(C[1G/`1G/`O!BzQtO,5>mO)jQdO,5>mOOQO,5>s,5>sO!CUQdO'#IROOQO-E<P-E<PO!CcQ`O,5?nO!CkQtO,5?nO!CrQ`O,5?yOOQ(C[1G/e1G/eO$}QdO,5?zO!CzQ`O'#IXOOQO-E<V-E<VO!CrQ`O,5?yOOQ(CW1G0m1G0mOOQ(C[1G/p1G/pOOQ(C[1G0Q1G0QO!D`Q`O,5?vO8YQ`O,5?vO!DhQ`O,5?vOOQ(CW'#E_'#E_O$}QdO,5?wO!DvQ(ChO,5?wO!EXQ(ChO,5?wO!E`Q`O'#IZO!D`Q`O,5?vOOQ(CW1G0l1G0lOMZQ,UO,5:nOMfQ,UO,5:nOOQO,5:p,5:pO!E}Q`O,5:pO!FVQ&kO1G2mO6tQ`O1G2mOOQ(C[1G0j1G0jO!FhQ(C|O1G0jO!GmQ(CyO,5:zOOQ(C]'#F{'#F{O!JWQ(C}O'#I}OHRQdO1G0jO!J}Q&kO'#JVO!KXQ`O,5:YO!K^QtO'#JWO$}QdO'#JWO!KhQ`O,5:_OOQ(C]'#DW'#DWOOQ(C[1G0s1G0sO$}QdO1G0sOOQ(C[1G1]1G1]O!KmQ`O1G0sO!NUQ(C|O1G0tO!N]Q(C|O1G0tO#!vQ(C|O1G0tO#!}Q(C|O1G0tO#%XQ(C|O1G0tO#%oQ(C|O1G0tO#(iQ(C|O1G0tO#(pQ(C|O1G0tO#+ZQ(C|O1G0tO#+bQ(C|O1G0tO#-YQ(C|O1G0tO#0YQ!LUO'#ChO#2WQ!LUO1G1VO#4UQ!LUO'#JRO! tQ`O1G1]O#4iQ(C|O,5>xOOQ(CW-E<[-E<[O#5]Q(C}O1G0tOOQ(C[1G0t1G0tO#7hQ(C|O1G1YO#8[Q!bO,5;}O#8dQ!bO,5<OO#8lQ!bO'#FfO#9TQ`O'#FeOOQO'#Je'#JeOOQO'#I['#I[O#9YQ!bO1G1eOOQ(C[1G1e1G1eOOOO1G1p1G1pO#9kQ!LUO'#JQO#9uQ`O,5<XOMqQdO,5<XOOOO-E<Z-E<ZOOQ(C[1G1b1G1bOOQ(C[,5<Z,5<ZO#9zQ!bO,5<ZOOQ(C],59b,59bOJRQ&jO'#C|OOOW'#IP'#IPO#:POWO,59fOOQ(C],59f,59fO$}QdO1G1vO!,YQ`O'#I`O#:[Q`O,5<oOOQ(C],5<l,5<lOOQO'#Gb'#GbOKhQ&jO,5<{OOQO'#Gd'#GdOKhQ&jO,5<}OJRQ&jO,5=POOQO1G1x1G1xO#:gQqO'#CpO#:zQqO,5<hO#;RQ`O'#JhO6tQ`O'#JhO#;aQ`O,5<jOKhQ&jO,5<iO#;fQ`O'#GOO#;qQ`O,5<iO#;vQqO'#F{O#<TQqO'#JiO#<_Q`O'#JiOJRQ&jO'#JiO#<dQ`O,5<mOOQ(CW'#Di'#DiO#<iQ!bO'#GWO!)dQ,UO'#GWO#<zQ`O'#GYO#=PQ`O'#G[O!(eQ`O'#G_O#=UQ(ChO'#IbO#=aQ,UO,5<qOOQ(C],5<q,5<qO#=hQ,UO'#GWO#=vQ,UO'#GXO#>OQ,UO'#GXOOQ(C],5=Q,5=QOKhQ&jO,5?hOKhQ&jO,5?hO#>TQ`O'#IcO#>`Q`O,5?gO#>hQ`O,59^O#?XQ&kO,59mOOQ(C],59m,59mO#?zQ&kO,5<`O#@mQ&kO,5<bO#@wQ`O,5<dOOQ(C],5<e,5<eO#@|Q`O,5<kO#ARQ&kO,5<pOHRQdO1G1wO#AcQ`O1G1wOOQS1G4R1G4ROOQ(C[1G/r1G/rO! qQ`O1G/rOOQS1G2m1G2mOJRQ&jO1G2mO$}QdO1G2mOJRQ&jO1G2mO#AhQaO1G2mO#CQQ&jO'#E`OOQ(CW,5?e,5?eO#C[Q(ChO,5?eOOQS1G.s1G.sO;dQ`O1G.sO!0`Q!bO1G.sO!0hQ&jO1G.sO#CmQ`O1G0jO#CrQ`O'#ChO#C}Q`O'#JpO#DVQ`O,5=oO#D[Q`O'#JpO#DaQ`O'#JpO#DiQ`O'#IkO#DwQ`O,5@ZO#EPQtO1G1_OOQ(C[1G1a1G1aO6tQ`O1G3YO#EWQ`O1G3YO#E]Q`O1G3YO#EbQ`O1G3YOOQS1G3Y1G3YO8YQ`O'#J_O8YQ`O'#EiO$}QdO'#EiO8YQ`O'#IeO#EgQ(ChO,5@WOOQS1G2q1G2qO!3nQ`O1G2wOJRQ&jO1G2tO#ErQ`O1G2tOOQS1G2u1G2uOJRQ&jO1G2uO#EwQaO1G2uO#FPQ,UO'#GsOOQS1G2w1G2wO!)dQ,UO'#IgO!3sQpO1G2zOOQS1G2z1G2zOOQS,5=e,5=eO#FXQ&kO,5=gO6tQ`O,5=gO#=PQ`O,5=jO6bQ`O,5=jO!0`Q!bO,5=jO!0hQ&jO,5=jO6yQ&jO,5=jO#FjQ`O'#JnO#FuQ`O,5=kOOQS1G.j1G.jO#FzQ(ChO1G.jO#GVQ`O1G.jO#G[Q`O1G.jO6lQ(ChO1G.jO#GdQtO,5@]O#GnQ`O,5@]O#GyQdO,5=rO#HQQ`O,5=rO8YQ`O,5@]OOQS1G3[1G3[O`QdO1G3[OOQS1G3b1G3bOOQS1G3d1G3dO;_Q`O1G3fO#HVQdO1G3hO#LTQdO'#HgOOQS1G3k1G3kO#LbQ`O'#HmO;dQ`O'#HoOOQS1G3q1G3qO#LjQdO1G3qO6lQ(ChO1G3wOOQS1G3y1G3yOOQ(CW'#GS'#GSO6lQ(ChO1G3{O6lQ(ChO1G3}O$!kQ`O,5?pOMqQdO,5;TO8YQ`O,5;TO;dQ`O,5:POMqQdO,5:PO$}QdO'#JUO!0`Q!bO,5:PO$!pQ!LUO,5:POOQO,5;T,5;TO$!zQ,UO'#ISO$#bQ`O,5?oOOQ(C[1G/j1G/jO$#jQ,UO'#IYO$#tQ`O,5?{OOQ(CW1G0n1G0nO!=tQ,UO,5:PO$#|Q,UO'#E[OOQ(CW'#EZ'#EZO$$sQ(DjO'#E[O$%_Q,UO'#EPOOQO'#IV'#IVO$%pQ,UO,5:jOOQ(C[,5:j,5:jO$&mQ,UO'#EPO$&zQ,UO'#EPO$'[Q,UO'#EbO$'_Q,UO'#E[O$'xQ,UO'#E[O$%_Q,UO'#E[O$(iQ`O1G0RO$(nQqO1G0ROOQ(C[1G0R1G0RO$}QdO1G0ROJRQ&jO1G0ROOQ(C[1G0i1G0iO;dQ`O1G0iO!0`Q!bO1G0iO!0hQ&jO1G0iOOOW1G/a1G/aO$(uQpO,5<_O$(}QtO1G4XOOQO1G4_1G4_O$}QdO,5>mO$)XQ`O1G5YO$)aQ`O1G5eO$)iQtO1G5fO8YQ`O,5>sO$)sQ`O1G5bO$)sQ`O1G5bO8YQ`O1G5bO$){Q(C|O1G5cO$}QdO1G5cO$*]Q(ChO1G5cO$*nQ`O,5>uO8YQ`O,5>uOOQO,5>u,5>uO$+SQ`O,5>uOOQO-E<X-E<XOOQO1G0Y1G0YOOQO1G0[1G0[O! tQ`O1G0[OOQS7+(X7+(XOJRQ&jO7+(XO$}QdO7+(XOJRQ&jO7+(XO$+bQaO7+(XO$+pQ&kO7+(XO$,RQ(C}O,59mO$.ZQ(C}O,5<`O$0fQ(C}O,5<bO$2qQ(C}O,5<pOOQ(C[7+&U7+&UO$5SQ(C|O7+&UO$5vQ&jO'#ITO$6QQ`O,5?qOOQ(C]1G/t1G/tO$6YQdO'#IUO$6gQ`O,5?rO$6oQtO,5?rOOQ(C[1G/y1G/yO$6yQ`O7+&_OOQ(C[7+&_7+&_O$7OQ!LUO,5:`O$}QdO7+&qO$7YQ!LUO,5:WOOQ(C[7+&w7+&wOOQO1G1i1G1iOOQO1G1j1G1jO$7gQ$ISO,5<QOMqQdO,5<POOQO-E<Y-E<YOOQ(C[7+'P7+'POOOO7+'[7+'[OOOO1G1s1G1sO$7rQ`O1G1sOOQ(C[1G1u1G1uO$7wQqO,59hOOOW-E;}-E;}OOQ(C]1G/Q1G/QO$8OQ(C|O7+'bOOQ(C],5>z,5>zO$8rQ`O,5>zOOQ(C]1G2Z1G2ZP$8wQ`O'#I`POQ(C]-E<^-E<^O$9hQ&kO1G2gO$:ZQ&kO1G2iO$:eQqO1G2kOOQ(C]1G2S1G2SO$:lQ`O'#I_O$:zQ`O,5@SO$:zQ`O,5@SO$;SQ`O,5@SO$;_Q`O,5@SOOQO1G2U1G2UO$;mQ&kO1G2TOKhQ&jO1G2TO$;}QMhO'#IaO$<_Q`O,5@TOJRQ&jO,5@TO$<gQqO,5@TOOQ(C]1G2X1G2XOOQ(CW,5<r,5<rOOQ(CW,5<s,5<sO$<qQ`O,5<sO#<uQ`O,5<sO!0`Q!bO,5<rOOQO'#GZ'#GZO$<vQ`O,5<tOOQ(CW,5<v,5<vO$<qQ`O,5<yOOQO,5>|,5>|OOQO-E<`-E<`OOQ(C]1G2]1G2]O!)dQ,UO,5<rO$=OQ`O,5<sO#<zQ`O,5<tO!)dQ,UO,5<sO$=ZQ&kO1G5SO$=eQ&kO1G5SOOQO,5>},5>}OOQO-E<a-E<aOOQP1G.x1G.xO!1cQ,UO,59oO$}QdO,59oO$=rQ`O1G2OOKhQ&jO1G2VO$=wQ(C|O7+'cOOQ(C[7+'c7+'cOHRQdO7+'cOOQ(C[7+%^7+%^O$>kQqO'#JjO$(iQ`O7+(XO$>uQ`O7+(XO$>}QqO7+(XO$?XQ(CyO'#ChO$?lQ(CyO,5<wO$@^Q`O,5<wOOQ(CW1G5P1G5POOQS7+$_7+$_O;dQ`O7+$_O!0`Q!bO7+$_OHRQdO7+&UO$@cQ`O'#IjO$@tQ`O,5@[OOQO1G3Z1G3ZO6tQ`O,5@[O$@tQ`O,5@[O$@|Q`O,5@[OOQO,5?V,5?VOOQO-E<i-E<iOOQ(C[7+&y7+&yO$ARQ`O7+(tO6lQ(ChO7+(tO6tQ`O7+(tO$AWQ`O7+(tO$A]Q`O,5;TOOQ(CW,5?P,5?POOQ(CW-E<c-E<cOOQS7+(c7+(cO$AbQ(CyO7+(`OJRQ&jO7+(`O$AlQqO7+(aOOQS7+(a7+(aOJRQ&jO7+(aO$AsQ`O'#JmO$BOQ`O,5=_OOQO,5?R,5?ROOQO-E<e-E<eOOQS7+(f7+(fO$CUQ,UO'#G|OOQS1G3R1G3ROJRQ&jO1G3RO$}QdO1G3ROJRQ&jO1G3RO$C]QaO1G3RO$CkQ&kO1G3RO6lQ(ChO1G3UO#=PQ`O1G3UO6bQ`O1G3UO!0`Q!bO1G3UO!0hQ&jO1G3UO$C|Q`O'#IiO$DXQ`O,5@YO$DaQ,UO,5@YOOQ(CW1G3V1G3VOOQS7+$U7+$UO$DiQ`O7+$UO6lQ(ChO7+$UO$DnQ`O7+$UO$}QdO1G5wO$}QdO1G5xO$DsQdO1G3^O$DzQ`O1G3^O$EPQdO1G3^O$EWQ(ChO1G5wOOQS7+(v7+(vO6lQ(ChO7+)QO`QdO7+)SOOQS'#Js'#JsOOQS'#Il'#IlO$EbQdO,5>ROOQS,5>R,5>RO$}QdO'#HhO$EoQ`O'#HjOOQS,5>X,5>XO8YQ`O,5>XOOQS,5>Z,5>ZOOQS7+)]7+)]OOQS7+)c7+)cOOQS7+)g7+)gOOQS7+)i7+)iO$EtQ!bO1G5[O$FYQ!LUO1G0oO$FdQ`O1G0oOOQO1G/k1G/kO$FoQ!LUO1G/kO$FyQ`O,5?pO;dQ`O1G/kOMqQdO'#DeOOQO,5>n,5>nOOQO-E<Q-E<QOOQO,5>t,5>tOOQO-E<W-E<WO!0`Q!bO1G/kO$GOQ7[O,5:lO$HOQ(DjO,5:vO$%_Q,UO,5:kO$HjQ,UO,5:kO$HwQ,UO,5:kO$IXQ,UO,5:vO$IrQ,UO,5:vO$%_Q,UO,5:vO;dQ`O,5:kOOQO,5:v,5:vO$}QdO,5:vO$JcQ(ChO,5:vO$JnQ(ChO,5:vO!0`Q!bO,5:kOOQO-E<T-E<TOOQ(C[1G0U1G0UOOQO,5:|,5:|O$J|Q(ChO,5:vOOQ(C[7+%m7+%mO$(iQ`O7+%mO$(nQqO7+%mOOQ(C[7+&T7+&TO;dQ`O7+&TO!0`Q!bO7+&TO$KbQ`O7+*|O$KbQ`O7+*|O$KjQ(C|O7+*}O$}QdO7+*}OOQO1G4a1G4aO8YQ`O1G4aO$KzQ`O1G4aOOQO7+%v7+%vO$(iQ`O<<KsO$LYQ`O<<KsO$LbQqO<<KsOOQS<<Ks<<KsOJRQ&jO<<KsO$}QdO<<KsOJRQ&jO<<KsO$LlQaO<<KsO$LzQ(C}O1G2gO% VQ(C}O1G2iO%#bQ(C}O1G2TO%%sQ&kO,5>oOOQO-E<R-E<RO%%}QtO,5>pO$}QdO,5>pOOQO-E<S-E<SO%&XQ`O1G5^OOQ(C[<<Iy<<IyO%&aQ!LUO1G0jO%(kQ!LUO1G0tO%(rQ!LUO1G0tO%*vQ!LUO1G0tO%*}Q!LUO1G0tO%,rQ!LUO1G0tO%-YQ!LUO1G0tO%/mQ!LUO1G0tO%/tQ!LUO1G0tO%1xQ!LUO1G0tO%2PQ!LUO1G0tO%3wQ!LUO1G0tO%4[Q(C|O<<J]O%5aQ!LVO1G0tO%7VQ!LVO'#I}O%7aQ!LUO1G1YOMqQdO'#FhOOQO'#Jf'#JfOOQO1G1l1G1lO%7nQ`O1G1kO%7sQ!LUO,5>xOOOO7+'_7+'_OOOW1G/S1G/SOOQ(C]1G4f1G4fOKhQ&jO7+(VO%7}Q`O,5>yO6tQ`O,5>yOOQO-E<]-E<]O%8]Q`O1G5nO%8]Q`O1G5nO%8eQ`O1G5nO%8pQ&kO7+'oO%9QQqO,5>{O%9[Q`O,5>{OJRQ&jO,5>{OOQO-E<_-E<_O%9aQqO1G5oO%9kQ`O1G5oOOQ(CW1G2_1G2_O$<qQ`O1G2_OOQ(CW1G2^1G2^O%9sQ`O1G2`OJRQ&jO1G2`OOQ(CW1G2e1G2eO!0`Q!bO1G2^O#<uQ`O1G2_O%9xQ`O1G2`O%:QQ`O1G2_OKhQ&jO7+*nOOQ(C]1G/Z1G/ZO%:]Q`O1G/ZOOQ(C]7+'j7+'jO%:bQ&kO7+'qO%:rQ(C|O<<J}OOQ(C[<<J}<<J}OJRQ&jO'#IdO%;fQ`O,5@UOJRQ&jO1G2cOOQS<<Gy<<GyO;dQ`O<<GyO%;nQ(C|O<<IpOOQ(C[<<Ip<<IpOOQO,5?U,5?UO%<bQ`O,5?UO%<gQ`O,5?UOOQO-E<h-E<hO%<oQ`O1G5vO%<oQ`O1G5vO6tQ`O1G5vO%<wQ`O<<L`OOQS<<L`<<L`O%<|Q`O<<L`O6lQ(ChO<<L`O%=RQ`O1G0oOOQS<<Kz<<KzO$AbQ(CyO<<KzOOQS<<K{<<K{O$AlQqO<<K{O%=WQ,UO'#IfO%=cQ`O,5@XOMqQdO,5@XOOQS1G2y1G2yO%=kQ(DjO'#JUO%>VQdO'#JUO%>^Q,UO'#E[O%>tQ(ChO'#E[O$$sQ(DjO'#E[O$%hQ,UO'#G}OOQO'#Ih'#IhO%?YQ,UO,5=hOOQS,5=h,5=hO%?aQ,UO'#E[O%?rQ,UO'#E[O%@YQ,UO'#E[O%@vQ,UO'#G}O%AXQ`O7+(mO%A^Q`O7+(mO%AfQqO7+(mOOQS7+(m7+(mOJRQ&jO7+(mO$}QdO7+(mOJRQ&jO7+(mO%ApQaO7+(mOOQS7+(p7+(pO6lQ(ChO7+(pO#=PQ`O7+(pO6bQ`O7+(pO!0`Q!bO7+(pO%BOQ`O,5?TOOQO-E<g-E<gOOQO'#HQ'#HQO%BZQ`O1G5tO6lQ(ChO<<GpOOQS<<Gp<<GpO%BcQ`O<<GpO%BhQ`O7++cO%BmQ`O7++dOOQS7+(x7+(xO%BrQ`O7+(xO%BwQdO7+(xO%COQ`O7+(xO$}QdO7++cO$}QdO7++dOOQS<<Ll<<LlOOQS<<Ln<<LnOOQS-E<j-E<jOOQS1G3m1G3mO%CTQ`O,5>SOOQS,5>U,5>UO%CYQ`O1G3sO8YQ`O7+&ZOMqQdO7+&ZOOQ(CW1G5[1G5[OOQO7+%V7+%VO%C_Q!LUO1G5fO;dQ`O7+%VO;dQ`O1G0VOOQO1G0b1G0bO$}QdO1G0bO%CiQ(ChO1G0bO%CtQ(ChO1G0bO!0`Q!bO1G0VO$%_Q,UO1G0VO%DSQ,UO1G0VO%DaQ(DjO1G0bO%D{Q,UO1G0VO$%_Q,UO1G0bO%E]Q,UO1G0bO%EvQ(ChO1G0bOOQO1G0V1G0VO%F[Q(C|O1G0bOOQ(C[<<IX<<IXOOQ(C[<<Io<<IoO;dQ`O<<IoO%FfQ`O<<NhO%FnQ(C|O<<NiOOQO7+){7+){O8YQ`O7+){OOQSANA_ANA_OJRQ&jOANA_O$(iQ`OANA_O%GOQ`OANA_O%GWQqOANA_O$}QdOANA_OJRQ&jOANA_O%GbQ(C}O7+'oO%IsQ(C}O7+'qO%LUQtO1G4[O%L`Q!LUO7+&UO%MUQ!LVO,59mO& YQ!LVO,5<`O&#aQ!LVO,5<bO&%SQ!LVO,5<pO&&xQ!LUO7+'bO&'VQ!LUO7+'cO&'dQ`O,5<SOOQO7+'V7+'VO&'iQ&kO<<KqOOQO1G4e1G4eO&'pQ`O1G4eO&'{Q`O1G4eO&(ZQ`O7++YO&(ZQ`O7++YOJRQ&jO1G4gO&(cQqO1G4gO&(mQ`O7++ZOOQ(CW7+'y7+'yO$<qQ`O7+'zO&(uQqO7+'zOOQ(CW7+'x7+'xO$<qQ`O7+'yO&(|Q`O7+'zOJRQ&jO7+'zO#<uQ`O7+'yO&)RQ&kO<<NYOOQ(C]7+$u7+$uO&)]QqO,5?OOOQO-E<b-E<bO&)gQ(CyO7+'}OOQSAN=eAN=eO6tQ`O1G4pOOQO1G4p1G4pO&)wQ`O1G4pO&)|Q`O7++bO&)|Q`O7++bO6lQ(ChOANAzO&*UQ`OANAzOOQSANAzANAzOOQSANAfANAfOOQSANAgANAgO&*ZQ`O,5?QOOQO-E<d-E<dO&*fQ!LUO1G5sO#=PQ`O,5=iO6bQ`O,5=iO&,vQtO'#ChO&-QQ,UO,5:vO&-[Q,UO,5:vO!0`Q!bO,5=iOOQO-E<f-E<fOOQS1G3S1G3SO%>VQdO,5<tO%=kQ(DjO,5=iO$HOQ(DjO,5:vO$%hQ,UO,5=iO&-lQ,UO,5=iO&-}Q,UO,5:vOOQS<<LX<<LXOJRQ&jO<<LXO%AXQ`O<<LXO&.eQ`O<<LXO&.mQqO<<LXO$}QdO<<LXOJRQ&jO<<LXOOQS<<L[<<L[O6lQ(ChO<<L[O#=PQ`O<<L[O6bQ`O<<L[O&.wQ,UO1G4oO&/PQ`O7++`OOQSAN=[AN=[O6lQ(ChOAN=[OOQS<<N}<<N}OOQS<= O<= OOOQS<<Ld<<LdO&/XQ`O<<LdO&/^QdO<<LdO&/eQ`O<<N}O&/jQ`O<= OOOQS1G3n1G3nO;dQ`O7+)_O&/oQ`O<<IuO&/zQ!LUO<<IuOOQO<<Hq<<HqOOQO7+%q7+%qO%F[Q(C|O7+%|OOQO7+%|7+%|O$}QdO7+%|O&0UQ(ChO7+%|O;dQ`O7+%qO!0`Q!bO7+%qO$%_Q,UO7+%qO&0aQ(ChO7+%|O&0oQ,UO7+%qO&0|Q(ChO7+%|O&1bQ(DjO7+%|O&1lQ,UO7+%qO$%_Q,UO7+%|OOQ(C[AN?ZAN?ZOOQO<<Mg<<MgO$(iQ`OG26yOOQSG26yG26yOJRQ&jOG26yO&1|Q`OG26yO&2UQqOG26yO&2`Q!LUO<<J]O&2mQ!LVO1G2TO&4wQ!LVO1G2gO&7OQ!LVO1G2iO&8qQ!LUO<<J}O&9OQ!LUO<<IpOOQO1G1n1G1nOKhQ&jOANA]OOQO7+*P7+*PO&9]Q`O7+*PO&9hQ`O<<NtO&9pQqO7+*ROOQ(CW<<Kf<<KfO$<qQ`O<<KfOOQ(CW<<Ke<<KeO&9zQqO<<KfO$<qQ`O<<KeOOQO7+*[7+*[O6tQ`O7+*[O&:RQ`O<<N|OOQSG27fG27fO6lQ(ChOG27fOMqQdO1G4lO&:ZQ`O7++_O6lQ(ChO1G3TO#=PQ`O1G3TO&:cQ,UO1G0bO6bQ`O1G3TO!0`Q!bO1G3TO$%hQ,UO1G3TO%=kQ(DjO1G3TO%DaQ(DjO1G0bO&:mQ,UO1G3TO%AXQ`OANAsOOQSANAsANAsOJRQ&jOANAsO&;OQ`OANAsO&;WQqOANAsOOQSANAvANAvO6lQ(ChOANAvO#=PQ`OANAvOOQO'#HR'#HROOQO7+*Z7+*ZOOQSG22vG22vOOQSANBOANBOO&;bQ`OANBOOOQSANDiANDiOOQSANDjANDjOOQS<<Ly<<LyOMqQdOAN?aOOQO<<Ih<<IhO%F[Q(C|O<<IhO$}QdO<<IhOOQO<<I]<<I]O;dQ`O<<I]O!0`Q!bO<<I]O&;gQ(ChO<<IhO$%_Q,UO<<I]O&;rQ(ChO<<IhO&<QQ,UO<<I]O&<_Q(ChO<<IhOOQSLD,eLD,eO$(iQ`OLD,eOJRQ&jOLD,eO&<sQ!LVO7+'oO&>iQ!LVO7+'qO&@_Q&kOG26wOOQO<<Mk<<MkOOQ(CWANAQANAQO$<qQ`OANAQOOQ(CWANAPANAPOOQO<<Mv<<MvOOQSLD-QLD-QO&@oQ!LUO7+*WOOQO7+(o7+(oO6lQ(ChO7+(oO#=PQ`O7+(oO6bQ`O7+(oO!0`Q!bO7+(oO$%hQ,UO7+(oOOQSG27_G27_O%AXQ`OG27_OJRQ&jOG27_OOQSG27bG27bO6lQ(ChOG27bOOQSG27jG27jO&@yQ!LUOG24{OOQOAN?SAN?SO%F[Q(C|OAN?SOOQOAN>wAN>wO;dQ`OAN>wO$}QdOAN?SO!0`Q!bOAN>wO&ATQ(ChOAN?SO$%_Q,UOAN>wO&A`Q(ChOAN?SOOQS!$(!P!$(!PO$(iQ`O!$(!PO&AnQ(C}OG26wOOQ(CWG26lG26lOOQO<<LZ<<LZO6lQ(ChO<<LZO#=PQ`O<<LZO6bQ`O<<LZO!0`Q!bO<<LZOOQSLD,yLD,yO%AXQ`OLD,yOOQSLD,|LD,|OOQOG24nG24nOOQOG24cG24cO%F[Q(C|OG24nO;dQ`OG24cO$}QdOG24nO!0`Q!bOG24cO&DPQ(ChOG24nOOQS!)9Ek!)9EkO&DmQ7]O,5:zOOQOANAuANAuO6lQ(ChOANAuO#=PQ`OANAuO6bQ`OANAuOOQS!$(!e!$(!eOOQOLD*YLD*YOOQOLD)}LD)}O%F[Q(C|OLD*YO;dQ`OLD)}O$}QdOLD*YO&EpQ!LVOG26wO&GfQ7]O,59mO&HfQ7]O,5<`O&IfQ7]O,5<bO&JfQ7]O,5<pOOQOG27aG27aO6lQ(ChOG27aO#=PQ`OG27aOOQO!$'Mt!$'MtOOQO!$'Mi!$'MiO%F[Q(C|O!$'MtO&KiQ7]O1G2gO&LiQ7]O1G2iO&MiQ7]O1G2TOOQOLD,{LD,{O6lQ(ChOLD,{OOQO!)9C`!)9C`O&NlQ7]O7+'oO' oQ7]O7+'qOOQO!$(!g!$(!gO'!rQ7]OG26wOMqQdO'#DtO.fQ`O'#EQO'#uQtO'#JQOMqQdO'#DlO'#|QtO'#ChO'&dQtO'#ChO'&tQdO,5;OO'(tQ&jO'#E`OMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO'#I^O'*UQ`O,5<_O'*^Q&jO,5;YO'+nQ&jO,5;YOMqQdO,5;nO.iQ`O'#DRO.iQ`O'#DRO.iQ`O'#DROJRQ&jO'#FtO'(tQ&jO'#FtO'*^Q&jO'#FtOJRQ&jO'#FvO'(tQ&jO'#FvO'*^Q&jO'#FvOJRQ&jO'#GUO'(tQ&jO'#GUO'*^Q&jO'#GUOMqQdO,5?zO'&tQdO1G0jO'+uQ!LUO'#ChOMqQdO1G1vOJRQ&jO,5<{O'(tQ&jO,5<{O'*^Q&jO,5<{OJRQ&jO,5<}O'(tQ&jO,5<}O'*^Q&jO,5<}OJRQ&jO,5<iO'(tQ&jO,5<iO'*^Q&jO,5<iO'&tQdO1G1wOMqQdO7+&qOJRQ&jO1G2TO'(tQ&jO1G2TO'*^Q&jO1G2TOJRQ&jO1G2VO'(tQ&jO1G2VO'*^Q&jO1G2VO'&tQdO7+'cO'&tQdO7+&UO',PQ`O7+'zOJRQ&jOANA]O'(tQ&jOANA]O'*^Q&jOANA]O',PQ`O<<KfO',PQ`OANAQO',UQ`O'#EdO',ZQ`O'#EdO',cQ`O'#FSO',hQ`O'#EnO',mQ`O'#J`O',xQ`O'#J^O'-TQ`O,5;OO'-YQ&kO,5<[O'-aQ`O'#F}O'-fQ`O'#F}O'-kQ`O'#F}O'-pQ`O,5<]O'-xQ`O,5;OO'.QQ!LUO1G1VO'.XQ`O,5<iO'.^Q`O,5<iO'.cQ`O,5<iO'.hQ`O,5<kO'.mQ`O,5<kO'.rQ`O,5<kO'.wQ`O1G1wO'.|Q`O1G0jO'/RQ`O1G2`O'/WQ&kO<<KqO'/_Q&kO<<KqO'/fQ&kO<<KqO'/mQqO7+'zO'/tQ`O7+'zO'/yQqO<<KfO4}Q&jO'#FrO6bQ`O'#FqO={Q`O'#EcOMqQdO,5;kO!(eQ`O'#F}O!(eQ`O'#F}O!(eQ`O'#F}O!(eQ`O'#GPO!(eQ`O'#GPO!(eQ`O'#GPO'0QQ`O,5<tOKhQ&jO7+(VOKhQ&jO7+(VOKhQ&jO7+(VOJRQ&jO1G2`O'0YQ`O1G2`OJRQ&jO7+'zO$:eQqO1G2kO$:eQqO1G2kO$:eQqO1G2kOJRQ&jO,5=POJRQ&jO,5=POJRQ&jO,5=P",stateData:"'1c~O'gOS'hOSTOSUOS~OQUORUOX}O]gO_lObrOcqOigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!VTO!aoO!fVO!iUO!jUO!kUO!lUO!mUO!ppO!uXO#lwO#|tO$QbO%[uO%^xO%`vO%avO%dyO%fzO%i{O%j{O%l|O%y!OO&P!PO&R!QO&T!RO&V!SO&Y!TO&`!UO&f!VO&h!WO&j!XO&l!YO&n!ZO'jQO'rRO'|WO(ZeO~OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!V!]O!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'j![O'rRO'|WO(ZeO~OQ[XZ[X_[Xk[Xx[Xy[X{[X!T[X!c[X!d[X!f[X!l[X#T[X#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'e[X'r[X'}[X(U[X(V[X~O!_$vX~P&}OS!cO'c!dO'd!fO~OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!V!]O!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'j;ZO'rRO'|WO(ZeO~O!S!jO!T!gO!Q'vP!Q(RP~P)jO!U!rO~P`OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!V!]O!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'rRO'|WO(ZeO~O!S!xO!uXO#^!{O#_!xO'j;[O!e(OP~P,RO!f!}O'j!|O~O!p#RO!uXO%[#SO~O#`#TO~O!_#UO#`#TO~OQ#lOZ#sOk#aOx#YOy#ZO{#[O!T#pO!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO#r#iO'rRO'}#jO(U#]O(V#^O~O_'tX'e'tX'a'tX!e'tX!Q'tX!V'tX%]'tX!_'tX~P/WO#T#tO#w#tOQ'uXZ'uX_'uXk'uXx'uXy'uX{'uX!T'uX!c'uX!d'uX!f'uX!l'uX#c'uX#d'uX#e'uX#f'uX#g'uX#h'uX#i'uX#j'uX#m'uX#o'uX#q'uX#r'uX'r'uX'}'uX(U'uX(V'uX~O#k'uX'e'uX'a'uX!Q'uX!e'uXo'uX!V'uX%]'uX!_'uX~P1nO#T#tO~O$S#vO$U#uO$]#{O~O!V#|O$QbO$`#}O$b$PO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv$fO{$[O!V$]O!a$kO!f$XO#_$lO#|$iO$i$gO$k$hO$n$jO'j$RO'n$bO'r$UOe'oP~O!f$mO~O!_$oO~O_$pO'e$pO~O'j$tO~O!f$mO'j$tO'k$vO'n$bO~Oc$|O!f$mO'j$tO~O#k#cO~O]%VOx%RO!V%OO!f%QO%^%UO'j$tO'k$vO^(cP~O!p#RO~O{%WO!V%XO'j$tO~O{%WO!V%XO%f%]O'j$tO~O'j%^O~O#lwO%^xO%`vO%avO%dyO%fzO%i{O%j{O~Ob%gOc%fO!p%dO%[%eO%n%cO~P8xOb%jOcqO!V%iO!ppO!uXO#lwO%[uO%`vO%avO%dyO%fzO%i{O%j{O%l|O~O`%mO#T%pO%^%kO'k$vO~P9wO!f%qO!i%uO~O!f!}O~O!VTO~O_$pO'b%}O'e$pO~O_$pO'b&QO'e$pO~O_$pO'b&SO'e$pO~O'a[Xo[X!Q[X!e[X%}[X!V[X%][X!_[X~P&}O]&XOl&XO{&WO!S&[O!Y&bO!Z&ZO![&ZO'k$vO's&UO!U'wP!U(TP~OP&fO!V&cO!q&eO'j$tO~Oc&kO!f$mO'j$tO~Ox%RO!f%QO~OS!cO'c!dO'd&nO~O!S&pO!Q&uX!Q&{X!T&uX!T&{X~P)jO!T&rO!Q'vX~OQ#lOZ#sOk#aOx#YOy#ZO{#[O!T&rO!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO#r#iO'rRO'}#jO(U#]O(V#^O~O!Q'vX~P?WO!Q&wO~O!Q(QX!T(QX!_(QX!e(QX'}(QX~O#T(QX#`#XX!U(QX~PA^O#T&xO!Q(SX!T(SX~O!T&yO!Q(RX~O!Q&|O~O#T#tO~PA^O!U&}O~P`Ox#YOy#ZO{#[O!d#WO!f#XO'rROQ!haZ!hak!ha!T!ha!c!ha!l!ha#c!ha#d!ha#e!ha#f!ha#g!ha#h!ha#i!ha#j!ha#k!ha#m!ha#o!ha#q!ha#r!ha'}!ha(U!ha(V!ha~O_!ha'e!ha'a!ha!Q!ha!e!hao!ha!V!ha%]!ha!_!ha~PBtO!e'OO~O{%WO!V%XO!uXO#^'RO#_'QO'j$tO~O!_#UO#T'TO'}'SO!T(PX_(PX'e(PX~O!e(PX~PExO!T'WO!e(OX~O!e'YO~O{%WO!V%XO#_'QO'j$tO~Ox'ZOy'[O!d#WO!f#XO!u!ta{!ta~O!p!ta%[!ta!V!ta#^!ta#_!ta'j!ta~PGQO!p'`O~OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!VTO!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'j![O'rRO'|WO(ZeO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;oO{$[O!V$]O!a=`O!f$XO#_;xO#|$iO$i;rO$k;uO$n$jO'j'dO'n$bO'r$UO~O#`'fO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv$fO{$[O!V$]O!a$kO!f$XO#_$lO#|$iO$i$gO$k$hO$n$jO'j'dO'n$bO'r$UO~Oe'yP~PKhO!S'jO!e'zP~P$}O's'lO'|WO~O{'nO!f#XO's'lO'|WO~OQ;VOR;VO]gOb=ZOc!`OigOk;VOlgOmgOrgOt;VOv;VO{SO!OgO!PgO!V!]O!a;YO!fVO!i;VO!j;VO!k;VO!l;VO!m;VO!p!_O#|!bO$QbO'j'|O'rRO'|WO(Z=XO~Oy(PO!f#XO~O!T#pO_$ga'e$ga'a$ga!e$ga!Q$ga!V$ga%]$ga!_$ga~O#l(TO~PJROx(WO!_(VO!V$TX$P$TX$S$TX$U$TX$]$TX~O!_(VO!V(WX$P(WX$S(WX$U(WX$](WX~Ox(WO~P!#WOx(WO!V(WX$P(WX$S(WX$U(WX$](WX~O!V(YO$P(^O$S(XO$U(XO$](_O~O!S(bO~PMqO$S#vO$U#uO$](eO~OP$oXx$oX{$oX!d$oX(U$oX(V$oX~OPgXegXe$oX!TgX#TgX~P!$|Ol(gO~OS(hO'c(iO'd(kO~OP(tOx(mO{(nO(U(pO(V(rO~Oe(lO~P!&VOe(uO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;oO{$[O!V$]O!a=`O!f$XO#_;xO#|$iO$i;rO$k;uO$n$jO'n$bO'r$UO~O!S(yO'j(vO!e([P~P!&tO#`({O~O!f(|O~O!S)RO'j)OO!Q(]P~P!&tOk)`O{)WO!Y)^O!Z)VO![)VO!f(|O#P)_O%S)YO'k$vO's)TO~O!U)]O~P!(wO!d#WOP'qXx'qX{'qX(U'qX(V'qX!T'qX#u'qX!U'qX~Oe'qX#T'qX]'qXl'qX!Y'qX!Z'qX!['qX!u'qX!y'qX!z'qX!{'qX#P'qX#Q'qX'k'qX's'qX'|'qX~P!)pOP)cO#T)bOe'pX!T'pX~O!T)dOe'oX~O'j%^Oe'oP~O!f)kO~O'j'dO~O{%WO!S!xO!V%XO!uXO#^!{O#_!xO'j$tO!e(OP~O!_#UO#`)oO~OQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO#r#iO'rRO'}#jO(U#]O(V#^O~O_!`a!T!`a'e!`a'a!`a!Q!`a!e!`ao!`a!V!`a%]!`a!_!`a~P!-ROP)wO!V&cO!q)vO%])uO'n$bO~O!_)yO!V'mX_'mX!T'mX'e'mX~O!f$mO'n$bO~O!f$mO'j$tO'n$bO~O!_#UO#`'fO~O]*UO%^*VO'j*RO!U(dP~O!T*WO^(cX~O's'lO~OZ*[O~O^*]O~O!V%OO'j$tO'k$vO^(cP~O{%WO!S*aO!T&yO!V%XO'j$tO!Q(RP~O]&_Ol&_O{*cO!S*bO's'lO~O!U(TP~P!2fO!T*dO_(`X'e(`X~O#T*hO'n$bO~OP*kO!V$]O'n$bO~O!V*mO~Ox*oO!VTO~O!p*tO~Oc*yO~O'j!|O!U(bP~Oc$|O~O%^xO'j%^O~P9wOZ+PO^+OO~OQUORUO]gObrOcqOigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!aoO!fVO!iUO!jUO!kUO!lUO!mUO!ppO!uXO$QbO%[uO'rRO'|WO(ZeO~O!V!]O#|!bO'j![O~P!4vO^+OO_$pO'e$pO~O_+TO#l+VO%`+VO%a+VO~P$}O!f%qO~O&P+[O~O!V+^O~O&b+`O&d+aOQ&_aR&_aX&_a]&_a_&_ab&_ac&_ai&_ak&_al&_am&_ar&_at&_av&_a{&_a!O&_a!P&_a!V&_a!a&_a!f&_a!i&_a!j&_a!k&_a!l&_a!m&_a!p&_a!u&_a#l&_a#|&_a$Q&_a%[&_a%^&_a%`&_a%a&_a%d&_a%f&_a%i&_a%j&_a%l&_a%y&_a&P&_a&R&_a&T&_a&V&_a&Y&_a&`&_a&f&_a&h&_a&j&_a&l&_a&n&_a'a&_a'j&_a'r&_a'|&_a(Z&_a!U&_a&W&_a`&_a&]&_a~O'j+fO~O!TzX!T!]X!UzX!U!]X!_zX!_!]X!f!]X#TzX'n!]X~O!_+kO#T+jO!T#]X!T'xX!U#]X!U'xX!_'xX!f'xX'n'xX~O!_+mO!f$mO'n$bO!T!XX!U!XX~O]&VOl&VO{+nO's)TO~OQ;VOR;VO]gOb=ZOc!`OigOk;VOlgOmgOrgOt;VOv;VO{SO!OgO!PgO!V!]O!a;YO!fVO!i;VO!j;VO!k;VO!l;VO!m;VO!p!_O#|!bO$QbO'rRO'|WO(Z=XO~O'j;}O~P!>SO!T+rO!U'wX~O!U+tO~O!_+kO#T+jO!T#]X!U#]X~O!T+uO!U(TX~O!U+wO~O]&VOl&VO{+nO'k$vO's)TO~O!Z+xO![+xO~P!AQO_+}O!U,PO!Y,QO!Z+|O![+|O!u;WO!y,UO!z,SO!{,TO!|,RO#P,VO#Q,VO'|+zO~P!AQOP,[O!V&cO!q,ZO~Oo,aO~O!Q&ua!T&ua~P!-RO!S,eO!Q&uX!T&uX~P$}O!T&rO!Q'va~O!Q'va~P?WO!T&yO!Q(Ra~O{%WO!S,iO!V%XO'j$tO!Q&{X!T&{X~O!T'WO!e(Oa~O{%WO!V%XO#_,lO'j$tO~O#T,nO!T(Pa!e(Pa_(Pa'e(Pa~O!_#UO~P!DvO{%WO!S,qO!V%XO!uXO#^,sO#_,qO'j$tO!T&}X!e&}X~Oy,wO!f#XO~OP,{O!V&cO!q,zO%],yO'n$bO~O_#Wi!T#Wi'e#Wi'a#Wi!Q#Wi!e#Wio#Wi!V#Wi%]#Wi!_#Wi~P!-ROP=mOx(mO{(nO(U(pO(V(rO~O#`#Sa!T#Sa!e#Sa#T#Sa!V#Sa_#Sa'e#Sa!Q#Sa~P!G[O!d#WOP'qXx'qX{'qX(U'qX(V'qXQ'qXZ'qXk'qXy'qX!T'qX!c'qX!f'qX!l'qX#c'qX#d'qX#e'qX#f'qX#g'qX#h'qX#i'qX#j'qX#k'qX#m'qX#o'qX#q'qX#r'qX'r'qX'}'qX~O#`'qX_'qX'e'qX!e'qX!Q'qX'a'qX!V'qX#T'qXo'qX%]'qX!_'qX~P!HZO!T-UOe'yX~P!&VOe-WO~O!T-XO!e'zX~P!-RO!e-[O~O!Q-^O~OQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO'rROZ#bi_#bik#bi!T#bi!c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi'e#bi'}#bi(U#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~O#c#bi~P!KrO#c#_O~P!KrOQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O'rROZ#bi_#bi!T#bi!c#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi'e#bi'}#bi(U#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~Ok#bi~P!NdOk#aO~P!NdOQ#lOk#aOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO'rRO_#bi!T#bi#m#bi#o#bi#q#bi#r#bi'e#bi'}#bi(U#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~OZ#bi!c#bi#h#bi#i#bi#j#bi#k#bi~P##UOZ#sO!c#cO#h#cO#i#cO#j#rO#k#cO~P##UOQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO'rRO_#bi!T#bi#o#bi#q#bi#r#bi'e#bi'}#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~O(U#bi~P#&VO(U#]O~P#&VOQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO'rRO(U#]O_#bi!T#bi#q#bi#r#bi'e#bi'}#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~O(V#bi~P#(wO(V#^O~P#(wOQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO'rRO(U#]O(V#^O~O_#bi!T#bi#r#bi'e#bi'}#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~P#+iOQ[XZ[Xk[Xx[Xy[X{[X!c[X!d[X!f[X!l[X#T[X#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'r[X'}[X(U[X(V[X!T[X!U[X~O#u[X~P#.SOQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO#o;fO#q;hO#r;iO'rRO'}#jO(U#]O(V#^O~O#u-`O~P#0aOQ'uXZ'uXk'uXx'uXy'uX{'uX!c'uX!d'uX!f'uX!l'uX#c'uX#d'uX#e'uX#f'uX#g'uX#h'uX#i'uX#j'uX#m'uX#o'uX#q'uX#r'uX'r'uX'}'uX(U'uX(V'uX!T'uX~O#T;nO#w;nO#k'uX#u'uX!U'uX~P#2_O_'Qa!T'Qa'e'Qa'a'Qa!e'Qao'Qa!Q'Qa!V'Qa%]'Qa!_'Qa~P!-ROQ#biZ#bi_#bik#biy#bi!T#bi!c#bi!d#bi!f#bi!l#bi#c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi'e#bi'r#bi'}#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~P!G[O_#vi!T#vi'e#vi'a#vi!Q#vi!e#vio#vi!V#vi%]#vi!_#vi~P!-RO$S-cO$U-cO~O$S-dO$U-dO~O!_(VO#T-eO!V$YX$P$YX$S$YX$U$YX$]$YX~O!S-fO~O!V(YO$P-hO$S(XO$U(XO$]-iO~O!T;jO!U'tX~P#0aO!U-jO~O$]-lO~OS(hO'c(iO'd-oO~O]-rOl-rO!Q-sO~O!TdX!_dX!edX!e$oX'}dX~P!$|O!e-yO~P!G[O!T-zO!_#UO'}'SO!e([X~O!e.PO~O!S(yO'j$tO!e([P~O#`.RO~O!Q$oX!T$oX!_$vX~P!$|O!T.SO!Q(]X~P!G[O!_.UO~O!Q.WO~Ok.[O!_#UO!f$mO'n$bO'}'SO~O'j.^O~O!_)yO~O_$pO!T.bO'e$pO~O!U.dO~P!(wO!Z.eO![.eO'k$vO's)TO~O{.gO's)TO~O#P.hO~O'j%^Oe'VX!T'VX~O!T)dOe'oa~Oe.mO~Ox.nOy.nO{.oOPua(Uua(Vua!Tua#Tua~Oeua#uua~P#>mOx(mO{(nOP$ha(U$ha(V$ha!T$ha#T$ha~Oe$ha#u$ha~P#?cOx(mO{(nOP$ja(U$ja(V$ja!T$ja#T$ja~Oe$ja#u$ja~P#@UO].pO~O#`.qO~Oe$xa!T$xa#T$xa#u$xa~P!&VO#`.tO~OP,{O!V&cO!q,zO%],yO~O]$SOk$TOl$SOm$SOr$dOt$eOv;oO{$[O!V$]O!a=`O!f$XO#_;xO#|$iO$i;rO$k;uO$n$jO'n$bO'r$UO~Oi.{O'j.zO~P#AvO!_)yO!V'ma_'ma!T'ma'e'ma~O#`/RO~OZ[X!TdX!UdX~O!T/SO!U(dX~O!U/UO~OZ/VO~O]/XO'j*RO~O!V%OO'j$tO^'_X!T'_X~O!T*WO^(ca~O!e/[O~P!-RO]/^O~OZ/_O~O^/`O~O!T*dO_(`a'e(`a~O#T/fO~OP/iO!V$]O~O's'lO!U(aP~OP/sO!V/oO!q/rO%]/qO'n$bO~OZ/}O!T/{O!U(bX~O!U0OO~O^0QO_$pO'e$pO~O]0RO~O]0SO'j!|O~O#k0TO%}0UO~P1nO#T#tO#k0TO%}0UO~O_0VO~P$}O_0XO~O&W0]OQ&UiR&UiX&Ui]&Ui_&Uib&Uic&Uii&Uik&Uil&Uim&Uir&Uit&Uiv&Ui{&Ui!O&Ui!P&Ui!V&Ui!a&Ui!f&Ui!i&Ui!j&Ui!k&Ui!l&Ui!m&Ui!p&Ui!u&Ui#l&Ui#|&Ui$Q&Ui%[&Ui%^&Ui%`&Ui%a&Ui%d&Ui%f&Ui%i&Ui%j&Ui%l&Ui%y&Ui&P&Ui&R&Ui&T&Ui&V&Ui&Y&Ui&`&Ui&f&Ui&h&Ui&j&Ui&l&Ui&n&Ui'a&Ui'j&Ui'r&Ui'|&Ui(Z&Ui!U&Ui`&Ui&]&Ui~O`0cO!U0aO&]0bO~P`O!VTO!f0eO~O&d+aOQ&_iR&_iX&_i]&_i_&_ib&_ic&_ii&_ik&_il&_im&_ir&_it&_iv&_i{&_i!O&_i!P&_i!V&_i!a&_i!f&_i!i&_i!j&_i!k&_i!l&_i!m&_i!p&_i!u&_i#l&_i#|&_i$Q&_i%[&_i%^&_i%`&_i%a&_i%d&_i%f&_i%i&_i%j&_i%l&_i%y&_i&P&_i&R&_i&T&_i&V&_i&Y&_i&`&_i&f&_i&h&_i&j&_i&l&_i&n&_i'a&_i'j&_i'r&_i'|&_i(Z&_i!U&_i&W&_i`&_i&]&_i~O!Q0kO~O!T!Xa!U!Xa~P#0aO!S0rO!Y&bO!Z&ZO![&ZO!T&vX!U&vX~P!AQO!T+rO!U'wa~O!T&|X!U&|X~P!2fO!T+uO!U(Ta~O!Y0{O!Z0zO![0zO!u;WO!y1OO!z0}O!{0}O!|0|O#P1PO#Q1PO'|+zO~P!AQO_$pO!_#UO!f$mO!l1UO#T1SO'e$pO'n$bO'}'SO~O]&VOl&VO{+nO's)TO'|+zO~O_+}O!U1XO!Y,QO!Z+|O![+|O!u;WO!y,UO!z,SO!{,TO!|,RO#P,VO#Q,VO'|+zO~P!AQO!Z0zO![0zO'|+zO~P!AQO!Y0{O!Z0zO![0zO'|+zO~P!AQO!VTO!Y0{O!Z0zO![0zO!|0|O#P1PO#Q1PO'|+zO~P!AQO!Y0{O!Z0zO![0zO!z0}O!{0}O!|0|O#P1PO#Q1PO'|+zO~P!AQO!V&cO~O!V&cO~P!G[O!T#pOo$ga~O!Q&ui!T&ui~P!-RO!T&rO!Q'vi~O!T&yO!Q(Ri~O!Q(Si!T(Si~P!-RO!T'WO!e(Oi~O!T(Pi!e(Pi_(Pi'e(Pi~P!-RO#T1eO!T(Pi!e(Pi_(Pi'e(Pi~O{%WO!V%XO!uXO#^1hO#_1gO'j$tO~O{%WO!V%XO#_1gO'j$tO~OP1pO!V&cO!q1oO%]1nO~OP1pO!V&cO!q1oO%]1nO'n$bO~O#`uaQuaZua_uakua!cua!dua!fua!lua#cua#dua#eua#fua#gua#hua#iua#jua#kua#mua#oua#qua#rua'eua'rua'}ua!eua!Qua'aua!Vuaoua%]ua!_ua~P#>mO#`$haQ$haZ$ha_$hak$hay$ha!c$ha!d$ha!f$ha!l$ha#c$ha#d$ha#e$ha#f$ha#g$ha#h$ha#i$ha#j$ha#k$ha#m$ha#o$ha#q$ha#r$ha'e$ha'r$ha'}$ha!e$ha!Q$ha'a$ha!V$hao$ha%]$ha!_$ha~P#?cO#`$jaQ$jaZ$ja_$jak$jay$ja!c$ja!d$ja!f$ja!l$ja#c$ja#d$ja#e$ja#f$ja#g$ja#h$ja#i$ja#j$ja#k$ja#m$ja#o$ja#q$ja#r$ja'e$ja'r$ja'}$ja!e$ja!Q$ja'a$ja!V$jao$ja%]$ja!_$ja~P#@UO#`$xaQ$xaZ$xa_$xak$xay$xa!T$xa!c$xa!d$xa!f$xa!l$xa#c$xa#d$xa#e$xa#f$xa#g$xa#h$xa#i$xa#j$xa#k$xa#m$xa#o$xa#q$xa#r$xa'e$xa'r$xa'}$xa!e$xa!Q$xa'a$xa!V$xa#T$xao$xa%]$xa!_$xa~P!G[O_#Wq!T#Wq'e#Wq'a#Wq!Q#Wq!e#Wqo#Wq!V#Wq%]#Wq!_#Wq~P!-ROe&wX!T&wX~PKhO!T-UOe'ya~O!S1xO!T&xX!e&xX~P$}O!T-XO!e'za~O!T-XO!e'za~P!-RO!Q1{O~O#u!ha!U!ha~PBtO#u!`a!T!`a!U!`a~P#0aO!V2^O$QbO$Z2_O~O!U2cO~Oo2dO~P!G[O_$dq!T$dq'e$dq'a$dq!Q$dq!e$dqo$dq!V$dq%]$dq!_$dq~P!-RO!Q2eO~O]-rOl-rO~Ox(mO{(nO(V(rOP%Ti(U%Ti!T%Ti#T%Ti~Oe%Ti#u%Ti~P$9POx(mO{(nOP%Vi(U%Vi(V%Vi!T%Vi#T%Vi~Oe%Vi#u%Vi~P$9rO'}#jO~P!G[O!S2hO'j$tO!T'RX!e'RX~O!T-zO!e([a~O!T-zO!_#UO!e([a~O!T-zO!_#UO'}'SO!e([a~Oe$qi!T$qi#T$qi#u$qi~P!&VO!S2pO'j)OO!Q'TX!T'TX~P!&tO!T.SO!Q(]a~O!T.SO!Q(]a~P!G[O!_#UO~O!_#UO#k2xO~Ok2{O!_#UO'}'SO~Oe'pi!T'pi~P!&VO#T3OOe'pi!T'pi~P!&VO!e3RO~O_$eq!T$eq'e$eq'a$eq!Q$eq!e$eqo$eq!V$eq%]$eq!_$eq~P!-RO!T3VO!V(^X~P!G[O!V&cO%]1nO~O!V&cO%]1nO~P!G[O!V$oX%Q[X_$oX!T$oX'e$oX~P!$|O%Q3XOPhXxhX{hX!VhX(UhX(VhX_hX!ThX'ehX~O%Q3XO~O]3_O%^3`O'j*RO!T'^X!U'^X~O!T/SO!U(da~OZ3dO~O^3eO~O]3hO~O!Q3iO~O_$pO'e$pO~P!G[O!V$]O~P!G[O!T3nO#T3pO!U(aX~O!U3qO~O]&VOl&VO{3sO!Y4OO!Z3wO![3wO!u;WO!y3}O!z3|O!{3|O#P3{O#Q,VO'k$vO's)TO'|+zO~O!U3zO~P$BTOP4VO!V/oO!q4UO%]4TO~OP4VO!V/oO!q4UO%]4TO'n$bO~O'j!|O!T']X!U']X~O!T/{O!U(ba~O]4aO's4`O~O]4bO~O^4dO~O!e4gO~P$}O_4iO~O_4iO~P$}O#k4kO%}4lO~PExO`0cO!U4pO&]0bO~P`O!_4rO~O!_4tO!T'xi!U'xi!_'xi!f'xi'n'xi~O!T#]i!U#]i~P#0aO#T4uO!T#]i!U#]i~O!T!Xi!U!Xi~P#0aO!Q4vO~O]!tal!ta!Y!ta!Z!ta![!ta!y!ta!z!ta!{!ta!|!ta#P!ta#Q!ta'k!ta's!ta'|!ta~PGQO_$pO!_#UO!f$mO!l5OO#T4|O'e$pO'n$bO'}'SO~O!Z5QO![5QO'|+zO~P!AQO!Y5RO!Z5QO![5QO'|+zO~P!AQO!Y5RO!Z5QO![5QO!|5TO#P5UO#Q5UO'|+zO~P!AQO!Y5RO!Z5QO![5QO!z5VO!{5VO!|5TO#P5UO#Q5UO'|+zO~P!AQO_$pO#T4|O'e$pO~O_$pO!_#UO#T4|O'e$pO~O_$pO!_#UO!l5OO#T4|O'e$pO'}'SO~O!T'WO!e(Oq~O!T(Pq!e(Pq_(Pq'e(Pq~P!-RO{%WO!V%XO#_5aO'j$tO~O!V&cO%]5cO~O!V&cO%]5cO~P!G[OP5hO!V&cO!q5gO%]5cO~O#`%TiQ%TiZ%Ti_%Tik%Tiy%Ti!c%Ti!d%Ti!f%Ti!l%Ti#c%Ti#d%Ti#e%Ti#f%Ti#g%Ti#h%Ti#i%Ti#j%Ti#k%Ti#m%Ti#o%Ti#q%Ti#r%Ti'e%Ti'r%Ti'}%Ti!e%Ti!Q%Ti'a%Ti!V%Tio%Ti%]%Ti!_%Ti~P$9PO#`%ViQ%ViZ%Vi_%Vik%Viy%Vi!c%Vi!d%Vi!f%Vi!l%Vi#c%Vi#d%Vi#e%Vi#f%Vi#g%Vi#h%Vi#i%Vi#j%Vi#k%Vi#m%Vi#o%Vi#q%Vi#r%Vi'e%Vi'r%Vi'}%Vi!e%Vi!Q%Vi'a%Vi!V%Vio%Vi%]%Vi!_%Vi~P$9rO#`$qiQ$qiZ$qi_$qik$qiy$qi!T$qi!c$qi!d$qi!f$qi!l$qi#c$qi#d$qi#e$qi#f$qi#g$qi#h$qi#i$qi#j$qi#k$qi#m$qi#o$qi#q$qi#r$qi'e$qi'r$qi'}$qi!e$qi!Q$qi'a$qi!V$qi#T$qio$qi%]$qi!_$qi~P!G[Oe&wa!T&wa~P!&VO!T&xa!e&xa~P!-RO!T-XO!e'zi~O#u#Wi!T#Wi!U#Wi~P#0aOQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO'rROZ#bik#bi!c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi#u#bi'}#bi(U#bi(V#bi!T#bi!U#bi~O#c#bi~P%&nO#c;_O~P%&nOQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O'rROZ#bi!c#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi#u#bi'}#bi(U#bi(V#bi!T#bi!U#bi~Ok#bi~P%(yOk;aO~P%(yOQ#lOk;aOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO'rRO#m#bi#o#bi#q#bi#r#bi#u#bi'}#bi(U#bi(V#bi!T#bi!U#bi~OZ#bi!c#bi#h#bi#i#bi#j#bi#k#bi~P%+UOZ;mO!c;cO#h;cO#i;cO#j;lO#k;cO~P%+UOQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO'rRO#o#bi#q#bi#r#bi#u#bi'}#bi(V#bi!T#bi!U#bi~O(U#bi~P%-pO(U#]O~P%-pOQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO#o;fO'rRO(U#]O#q#bi#r#bi#u#bi'}#bi!T#bi!U#bi~O(V#bi~P%/{O(V#^O~P%/{OQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO#o;fO#q;hO'rRO(U#]O(V#^O~O#r#bi#u#bi'}#bi!T#bi!U#bi~P%2WO_#sy!T#sy'e#sy'a#sy!Q#sy!e#syo#sy!V#sy%]#sy!_#sy~P!-ROP=oOx(mO{(nO(U(pO(V(rO~OQ#biZ#bik#biy#bi!c#bi!d#bi!f#bi!l#bi#c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi#u#bi'r#bi'}#bi!T#bi!U#bi~P%5OO#u'qX!U'qX~P!HZO#u#vi!T#vi!U#vi~P#0aO!U5tO~O!T'Qa!U'Qa~P#0aO!_#UO'}'SO!T'Ra!e'Ra~O!T-zO!e([i~O!T-zO!_#UO!e([i~Oe$qq!T$qq#T$qq#u$qq~P!&VO!Q'Ta!T'Ta~P!G[O!_5{O~O!T.SO!Q(]i~P!G[O!T.SO!Q(]i~O!Q6PO~O!_#UO#k6UO~Ok6VO!_#UO'}'SO~O!Q6XO~Oe$sq!T$sq#T$sq#u$sq~P!&VO_$ey!T$ey'e$ey'a$ey!Q$ey!e$eyo$ey!V$ey%]$ey!_$ey~P!-RO!T3VO!V(^a~O_#Wy!T#Wy'e#Wy'a#Wy!Q#Wy!e#Wyo#Wy!V#Wy%]#Wy!_#Wy~P!-ROZ6^O~O]6`O'j*RO~O!T/SO!U(di~O]6cO~O^6dO~O!_4tO~O's'lO!T'YX!U'YX~O!T3nO!U(aa~O!f$mO'n$bO_'xX!_'xX!l'xX#T'xX'e'xX'}'xX~O'j6mO~P,RO!u;WO!y6oO!z6nO!{6nO#P1PO#Q1PO~P$%_O_$pO!_#UO!l1UO#T1SO'e$pO'}'SO~O!U6rO~P$BTO]&VOl&VO{6sO's)TO'|+zO~O!Y6wO!Z6vO![6vO#P1PO#Q1PO'|+zO~P!AQO!Y6wO!Z6vO![6vO!z6xO!{6xO#P1PO#Q1PO'|+zO~P!AQO!Z6vO![6vO'k$vO's)TO'|+zO~O!V/oO~O!V/oO%]6zO~O!V/oO%]6zO~P!G[OP7PO!V/oO!q7OO%]6zO~OZ7UO!T']a!U']a~O!T/{O!U(bi~O]7XO~O!e7YO~O!e7ZO~O!e7[O~O!e7[O~P$}O_7^O~O!_7aO~O!e7bO~O!T(Si!U(Si~P#0aO_$pO#T7iO'e$pO~O_$pO!_#UO#T7iO'e$pO~O!Z7mO![7mO'|+zO~P!AQO_$pO!_#UO!f$mO!l7nO#T7iO'e$pO'n$bO'}'SO~O!Y7oO!Z7mO![7mO'|+zO~P!AQO!Y7oO!Z7mO![7mO!|7rO#P7sO#Q7sO'|+zO~P!AQO_$pO!_#UO!l7nO#T7iO'e$pO'}'SO~O_$pO'e$pO~P!-RO!T'WO!e(Oy~O!T(Py!e(Py_(Py'e(Py~P!-RO!V&cO%]7xO~O!V&cO%]7xO~P!G[O#`$qqQ$qqZ$qq_$qqk$qqy$qq!T$qq!c$qq!d$qq!f$qq!l$qq#c$qq#d$qq#e$qq#f$qq#g$qq#h$qq#i$qq#j$qq#k$qq#m$qq#o$qq#q$qq#r$qq'e$qq'r$qq'}$qq!e$qq!Q$qq'a$qq!V$qq#T$qqo$qq%]$qq!_$qq~P!G[O#`$sqQ$sqZ$sq_$sqk$sqy$sq!T$sq!c$sq!d$sq!f$sq!l$sq#c$sq#d$sq#e$sq#f$sq#g$sq#h$sq#i$sq#j$sq#k$sq#m$sq#o$sq#q$sq#r$sq'e$sq'r$sq'}$sq!e$sq!Q$sq'a$sq!V$sq#T$sqo$sq%]$sq!_$sq~P!G[O!T&xi!e&xi~P!-RO#u#Wq!T#Wq!U#Wq~P#0aOx.nOy.nO{.oOPua(Uua(Vua!Uua~OQuaZuakua!cua!dua!fua!lua#cua#dua#eua#fua#gua#hua#iua#jua#kua#mua#oua#qua#rua#uua'rua'}ua!Tua~P%LmOx(mO{(nOP$ha(U$ha(V$ha!U$ha~OQ$haZ$hak$hay$ha!c$ha!d$ha!f$ha!l$ha#c$ha#d$ha#e$ha#f$ha#g$ha#h$ha#i$ha#j$ha#k$ha#m$ha#o$ha#q$ha#r$ha#u$ha'r$ha'}$ha!T$ha~P%NtOx(mO{(nOP$ja(U$ja(V$ja!U$ja~OQ$jaZ$jak$jay$ja!c$ja!d$ja!f$ja!l$ja#c$ja#d$ja#e$ja#f$ja#g$ja#h$ja#i$ja#j$ja#k$ja#m$ja#o$ja#q$ja#r$ja#u$ja'r$ja'}$ja!T$ja~P&!{OQ$xaZ$xak$xay$xa!c$xa!d$xa!f$xa!l$xa#c$xa#d$xa#e$xa#f$xa#g$xa#h$xa#i$xa#j$xa#k$xa#m$xa#o$xa#q$xa#r$xa#u$xa'r$xa'}$xa!T$xa!U$xa~P%5OO#u$dq!T$dq!U$dq~P#0aO#u$eq!T$eq!U$eq~P#0aO!U8RO~O#u8SO~P!&VO!_#UO!T'Ri!e'Ri~O!_#UO'}'SO!T'Ri!e'Ri~O!T-zO!e([q~O!Q'Ti!T'Ti~P!G[O!T.SO!Q(]q~O!Q8YO~P!G[O!Q8YO~Oe'py!T'py~P!&VO!T'Wa!V'Wa~P!G[O!V%Pq_%Pq!T%Pq'e%Pq~P!G[OZ8_O~O!T/SO!U(dq~O]8bO~O#T8cO!T'Ya!U'Ya~O!T3nO!U(ai~P#0aOQ[XZ[Xk[Xx[Xy[X{[X!Q[X!T[X!c[X!d[X!f[X!l[X#T[X#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'r[X'}[X(U[X(V[X~O!_$}X#k$}X~P&*pO#P5UO#Q5UO~P$%_O!z8gO!{8gO#P5UO#Q5UO~P$%_O!Z8jO![8jO'k$vO's)TO'|+zO~O!Y8mO!Z8jO![8jO#P5UO#Q5UO'|+zO~P!AQO!V/oO%]8pO~O!V/oO%]8pO~P!G[O]8wO's8vO~O!T/{O!U(bq~O!e8yO~O!e8yO~P$}O!e8{O~O!e8|O~O#T9OO!T#]y!U#]y~O!T#]y!U#]y~P#0aO_$pO#T9RO'e$pO~O_$pO!_#UO#T9RO'e$pO~O!Z9WO![9WO'|+zO~P!AQO_$pO!_#UO!l9XO#T9RO'e$pO'}'SO~O!f$mO'n$bO~P&0|O!Y9YO!Z9WO![9WO'|+zO~P!AQO!V&cO%]9^O~O!V&cO%]9^O~P!G[O#u#sy!T#sy!U#sy~P#0aOQ$qiZ$qik$qiy$qi!c$qi!d$qi!f$qi!l$qi#c$qi#d$qi#e$qi#f$qi#g$qi#h$qi#i$qi#j$qi#k$qi#m$qi#o$qi#q$qi#r$qi#u$qi'r$qi'}$qi!T$qi!U$qi~P%5OOx(mO{(nO(V(rOP%Ti(U%Ti!U%Ti~OQ%TiZ%Tik%Tiy%Ti!c%Ti!d%Ti!f%Ti!l%Ti#c%Ti#d%Ti#e%Ti#f%Ti#g%Ti#h%Ti#i%Ti#j%Ti#k%Ti#m%Ti#o%Ti#q%Ti#r%Ti#u%Ti'r%Ti'}%Ti!T%Ti~P&4cOx(mO{(nOP%Vi(U%Vi(V%Vi!U%Vi~OQ%ViZ%Vik%Viy%Vi!c%Vi!d%Vi!f%Vi!l%Vi#c%Vi#d%Vi#e%Vi#f%Vi#g%Vi#h%Vi#i%Vi#j%Vi#k%Vi#m%Vi#o%Vi#q%Vi#r%Vi#u%Vi'r%Vi'}%Vi!T%Vi~P&6jO#u$ey!T$ey!U$ey~P#0aO#u#Wy!T#Wy!U#Wy~P#0aO!_#UO!T'Rq!e'Rq~O!T-zO!e([y~O!Q'Tq!T'Tq~P!G[O!Q9dO~P!G[O!T/SO!U(dy~O!T3nO!U(aq~O#P7sO#Q7sO~P$%_O!Z9nO![9nO'k$vO's)TO'|+zO~O!V/oO%]9qO~O!V/oO%]9qO~P!G[O!e9tO~O_$pO#T9zO'e$pO~O_$pO!_#UO#T9zO'e$pO~O!Z9}O![9}O'|+zO~P!AQO_$pO!_#UO!l:OO#T9zO'e$pO'}'SO~OQ$qqZ$qqk$qqy$qq!c$qq!d$qq!f$qq!l$qq#c$qq#d$qq#e$qq#f$qq#g$qq#h$qq#i$qq#j$qq#k$qq#m$qq#o$qq#q$qq#r$qq#u$qq'r$qq'}$qq!T$qq!U$qq~P%5OOQ$sqZ$sqk$sqy$sq!c$sq!d$sq!f$sq!l$sq#c$sq#d$sq#e$sq#f$sq#g$sq#h$sq#i$sq#j$sq#k$sq#m$sq#o$sq#q$sq#r$sq#u$sq'r$sq'}$sq!T$sq!U$sq~P%5OOe%X!Z!T%X!Z#T%X!Z#u%X!Z~P!&VO!T'Yq!U'Yq~P#0aO!T#]!Z!U#]!Z~P#0aO_$pO#T:aO'e$pO~O_$pO!_#UO#T:aO'e$pO~O#`%X!ZQ%X!ZZ%X!Z_%X!Zk%X!Zy%X!Z!T%X!Z!c%X!Z!d%X!Z!f%X!Z!l%X!Z#c%X!Z#d%X!Z#e%X!Z#f%X!Z#g%X!Z#h%X!Z#i%X!Z#j%X!Z#k%X!Z#m%X!Z#o%X!Z#q%X!Z#r%X!Z'e%X!Z'r%X!Z'}%X!Z!e%X!Z!Q%X!Z'a%X!Z!V%X!Z#T%X!Zo%X!Z%]%X!Z!_%X!Z~P!G[O_$pO#T:oO'e$pO~OP=nOx(mO{(nO(U(pO(V(rO~O]#Sal#Sa!U#Sa!Y#Sa!Z#Sa![#Sa!u#Sa!y#Sa!z#Sa!{#Sa#P#Sa#Q#Sa'k#Sa's#Sa'|#Sa~P&D[OQ%X!ZZ%X!Zk%X!Zy%X!Z!c%X!Z!d%X!Z!f%X!Z!l%X!Z#c%X!Z#d%X!Z#e%X!Z#f%X!Z#g%X!Z#h%X!Z#i%X!Z#j%X!Z#k%X!Z#m%X!Z#o%X!Z#q%X!Z#r%X!Z#u%X!Z'r%X!Z'}%X!Z!T%X!Z!U%X!Z~P%5OO]ualua!Yua!Zua![ua!uua!yua!zua!{ua#Pua#Qua'kua'sua'|ua~P%LmO]$hal$ha!Y$ha!Z$ha![$ha!u$ha!y$ha!z$ha!{$ha#P$ha#Q$ha'k$ha's$ha'|$ha~P%NtO]$jal$ja!Y$ja!Z$ja![$ja!u$ja!y$ja!z$ja!{$ja#P$ja#Q$ja'k$ja's$ja'|$ja~P&!{O]$xal$xa!U$xa!Y$xa!Z$xa![$xa!u$xa!y$xa!z$xa!{$xa#P$xa#Q$xa'k$xa's$xa'|$xa~P&D[O]%Til%Ti!Y%Ti!Z%Ti![%Ti!u%Ti!y%Ti!z%Ti!{%Ti#P%Ti#Q%Ti'k%Ti's%Ti'|%Ti~P&4cO]%Vil%Vi!Y%Vi!Z%Vi![%Vi!u%Vi!y%Vi!z%Vi!{%Vi#P%Vi#Q%Vi'k%Vi's%Vi'|%Vi~P&6jO]$qil$qi!U$qi!Y$qi!Z$qi![$qi!u$qi!y$qi!z$qi!{$qi#P$qi#Q$qi'k$qi's$qi'|$qi~P&D[O]$qql$qq!U$qq!Y$qq!Z$qq![$qq!u$qq!y$qq!z$qq!{$qq#P$qq#Q$qq'k$qq's$qq'|$qq~P&D[O]$sql$sq!U$sq!Y$sq!Z$sq![$sq!u$sq!y$sq!z$sq!{$sq#P$sq#Q$sq'k$sq's$sq'|$sq~P&D[O]%X!Zl%X!Z!U%X!Z!Y%X!Z!Z%X!Z![%X!Z!u%X!Z!y%X!Z!z%X!Z!{%X!Z#P%X!Z#Q%X!Z'k%X!Z's%X!Z'|%X!Z~P&D[Oo'tX~P/WO!QdX!TdX#TdX~P&*pOQ[XZ[Xk[Xx[Xy[X{[X!T[X!TdX!c[X!d[X!f[X!l[X#T[X#TdX#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'r[X'}[X(U[X(V[X~O!_dX!e[X!edX'}dX~P'$ZOQ;VOR;VO]gOb=ZOc!`OigOk;VOlgOmgOrgOt;VOv;VO{SO!OgO!PgO!VTO!a;YO!fVO!i;VO!j;VO!k;VO!l;VO!m;VO!p!_O#|!bO$QbO'j'|O'rRO'|WO(Z=XO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;pO{$[O!V$]O!a=aO!f$XO#_;yO#|$iO$i;sO$k;vO$n$jO'j'dO'n$bO'r$UO~O!T;jO!U$ga~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;qO{$[O!V$]O!a=bO!f$XO#_;zO#|$iO$i;tO$k;wO$n$jO'j'dO'n$bO'r$UO~O#l(TO~P'*^O!U[X!UdX~P'$ZO!_;^O~O#`;]O~O!_#UO#`;]O~O#T;nO~O#k;cO~O#T;{O!T(SX!U(SX~O#T;nO!T(QX!U(QX~O#`;|O~Oe<OO~P!&VO#`<VO~O#`<WO~O#`<XO~O!_#UO#`<YO~O!_#UO#`;|O~O#u<ZO~P#0aO#`<[O~O#`<]O~O#`<^O~O#`<_O~O#`<`O~O#`<aO~O#`<bO~O#`<cO~O!Q<dO~O#u<eO~P!&VO#u<fO~P!&VO#u<gO~P!&VO!Q<hO~P!G[O!Q<hO~O!Q<iO~P!G[O!_#UO#k=gO~O!_#UO#k=iO~O$Q~!d!y!{!|#P#^#_#j(Z$i$k$n%Q%[%]%^%d%f%i%j%l%n~UT$Q(Z#d!P'g'k#el#c#fkx'h's'h'j$S$U$S~",goto:"$(n(hPPPPPPPP(iP(yP*tPPPP.mPP/SP4y9R9fP9fPPP9fP;l9fP9fP9fP;pPP;vP<a@}PPPARPPPPARC|PPPDSE|PARPHdPPPPJbARPPPPPLlARPP! z!#O!#SP!#s!#w!#sPPPP!&|!(wPP!)P!*VP!#OARAR!-m!0q!5r!5r!9cPPP!9jARPPPPPPPPPPP!<iP!=|PPAR!?]PARPARARARARPAR!@tPP!CvP!FtP!Fx!GQ!GU!GUP!CsP!GY!GYP!JWP!J[ARAR!Jb!M_9fP9fP9f9fP!Ni9f9f#!y9f#%v9f#(Q9f9f#(n#+Q#+Q#+U#+^#+Q#+jP#+QP9f#,f9f#.T9f9f.mPPP#/vPP#0`#0`P#0`P#0u#0`PP#0{P#0rP#0r#1_!({#0r#1|#2S#2V(i#2Y(iP#2a#2a#2aP(iP(iP(iP(iPP(iP#2g#2jP#2j(iP#2nP#2qP(iP(iP(iP(iP(iP(i(iP#2w#3R#3X#3_#3m#3s#3y#4T#4Z#5U#5e#5k#5}#6T#6Z#6i#7O#8w#9V#9]#9c#9i#9o#9y#:P#:V#:a#:s#:yPPPPPPPP#;PPP#;s#?TP#@o#@v#AOPP#Fp#If$ o$ r$ u$#h$#k$#nPP$#t$#x$$q$%q$%u$&ZPP$&_$&e$&iP$&l$&p$&s$'f$'|$(R$(U$(X$(_$(b$(f$(jmlOTn!R!s$o%t%v%w%y+X+^0]0`Q${qQ%StQ%l}S&Z!]+rQ&j!`S)V$])[Q*P$|Q*^%UQ*x%fQ+x&bS+|&c,OQ,`&kQ.e)^Q/z*y[0z+y,Q,R,S,T,US3w/o3yW5Q0{0|0}1OU6v3|3}4OU7m5R5T5VS8j6w6xS9W7o7rQ9n8mR9}9Y%Q`OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oS#PX;W!l(O#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[Q)g$fQ*U%OQ*z%iQ+R%qQ-O;oQ.|)yQ/X*VQ0S+PQ3_/SQ4^/{Q5m;qQ6`3`R:q;ppiOTn}!R!s$o%k%t%v%w%y+X+^0]0`R*|%m&j[OPTUnor!R!W!a!c!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&e&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=Z=[[!lSV!g!j&[&pQ$upQ$zqS%Pt%U!U%Yvw!v!x!{$m%W&y'Q'R'W*a*b*d+V+k,i,l,p,q,s0e1g1h4t5aQ%b{Q&g!_Q&i!`Q'_#RS(x$X(|S*O${$|Q*S%OQ*s%dQ*w%fS,_&j&kQ,}'`Q.O(yQ/Q*PQ/W*VQ/Y*WQ/]*[Q/u*tS/y*x*yQ1a,`Q2g-zQ3^/SQ3b/VQ3g/_Q4]/zQ5x2hQ6_3`Q6b3dQ8^6^R9f8_x$Ze#W$g$h$l(q(s({)b)c-U.R.q2f3O8S=X=d=e=f!^$xq!`$z${$|&Y&i&j&k)U*O*P+o+{,_,`.]/Q0w0y1V1a2z5P5S7l7q9U9{:bQ)x$uQ*i%_Q*l%`Q*v%fQ,|'_Q/t*sU/x*w*x*yQ1q,}Q4W/uS4[/y/zS6l3r3vQ7T4]U8h6p6t6uU9l8i8k8lQ:W9mQ:i:X#b=]#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=od=^;^;s;v;y<Q<T<W<]<`<fg=_;l;m;t;w;z<R<U<X<^<a<gW$`e$b)d=XS%_x%kQ%`yQ%azR*g%]%X$_e#U#W#r#s$X$[$g$h$l&f(h(q(s(t({)R)b)c)u)w)y*h*k,[,y,{-U.R.S.U.q/f/i/q/s1n1p2f2p2x3O3V3X4T4V5c5h5{6U6z7P7x8S8p9^9q;^;l;m;r;s;t;u;v;w;x;y;z<P<Q<R<S<T<U<V<W<X<[<]<^<_<`<a<e<f<g=X=d=e=f=g=i=m=n=oT(i$U(jX)h$f;o;p;qU&_!]%X+uS'm#Y#ZQ*Z%RS,u'Z'[Q/j*mQ3P.nR6h3n&pgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[$a#o_!i!t$s&o&u'b'i'q'r's't'u'v'w'x'y'z'{'}(Q(U(`*Y+p,c,h,m-T-Z-_-a-p.r0l0o1d1w1|1}2O2P2Q2R2S2T2U2V2W2X2Y2]2b3T3[4x5Y5_5k5l5q5r6j7d7g7{8P8Q9Q9h9u9w:_:m:z;X<wT!dR!e&qgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[Q&]!]R0s+r!n&V!]&Z&b&c+r+x+y+|,O,Q,R,S,T,U,V0z0{0|0}1O1P3t3{5Q5R5T5U5V6n6o7m7o7r7s8g9W9Y9}S)U$])[S.])V)^Q.f)_Q/l*oQ2z.eQ2}.hS3r/o3yS6p3w4OS6t3|3}S8i6v6wQ8k6xS9m8j8mR:X9nllOTn!R!s$o%t%v%w%y+X+^0]0`Q%{!US'a#T;]Q)|$yQ*q%bQ*r%cQ,]&hS-S'f;|S.s)o<YQ/O)}Q/n*pQ0d+`Q0f+aQ0n+lQ1Y,SQ1_,^S3U.t<bQ3Y/PS3]/R<cQ4w0qQ5X1QQ5[1`Q6]3ZQ7e4yQ7f4zQ7t5]Q8}7bQ9S7kQ9x9TQ:^9yQ:l:`R:y:n$[#n_!i!t&o&u'b'i'q'r's't'u'v'w'x'y'z'{'}(Q(U(`*Y+p,c,h,m-T-Z-_-p.r0l0o1d1w1|1}2O2P2Q2R2S2T2U2V2W2X2Y2]2b3T3[4x5Y5_5k5l5q5r6j7d7g7{8P8Q9Q9h9u9w:_:m:z;X<wS'^#O0xU)a$^'e2[T)s$s-a$[#m_!i!t&o&u'b'i'q'r's't'u'v'w'x'y'z'{'}(Q(U(`*Y+p,c,h,m-T-Z-_-p.r0l0o1d1w1|1}2O2P2Q2R2S2T2U2V2W2X2Y2]2b3T3[4x5Y5_5k5l5q5r6j7d7g7{8P8Q9Q9h9u9w:_:m:z;X<wS']#O0xS'o#Z#nS)r$s-aS,v'['^Q-b(PQ.u)sR1i,w&pgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[S#PX;WQ%v!PQ%w!QQ%y!SQ%z!TR0[+[Q&d!_Q)t$uQ,Y&gS,x'_)xS1[,W,XY1m,|,}.w.x.yS5Z1]1^W5b1j1k1l1qU7w5d5e5fU9[7v7y7zQ:P9]R:d:QT+}&c,O!]YOTVZn}!R!s!v$m$o%k%m%t%v%w%y&c'W+X+^+y,O,p/o0]0`3t3yT#PX;W%SsOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oS'm#Y#ZS,u'Z'[!m<m#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[S+{&c,OW0y+y,S,T,UU1V+|,Q,RU1Z,V3t3{S3v/o3yU5P0z0{0|S5S0}1OU5W1P6n6oS6p3w4OS6u3|3}U7l5Q5R5TS7p5U8gQ7q5VS8i6v6wQ8l6xU9U7m7o7rQ9Z7sS9m8j8mS9{9W9YQ:X9nR:b9}S+}&c,OT3x/o3yS'V!w0YQ-}(xQ.Z)UU1U+{3u3vQ2l.OS2u.[.fU5O0y1Z6uQ5w2gS6S2{2}U7n5S5W8lQ8U5xQ8]6VS9X7p7qR:O9ZQ#V^S'U!w0YQ)p$nQ)z$wQ*Q$}Q,o'VQ-|(xQ.Y)UQ.`)XQ.}){Q/v*uU1T+{3u3vS2k-}.OS2t.Z.fQ2w._Q2y.aQ4Y/wW4}0y1U1Z6uQ5v2gQ5z2lS6O2u2}Q6T2|Q7R4ZW7j5O5S5W8lS8T5w5xS8X6P<dQ8Z6SQ8e6kQ8t7SU9V7n7p7qQ9b8US9c8Y<hQ9e8]Q9j8fQ9s8uS9|9X9ZS:S9d<iQ:U9kQ:c:OQ:g:VQ:v:hQ;P:wQ<p<kQ=O<uQ=P<vQ=Q=cR=V=h%S]OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oS#Vr!a!l<j#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[R<p=Z%S^OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oQ$nf!^$wq!`$z${$|&Y&i&j&k)U*O*P+o+{,_,`.]/Q0w0y1V1a2z5P5S7l7q9U9{:bS$}r!aQ){$xQ*u%fW/w*v*w*x*yU4Z/x/y/zS6k3r3vS7S4[4]W8f6l6p6t6uQ8u7TW9k8h8i8k8lS:V9l9mS:h:W:XQ:w:i!l<k#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[Q<u=YR<v=Z$vaOPTUno!R!W!c!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%t%v%w%y%}&W&e&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oY!qSV!g!j&p!U%Yvw!v!x!{$m%W&y'Q'R'W*a*b*d+V+k,i,l,p,q,s0e1g1h4t5aQ+S%q!j<l#k#|(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[R<o&[S&`!]%XR0u+u%Q`OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:o!l(O#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[R+R%q!j#e_!i$s&o&u'b'i'x'y'z'{(Q(U*Y,c,h,m-T-Z-p.r1d1w2Y3T3[5Y5_5k7g9Q9w:_:m:z;X!T;e'}(`+p-a0l0o1|2U2V2W2X2]2b4x5l5q5r6j7d7{8P8Q9h9u<w!f#g_!i$s&o&u'b'i'z'{(Q(U*Y,c,h,m-T-Z-p.r1d1w2Y3T3[5Y5_5k7g9Q9w:_:m:z;X!P;g'}(`+p-a0l0o1|2W2X2]2b4x5l5q5r6j7d7{8P8Q9h9u<w!b#k_!i$s&o&u'b'i(Q(U*Y,c,h,m-T-Z-p.r1d1w2Y3T3[5Y5_5k7g9Q9w:_:m:z;XQ2f-xz=['}(`+p-a0l0o1|2]2b4x5l5q5r6j7d7{8P8Q9h9u<wQ=d=jQ=e=kR=f=l&pgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[S#}d$OR2_-e&wcOPSTUVdno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$O$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-e-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[T#yb$PS#wb$PT(X#z(]T#xb$PT(Z#z(]&wdOPSTUVdno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$O$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-e-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[T#}d$OQ$QdR(d$O%SfOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:o!m=Y#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[#ahOPTVn!R!W!c!s!}#[#|$o%m%p%q%t%v%w%y%}&W&e'n(b)v*c+T+X+^+n,Z,z-f.o/r0T0U0V0X0]0`0b1o2^3s4U4i4k4l5g6s7O7^!^$^e#W$g$h$l(q(s({)b)c-U.R.q2f3O8S;^;s;v;y<Q<T<W<]<`<f=X=d=e=f#b'e#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=oQ)l$jQ-q(mg2[;l;m;t;w;z<R<U<X<^<a<gx$Ye#W$g$h$l(q(s({)b)c-U.R.q2f3O8S=X=d=e=fQ(}$ZS)X$])[Q)m$kQ.a)Y#b<r#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=od<s;^;s;v;y<Q<T<W<]<`<ff<t;l;m;t;w;z<R<U<X<^<a<gQ<x=]Q<y=^Q<z=_Q<{=`Q<|=aR<}=b!^$^e#W$g$h$l(q(s({)b)c-U.R.q2f3O8S;^;s;v;y<Q<T<W<]<`<f=X=d=e=f#b'e#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=og2[;l;m;t;w;z<R<U<X<^<a<gljOTn!R!s$o%t%v%w%y+X+^0]0`Q)Q$[Q+g&QQ+h&SR2o.S%W$_e#U#W#r#s$X$[$g$h$l&f(h(q(s(t({)R)b)c)u)w)y*h*k,[,y,{-U.R.S.U.q/f/i/q/s1n1p2f2p2x3O3V3X4T4V5c5h5{6U6z7P7x8S8p9^9q;^;l;m;r;s;t;u;v;w;x;y;z<P<Q<R<S<T<U<V<W<X<[<]<^<_<`<a<e<f<g=X=d=e=f=g=i=m=n=oQ*j%`Q/h*lQ3l/gR6g3mT)Z$])[S)Z$])[T3x/o3yQ._)WQ2|.gQ=c3sR=h6sQ)z$wQ.`)XQ.}){Q/v*uQ4Y/wQ7R4ZQ8e6kQ8t7SQ9j8fQ9s8uQ:U9kQ:g:VQ:v:hR;P:wp(q$V'g)n.Q.i.j1u2m3S5u6W9a<q=R=S=T!p<P'c(S(w)P,X-R-m-x.V.v.y/e/g1^1l1t2n2r3k3m4R5f5i5j5|6Q6Y6[6}7z8W8[8r:R=U=W=j=k=l[<Q:e:t:};R;S;U]<R2Z5p7|9_9`:pr(s$V'g)n-v.Q.i.j1u2m3S5u6W9a<q=R=S=T!r<S'c(S(w)P,X-R-m-x.V.v.y/e/g1^1l1r1t2n2r3k3m4R5f5i5j5|6Q6Y6[6}7z8W8[8r:R=U=W=j=k=l^<T:e:t:{:};R;S;U_<U2Z5p7|7}9_9`:ppiOTn}!R!s$o%k%t%v%w%y+X+^0]0`Q%h|R+T%qpiOTn}!R!s$o%k%t%v%w%y+X+^0]0`R%h|Q*n%aR/d*gqiOTn}!R!s$o%k%t%v%w%y+X+^0]0`Q/p*sS4S/t/uW6y4P4Q4R4WU8o6{6|6}U9o8n8q8rQ:Y9pR:j:ZQ%o}R*}%kR4a/}R8w7US%Pt%UR/Y*WQ%t!OR+X%uR+_%zT0^+^0`R+c%{Q+b%{R0g+cQnOQ!sTT$rn!sQ(j$UR-n(jQ!eRR&m!eQ!hSU&s!h&t,fQ&t!iR,f&uQ+s&]R0t+sQ-V'gR1v-VQ-Y'iS1y-Y1zR1z-ZQ,O&cR1W,OrZOTn}!R!s$o%k%m%t%v%w%y+X+^0]0`S!vV$mY#QZ!v+y,p3tS+y&c,OQ,p'WT3t/o3yS!nS%WU&z!n&{,gQ&{!oR,g&vQ+v&`R0v+vQ'X!yQ,j'PW,t'X,j1b5^Q1b,kR5^1cQ(]#zR-g(]Q$OdR(c$OQ#q_U(R#q,b;kQ,b;XR;k(`Q-{(xW2i-{2j5y8VU2j-|-}.OS5y2k2lR8V5z$m(o$V'c'g(S(w)P)i)j)n,X-P-Q-R-m-v-w-x.Q.V.i.j.v.y/e/g1^1l1r1s1t1u2Z2m2n2r3S3k3m4R5f5i5j5n5o5p5u5|6Q6W6Y6[6}7z7|7}8O8W8[8r9_9`9a:R:e:p:r:s:t:{:|:};R;S;U<q=R=S=T=U=W=j=k=lQ.T)PU2q.T2s5}Q2s.VR5}2rQ)[$]R.c)[Q)e$aR.l)eQ3W.vR6Z3WQ*e%ZR/c*eQ3o/jS6i3o8dR8d6jQ*p%bR/m*pQ3y/oR6q3yQ/|*zS4_/|7VR7V4aQ/T*SW3a/T3c6a8`Q3c/WQ6a3bR8`6bQ*X%PR/Z*XQ0`+^R4o0`WmOTn!sQ%x!RQ)q$oQ+W%tQ+Y%vQ+Z%wQ+]%yQ0Z+XS0^+^0`R4n0]Q$qkQ%|!VQ&P!XQ&R!YQ&T!ZQ*`%VQ*f%[Q*|%oQ+e&OQ.b)ZS0P*}+QQ0h+dQ0i+gQ0j+hU1R+{3u3vQ3f/^Q3j/eQ4X/vQ4c0RQ4m0[Y4{0y1T1U1Z6uQ6e3hQ6f3kQ7Q4YQ7W4b[7h4}5O5S5W5Y8lQ8a6cQ8s7RQ8x7XY9P7g7j7n7p7qQ9g8bQ9i8eQ9r8tW9v9Q9V9X9ZQ:T9jQ:[9sU:]9w9|:OQ:f:US:k:_:cQ:u:gQ:x:mQ;O:vQ;Q:zR;T;PQ$yqQ&h!`U)}$z${$|Q+l&YU,^&i&j&kQ.X)US/P*O*PQ0q+oQ1Q+{S1`,_,`Q2v.]Q3Z/QQ4y0wS4z0y1VQ5]1aQ6R2zS7k5P5SS9T7l7qQ9y9UQ:`9{R:n:bS$We=XR)f$bU$ae$b=XR.k)dQ$VeS'c#U)yQ'g#WS(S#r#sQ(w$XQ)P$[Q)i$gQ)j$hQ)n$lQ,X&fQ-P;rQ-Q;uQ-R;xQ-m(hQ-v(qQ-w(sQ-x(tQ.Q({Q.V)RQ.i)bQ.j)cf.v)u,y/q1n4T5c6z7x8p9^9qQ.y)wQ/e*hQ/g*kQ1^,[Q1l,{Q1r<PQ1s<SQ1t<VQ1u-US2Z;l;mQ2m.RQ2n.SQ2r.UQ3S.qQ3k/fQ3m/iQ4R/sQ5f1pQ5i<[Q5j<_Q5n;tQ5o;wQ5p;zQ5u2fQ5|2pQ6Q2xQ6W3OQ6Y3VQ6[3XQ6}4VQ7z5hQ7|<XQ7}<RQ8O<UQ8W5{Q8[6UQ8r7PQ9_<^Q9`<aQ9a8SQ:R<eQ:e;^Q:p<gQ:r;sQ:s;vQ:t;yQ:{<QQ:|<TQ:}<WQ;R<]Q;S<`Q;U<fQ<q=XQ=R=dQ=S=eQ=T=fQ=U=gQ=W=iQ=j=mQ=k=nR=l=olkOTn!R!s$o%t%v%w%y+X+^0]0`Q!^PS!uV!}Q&O!WQ&l!cQ'p#[Q(a#|S+Q%m%pQ+U%qQ+d%}Q+i&WQ,W&eQ-]'nQ-k(bQ.x)vQ/a*cQ0W+TU0p+n3s6sQ1],ZQ1k,zQ2a-fQ3Q.oQ4Q/rQ4e0TQ4f0UQ4h0VQ4j0XQ4q0bQ5e1oQ5s2^Q6|4UQ7]4iQ7_4kQ7`4lQ7y5gQ8q7OR8z7^#U_OPTVn!R!W!s!}#[$o%m%p%q%t%v%w%y%}&W&e'n)v*c+T+X+^+n,Z,z.o/r0T0U0V0X0]0`0b1o3s4U4i4k4l5g6s7O7^Q!iSQ!tUQ$soS&o!g&rQ&u!jQ'b#TQ'i#XQ'q#_Q'r#`Q's#aQ't#bQ'u#cQ'v#dQ'w#eQ'x#fQ'y#gQ'z#hQ'{#iQ'}#kQ(Q#pQ(U#tW(`#|(b-f2^Q*Y%QS+p&[0rS,c&p,eQ,h&xQ,m'TQ-T'fQ-Z'jQ-_;VQ-a;YQ-p(lQ.r)oQ0l+jQ0o+mQ1d,nQ1w-XQ1|;]Q1};_Q2O;`Q2P;aQ2Q;bQ2R;cQ2S;dQ2T;eQ2U;fQ2V;gQ2W;hQ2X;iQ2Y-`Q2];nQ2b;jQ3T.tQ3[/RQ4x;{Q5Y1SQ5_1eQ5k1xQ5l;|Q5q<OQ5r<YQ6j3pQ7d4uQ7g4|Q7{<ZQ8P<bQ8Q<cQ9Q7iQ9h8cQ9u9OQ9w9RQ:_9zQ:m:aQ:z:oQ;X!cR<w=[R!kSR&^!]S&Y!]+rS+o&Z&bS+{&c,OQ0w+xW0y+y,S,T,UU1V+|,Q,RY1Z,V3t3{3|3}S3u/o3yU5P0z0{0|S5S0}1OW5W1P6n6o6xU7l5Q5R5TS7p5U8gQ7q5VU9U7m7o7rQ9Z7sS9{9W9YR:b9}R'h#WR'k#XQ#OXR0x;WT!zV$mS!yV$mU%Zvw+VU'P!v!x!{S,k'Q'RQ,r'WQ/b*dQ1c,lU1f,p,q,sS5`1g1hR7u5a`!mS!g!j%W&p&y*a,it!wVvw!v!x!{$m'Q'R'W*d,l,p,q,s1g1h5aQ0Y+VQ0m+kQ4s0eQ7c4tT<n&[*bT!pS%WS!oS%WS&q!g&yS&v!j*aS+q&[*bT,d&p,iT&a!]%XQ#zbR(f$PT([#z(]R2`-eT(z$X(|R)S$[Q.w)uQ1j,yQ4P/qQ5d1nQ6{4TQ7v5cQ8n6zQ9]7xQ9p8pQ:Q9^R:Z9qllOTn!R!s$o%t%v%w%y+X+^0]0`Q%n}R*|%kV%[vw+VR/k*mR*{%iQ%TtR*_%UR*T%OT%r!O%uT%s!O%uT0_+^0`",nodeNames:"⚠ extends ArithOp ArithOp InterpolationStart LineComment BlockComment Script ExportDeclaration export Star as VariableName String from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression",maxTerm:345,context:trackNewline,nodeProps:[["closedBy",4,"InterpolationEnd",43,"]",53,"}",68,")",140,"JSXSelfCloseEndTag JSXEndTag",156,"JSXEndTag"],["group",-26,8,15,17,60,195,199,202,203,205,208,211,222,224,230,232,234,236,239,245,251,253,255,257,259,261,262,"Statement",-30,12,13,25,28,29,34,44,46,47,49,54,62,70,76,77,99,100,109,110,127,130,132,133,134,135,137,138,158,159,161,"Expression",-23,24,26,30,33,35,37,162,164,166,167,169,170,171,173,174,175,177,178,179,189,191,193,194,"Type",-3,81,92,98,"ClassItem"],["openedBy",31,"InterpolationStart",48,"[",52,"{",67,"(",139,"JSXStartTag",151,"JSXStartTag JSXStartCloseTag"]],propSources:[jsHighlight],skippedNodes:[0,5,6],repeatNodeCount:29,tokenData:"#2k~R!bOX%ZXY%uYZ'kZ[%u[]%Z]^'k^p%Zpq%uqr(Rrs)mst7]tu9guv<avw=bwx>lxyJcyzJyz{Ka{|Lm|}MW}!OLm!O!PMn!P!Q!$v!Q!R!Er!R![!G_![!]!Nc!]!^!N{!^!_# c!_!`#!`!`!a##d!a!b#%s!b!c#'h!c!}9g!}#O#(O#O#P%Z#P#Q#(f#Q#R#(|#R#S9g#S#T#)g#T#o#)}#o#p#,w#p#q#,|#q#r#-j#r#s#.S#s$f%Z$f$g%u$g#BY9g#BY#BZ#.j#BZ$IS9g$IS$I_#.j$I_$I|9g$I|$I}#1X$I}$JO#1X$JO$JT9g$JT$JU#.j$JU$KV9g$KV$KW#.j$KW&FU9g&FU&FV#.j&FV;'S9g;'S;=`<Z<%l?HT9g?HT?HU#.j?HUO9gW%`T$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%ZW%rP;=`<%l%Z7Z%|i$`W'g7ROX%ZXY%uYZ%ZZ[%u[p%Zpq%uq!^%Z!_#o%Z#p$f%Z$f$g%u$g#BY%Z#BY#BZ%u#BZ$IS%Z$IS$I_%u$I_$JT%Z$JT$JU%u$JU$KV%Z$KV$KW%u$KW&FU%Z&FU&FV%u&FV;'S%Z;'S;=`%o<%l?HT%Z?HT?HU%u?HUO%Z7Z'rT$`W'h7RO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&y(YU$`W!l&qO!^%Z!_!`(l!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t(sU#m&l$`WO!^%Z!_!`)V!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t)^T#m&l$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z1i)t]$`W]&ZOY)mYZ*mZr)mrs,js!^)m!^!_-S!_#O)m#O#P1q#P#o)m#o#p-S#p;'S)m;'S;=`7V<%lO)m,^*rX$`WOr*mrs+_s!^*m!^!_+u!_#o*m#o#p+u#p;'S*m;'S;=`,d<%lO*m,^+fT$Z,U$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,U+xTOr+urs,Xs;'S+u;'S;=`,^<%lO+u,U,^O$Z,U,U,aP;=`<%l+u,^,gP;=`<%l*m1i,sT$Z,U$`W]&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z1a-XX]&ZOY-SYZ+uZr-Srs-ts#O-S#O#P-{#P;'S-S;'S;=`1k<%lO-S1a-{O$Z,U]&Z1a.OUOr-Srs.bs;'S-S;'S;=`0y;=`<%l/R<%lO-S1a.iW$Z,U]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s<%lO/R&Z/WW]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s<%lO/R&Z/uO]&Z&Z/xRO;'S/R;'S;=`0R;=`O/R&Z0WX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l/R<%lO/R&Z0vP;=`<%l/R1a1OX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l-S<%lO/R1a1nP;=`<%l-S1i1vY$`WOr)mrs2fs!^)m!^!_-S!_#o)m#o#p-S#p;'S)m;'S;=`6e;=`<%l/R<%lO)m1i2o]$Z,U$`W]&ZOY3hYZ%ZZr3hrs4hs!^3h!^!_/R!_#O3h#O#P5O#P#o3h#o#p/R#p;'S3h;'S;=`6_<%lO3h&c3o]$`W]&ZOY3hYZ%ZZr3hrs4hs!^3h!^!_/R!_#O3h#O#P5O#P#o3h#o#p/R#p;'S3h;'S;=`6_<%lO3h&c4oT$`W]&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c5TW$`WO!^3h!^!_/R!_#o3h#o#p/R#p;'S3h;'S;=`5m;=`<%l/R<%lO3h&c5rX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l3h<%lO/R&c6bP;=`<%l3h1i6jX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l)m<%lO/R1i7YP;=`<%l)m#]7b]$`WOt%Ztu8Zu!^%Z!_!c%Z!c!}8Z!}#R%Z#R#S8Z#S#T%Z#T#o8Z#p$g%Z$g;'S8Z;'S;=`9a<%lO8Z#]8b_$`W'|#TOt%Ztu8Zu!Q%Z!Q![8Z![!^%Z!_!c%Z!c!}8Z!}#R%Z#R#S8Z#S#T%Z#T#o8Z#p$g%Z$g;'S8Z;'S;=`9a<%lO8Z#]9dP;=`<%l8Z,T9ra$`W's#S'j)s$SSOt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$g%Z$g;'S9g;'S;=`<Z<%lO9g[;Oa$`W$SSOt%Ztu:wu}%Z}!O:w!O!Q%Z!Q![:w![!^%Z!_!c%Z!c!}:w!}#R%Z#R#S:w#S#T%Z#T#o:w#p$g%Z$g;'S:w;'S;=`<T<%lO:w[<WP;=`<%l:w,T<^P;=`<%l9g&t<hU$`W#e&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t=RT$`W#w&lO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z(h=iW(V(`$`WOv%Zvw>Rw!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t>YU$`W#q&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z1i>s]$`W]&ZOY>lYZ?lZw>lwx,jx!^>l!^!_@|!_#O>l#O#PE_#P#o>l#o#p@|#p;'S>l;'S;=`J]<%lO>l,^?qX$`WOw?lwx+_x!^?l!^!_@^!_#o?l#o#p@^#p;'S?l;'S;=`@v<%lO?l,U@aTOw@^wx,Xx;'S@^;'S;=`@p<%lO@^,U@sP;=`<%l@^,^@yP;=`<%l?l1aARX]&ZOY@|YZ@^Zw@|wx-tx#O@|#O#PAn#P;'S@|;'S;=`EX<%lO@|1aAqUOw@|wxBTx;'S@|;'S;=`Dg;=`<%lBt<%lO@|1aB[W$Z,U]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da<%lOBt&ZByW]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da<%lOBt&ZCfRO;'SBt;'S;=`Co;=`OBt&ZCtX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%lBt<%lOBt&ZDdP;=`<%lBt1aDlX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%l@|<%lOBt1aE[P;=`<%l@|1iEdY$`WOw>lwxFSx!^>l!^!_@|!_#o>l#o#p@|#p;'S>l;'S;=`Ik;=`<%lBt<%lO>l1iF]]$Z,U$`W]&ZOYGUYZ%ZZwGUwx4hx!^GU!^!_Bt!_#OGU#O#PHU#P#oGU#o#pBt#p;'SGU;'S;=`Ie<%lOGU&cG]]$`W]&ZOYGUYZ%ZZwGUwx4hx!^GU!^!_Bt!_#OGU#O#PHU#P#oGU#o#pBt#p;'SGU;'S;=`Ie<%lOGU&cHZW$`WO!^GU!^!_Bt!_#oGU#o#pBt#p;'SGU;'S;=`Hs;=`<%lBt<%lOGU&cHxX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%lGU<%lOBt&cIhP;=`<%lGU1iIpX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%l>l<%lOBt1iJ`P;=`<%l>l,TJjT!f+{$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$PKQT!e#w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z)ZKjW$`W'k#e#f&lOz%Zz{LS{!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&tLZU$`W#c&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z*qLtU$`Wk*iO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z,TM_T!T+{$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,TMuX$`Wx(dO!O%Z!O!PNb!P!Q%Z!Q![! d![!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$oNgV$`WO!O%Z!O!PN|!P!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$o! TT!S$g$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c! k]$`Wl&ZO!Q%Z!Q![! d![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S! d#S#X%Z#X#Y!!d#Y#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!!i]$`WO{%Z{|!#b|}%Z}!O!#b!O!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!#gX$`WO!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!$ZX$`Wl&ZO!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z7Z!$}b$`W#d&lOY!&VYZ%ZZz!&Vz{!-n{!P!&V!P!Q!BV!Q!^!&V!^!_!(f!_!`!Ch!`!a!Dm!a!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!&^^$`W!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!'aa$`W!PPO!^%Z!_#Z%Z#Z#[!'Y#[#]%Z#]#^!'Y#^#a%Z#a#b!'Y#b#g%Z#g#h!'Y#h#i%Z#i#j!'Y#j#m%Z#m#n!'Y#n#o%Z#p;'S%Z;'S;=`%o<%lO%ZP!(kX!PPOY!(fZ!P!(f!P!Q!)W!Q!}!(f!}#O!)o#O#P!*n#P;'S!(f;'S;=`!*}<%lO!(fP!)]U!PP#Z#[!)W#]#^!)W#a#b!)W#g#h!)W#i#j!)W#m#n!)WP!)rVOY!)oZ#O!)o#O#P!*X#P#Q!(f#Q;'S!)o;'S;=`!*h<%lO!)oP!*[SOY!)oZ;'S!)o;'S;=`!*h<%lO!)oP!*kP;=`<%l!)oP!*qSOY!(fZ;'S!(f;'S;=`!*}<%lO!(fP!+QP;=`<%l!(fX!+Y[$`WOY!+TYZ%ZZ!^!+T!^!_!)o!_#O!+T#O#P!,O#P#Q!&V#Q#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+TX!,TX$`WOY!+TYZ%ZZ!^!+T!^!_!)o!_#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+TX!,sP;=`<%l!+TX!,{X$`WOY!&VYZ%ZZ!^!&V!^!_!(f!_#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!-kP;=`<%l!&V7Z!-u`$`W!PPOY!-nYZ!.wZz!-nz{!2U{!P!-n!P!Q!@m!Q!^!-n!^!_!4m!_!}!-n!}#O!;l#O#P!?o#P#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!.|X$`WOz!.wz{!/i{!^!.w!^!_!0w!_#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!/nZ$`WOz!.wz{!/i{!P!.w!P!Q!0a!Q!^!.w!^!_!0w!_#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!0hT$`WU7RO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z7R!0zTOz!0wz{!1Z{;'S!0w;'S;=`!1x<%lO!0w7R!1^VOz!0wz{!1Z{!P!0w!P!Q!1s!Q;'S!0w;'S;=`!1x<%lO!0w7R!1xOU7R7R!1{P;=`<%l!0w7Z!2RP;=`<%l!.w7Z!2]`$`W!PPOY!-nYZ!.wZz!-nz{!2U{!P!-n!P!Q!3_!Q!^!-n!^!_!4m!_!}!-n!}#O!;l#O#P!?o#P#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!3ha$`WU7R!PPO!^%Z!_#Z%Z#Z#[!'Y#[#]%Z#]#^!'Y#^#a%Z#a#b!'Y#b#g%Z#g#h!'Y#h#i%Z#i#j!'Y#j#m%Z#m#n!'Y#n#o%Z#p;'S%Z;'S;=`%o<%lO%Z7R!4r[!PPOY!4mYZ!0wZz!4mz{!5h{!P!4m!P!Q!:b!Q!}!4m!}#O!6|#O#P!9r#P;'S!4m;'S;=`!:[<%lO!4m7R!5m[!PPOY!4mYZ!0wZz!4mz{!5h{!P!4m!P!Q!6c!Q!}!4m!}#O!6|#O#P!9r#P;'S!4m;'S;=`!:[<%lO!4m7R!6jUU7R!PP#Z#[!)W#]#^!)W#a#b!)W#g#h!)W#i#j!)W#m#n!)W7R!7PYOY!6|YZ!0wZz!6|z{!7o{#O!6|#O#P!9S#P#Q!4m#Q;'S!6|;'S;=`!9l<%lO!6|7R!7r[OY!6|YZ!0wZz!6|z{!7o{!P!6|!P!Q!8h!Q#O!6|#O#P!9S#P#Q!4m#Q;'S!6|;'S;=`!9l<%lO!6|7R!8mVU7ROY!)oZ#O!)o#O#P!*X#P#Q!(f#Q;'S!)o;'S;=`!*h<%lO!)o7R!9VVOY!6|YZ!0wZz!6|z{!7o{;'S!6|;'S;=`!9l<%lO!6|7R!9oP;=`<%l!6|7R!9uVOY!4mYZ!0wZz!4mz{!5h{;'S!4m;'S;=`!:[<%lO!4m7R!:_P;=`<%l!4m7R!:ga!PPOz!0wz{!1Z{#Z!0w#Z#[!:b#[#]!0w#]#^!:b#^#a!0w#a#b!:b#b#g!0w#g#h!:b#h#i!0w#i#j!:b#j#m!0w#m#n!:b#n;'S!0w;'S;=`!1x<%lO!0w7Z!;q^$`WOY!;lYZ!.wZz!;lz{!<m{!^!;l!^!_!6|!_#O!;l#O#P!>q#P#Q!-n#Q#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!<r`$`WOY!;lYZ!.wZz!;lz{!<m{!P!;l!P!Q!=t!Q!^!;l!^!_!6|!_#O!;l#O#P!>q#P#Q!-n#Q#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!={[$`WU7ROY!+TYZ%ZZ!^!+T!^!_!)o!_#O!+T#O#P!,O#P#Q!&V#Q#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+T7Z!>vZ$`WOY!;lYZ!.wZz!;lz{!<m{!^!;l!^!_!6|!_#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!?lP;=`<%l!;l7Z!?tZ$`WOY!-nYZ!.wZz!-nz{!2U{!^!-n!^!_!4m!_#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!@jP;=`<%l!-n7Z!@te$`W!PPOz!.wz{!/i{!^!.w!^!_!0w!_#Z!.w#Z#[!@m#[#]!.w#]#^!@m#^#a!.w#a#b!@m#b#g!.w#g#h!@m#h#i!.w#i#j!@m#j#m!.w#m#n!@m#n#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!B^X$`WT7ROY!BVYZ%ZZ!^!BV!^!_!By!_#o!BV#o#p!By#p;'S!BV;'S;=`!Cb<%lO!BV7R!COST7ROY!ByZ;'S!By;'S;=`!C[<%lO!By7R!C_P;=`<%l!By7Z!CeP;=`<%l!BV&u!Cq^$`W#w&l!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&V]!Dv^$PS$`W!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&V&c!Eyf$`Wl&ZO!O%Z!O!P! d!P!Q%Z!Q![!G_![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S!G_#S#U%Z#U#V!IR#V#X%Z#X#Y!!d#Y#b%Z#b#c!Hk#c#d!Js#d#l%Z#l#m!L_#m#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Gfa$`Wl&ZO!O%Z!O!P! d!P!Q%Z!Q![!G_![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S!G_#S#X%Z#X#Y!!d#Y#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!HrT$`Wl&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!IWY$`WO!Q%Z!Q!R!Iv!R!S!Iv!S!^%Z!_#R%Z#R#S!Iv#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!I}[$`Wl&ZO!Q%Z!Q!R!Iv!R!S!Iv!S!^%Z!_#R%Z#R#S!Iv#S#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!JxX$`WO!Q%Z!Q!Y!Ke!Y!^%Z!_#R%Z#R#S!Ke#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!KlZ$`Wl&ZO!Q%Z!Q!Y!Ke!Y!^%Z!_#R%Z#R#S!Ke#S#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Ld]$`WO!Q%Z!Q![!M]![!^%Z!_!c%Z!c!i!M]!i#R%Z#R#S!M]#S#T%Z#T#Z!M]#Z#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Md_$`Wl&ZO!Q%Z!Q![!M]![!^%Z!_!c%Z!c!i!M]!i#R%Z#R#S!M]#S#T%Z#T#Z!M]#Z#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m!NlT!_V$`W#u(^O!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z!P# ST_w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z6i# nR'n$Y!c(O$Q,_(ZP!P!Q# w!^!_# |!_!`#!ZW# |O$bW&l#!RP#g&l!_!`#!U&l#!ZO#w&l&l#!`O#h&l(m#!gV#T(e$`WO!^%Z!_!`(l!`!a#!|!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&u##TT#`&m$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m##oVe!s#h&l$]S$`WO!^%Z!_!`#$U!`!a#$l!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#$]T#h&l$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#$sV#g&l$`WO!^%Z!_!`<z!`!a#%Y!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#%aU#g&l$`WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m#%zX'}&q$`WO!O%Z!O!P#&g!P!^%Z!_!a%Z!a!b#&}!b#o%Z#p;'S%Z;'S;=`%o<%lO%Z(i#&nTy(a$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#'UU$`W#r&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z#_#'oT!u#V$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,P#(VT{+w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$P#(mT!Q#w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#)TU#o&l$`WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z){#)nT$`W'r)sO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,T#*Ya$`W's#S'j)s$USOt%Ztu#)}u}%Z}!O#+_!O!Q%Z!Q![#)}![!^%Z!_!c%Z!c!}#)}!}#R%Z#R#S#)}#S#T%Z#T#o#)}#p$g%Z$g;'S#)};'S;=`#,q<%lO#)}[#+fa$`W$USOt%Ztu#+_u}%Z}!O#+_!O!Q%Z!Q![#+_![!^%Z!_!c%Z!c!}#+_!}#R%Z#R#S#+_#S#T%Z#T#o#+_#p$g%Z$g;'S#+_;'S;=`#,k<%lO#+_[#,nP;=`<%l#+_,T#,tP;=`<%l#)}~#,|O!V~(h#-TV(U(`$`WO!^%Z!_!`<z!`#o%Z#p#q#&}#q;'S%Z;'S;=`%o<%lO%Z(}#-sT!U(soQ$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%ZX#.ZT!mP$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z7Z#.wt$`W'g7R's#S'j)s$SSOX%ZXY%uYZ%ZZ[%u[p%Zpq%uqt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$f%Z$f$g%u$g#BY9g#BY#BZ#.j#BZ$IS9g$IS$I_#.j$I_$JT9g$JT$JU#.j$JU$KV9g$KV$KW#.j$KW&FU9g&FU&FV#.j&FV;'S9g;'S;=`<Z<%l?HT9g?HT?HU#.j?HUO9g7Z#1fa$`W'h7R's#S'j)s$SSOt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$g%Z$g;'S9g;'S;=`<Z<%lO9g",tokenizers:[tsExtends,noSemicolon,incdecToken,template,0,1,2,3,4,5,6,7,8,9,insertSemicolon],topRules:{Script:[0,7],SingleExpression:[1,263]},dialects:{jsx:13404,ts:13406},dynamicPrecedences:{159:1,187:1},specialized:[{term:302,get:e=>spec_identifier[e]||-1},{term:311,get:e=>spec_word[e]||-1},{term:65,get:e=>spec_LessThan[e]||-1}],tokenPrec:13429});[snippetCompletion("function ${name}(${params}) {\n\t${}\n}",{label:"function",detail:"definition",type:"keyword"}),snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}",{label:"for",detail:"loop",type:"keyword"}),snippetCompletion("for (let ${name} of ${collection}) {\n\t${}\n}",{label:"for",detail:"of loop",type:"keyword"}),snippetCompletion("do {\n\t${}\n} while (${})",{label:"do",detail:"loop",type:"keyword"}),snippetCompletion("while (${}) {\n\t${}\n}",{label:"while",detail:"loop",type:"keyword"}),snippetCompletion("try {\n\t${}\n} catch (${error}) {\n\t${}\n}",{label:"try",detail:"/ catch block",type:"keyword"}),snippetCompletion("if (${}) {\n\t${}\n}",{label:"if",detail:"block",type:"keyword"}),snippetCompletion("if (${}) {\n\t${}\n} else {\n\t${}\n}",{label:"if",detail:"/ else block",type:"keyword"}),snippetCompletion("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}",{label:"class",detail:"definition",type:"keyword"}),snippetCompletion('import {${names}} from "${module}"\n${}',{label:"import",detail:"named",type:"keyword"}),snippetCompletion('import ${name} from "${module}"\n${}',{label:"import",detail:"default",type:"keyword"})];const javascriptLanguage=LRLanguage.define({name:"javascript",parser:parser.configure({props:[indentNodeProp.add({IfStatement:continuedIndent({except:/^\s*({|else\b)/}),TryStatement:continuedIndent({except:/^\s*({|catch\b|finally\b)/}),LabeledStatement:flatIndent,SwitchBody:e=>{let t=e.textAfter,i=/^\s*\}/.test(t),n=/^\s*(case|default)\b/.test(t);return e.baseIndent+(i?0:n?1:2)*e.unit},Block:delimitedIndent({closing:"}"}),ArrowFunction:e=>e.baseIndent+e.unit,"TemplateString BlockComment":()=>null,"Statement Property":continuedIndent({except:/^{/}),JSXElement(e){let t=/^\s*<\//.test(e.textAfter);return e.lineIndent(e.node.from)+(t?0:e.unit)},JSXEscape(e){let t=/\s*\}/.test(e.textAfter);return e.lineIndent(e.node.from)+(t?0:e.unit)},"JSXOpenTag JSXSelfClosingTag":e=>e.column(e.node.from)+e.unit}),foldNodeProp.add({"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression":foldInside,BlockComment:e=>({from:e.from+2,to:e.to-2})})]}),languageData:{closeBrackets:{brackets:["(","[","{","'",'"',"`"]},commentTokens:{line:"//",block:{open:"/*",close:"*/"}},indentOnInput:/^\s*(?:case |default:|\{|\}|<\/)$/,wordChars:"$"}});javascriptLanguage.configure({dialect:"ts"},"typescript");javascriptLanguage.configure({dialect:"jsx"});javascriptLanguage.configure({dialect:"jsx ts"},"typescript");function elementName(e,t,i=e.length){if(!t)return "";let n=t.getChild("JSXIdentifier");return n?e.sliceString(n.from,Math.min(n.to,i)):""}const android$1="object"==typeof navigator&&/Android\b/.test(navigator.userAgent);EditorView.inputHandler.of((e,t,i,n)=>{if((android$1?e.composing:e.compositionStarted)||e.state.readOnly||t!=i||">"!=n&&"/"!=n||!javascriptLanguage.isActiveAt(e.state,t,-1))return  false;let{state:o}=e,r=o.changeByRange(e=>{var t,i,r;let s,{head:a}=e,l=syntaxTree(o).resolveInner(a,-1);if("JSXStartTag"==l.name&&(l=l.parent),">"==n&&"JSXFragmentTag"==l.name)return {range:EditorSelection.cursor(a+1),changes:{from:a,insert:"><>"}};if(">"==n&&"JSXIdentifier"==l.name){if("JSXEndTag"!=(null===(i=null===(t=l.parent)||void 0===t?void 0:t.lastChild)||void 0===i?void 0:i.name)&&(s=elementName(o.doc,l.parent,a)))return {range:EditorSelection.cursor(a+1),changes:{from:a,insert:`></${s}>`}}}else if("/"==n&&"JSXFragmentTag"==l.name){let e=l.parent,t=null===e||void 0===e?void 0:e.parent;if(e.from==a-1&&"JSXEndTag"!=(null===(r=t.lastChild)||void 0===r?void 0:r.name)&&(s=elementName(o.doc,null===t||void 0===t?void 0:t.firstChild,a))){let e=`/${s}>`;return {range:EditorSelection.cursor(a+e.length),changes:{from:a,insert:e}}}}return {range:e}});return !r.changes.empty&&(e.dispatch(r,{userEvent:"input.type",scrollIntoView:true}),true)});let updateCallback=function(){},internCallback=function(){};const listenChangesExtension=StateField.define({create:()=>null,update:(e,t)=>(t.docChanged&&internCallback(t.newDoc.toString()),null)}),errorLinter=linter(e=>{let t=[],i=e.errorLines.length;if(0===i)return t;for(;i--;)t.push({from:e.state.doc.line(e.errorLines[i].lineNumber).from,to:e.state.doc.line(e.errorLines[i].lineNumber).from+2,message:e.errorLines[i].description,severity:"error"});return t});function createEditorState(e="",t={}){let i=[lineNumbers(),highlightActiveLineGutter(),highlightSpecialChars(),history(),foldGutter(),drawSelection(),indentUnit.of("    "),EditorState.allowMultipleSelections.of(true),indentOnInput(),bracketMatching(),closeBrackets(),keymap.of([indentWithTab,...closeBracketsKeymap,...defaultKeymap,...historyKeymap,...foldKeymap,...completionKeymap]),javascriptLanguage,syntaxHighlighting(defaultHighlightStyle,{fallback:true}),listenChangesExtension,errorLinter,lintGutter(),oneDark];return EditorState.create({doc:e,extensions:i})}class CodeMirror extends EditorView{constructor(e,t){super({state:createEditorState(),parent:e}),this.isEdit=false,this.errorLines=[],updateCallback=t,internCallback=this.onChange.bind(this);}addError(e){this.errorLines=e;}noError(){this.errorLines=[];}setValue(e){this.isEdit=false,this.dispatch({changes:{from:0,to:this.state.doc.length,insert:e}});}clear(){this.setValue("");}getValue(){return this.state.doc.toString()}onChange(e){const t=this.getValue();""!==t&&(this.isEdit=e!==t),updateCallback(e);}}

//import * as UIL from 'uil'

/** __
*    _)_|_|_
*   __) |_| | 2023
* @author lo.th / https://github.com/lo-th
*/

class Editor {

    constructor ( solo = false ) {

        this.esprimaReady = false;

        this.loadEsprima();

        this.isSolo = solo;
        this.isOpen = false;
        this.source = null;
        this.left = 0;
        this.refresh = false;
        this.old = '';

        this.extraCode = [];

        this.useCodeMirror = true;
        this.errorLines = [];
        this.widgets = [];


        if( this.isSolo ) this.open();

    }

    message ( e ) {

        let type = e.data.type;

        switch( type ){
            case 'connect' :

            this.source = e.source;
            this.send({ type:'connect', msg:'Editor connected !!'});

            break;
            case 'set' :

            this.set( e.data.code, e.data.name );

            break;
        }

    }

    send( data ){

        if( !this.source )  return 
        this.source.postMessage( data );

    }

    detach () {

        if(this.isSolo) this.send({ type:'close' });
        else Main.externEditor();

    }

    reset(){

        //let extra = document.getElementById("extra");
        //if(extra)document.head.removeChild(extra);//Remooves main.js from the DOM tree

        
        let i = this.extraCode.length;
        while( i-- ){
            this.extraCode[i].remove(); 
            //document.getElementsByTagName('head')[0].removeChild(this.extraCode[i]);
        }
        this.extraCode = [];
        //console.log('extra is reset')

    }

    loadSrcipt ( url ) {

        const name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        var xml = new XMLHttpRequest();
        xml.open('GET', url );
        xml.overrideMimeType( "text/javascript" );
        xml.onreadystatechange = function() {
            if ( xml.readyState === 4 ) {
                if ( xml.status === 200 || xml.status === 0 ) {
                    this.set( xml.responseText, name );
                }
                else console.error( "Couldn't load ["+ name + "] [" + xml.status + "]" );
            }
        }.bind(this);
        xml.send();

    }

    loadExtra ( url, callback ) {

        const name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        var xml = new XMLHttpRequest();
        xml.open('GET', url );
        xml.overrideMimeType( "text/javascript" );
        xml.onreadystatechange = function() {
            if ( xml.readyState === 4 ) {
                if ( xml.status === 200 || xml.status === 0 ) {
                    let n = document.createElement("script");
                    n.language = "javascript";
                    n.type = "text/javascript";
                    n.charset = "utf-8";
                    n.async = false;
                    n.innerHTML =  '{' + xml.responseText + '}';
                    this.extraCode.push(n);
                    document.getElementsByTagName('head')[0].appendChild(n);
                    //document.head.appendChild(n)
                    callback();
                }
                else console.error( "Couldn't load ["+ name + "] [" + xml.status + "]" );
            }
        }.bind(this);
        xml.send();

    }

    loadEsprima () {

        var xml = new XMLHttpRequest();
        xml.open('GET', './src/libs/esprima.js');
        xml.overrideMimeType( "text/javascript" );
        xml.onreadystatechange = function() {
            if ( xml.readyState === 4 ) {
                if ( xml.status === 200 || xml.status === 0 ) {
                    let n = document.createElement("script");
                    n.type = "text/javascript";
                    n.async = true;
                    n.charset = "utf-8";
                    n.text = xml.responseText;
                    document.getElementsByTagName('head')[0].appendChild(n);
                    this.esprimaReady = true;
                }
                else console.error( "Couldn't load [esprima] [" + xml.status + "]" );
            }
            
        }.bind(this);
        xml.send();

    }

    show ( b ) {

        if( this.isOpen && !b ) this.close();
        else this.open();
        if( Main ) Main.setLeft( this.left );

    }
 
    open () {

        this.left = this.isSolo ? window.innerWidth : (window.innerWidth*0.5)-200;
        this.isOpen = true;

        let text = 'font-smooth: antialiased; -webkit-font-smoothing : antialiased; -moz-osx-font-smoothing: grayscale;';//text-rendering: optimizeSpeed; text-shadow: 1px 1px 1px #000;

        let unselectable = '-o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none; pointer-events:none; ';

        this.content = document.createElement( 'div' );

        if( this.isSolo ) this.content.style.cssText = 'position:absolute; margin:0; padding:0; top:0px; left:0px; width:100%;  height:100%; ';
        else this.content.style.cssText = 'position:absolute; margin:0; padding:0; top:0px; left:0px; width:'+this.left+'px;  height:100%; ';
        this.content.style.cssText += "font-size:18px; font-family:'Roboto Mono', 'Source Code Pro', Consolas, monospace; color:#f8f8f2; background:#181915;";//background: #282923;#20211c
        document.body.appendChild( this.content );


        this.codeContent = document.createElement( 'div' );
        this.codeContent.style.cssText = text + 'position:absolute; margin:0; padding:0; top:30px; left:3px; width:calc( 100% - 6px); height:calc( 100% - 60px); border-top: 1px solid #3e4036; border-bottom: 1px solid #3e4036;';
        
        if(this.useCodeMirror){
            this.code = new CodeMirror( this.codeContent, this.onUpdate.bind(this) );
            //this.code = CodeMirror( this.codeContent, { theme:'monokai', lineNumbers: true, matchBrackets: true, indentWithTabs: false, styleActiveLine: false, tabSize: 4, indentUnit: 4/*, highlightSelectionMatches: {showToken: /\w/}*/});
            //this.code.on('change', function () { this.onUpdate(this.code.getValue()) }.bind(this) );
        } else {
            this.code = new CodeFlask( this.codeContent, { language: 'js', handleTabs: true, lineNumbers: true });
            this.code.onUpdate( this.onUpdate.bind(this) );
        }

        this.content.appendChild( this.codeContent );

        this.title = document.createElement( 'div' );
        this.title.style.cssText = unselectable + "position:absolute; top:3px; left:10px; width:calc( 100% - 20px); color:#7c806c; text-shadow: 1px 1px 1px #000;";
        this.content.appendChild( this.title );

        //  mini menu
        
        this.solo = document.createElement( 'div' );
        this.solo.style.cssText = unselectable + "position:absolute; top:0px; right:0px; width:30px; height:30px; pointer-events:auto; cursor: pointer;";
        this.solo.appendChild( h$2.dom( 'path', 'position:absolute; width:14px; height:14px; left:8px; top:8px; pointer-events:none;', { d:h$2.svgs[ 'extern' ], fill:'#DDD', stroke:'none'} ));
        this.content.appendChild( this.solo );
        this.solo.name = 'detach';

        this.saver = document.createElement( 'div' );
        this.saver.style.cssText = unselectable + "position:absolute; top:0px; right:30px; width:30px; height:30px; pointer-events:auto; cursor: pointer;";
        this.saver.appendChild( h$2.dom( 'path', 'position:absolute; width:14px; height:14px; left:8px; top:8px; pointer-events:none;', { d:h$2.svgs[ 'save' ], fill:'#DDD', stroke:'none'} ));
        this.content.appendChild( this.saver );
        this.saver.name = 'save';

        this.loader = document.createElement( 'div' );
        this.loader.style.cssText = unselectable + "position:absolute; top:0px; right:60px; width:30px; height:30px; pointer-events:auto; cursor: pointer;";
        this.loader.appendChild( h$2.dom( 'path', 'position:absolute; width:14px; height:14px; left:8px; top:8px; pointer-events:none;', { d:h$2.svgs[ 'load' ], fill:'#DDD', stroke:'none'} ));
        this.content.appendChild( this.loader );
        this.loader.name = 'load';

        this.help = document.createElement( 'div' );
        this.help.style.cssText = unselectable + "position:absolute; top:3px; right:100px; width:60px; height:30px; pointer-events:none; color:#7c806c; text-shadow: 1px 1px 1px #000; text-align:right";
        this.content.appendChild( this.help );

        //

        this.info = document.createElement( 'div' );
        this.info.style.cssText = unselectable + "position:absolute; bottom:2px; left:10px; width:calc( 100% - 20px); text-shadow: 1px 1px 1px #000;";
        this.content.appendChild( this.info );

        this.separator = document.createElement( 'div' );
        this.separator.style.cssText = unselectable + 'background:none; position:absolute; top:0px; right:0px; width:3px; height:100%; cursor: e-resize; pointer-events:auto; z-index: 5; display:block; ';
        this.content.appendChild( this.separator );

        this.midDown = function (e) { this.isDown = true;  }.bind(this);

        this.midUp = function (e) { 
            this.isDown = false; 
            document.body.style.cursor = 'auto';
            this.codeContent.style.pointerEvents = 'auto';
        }.bind(this);

        this.midMove = function (e) { 

            if( e.target.name ){
                this.help.innerHTML = e.target.name;
            }  else this.help.innerHTML = '';

            if(!this.isDown) return

            this.codeContent.style.pointerEvents = 'none';
            document.body.style.cursor = 'e-resize';

            this.left = e.clientX+2;
            this.content.style.width = this.left+'px';
            if(Main) Main.setLeft( this.left );

        }.bind(this);

        this.helpers = function (e) { console.log(e.target.name); }.bind(this);

        if( !this.isSolo ){
            this.separator.addEventListener( 'pointerdown', this.midDown, false );
            document.addEventListener('pointermove', this.midMove, false );
            document.addEventListener('pointerup', this.midUp, false );
        }
        
        this.saver.addEventListener( 'pointerdown', this.save.bind(this), false );
        this.loader.addEventListener( 'pointerdown', this.load.bind(this), false );
        this.solo.addEventListener( 'pointerdown', this.detach.bind(this), false );

        if( Main ) {
            this.setInternCode( Main.getCode() );
            this.setTitle( Main.getCodeName() );
        }

        if( this.isSolo ){
            var hash = location.hash.substr( 1 );
            if( hash !== '' ) this.loadSrcipt('./demos/'+ hash + '.js');
        } else {
           if(!this.useCodeMirror) this.content.addEventListener( 'wheel', function(e){ this.code.wheel(e); }.bind(this) );
        }

        this.content.addEventListener( 'dragover', function(e){ e.preventDefault(); }, false );
        this.content.addEventListener( 'dragend', function(e){ e.preventDefault(); }, false );
        this.content.addEventListener( 'dragleave', function(e){ e.preventDefault();}, false );
        this.content.addEventListener( 'drop', this.drop.bind(this), false );

    }

    setTitle ( name ) {

        this.codeName = name;
        this.title.innerHTML = '&#x2022;&#160;' + this.codeName;

    }

    close () {

        this.left = 0;
        this.isOpen = false;

        document.removeEventListener('pointerdown', this.midDown );
        document.removeEventListener('pointerup', this.midUp );
        document.removeEventListener('pointermove', this.midMove );

        this.code.clear();

        this.content.innerHTML = '';

        document.body.removeChild( this.content );
        
    }

    onUpdate ( code ){

        let b = this.validate( code );//this.useCodeMirror ? this.validateMirror( code ) : this.validate( code )
        
        if( !this.refresh ) this.refresh = this.code.isEdit;

        if( b && this.refresh ){ 
            if( Main ) Main.injectCode( code );
            if( this.source ) this.send({ type:'inject', code:code });
            this.refresh = false;
        }

    }

    set ( code, name, refresh ){

        //console.log('editor set')

        if( !this.isOpen ) return

        this.setTitle( name );

        if( this.isSolo ) location.hash = name;

        if( refresh ) this.refresh = refresh;

        this.setInternCode( code );

    }

    setInternCode( code ) {

        if( this.useCodeMirror ) this.code.setValue( code );
        else this.code.updateCode( code );
        this.code.isEdit = false;

    }

    get () {

        return this.useCodeMirror ? this.code.getValue() : this.code.getCode()

    }

    save ( e ) {

        o$1.save( { name:this.codeName, data:this.get(), type:'js' } );
    
    }

    load ( e ) {

        o$1.load( { callback:this.onLoad.bind(this), type:'js' } );
    
    }

    onLoad ( src, Name ) {

        const name = Name.substring( 0, Name.lastIndexOf('.') );
        this.set( src, name );

    }

    setInfo ( message, e=0 ) {

        this.info.style.color = e ? '#ff0000':'#7c806c';
        this.info.innerHTML = message;

    }

    /*validate ( code ) {

        if( !code ) return
        if( !this.esprimaReady ) return true

        try {
            const syntax = esprima.parseModule(code, { tolerant: true, loc: true, range: true, jsx: true });
            if (syntax.errors.length > 0) {
                for (let i = 0; i < syntax.errors.length; ++i) {
                    let e = syntax.errors[i]
                    console.log( e.description, e.lineNumber, e.column )
                    this.code.addError(e.description, e.lineNumber, e.column)
                }
                this.setInfo('Invalid code. Total issues: ' + syntax.errors.length, 1)
                return false
            } else {
                if (syntax.body.length === 0) this.setInfo('info', 'Empty code. Nothing to validate.')
                this.setInfo('&#2039;')
                this.code.noError()
                return true
            }
        } catch (e) {
            this.code.addError(e.toString(), e.lineNumber, e.column);
            this.setInfo(e.toString(), 1)
            return false
        }

    }*/

    validate ( code ) {

        if( !code ) return
        if( !this.esprimaReady ) return true

        let errorLines = [];

        try {
            errorLines = esprima.parseModule( code, { tolerant: true, loc: true, range: true, jsx: true }).errors;
        } catch ( e ) {
            errorLines.push( e );
        }

        let j = errorLines.length;
        if( j === 0) this.setInfo('&#2039;');
        else this.setInfo('Invalid code. Total issues: ' + j , 1);

        this.code.addError( errorLines );

        return j === 0

    }

    /*validateMirror ( value ) {

        if( !value ) return
        if( !this.esprimaReady ) return true

        const code = this.code
        const errorLines = this.errorLines
        const widgets = this.widgets
        let _selt = this

        return code.operation( function () {
            while ( errorLines.length > 0 ) code.removeLineClass( errorLines.shift(), 'background', 'errorLine' );
            var i = widgets.length;
            while(i--) code.removeLineWidget( widgets[ i ] );
            widgets.length = 0;
            var string = value//currentCode;
            try {
                var result = esprima.parse( string, { tolerant: true } ).errors;
                i = result.length;
                while(i--){
                    var error = result[ i ];
                    var m = document.createElement( 'div' );
                    m.className = 'esprima-error';
                    m.textContent = error.message.replace(/Line [0-9]+: /, '');
                    var l = error.lineNumber - 1;
                    errorLines.push( l );
                    code.addLineClass( l, 'background', 'errorLine' );
                    var widget = code.addLineWidget( l, m );
                    widgets.push( widget );
                }
            } catch ( error ) {
                var m = document.createElement( 'div' );
                m.className = 'esprima-error';
                m.textContent = error.message.replace(/Line [0-9]+: /, '');
                var l = error.lineNumber - 1;
                errorLines.push( l );
                code.addLineClass( l, 'background', 'errorLine' );
                var widget = code.addLineWidget( l, m );
                widgets.push( widget );
            }
            let rs = errorLines.length ;
            if( rs === 0) _selt.setInfo('&#2039;')
            else _selt.setInfo('Invalid code. Total issues: ' + rs , 1)
            return rs === 0
        });

    }*/

    drop ( e ) {

        e.preventDefault();
        if ( !e.dataTransfer.items) return

        const file = e.dataTransfer.files[0];
        const reader = new FileReader();
        const name = file.name;
        const type = name.substring(name.lastIndexOf('.')+1, name.length );
        const finalName = name.substring( name.lastIndexOf('/')+1, name.lastIndexOf('.') );

        if ( type === 'js' ) reader.readAsText( file );
        else return

        reader.onload = function ( e ) {
            this.set( e.target.result, finalName, true );
        }.bind(this);

    }

}

/**
 * postprocessing v6.35.2 build Thu Mar 14 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rüschen
 * @license Zlib
 */


// src/core/Timer.js
var MILLISECONDS_TO_SECONDS = 1 / 1e3;
var SECONDS_TO_MILLISECONDS = 1e3;
var Timer$1 = class Timer {
  /**
   * Constructs a new timer.
   */
  constructor() {
    this.startTime = performance.now();
    this.previousTime = 0;
    this.currentTime = 0;
    this._delta = 0;
    this._elapsed = 0;
    this._fixedDelta = 1e3 / 60;
    this.timescale = 1;
    this.useFixedDelta = false;
    this._autoReset = false;
  }
  /**
   * Enables or disables auto reset based on page visibility.
   *
   * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page
   * is hidden. Has no effect if the API is not supported.
   *
   * @type {Boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API
   */
  get autoReset() {
    return this._autoReset;
  }
  set autoReset(value) {
    if (typeof document !== "undefined" && document.hidden !== void 0) {
      if (value) {
        document.addEventListener("visibilitychange", this);
      } else {
        document.removeEventListener("visibilitychange", this);
      }
      this._autoReset = value;
    }
  }
  get delta() {
    return this._delta * MILLISECONDS_TO_SECONDS;
  }
  get fixedDelta() {
    return this._fixedDelta * MILLISECONDS_TO_SECONDS;
  }
  set fixedDelta(value) {
    this._fixedDelta = value * SECONDS_TO_MILLISECONDS;
  }
  get elapsed() {
    return this._elapsed * MILLISECONDS_TO_SECONDS;
  }
  /**
   * Updates this timer.
   *
   * @param {Boolean} [timestamp] - The current time in milliseconds.
   */
  update(timestamp) {
    if (this.useFixedDelta) {
      this._delta = this.fixedDelta;
    } else {
      this.previousTime = this.currentTime;
      this.currentTime = (timestamp !== void 0 ? timestamp : performance.now()) - this.startTime;
      this._delta = this.currentTime - this.previousTime;
    }
    this._delta *= this.timescale;
    this._elapsed += this._delta;
  }
  /**
   * Resets this timer.
   */
  reset() {
    this._delta = 0;
    this._elapsed = 0;
    this.currentTime = performance.now() - this.startTime;
  }
  getDelta() {
    return this.delta;
  }
  getElapsed() {
    return this.elapsed;
  }
  handleEvent(e) {
    if (!document.hidden) {
      this.currentTime = performance.now() - this.startTime;
    }
  }
  dispose() {
    this.autoReset = false;
  }
};
var dummyCamera = /* @__PURE__ */ new Camera();
var geometry = null;
function getFullscreenTriangle() {
  if (geometry === null) {
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
    geometry = new BufferGeometry();
    if (geometry.setAttribute !== void 0) {
      geometry.setAttribute("position", new BufferAttribute(vertices, 3));
      geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
    } else {
      geometry.addAttribute("position", new BufferAttribute(vertices, 3));
      geometry.addAttribute("uv", new BufferAttribute(uvs, 2));
    }
  }
  return geometry;
}
var Pass = class _Pass {
  /**
   * Constructs a new pass.
   *
   * @param {String} [name] - The name of this pass. Does not have to be unique.
   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.
   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.
   */
  constructor(name = "Pass", scene = new Scene(), camera = dummyCamera) {
    this.name = name;
    this.renderer = null;
    this.scene = scene;
    this.camera = camera;
    this.screen = null;
    this.rtt = true;
    this.needsSwap = true;
    this.needsDepthTexture = false;
    this.enabled = true;
  }
  /**
   * Sets the render to screen flag.
   *
   * If this flag is changed, the fullscreen material will be updated as well.
   *
   * @type {Boolean}
   */
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(value) {
    if (this.rtt === value) {
      const material = this.fullscreenMaterial;
      if (material !== null) {
        material.needsUpdate = true;
      }
      this.rtt = !value;
    }
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Sets the renderer
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Indicates whether this pass is enabled.
   *
   * @deprecated Use enabled instead.
   * @return {Boolean} Whether this pass is enabled.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables this pass.
   *
   * @deprecated Use enabled instead.
   * @param {Boolean} value - Whether the pass should be enabled.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * The fullscreen material.
   *
   * @type {Material}
   */
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(value) {
    let screen = this.screen;
    if (screen !== null) {
      screen.material = value;
    } else {
      screen = new Mesh(getFullscreenTriangle(), value);
      screen.frustumCulled = false;
      if (this.scene === null) {
        this.scene = new Scene();
      }
      this.scene.add(screen);
      this.screen = screen;
    }
  }
  /**
   * Returns the current fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @return {Material} The current fullscreen material, or null if there is none.
   */
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  /**
   * Sets the fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @protected
   * @param {Material} value - A fullscreen material.
   */
  setFullscreenMaterial(value) {
    this.fullscreenMaterial = value;
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return null;
  }
  /**
   * Sets the depth texture.
   *
   * This method will be called automatically by the {@link EffectComposer}.
   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Renders this pass.
   *
   * This is an abstract method that must be overridden.
   *
   * @abstract
   * @throws {Error} An error is thrown if the method is not overridden.
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    throw new Error("Render method not implemented!");
  }
  /**
   * Sets the size.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when this pass is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for disposable properties and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free
   * memory when you're certain that you don't need this pass anymore.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof _Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};

// src/passes/ClearMaskPass.js
var ClearMaskPass = class extends Pass {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super("ClearMaskPass", null, null);
    this.needsSwap = false;
  }
  /**
   * Disables the global stencil test.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const stencil = renderer.state.buffers.stencil;
    stencil.setLocked(false);
    stencil.setTest(false);
  }
};
var revision = Number(REVISION.replace(/\D+/g, ""));
function updateFragmentShader(fragmentShader) {
  if (revision < 154) {
    return fragmentShader.replace("colorspace_fragment", "encodings_fragment");
  }
  return fragmentShader;
}

// src/materials/glsl/copy.frag
var copy_default = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}";

// src/materials/glsl/common.vert
var common_default = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/CopyMaterial.js
var CopyMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new copy material.
   */
  constructor() {
    super({
      name: "CopyMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        opacity: new Uniform(1)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: copy_default,
      vertexShader: common_default
    });
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Number} value - The buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Returns the opacity.
   *
   * @deprecated Use opacity instead.
   * @return {Number} The opacity.
   */
  getOpacity(value) {
    return this.uniforms.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @deprecated Use opacity instead.
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.uniforms.opacity.value = value;
  }
};

// src/passes/CopyPass.js
var CopyPass = class extends Pass {
  /**
   * Constructs a new save pass.
   *
   * @param {WebGLRenderTarget} [renderTarget] - A render target.
   * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.
   */
  constructor(renderTarget, autoResize = true) {
    super("CopyPass");
    this.fullscreenMaterial = new CopyMaterial();
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      this.renderTarget.texture.name = "CopyPass.Target";
    }
    this.autoResize = autoResize;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @type {Boolean}
   */
  get resize() {
    return this.autoResize;
  }
  set resize(value) {
    this.autoResize = value;
  }
  /**
   * The output texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the output texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @param {Boolean} value - Whether the render target size should be updated automatically.
   */
  setAutoResizeEnabled(value) {
    this.autoResize = value;
  }
  /**
   * Saves the input buffer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.fullscreenMaterial.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    if (this.autoResize) {
      this.renderTarget.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};
var color = /* @__PURE__ */ new Color();
var ClearPass = class extends Pass {
  /**
   * Constructs a new clear pass.
   *
   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.
   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.
   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.
   */
  constructor(color2 = true, depth = true, stencil = false) {
    super("ClearPass", null, null);
    this.needsSwap = false;
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
    this.overrideClearColor = null;
    this.overrideClearAlpha = -1;
  }
  /**
   * Sets the clear flags.
   *
   * @param {Boolean} color - Whether the color buffer should be cleared.
   * @param {Boolean} depth - Whether the depth buffer should be cleared.
   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.
   */
  setClearFlags(color2, depth, stencil) {
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
  }
  /**
   * Returns the override clear color. Default is null.
   *
   * @deprecated Use overrideClearColor instead.
   * @return {Color} The clear color.
   */
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  /**
   * Sets the override clear color.
   *
   * @deprecated Use overrideClearColor instead.
   * @param {Color} value - The clear color.
   */
  setOverrideClearColor(value) {
    this.overrideClearColor = value;
  }
  /**
   * Returns the override clear alpha. Default is -1.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @return {Number} The clear alpha.
   */
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  /**
   * Sets the override clear alpha.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @param {Number} value - The clear alpha.
   */
  setOverrideClearAlpha(value) {
    this.overrideClearAlpha = value;
  }
  /**
   * Clears the input buffer or the screen.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const overrideClearColor = this.overrideClearColor;
    const overrideClearAlpha = this.overrideClearAlpha;
    const clearAlpha = renderer.getClearAlpha();
    const hasOverrideClearColor = overrideClearColor !== null;
    const hasOverrideClearAlpha = overrideClearAlpha >= 0;
    if (hasOverrideClearColor) {
      renderer.getClearColor(color);
      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(overrideClearAlpha);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
    renderer.clear(this.color, this.depth, this.stencil);
    if (hasOverrideClearColor) {
      renderer.setClearColor(color, clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(clearAlpha);
    }
  }
};

// src/passes/MaskPass.js
var MaskPass = class extends Pass {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use.
   */
  constructor(scene, camera) {
    super("MaskPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass(false, false, true);
    this.inverse = false;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  /**
   * Indicates whether the mask should be inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this.inverse;
  }
  set inverted(value) {
    this.inverse = value;
  }
  /**
   * Indicates whether this pass should clear the stencil buffer.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the internal clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Indicates whether the mask is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the mask is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Enables or disable mask inversion.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the mask should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const context = renderer.getContext();
    const buffers = renderer.state.buffers;
    const scene = this.scene;
    const camera = this.camera;
    const clearPass = this.clearPass;
    const writeValue = this.inverted ? 0 : 1;
    const clearValue = 1 - writeValue;
    buffers.color.setMask(false);
    buffers.depth.setMask(false);
    buffers.color.setLocked(true);
    buffers.depth.setLocked(true);
    buffers.stencil.setTest(true);
    buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    buffers.stencil.setClear(clearValue);
    buffers.stencil.setLocked(true);
    if (this.clearPass.enabled) {
      if (this.renderToScreen) {
        clearPass.render(renderer, null);
      } else {
        clearPass.render(renderer, inputBuffer);
        clearPass.render(renderer, outputBuffer);
      }
    }
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
    } else {
      renderer.setRenderTarget(inputBuffer);
      renderer.render(scene, camera);
      renderer.setRenderTarget(outputBuffer);
      renderer.render(scene, camera);
    }
    buffers.color.setLocked(false);
    buffers.depth.setLocked(false);
    buffers.stencil.setLocked(false);
    buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    buffers.stencil.setLocked(true);
  }
};

// src/core/EffectComposer.js
var EffectComposer = class {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer that should be used.
   * @param {Object} [options] - The options.
   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.
   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.
   * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.
   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
   * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.
   */
  constructor(renderer = null, {
    depthBuffer = true,
    stencilBuffer = false,
    multisampling = 0,
    frameBufferType
  } = {}) {
    this.renderer = null;
    this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);
    this.outputBuffer = this.inputBuffer.clone();
    this.copyPass = new CopyPass();
    this.depthTexture = null;
    this.passes = [];
    this.timer = new Timer$1();
    this.autoRenderToScreen = true;
    this.setRenderer(renderer);
  }
  /**
   * The current amount of samples used for multisample anti-aliasing.
   *
   * @type {Number}
   */
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  /**
   * Sets the amount of MSAA samples.
   *
   * Requires WebGL 2. Set to zero to disable multisampling.
   *
   * @type {Number}
   */
  set multisampling(value) {
    const buffer = this.inputBuffer;
    const multisampling = this.multisampling;
    if (multisampling > 0 && value > 0) {
      this.inputBuffer.samples = value;
      this.outputBuffer.samples = value;
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
    } else if (multisampling !== value) {
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
      this.inputBuffer = this.createBuffer(
        buffer.depthBuffer,
        buffer.stencilBuffer,
        buffer.texture.type,
        value
      );
      this.inputBuffer.depthTexture = this.depthTexture;
      this.outputBuffer = this.inputBuffer.clone();
    }
  }
  /**
   * Returns the internal timer.
   *
   * @return {Timer} The timer.
   */
  getTimer() {
    return this.timer;
  }
  /**
   * Returns the renderer.
   *
   * @return {WebGLRenderer} The renderer.
   */
  getRenderer() {
    return this.renderer;
  }
  /**
   * Sets the renderer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
    if (renderer !== null) {
      const size = renderer.getSize(new Vector2());
      const alpha = renderer.getContext().getContextAttributes().alpha;
      const frameBufferType = this.inputBuffer.texture.type;
      if (frameBufferType === UnsignedByteType && renderer.outputColorSpace === SRGBColorSpace) {
        this.inputBuffer.texture.colorSpace = SRGBColorSpace;
        this.outputBuffer.texture.colorSpace = SRGBColorSpace;
        this.inputBuffer.dispose();
        this.outputBuffer.dispose();
      }
      renderer.autoClear = false;
      this.setSize(size.width, size.height);
      for (const pass of this.passes) {
        pass.initialize(renderer, alpha, frameBufferType);
      }
    }
  }
  /**
   * Replaces the current renderer with the given one.
   *
   * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the
   * previous one, all passes will be updated.
   *
   * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM
   * element of the new renderer will take its place.
   *
   * @deprecated Use setRenderer instead.
   * @param {WebGLRenderer} renderer - The new renderer.
   * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.
   * @return {WebGLRenderer} The old renderer.
   */
  replaceRenderer(renderer, updateDOM = true) {
    const oldRenderer = this.renderer;
    const parent = oldRenderer.domElement.parentNode;
    this.setRenderer(renderer);
    if (updateDOM && parent !== null) {
      parent.removeChild(oldRenderer.domElement);
      parent.appendChild(renderer.domElement);
    }
    return oldRenderer;
  }
  /**
   * Creates a depth texture attachment that will be provided to all passes.
   *
   * Note: When a shader reads from a depth texture and writes to a render target that uses the same depth texture
   * attachment, the depth information will be lost. This happens even if `depthWrite` is disabled.
   *
   * @private
   * @return {DepthTexture} The depth texture.
   */
  createDepthTexture() {
    const depthTexture = this.depthTexture = new DepthTexture();
    this.inputBuffer.depthTexture = depthTexture;
    this.inputBuffer.dispose();
    if (this.inputBuffer.stencilBuffer) {
      depthTexture.format = DepthStencilFormat;
      depthTexture.type = UnsignedInt248Type;
    } else {
      depthTexture.type = UnsignedIntType;
    }
    return depthTexture;
  }
  /**
   * Deletes the current depth texture.
   *
   * @private
   */
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose();
      this.depthTexture = null;
      this.inputBuffer.depthTexture = null;
      this.inputBuffer.dispose();
      for (const pass of this.passes) {
        pass.setDepthTexture(null);
      }
    }
  }
  /**
   * Creates a new render target.
   *
   * @deprecated Create buffers manually via WebGLRenderTarget instead.
   * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.
   * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.
   * @param {Number} type - The frame buffer type.
   * @param {Number} multisampling - The number of samples to use for antialiasing.
   * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.
   */
  createBuffer(depthBuffer, stencilBuffer, type, multisampling) {
    const renderer = this.renderer;
    const size = renderer === null ? new Vector2() : renderer.getDrawingBufferSize(new Vector2());
    const options = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer,
      depthBuffer,
      type
    };
    const renderTarget = new WebGLRenderTarget(size.width, size.height, options);
    if (multisampling > 0) {
      renderTarget.ignoreDepthForMultisampleCopy = false;
      renderTarget.samples = multisampling;
    }
    if (type === UnsignedByteType && renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
      renderTarget.texture.colorSpace = SRGBColorSpace;
    }
    renderTarget.texture.name = "EffectComposer.Buffer";
    renderTarget.texture.generateMipmaps = false;
    return renderTarget;
  }
  /**
   * Can be used to change the main scene for all registered passes and effects.
   *
   * @param {Scene} scene - The scene.
   */
  setMainScene(scene) {
    for (const pass of this.passes) {
      pass.mainScene = scene;
    }
  }
  /**
   * Can be used to change the main camera for all registered passes and effects.
   *
   * @param {Camera} camera - The camera.
   */
  setMainCamera(camera) {
    for (const pass of this.passes) {
      pass.mainCamera = camera;
    }
  }
  /**
   * Adds a pass, optionally at a specific index.
   *
   * @param {Pass} pass - A new pass.
   * @param {Number} [index] - An index at which the pass should be inserted.
   */
  addPass(pass, index) {
    const passes = this.passes;
    const renderer = this.renderer;
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    const alpha = renderer.getContext().getContextAttributes().alpha;
    const frameBufferType = this.inputBuffer.texture.type;
    pass.setRenderer(renderer);
    pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    pass.initialize(renderer, alpha, frameBufferType);
    if (this.autoRenderToScreen) {
      if (passes.length > 0) {
        passes[passes.length - 1].renderToScreen = false;
      }
      if (pass.renderToScreen) {
        this.autoRenderToScreen = false;
      }
    }
    if (index !== void 0) {
      passes.splice(index, 0, pass);
    } else {
      passes.push(pass);
    }
    if (this.autoRenderToScreen) {
      passes[passes.length - 1].renderToScreen = true;
    }
    if (pass.needsDepthTexture || this.depthTexture !== null) {
      if (this.depthTexture === null) {
        const depthTexture = this.createDepthTexture();
        for (pass of passes) {
          pass.setDepthTexture(depthTexture);
        }
      } else {
        pass.setDepthTexture(this.depthTexture);
      }
    }
  }
  /**
   * Removes a pass.
   *
   * @param {Pass} pass - The pass.
   */
  removePass(pass) {
    const passes = this.passes;
    const index = passes.indexOf(pass);
    const exists = index !== -1;
    const removed = exists && passes.splice(index, 1).length > 0;
    if (removed) {
      if (this.depthTexture !== null) {
        const reducer = (a, b) => a || b.needsDepthTexture;
        const depthTextureRequired = passes.reduce(reducer, false);
        if (!depthTextureRequired) {
          if (pass.getDepthTexture() === this.depthTexture) {
            pass.setDepthTexture(null);
          }
          this.deleteDepthTexture();
        }
      }
      if (this.autoRenderToScreen) {
        if (index === passes.length) {
          pass.renderToScreen = false;
          if (passes.length > 0) {
            passes[passes.length - 1].renderToScreen = true;
          }
        }
      }
    }
  }
  /**
   * Removes all passes.
   */
  removeAllPasses() {
    const passes = this.passes;
    this.deleteDepthTexture();
    if (passes.length > 0) {
      if (this.autoRenderToScreen) {
        passes[passes.length - 1].renderToScreen = false;
      }
      this.passes = [];
    }
  }
  /**
   * Renders all enabled passes in the order in which they were added.
   *
   * @param {Number} [deltaTime] - The time since the last frame in seconds.
   */
  render(deltaTime) {
    const renderer = this.renderer;
    const copyPass = this.copyPass;
    let inputBuffer = this.inputBuffer;
    let outputBuffer = this.outputBuffer;
    let stencilTest = false;
    let context, stencil, buffer;
    if (deltaTime === void 0) {
      this.timer.update();
      deltaTime = this.timer.getDelta();
    }
    for (const pass of this.passes) {
      if (pass.enabled) {
        pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
        if (pass.needsSwap) {
          if (stencilTest) {
            copyPass.renderToScreen = pass.renderToScreen;
            context = renderer.getContext();
            stencil = renderer.state.buffers.stencil;
            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
            copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
            stencil.setFunc(context.EQUAL, 1, 4294967295);
          }
          buffer = inputBuffer;
          inputBuffer = outputBuffer;
          outputBuffer = buffer;
        }
        if (pass instanceof MaskPass) {
          stencilTest = true;
        } else if (pass instanceof ClearMaskPass) {
          stencilTest = false;
        }
      }
    }
  }
  /**
   * Sets the size of the buffers, passes and the renderer.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.
   */
  setSize(width, height, updateStyle) {
    const renderer = this.renderer;
    const currentSize = renderer.getSize(new Vector2());
    if (width === void 0 || height === void 0) {
      width = currentSize.width;
      height = currentSize.height;
    }
    if (currentSize.width !== width || currentSize.height !== height) {
      renderer.setSize(width, height, updateStyle);
    }
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    for (const pass of this.passes) {
      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    }
  }
  /**
   * Resets this composer by deleting all passes and creating new buffers.
   */
  reset() {
    this.dispose();
    this.autoRenderToScreen = true;
  }
  /**
   * Disposes this composer and all passes.
   */
  dispose() {
    for (const pass of this.passes) {
      pass.dispose();
    }
    this.passes = [];
    if (this.inputBuffer !== null) {
      this.inputBuffer.dispose();
    }
    if (this.outputBuffer !== null) {
      this.outputBuffer.dispose();
    }
    this.deleteDepthTexture();
    this.copyPass.dispose();
    this.timer.dispose();
  }
};

// src/enums/EffectAttribute.js
var EffectAttribute = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
};

// src/enums/EffectShaderSection.js
var EffectShaderSection = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
};

// src/core/EffectShaderData.js
var EffectShaderData = class {
  /**
   * Constructs new shader data.
   */
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      [EffectShaderSection.FRAGMENT_HEAD, null],
      [EffectShaderSection.FRAGMENT_MAIN_UV, null],
      [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null],
      [EffectShaderSection.VERTEX_HEAD, null],
      [EffectShaderSection.VERTEX_MAIN_SUPPORT, null]
    ]);
    this.defines = /* @__PURE__ */ new Map();
    this.uniforms = /* @__PURE__ */ new Map();
    this.blendModes = /* @__PURE__ */ new Map();
    this.extensions = /* @__PURE__ */ new Set();
    this.attributes = EffectAttribute.NONE;
    this.varyings = /* @__PURE__ */ new Set();
    this.uvTransformation = false;
    this.readDepth = false;
    this.colorSpace = LinearSRGBColorSpace;
  }
};
var workaroundEnabled = false;
var OverrideMaterialManager = class {
  /**
   * Constructs a new override material manager.
   *
   * @param {Material} [material=null] - An override material.
   */
  constructor(material = null) {
    this.originalMaterials = /* @__PURE__ */ new Map();
    this.material = null;
    this.materials = null;
    this.materialsBackSide = null;
    this.materialsDoubleSide = null;
    this.materialsFlatShaded = null;
    this.materialsFlatShadedBackSide = null;
    this.materialsFlatShadedDoubleSide = null;
    this.setMaterial(material);
    this.meshCount = 0;
    this.replaceMaterial = (node) => {
      if (node.isMesh) {
        let materials;
        if (node.material.flatShading) {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsFlatShadedDoubleSide;
              break;
            case BackSide:
              materials = this.materialsFlatShadedBackSide;
              break;
            default:
              materials = this.materialsFlatShaded;
              break;
          }
        } else {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsDoubleSide;
              break;
            case BackSide:
              materials = this.materialsBackSide;
              break;
            default:
              materials = this.materials;
              break;
          }
        }
        this.originalMaterials.set(node, node.material);
        if (node.isSkinnedMesh) {
          node.material = materials[2];
        } else if (node.isInstancedMesh) {
          node.material = materials[1];
        } else {
          node.material = materials[0];
        }
        ++this.meshCount;
      }
    };
  }
  /**
   * Clones the given material.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Material} The cloned material.
   */
  cloneMaterial(material) {
    if (!(material instanceof ShaderMaterial)) {
      return material.clone();
    }
    const uniforms = material.uniforms;
    const textureUniforms = /* @__PURE__ */ new Map();
    for (const key in uniforms) {
      const value = uniforms[key].value;
      if (value.isRenderTargetTexture) {
        uniforms[key].value = null;
        textureUniforms.set(key, value);
      }
    }
    const clone = material.clone();
    for (const entry of textureUniforms) {
      uniforms[entry[0]].value = entry[1];
      clone.uniforms[entry[0]].value = entry[1];
    }
    return clone;
  }
  /**
   * Sets the override material.
   *
   * @param {Material} material - The material.
   */
  setMaterial(material) {
    this.disposeMaterials();
    this.material = material;
    if (material !== null) {
      const materials = this.materials = [
        this.cloneMaterial(material),
        this.cloneMaterial(material),
        this.cloneMaterial(material)
      ];
      for (const m2 of materials) {
        m2.uniforms = Object.assign({}, material.uniforms);
        m2.side = FrontSide;
      }
      materials[2].skinning = true;
      this.materialsBackSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = BackSide;
        return c2;
      });
      this.materialsDoubleSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = DoubleSide;
        return c2;
      });
      this.materialsFlatShaded = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        return c2;
      });
      this.materialsFlatShadedBackSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = BackSide;
        return c2;
      });
      this.materialsFlatShadedDoubleSide = materials.map((m2) => {
        const c2 = this.cloneMaterial(m2);
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = DoubleSide;
        return c2;
      });
    }
  }
  /**
   * Renders the scene with the override material.
   *
   * @private
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - A scene.
   * @param {Camera} camera - A camera.
   */
  render(renderer, scene, camera) {
    const shadowMapEnabled = renderer.shadowMap.enabled;
    renderer.shadowMap.enabled = false;
    if (workaroundEnabled) {
      const originalMaterials = this.originalMaterials;
      this.meshCount = 0;
      scene.traverse(this.replaceMaterial);
      renderer.render(scene, camera);
      for (const entry of originalMaterials) {
        entry[0].material = entry[1];
      }
      if (this.meshCount !== originalMaterials.size) {
        originalMaterials.clear();
      }
    } else {
      const overrideMaterial = scene.overrideMaterial;
      scene.overrideMaterial = this.material;
      renderer.render(scene, camera);
      scene.overrideMaterial = overrideMaterial;
    }
    renderer.shadowMap.enabled = shadowMapEnabled;
  }
  /**
   * Deletes cloned override materials.
   *
   * @private
   */
  disposeMaterials() {
    if (this.material !== null) {
      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const m2 of materials) {
        m2.dispose();
      }
    }
  }
  /**
   * Performs cleanup tasks.
   */
  dispose() {
    this.originalMaterials.clear();
    this.disposeMaterials();
  }
  /**
   * Indicates whether the override material workaround is enabled.
   *
   * @type {Boolean}
   */
  static get workaroundEnabled() {
    return workaroundEnabled;
  }
  /**
   * Enables or disables the override material workaround globally.
   *
   * This only affects post processing passes and effects.
   *
   * @type {Boolean}
   */
  static set workaroundEnabled(value) {
    workaroundEnabled = value;
  }
};
var AUTO_SIZE = -1;
var Resolution = class extends EventDispatcher {
  /**
   * Constructs a new resolution.
   *
   * TODO Remove resizable param.
   * @param {Resizable} resizable - A resizable object.
   * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.
   * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.
   * @param {Number} [scale=1.0] - A resolution scale.
   */
  constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {
    super();
    this.resizable = resizable;
    this.baseSize = new Vector2(1, 1);
    this.preferredSize = new Vector2(width, height);
    this.target = this.preferredSize;
    this.s = scale;
    this.effectiveSize = new Vector2();
    this.addEventListener("change", () => this.updateEffectiveSize());
    this.updateEffectiveSize();
  }
  /**
   * Calculates the effective size.
   *
   * @private
   */
  updateEffectiveSize() {
    const base = this.baseSize;
    const preferred = this.preferredSize;
    const effective = this.effectiveSize;
    const scale = this.scale;
    if (preferred.width !== AUTO_SIZE) {
      effective.width = preferred.width;
    } else if (preferred.height !== AUTO_SIZE) {
      effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));
    } else {
      effective.width = Math.round(base.width * scale);
    }
    if (preferred.height !== AUTO_SIZE) {
      effective.height = preferred.height;
    } else if (preferred.width !== AUTO_SIZE) {
      effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));
    } else {
      effective.height = Math.round(base.height * scale);
    }
  }
  /**
   * The effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @type {Number}
   */
  get width() {
    return this.effectiveSize.width;
  }
  set width(value) {
    this.preferredWidth = value;
  }
  /**
   * The effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @type {Number}
   */
  get height() {
    return this.effectiveSize.height;
  }
  set height(value) {
    this.preferredHeight = value;
  }
  /**
   * Returns the effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @deprecated Use width instead.
   * @return {Number} The effective width.
   */
  getWidth() {
    return this.width;
  }
  /**
   * Returns the effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @deprecated Use height instead.
   * @return {Number} The effective height.
   */
  getHeight() {
    return this.height;
  }
  /**
   * The resolution scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.s;
  }
  set scale(value) {
    if (this.s !== value) {
      this.s = value;
      this.preferredSize.setScalar(AUTO_SIZE);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the current resolution scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.
   *
   * @deprecated Use scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.scale = value;
  }
  /**
   * The base width.
   *
   * @type {Number}
   */
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(value) {
    if (this.baseSize.width !== value) {
      this.baseSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base width.
   *
   * @deprecated Use baseWidth instead.
   * @return {Number} The base width.
   */
  getBaseWidth() {
    return this.baseWidth;
  }
  /**
   * Sets the base width.
   *
   * @deprecated Use baseWidth instead.
   * @param {Number} value - The width.
   */
  setBaseWidth(value) {
    this.baseWidth = value;
  }
  /**
   * The base height.
   *
   * @type {Number}
   */
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(value) {
    if (this.baseSize.height !== value) {
      this.baseSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base height.
   *
   * @deprecated Use baseHeight instead.
   * @return {Number} The base height.
   */
  getBaseHeight() {
    return this.baseHeight;
  }
  /**
   * Sets the base height.
   *
   * @deprecated Use baseHeight instead.
   * @param {Number} value - The height.
   */
  setBaseHeight(value) {
    this.baseHeight = value;
  }
  /**
   * Sets the base size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setBaseSize(width, height) {
    if (this.baseSize.width !== width || this.baseSize.height !== height) {
      this.baseSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * The preferred width.
   *
   * @type {Number}
   */
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(value) {
    if (this.preferredSize.width !== value) {
      this.preferredSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred width.
   *
   * @deprecated Use preferredWidth instead.
   * @return {Number} The preferred width.
   */
  getPreferredWidth() {
    return this.preferredWidth;
  }
  /**
   * Sets the preferred width.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.
   *
   * @deprecated Use preferredWidth instead.
   * @param {Number} value - The width.
   */
  setPreferredWidth(value) {
    this.preferredWidth = value;
  }
  /**
   * The preferred height.
   *
   * @type {Number}
   */
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(value) {
    if (this.preferredSize.height !== value) {
      this.preferredSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred height.
   *
   * @deprecated Use preferredHeight instead.
   * @return {Number} The preferred height.
   */
  getPreferredHeight() {
    return this.preferredHeight;
  }
  /**
   * Sets the preferred height.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.
   *
   * @deprecated Use preferredHeight instead.
   * @param {Number} value - The height.
   */
  setPreferredHeight(value) {
    this.preferredHeight = value;
  }
  /**
   * Sets the preferred size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setPreferredSize(width, height) {
    if (this.preferredSize.width !== width || this.preferredSize.height !== height) {
      this.preferredSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Copies the given resolution.
   *
   * @param {Resolution} resolution - The resolution.
   */
  copy(resolution) {
    this.s = resolution.scale;
    this.baseSize.set(resolution.baseWidth, resolution.baseHeight);
    this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);
    this.dispatchEvent({ type: "change" });
    this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  /**
   * An auto sizing constant.
   *
   * Can be used to automatically calculate the width or height based on the original aspect ratio.
   *
   * @type {Number}
   */
  static get AUTO_SIZE() {
    return AUTO_SIZE;
  }
};

// src/enums/BlendFunction.js
var BlendFunction = {
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
};

// src/effects/blending/glsl/add.frag
var add_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}";

// src/effects/blending/glsl/alpha.frag
var alpha_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}";

// src/effects/blending/glsl/average.frag
var average_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}";

// src/effects/blending/glsl/color.frag
var color_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/color-burn.frag
var color_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}";

// src/effects/blending/glsl/color-dodge.frag
var color_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/darken.frag
var darken_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}";

// src/effects/blending/glsl/difference.frag
var difference_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}";

// src/effects/blending/glsl/divide.frag
var divide_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}";

// src/effects/blending/glsl/exclusion.frag
var exclusion_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}";

// src/effects/blending/glsl/hard-light.frag
var hard_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/hard-mix.frag
var hard_mix_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}";

// src/effects/blending/glsl/hue.frag
var hue_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/invert.frag
var invert_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}";

// src/effects/blending/glsl/invert-rgb.frag
var invert_rgb_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}";

// src/effects/blending/glsl/lighten.frag
var lighten_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}";

// src/effects/blending/glsl/linear-burn.frag
var linear_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}";

// src/effects/blending/glsl/linear-dodge.frag
var linear_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}";

// src/effects/blending/glsl/linear-light.frag
var linear_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}";

// src/effects/blending/glsl/luminosity.frag
var luminosity_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/multiply.frag
var multiply_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}";

// src/effects/blending/glsl/negation.frag
var negation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}";

// src/effects/blending/glsl/normal.frag
var normal_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}";

// src/effects/blending/glsl/overlay.frag
var overlay_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}";

// src/effects/blending/glsl/pin-light.frag
var pin_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}";

// src/effects/blending/glsl/reflect.frag
var reflect_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/saturation.frag
var saturation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/screen.frag
var screen_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}";

// src/effects/blending/glsl/soft-light.frag
var soft_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}";

// src/effects/blending/glsl/src.frag
var src_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}";

// src/effects/blending/glsl/subtract.frag
var subtract_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}";

// src/effects/blending/glsl/vivid-light.frag
var vivid_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}";

// src/effects/blending/BlendMode.js
var blendFunctions = /* @__PURE__ */ new Map([
  [BlendFunction.ADD, add_default],
  [BlendFunction.ALPHA, alpha_default],
  [BlendFunction.AVERAGE, average_default],
  [BlendFunction.COLOR, color_default],
  [BlendFunction.COLOR_BURN, color_burn_default],
  [BlendFunction.COLOR_DODGE, color_dodge_default],
  [BlendFunction.DARKEN, darken_default],
  [BlendFunction.DIFFERENCE, difference_default],
  [BlendFunction.DIVIDE, divide_default],
  [BlendFunction.DST, null],
  [BlendFunction.EXCLUSION, exclusion_default],
  [BlendFunction.HARD_LIGHT, hard_light_default],
  [BlendFunction.HARD_MIX, hard_mix_default],
  [BlendFunction.HUE, hue_default],
  [BlendFunction.INVERT, invert_default],
  [BlendFunction.INVERT_RGB, invert_rgb_default],
  [BlendFunction.LIGHTEN, lighten_default],
  [BlendFunction.LINEAR_BURN, linear_burn_default],
  [BlendFunction.LINEAR_DODGE, linear_dodge_default],
  [BlendFunction.LINEAR_LIGHT, linear_light_default],
  [BlendFunction.LUMINOSITY, luminosity_default],
  [BlendFunction.MULTIPLY, multiply_default],
  [BlendFunction.NEGATION, negation_default],
  [BlendFunction.NORMAL, normal_default],
  [BlendFunction.OVERLAY, overlay_default],
  [BlendFunction.PIN_LIGHT, pin_light_default],
  [BlendFunction.REFLECT, reflect_default],
  [BlendFunction.SATURATION, saturation_default],
  [BlendFunction.SCREEN, screen_default],
  [BlendFunction.SOFT_LIGHT, soft_light_default],
  [BlendFunction.SRC, src_default],
  [BlendFunction.SUBTRACT, subtract_default],
  [BlendFunction.VIVID_LIGHT, vivid_light_default]
]);
var BlendMode = class extends EventDispatcher {
  /**
   * Constructs a new blend mode.
   *
   * @param {BlendFunction} blendFunction - The blend function.
   * @param {Number} opacity - The opacity of the color that will be blended with the base color.
   */
  constructor(blendFunction, opacity = 1) {
    super();
    this._blendFunction = blendFunction;
    this.opacity = new Uniform(opacity);
  }
  /**
   * Returns the opacity.
   *
   * @return {Number} The opacity.
   */
  getOpacity() {
    return this.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.opacity.value = value;
  }
  /**
   * The blend function.
   *
   * @type {BlendFunction}
   */
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(value) {
    this._blendFunction = value;
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Returns the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @return {BlendFunction} The blend function.
   */
  getBlendFunction() {
    return this.blendFunction;
  }
  /**
   * Sets the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @param {BlendFunction} value - The blend function.
   */
  setBlendFunction(value) {
    this.blendFunction = value;
  }
  /**
   * Returns the blend function shader code.
   *
   * @return {String} The blend function shader code.
   */
  getShaderCode() {
    return blendFunctions.get(this.blendFunction);
  }
};

// src/enums/KernelSize.js
var KernelSize = {
  MEDIUM: 2,
  LARGE: 3};

// src/materials/glsl/convolution.kawase.frag
var convolution_kawase_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.kawase.vert
var convolution_kawase_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/KawaseBlurMaterial.js
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var KawaseBlurMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new convolution material.
   *
   * TODO Remove texelSize param.
   * @param {Vector4} [texelSize] - Deprecated.
   */
  constructor(texelSize = new Vector4()) {
    super({
      name: "KawaseBlurMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector4()),
        scale: new Uniform(1),
        kernel: new Uniform(0)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_kawase_default,
      vertexShader: convolution_kawase_default2
    });
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernelSize = KernelSize.MEDIUM;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.inputBuffer = value;
  }
  /**
   * The kernel sequence for the current kernel size.
   *
   * @type {Float32Array}
   */
  get kernelSequence() {
    return kernelPresets[this.kernelSize];
  }
  /**
   * The blur scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.uniforms.scale.value;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} value - The scale.
   */
  setScale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the kernel.
   *
   * @return {Float32Array} The kernel.
   * @deprecated Implementation detail, removed with no replacement.
   */
  getKernel() {
    return null;
  }
  /**
   * The current kernel.
   *
   * @type {Number}
   */
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(value) {
    this.uniforms.kernel.value = value;
  }
  /**
   * Sets the current kernel.
   *
   * @deprecated Use kernel instead.
   * @param {Number} value - The kernel.
   */
  setKernel(value) {
    this.kernel = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const x = 1 / width, y = 1 / height;
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
};

// src/passes/KawaseBlurPass.js
var KawaseBlurPass = class extends Pass {
  /**
   * Constructs a new Kawase blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("KawaseBlurPass");
    this.renderTargetA = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "Blur.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "Blur.Target.B";
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this._blurMaterial = new KawaseBlurMaterial();
    this._blurMaterial.kernelSize = kernelSize;
    this.copyMaterial = new CopyMaterial();
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   */
  get blurMaterial() {
    return this._blurMaterial;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   * @protected
   */
  set blurMaterial(value) {
    this._blurMaterial = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use copyMaterial.dithering instead.
   */
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(value) {
    this.copyMaterial.dithering = value;
  }
  /**
   * The kernel size.
   *
   * @type {KernelSize}
   * @deprecated Use blurMaterial.kernelSize instead.
   */
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(value) {
    this.blurMaterial.kernelSize = value;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.width instead.
   */
  get width() {
    return this.resolution.width;
  }
  /**
   * Sets the render width.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredWidth instead.
   */
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.height instead.
   */
  get height() {
    return this.resolution.height;
  }
  /**
   * Sets the render height.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredHeight instead.
   */
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * The current blur scale.
   *
   * @type {Number}
   * @deprecated Use blurMaterial.scale instead.
   */
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the current blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.blurMaterial.scale;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the kernel size.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @return {KernelSize} The kernel size.
   */
  getKernelSize() {
    return this.kernelSize;
  }
  /**
   * Sets the kernel size.
   *
   * Larger kernels require more processing power but scale well with larger render resolutions.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @param {KernelSize} value - The kernel size.
   */
  setKernelSize(value) {
    this.kernelSize = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    const material = this.blurMaterial;
    const kernelSequence = material.kernelSequence;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = material;
    for (let i = 0, l = kernelSequence.length; i < l; ++i) {
      const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;
      material.kernel = kernelSequence[i];
      material.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(buffer);
      renderer.render(scene, camera);
      previousBuffer = buffer;
    }
    this.fullscreenMaterial = this.copyMaterial;
    this.copyMaterial.inputBuffer = previousBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.blurMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTargetA.texture.colorSpace = SRGBColorSpace;
        this.renderTargetB.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
  /**
   * An auto sizing flag.
   *
   * @type {Number}
   * @deprecated Use {@link Resolution.AUTO_SIZE} instead.
   */
  static get AUTO_SIZE() {
    return Resolution.AUTO_SIZE;
  }
};

// src/materials/glsl/luminance.frag
var luminance_default = "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}";

// src/materials/LuminanceMaterial.js
var LuminanceMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new luminance material.
   *
   * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.
   * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.
   */
  constructor(colorOutput = false, luminanceRange = null) {
    super({
      name: "LuminanceMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, "")
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        threshold: new Uniform(0),
        smoothing: new Uniform(1),
        range: new Uniform(null)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: luminance_default,
      vertexShader: common_default
    });
    this.colorOutput = colorOutput;
    this.luminanceRange = luminanceRange;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The luminance threshold.
   *
   * @type {Number}
   */
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(value) {
    if (this.smoothing > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.threshold.value = value;
  }
  /**
   * Returns the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @return {Number} The threshold.
   */
  getThreshold() {
    return this.threshold;
  }
  /**
   * Sets the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @param {Number} value - The threshold.
   */
  setThreshold(value) {
    this.threshold = value;
  }
  /**
   * The luminance threshold smoothing.
   *
   * @type {Number}
   */
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(value) {
    if (this.threshold > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.smoothing.value = value;
  }
  /**
   * Returns the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @return {Number} The smoothing factor.
   */
  getSmoothingFactor() {
    return this.smoothing;
  }
  /**
   * Sets the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @param {Number} value - The smoothing factor.
   */
  setSmoothingFactor(value) {
    this.smoothing = value;
  }
  /**
   * Indicates whether the luminance threshold is enabled.
   *
   * @type {Boolean}
   * @deprecated Adjust the threshold or smoothing factor instead.
   */
  get useThreshold() {
    return this.threshold > 0 || this.smoothing > 0;
  }
  set useThreshold(value) {
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @type {Boolean}
   */
  get colorOutput() {
    return this.defines.COLOR !== void 0;
  }
  set colorOutput(value) {
    if (value) {
      this.defines.COLOR = "1";
    } else {
      delete this.defines.COLOR;
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @deprecated Use colorOutput instead.
   * @return {Boolean} Whether color output is enabled.
   */
  isColorOutputEnabled(value) {
    return this.colorOutput;
  }
  /**
   * Enables or disables color output.
   *
   * @deprecated Use colorOutput instead.
   * @param {Boolean} value - Whether color output should be enabled.
   */
  setColorOutputEnabled(value) {
    this.colorOutput = value;
  }
  /**
   * Indicates whether luminance masking is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get useRange() {
    return this.luminanceRange !== null;
  }
  set useRange(value) {
    this.luminanceRange = null;
  }
  /**
   * The luminance range. Set to null to disable.
   *
   * @type {Boolean}
   */
  get luminanceRange() {
    return this.uniforms.range.value;
  }
  set luminanceRange(value) {
    if (value !== null) {
      this.defines.RANGE = "1";
    } else {
      delete this.defines.RANGE;
    }
    this.uniforms.range.value = value;
    this.needsUpdate = true;
  }
  /**
   * Returns the current luminance range.
   *
   * @deprecated Use luminanceRange instead.
   * @return {Vector2} The luminance range.
   */
  getLuminanceRange() {
    return this.luminanceRange;
  }
  /**
   * Sets a luminance range. Set to null to disable.
   *
   * @deprecated Use luminanceRange instead.
   * @param {Vector2} value - The luminance range.
   */
  setLuminanceRange(value) {
    this.luminanceRange = value;
  }
};

// src/passes/LuminancePass.js
var LuminancePass = class extends Pass {
  /**
   * Constructs a new luminance pass.
   *
   * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    renderTarget,
    luminanceRange,
    colorOutput,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("LuminancePass");
    this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
      this.renderTarget.texture.name = "LuminancePass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * The luminance texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the luminance texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Renders the luminance.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const material = this.fullscreenMaterial;
    material.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.renderTarget.texture.type = frameBufferType;
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};

// src/materials/glsl/convolution.downsampling.frag
var convolution_downsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.downsampling.vert
var convolution_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/DownsamplingMaterial.js
var DownsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new downsampling material.
   */
  constructor() {
    super({
      name: "DownsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_downsampling_default,
      vertexShader: convolution_downsampling_default2
    });
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/glsl/convolution.upsampling.frag
var convolution_upsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}";

// src/materials/glsl/convolution.upsampling.vert
var convolution_upsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/UpsamplingMaterial.js
var UpsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new upsampling material.
   */
  constructor() {
    super({
      name: "UpsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        supportBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2()),
        radius: new Uniform(0.85)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_upsampling_default,
      vertexShader: convolution_upsampling_default2
    });
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * A support buffer.
   *
   * @type {Texture}
   */
  set supportBuffer(value) {
    this.uniforms.supportBuffer.value = value;
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(value) {
    this.uniforms.radius.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/passes/MipmapBlurPass.js
var MipmapBlurPass = class extends Pass {
  /**
   * Constructs a new mipmap blur pass.
   *
   * @param {Object} [options] - The options.
   */
  constructor() {
    super("MipmapBlurPass");
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Upsampling.Mipmap0";
    this.downsamplingMipmaps = [];
    this.upsamplingMipmaps = [];
    this.downsamplingMaterial = new DownsamplingMaterial();
    this.upsamplingMaterial = new UpsamplingMaterial();
    this.resolution = new Vector2();
  }
  /**
   * A texture that contains the blurred result.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * The MIP levels. Default is 8.
   *
   * @type {Number}
   */
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(value) {
    if (this.levels !== value) {
      const renderTarget = this.renderTarget;
      this.dispose();
      this.downsamplingMipmaps = [];
      this.upsamplingMipmaps = [];
      for (let i = 0; i < value; ++i) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Downsampling.Mipmap" + i;
        this.downsamplingMipmaps.push(mipmap);
      }
      this.upsamplingMipmaps.push(renderTarget);
      for (let i = 1, l = value - 1; i < l; ++i) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Upsampling.Mipmap" + i;
        this.upsamplingMipmaps.push(mipmap);
      }
      this.setSize(this.resolution.x, this.resolution.y);
    }
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(value) {
    this.upsamplingMaterial.radius = value;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const { scene, camera } = this;
    const { downsamplingMaterial, upsamplingMaterial } = this;
    const { downsamplingMipmaps, upsamplingMipmaps } = this;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = downsamplingMaterial;
    for (let i = 0, l = downsamplingMipmaps.length; i < l; ++i) {
      const mipmap = downsamplingMipmaps[i];
      downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      downsamplingMaterial.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
    this.fullscreenMaterial = upsamplingMaterial;
    for (let i = upsamplingMipmaps.length - 1; i >= 0; --i) {
      const mipmap = upsamplingMipmaps[i];
      upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      upsamplingMaterial.inputBuffer = previousBuffer.texture;
      upsamplingMaterial.supportBuffer = downsamplingMipmaps[i].texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    let w = resolution.width, h = resolution.height;
    for (let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i) {
      w = Math.round(w * 0.5);
      h = Math.round(h * 0.5);
      this.downsamplingMipmaps[i].setSize(w, h);
      if (i < this.upsamplingMipmaps.length) {
        this.upsamplingMipmaps[i].setSize(w, h);
      }
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
      for (const mipmap of mipmaps) {
        mipmap.texture.type = frameBufferType;
      }
      if (frameBufferType !== UnsignedByteType) {
        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        for (const mipmap of mipmaps) {
          mipmap.texture.colorSpace = SRGBColorSpace;
        }
      }
    }
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    super.dispose();
    for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) {
      mipmap.dispose();
    }
  }
};
var Effect = class extends EventDispatcher {
  /**
   * Constructs a new effect.
   *
   * @param {String} name - The name of this effect. Doesn't have to be unique.
   * @param {String} fragmentShader - The fragment shader. This shader is required.
   * @param {Object} [options] - Additional options.
   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.
   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.
   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.
   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.
   */
  constructor(name, fragmentShader, {
    attributes = EffectAttribute.NONE,
    blendFunction = BlendFunction.NORMAL,
    defines = /* @__PURE__ */ new Map(),
    uniforms = /* @__PURE__ */ new Map(),
    extensions = null,
    vertexShader = null
  } = {}) {
    super();
    this.name = name;
    this.renderer = null;
    this.attributes = attributes;
    this.fragmentShader = fragmentShader;
    this.vertexShader = vertexShader;
    this.defines = defines;
    this.uniforms = uniforms;
    this.extensions = extensions;
    this.blendMode = new BlendMode(blendFunction);
    this.blendMode.addEventListener("change", (event) => this.setChanged());
    this._inputColorSpace = LinearSRGBColorSpace;
    this._outputColorSpace = NoColorSpace;
  }
  /**
   * The input color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set inputColorSpace(value) {
    this._inputColorSpace = value;
    this.setChanged();
  }
  /**
   * The output color space.
   *
   * Should only be changed if this effect converts the input colors to a different color space.
   *
   * @type {ColorSpace}
   * @experimental
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  /**
   * @type {ColorSpace}
   * @protected
   * @experimental
   */
  set outputColorSpace(value) {
    this._outputColorSpace = value;
    this.setChanged();
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Returns the name of this effect.
   *
   * @deprecated Use name instead.
   * @return {String} The name.
   */
  getName() {
    return this.name;
  }
  /**
   * Sets the renderer.
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Returns the preprocessor macro definitions.
   *
   * @deprecated Use defines instead.
   * @return {Map<String, String>} The extensions.
   */
  getDefines() {
    return this.defines;
  }
  /**
   * Returns the uniforms of this effect.
   *
   * @deprecated Use uniforms instead.
   * @return {Map<String, Uniform>} The extensions.
   */
  getUniforms() {
    return this.uniforms;
  }
  /**
   * Returns the WebGL extensions that are required by this effect.
   *
   * @deprecated Use extensions instead.
   * @return {Set<WebGLExtension>} The extensions.
   */
  getExtensions() {
    return this.extensions;
  }
  /**
   * Returns the blend mode.
   *
   * The result of this effect will be blended with the result of the previous effect using this blend mode.
   *
   * @deprecated Use blendMode instead.
   * @return {BlendMode} The blend mode.
   */
  getBlendMode() {
    return this.blendMode;
  }
  /**
   * Returns the effect attributes.
   *
   * @return {EffectAttribute} The attributes.
   */
  getAttributes() {
    return this.attributes;
  }
  /**
   * Sets the effect attributes.
   *
   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes
   * imply a higher priority.
   *
   * @protected
   * @param {EffectAttribute} attributes - The attributes.
   */
  setAttributes(attributes) {
    this.attributes = attributes;
    this.setChanged();
  }
  /**
   * Returns the fragment shader.
   *
   * @return {String} The fragment shader.
   */
  getFragmentShader() {
    return this.fragmentShader;
  }
  /**
   * Sets the fragment shader.
   *
   * @protected
   * @param {String} fragmentShader - The fragment shader.
   */
  setFragmentShader(fragmentShader) {
    this.fragmentShader = fragmentShader;
    this.setChanged();
  }
  /**
   * Returns the vertex shader.
   *
   * @return {String} The vertex shader.
   */
  getVertexShader() {
    return this.vertexShader;
  }
  /**
   * Sets the vertex shader.
   *
   * @protected
   * @param {String} vertexShader - The vertex shader.
   */
  setVertexShader(vertexShader) {
    this.vertexShader = vertexShader;
    this.setChanged();
  }
  /**
   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.
   *
   * Should be called after changing macros or extensions and after adding/removing uniforms.
   *
   * @protected
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Sets the depth texture.
   *
   * You may override this method if your effect requires direct access to the depth texture that is bound to the
   * associated {@link EffectPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Updates this effect by performing supporting operations.
   *
   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the
   * blend function is set to `SKIP`.
   *
   * You may override this method if you need to update custom uniforms or render additional off-screen textures.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
  }
  /**
   * Updates the size of this effect.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for properties that define a dispose method and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};

// src/effects/glsl/bloom.frag
var bloom_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}";

// src/effects/BloomEffect.js
var BloomEffect = class extends Effect {
  /**
   * Constructs a new bloom effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
   * @param {Number} [options.luminanceThreshold=0.9] - The luminance threshold. Raise this value to mask out darker elements in the scene.
   * @param {Number} [options.luminanceSmoothing=0.025] - Controls the smoothness of the luminance threshold.
   * @param {Boolean} [options.mipmapBlur=false] - Enables or disables mipmap blur.
   * @param {Number} [options.intensity=1.0] - The bloom intensity.
   * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.
   * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.
   * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   */
  constructor({
    blendFunction = BlendFunction.SCREEN,
    luminanceThreshold = 0.9,
    luminanceSmoothing = 0.025,
    mipmapBlur = false,
    intensity = 1,
    radius = 0.85,
    levels = 8,
    kernelSize = KernelSize.LARGE,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("BloomEffect", bloom_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Uniform(null)],
        ["intensity", new Uniform(intensity)]
      ])
    });
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Bloom.Target";
    this.blurPass = new KawaseBlurPass({ kernelSize });
    this.luminancePass = new LuminancePass({ colorOutput: true });
    this.luminanceMaterial.threshold = luminanceThreshold;
    this.luminanceMaterial.smoothing = luminanceSmoothing;
    this.mipmapBlurPass = new MipmapBlurPass();
    this.mipmapBlurPass.enabled = mipmapBlur;
    this.mipmapBlurPass.radius = radius;
    this.mipmapBlurPass.levels = levels;
    this.uniforms.get("map").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * A texture that contains the intermediate result of this effect.
   *
   * @type {Texture}
   */
  get texture() {
    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
  }
  /**
   * Returns the generated bloom texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the blur pass.
   *
   * @deprecated
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the luminance pass.
   *
   * @deprecated Use luminancePass instead.
   * @return {LuminancePass} The luminance pass.
   */
  getLuminancePass() {
    return this.luminancePass;
  }
  /**
   * The luminance material.
   *
   * @type {LuminanceMaterial}
   */
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * Returns the luminance material.
   *
   * @deprecated Use luminanceMaterial instead.
   * @return {LuminanceMaterial} The material.
   */
  getLuminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use EffectPass.dithering instead.
   */
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  /**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @deprecated
   */
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  /**
   * @type {Number}
   * @deprecated
   */
  get distinction() {
    console.warn(this.name, "distinction was removed");
    return 1;
  }
  set distinction(value) {
    console.warn(this.name, "distinction was removed");
  }
  /**
   * The bloom intensity.
   *
   * @type {Number}
   */
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  /**
   * The bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.intensity;
  }
  /**
   * Sets the bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.intensity = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    const luminancePass = this.luminancePass;
    if (luminancePass.enabled) {
      luminancePass.render(renderer, inputBuffer);
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);
      } else {
        this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget);
      }
    } else {
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, inputBuffer);
      } else {
        this.blurPass.render(renderer, inputBuffer, renderTarget);
      }
    }
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.blurPass.resolution.copy(resolution);
    this.luminancePass.setSize(width, height);
    this.mipmapBlurPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    this.luminancePass.initialize(renderer, alpha, frameBufferType);
    this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (renderer !== null && renderer.outputColorSpace === SRGBColorSpace) {
        this.renderTarget.texture.colorSpace = SRGBColorSpace;
      }
    }
  }
};
var ShaderPass = class extends Pass {
  /**
   * Constructs a new shader pass.
   *
   * @param {ShaderMaterial} material - A shader material.
   * @param {String} [input="inputBuffer"] - The name of the input buffer uniform.
   */
  constructor(material, input = "inputBuffer") {
    super("ShaderPass");
    this.fullscreenMaterial = material;
    this.input = input;
  }
  /**
   * Sets the name of the input buffer uniform.
   *
   * @param {String} input - The name of the input buffer uniform.
   * @deprecated Use input instead.
   */
  setInput(input) {
    this.input = input;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const uniforms = this.fullscreenMaterial.uniforms;
    if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {
      uniforms[this.input].value = inputBuffer.texture;
    }
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};

// src/passes/RenderPass.js
var RenderPass = class extends Pass {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Material} [overrideMaterial=null] - An override material.
   */
  constructor(scene, camera, overrideMaterial = null) {
    super("RenderPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass();
    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);
    this.ignoreBackground = false;
    this.skipShadowMapUpdate = false;
    this.selection = null;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(value) {
    super.renderToScreen = value;
    this.clearPass.renderToScreen = value;
  }
  /**
   * The current override material.
   *
   * @type {Material}
   */
  get overrideMaterial() {
    const manager = this.overrideMaterialManager;
    return manager !== null ? manager.material : null;
  }
  set overrideMaterial(value) {
    const manager = this.overrideMaterialManager;
    if (value !== null) {
      if (manager !== null) {
        manager.setMaterial(value);
      } else {
        this.overrideMaterialManager = new OverrideMaterialManager(value);
      }
    } else if (manager !== null) {
      manager.dispose();
      this.overrideMaterialManager = null;
    }
  }
  /**
   * Returns the current override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} The material.
   */
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  /**
   * Sets the override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} value - The material.
   */
  setOverrideMaterial(value) {
    this.overrideMaterial = value;
  }
  /**
   * Indicates whether the target buffer should be cleared before rendering.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the selection. Default is `null` (no restriction).
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * Sets the selection. Set to `null` to disable.
   *
   * @deprecated Use selection instead.
   * @param {Selection} value - The selection.
   */
  setSelection(value) {
    this.selection = value;
  }
  /**
   * Indicates whether the scene background is disabled.
   *
   * @deprecated Use ignoreBackground instead.
   * @return {Boolean} Whether the scene background is disabled.
   */
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  /**
   * Enables or disables the scene background.
   *
   * @deprecated Use ignoreBackground instead.
   * @param {Boolean} value - Whether the scene background should be disabled.
   */
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  /**
   * Indicates whether the shadow map auto update is disabled.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @return {Boolean} Whether the shadow map update is disabled.
   */
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  /**
   * Enables or disables the shadow map auto update.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @param {Boolean} value - Whether the shadow map auto update should be disabled.
   */
  setShadowMapDisabled(value) {
    this.skipShadowMapUpdate = value;
  }
  /**
   * Returns the clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Renders the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const mask = camera.layers.mask;
    const background = scene.background;
    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;
    const renderTarget = this.renderToScreen ? null : inputBuffer;
    if (selection !== null) {
      camera.layers.set(selection.getLayer());
    }
    if (this.skipShadowMapUpdate) {
      renderer.shadowMap.autoUpdate = false;
    }
    if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {
      scene.background = null;
    }
    if (this.clearPass.enabled) {
      this.clearPass.render(renderer, inputBuffer);
    }
    renderer.setRenderTarget(renderTarget);
    if (this.overrideMaterialManager !== null) {
      this.overrideMaterialManager.render(renderer, scene, camera);
    } else {
      renderer.render(scene, camera);
    }
    camera.layers.mask = mask;
    scene.background = background;
    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;
  }
};

// src/enums/LUTOperation.js
var LUTOperation = {
  SCALE_UP: "lut.scaleup"
};

// src/textures/RawImageData.js
function createCanvas(width, height, data) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  canvas.width = width;
  canvas.height = height;
  if (data instanceof Image) {
    context.drawImage(data, 0, 0);
  } else {
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
  }
  return canvas;
}
var RawImageData = class _RawImageData {
  /**
   * Constructs a new image data container.
   *
   * @param {Number} [width=0] - The width of the image.
   * @param {Number} [height=0] - The height of the image.
   * @param {Uint8ClampedArray} [data=null] - The image data.
   */
  constructor(width = 0, height = 0, data = null) {
    this.width = width;
    this.height = height;
    this.data = data;
  }
  /**
   * Creates a canvas from this image data.
   *
   * @return {Canvas} The canvas, or null if it couldn't be created.
   */
  toCanvas() {
    return typeof document === "undefined" ? null : createCanvas(this.width, this.height, this.data);
  }
  /**
   * Creates a new image data container.
   *
   * @param {ImageData|Image} image - An image or plain image data.
   * @return {RawImageData} The image data.
   */
  static from(image) {
    const { width, height } = image;
    let data;
    if (image instanceof Image) {
      const canvas = createCanvas(width, height, image);
      if (canvas !== null) {
        const context = canvas.getContext("2d");
        data = context.getImageData(0, 0, width, height).data;
      }
    } else {
      data = image.data;
    }
    return new _RawImageData(width, height, data);
  }
};

// tmp/lut/worker.txt
var worker_default = '"use strict";(()=>{var O={SCALE_UP:"lut.scaleup"};var _=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function k(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=_[0];P[0]=s,P[1]=F,P[2]=f;let o=_[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(r**3*4),y=t instanceof Uint8Array?255:1,h=r**2,A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;k(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener("message",a=>{let t=a.data,r=t.data;switch(t.operation){case O.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();\n';

// src/textures/lut/LookupTexture.js
var c = /* @__PURE__ */ new Color();
var LookupTexture = class _LookupTexture extends Data3DTexture {
  /**
   * Constructs a cubic 3D lookup texture.
   *
   * @param {TypedArray} data - The pixel data. The default format is RGBA.
   * @param {Number} size - The sidelength.
   */
  constructor(data, size) {
    super(data, size, size, size);
    this.type = FloatType;
    this.format = RGBAFormat;
    this.minFilter = LinearFilter;
    this.magFilter = LinearFilter;
    this.wrapS = ClampToEdgeWrapping;
    this.wrapT = ClampToEdgeWrapping;
    this.wrapR = ClampToEdgeWrapping;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
    this.colorSpace = LinearSRGBColorSpace;
    this.domainMin = new Vector3(0, 0, 0);
    this.domainMax = new Vector3(1, 1, 1);
  }
  /**
   * Indicates that this is an instance of LookupTexture3D.
   *
   * @type {Boolean}
   * @deprecated
   */
  get isLookupTexture3D() {
    return true;
  }
  /**
   * Scales this LUT up to a given target size using tetrahedral interpolation.
   *
   * @param {Number} size - The target sidelength.
   * @param {Boolean} [transferData=true] - Extra fast mode. Set to false to keep the original data intact.
   * @return {Promise<LookupTexture>} A promise that resolves with a new LUT upon completion.
   */
  scaleUp(size, transferData = true) {
    const image = this.image;
    let promise;
    if (size <= image.width) {
      promise = Promise.reject(new Error("The target size must be greater than the current size"));
    } else {
      promise = new Promise((resolve, reject) => {
        const workerURL = URL.createObjectURL(new Blob([worker_default], {
          type: "text/javascript"
        }));
        const worker = new Worker(workerURL);
        worker.addEventListener("error", (event) => reject(event.error));
        worker.addEventListener("message", (event) => {
          const lut = new _LookupTexture(event.data, size);
          this.colorSpace = lut.colorSpace;
          lut.type = this.type;
          lut.name = this.name;
          URL.revokeObjectURL(workerURL);
          resolve(lut);
        });
        const transferList = transferData ? [image.data.buffer] : [];
        worker.postMessage({
          operation: LUTOperation.SCALE_UP,
          data: image.data,
          size
        }, transferList);
      });
    }
    return promise;
  }
  /**
   * Applies the given LUT to this one.
   *
   * @param {LookupTexture} lut - A LUT. Must have the same dimensions, type and format as this LUT.
   * @return {LookupTexture} This texture.
   */
  applyLUT(lut) {
    const img0 = this.image;
    const img1 = lut.image;
    const size0 = Math.min(img0.width, img0.height, img0.depth);
    const size1 = Math.min(img1.width, img1.height, img1.depth);
    if (size0 !== size1) {
      console.error("Size mismatch");
    } else if (lut.type !== FloatType || this.type !== FloatType) {
      console.error("Both LUTs must be FloatType textures");
    } else if (lut.format !== RGBAFormat || this.format !== RGBAFormat) {
      console.error("Both LUTs must be RGBA textures");
    } else {
      const data0 = img0.data;
      const data1 = img1.data;
      const size = size0;
      const sizeSq = size ** 2;
      const s = size - 1;
      for (let i = 0, l = size ** 3; i < l; ++i) {
        const i4 = i * 4;
        const r = data0[i4 + 0] * s;
        const g = data0[i4 + 1] * s;
        const b = data0[i4 + 2] * s;
        const iRGB = Math.round(r + g * size + b * sizeSq) * 4;
        data0[i4 + 0] = data1[iRGB + 0];
        data0[i4 + 1] = data1[iRGB + 1];
        data0[i4 + 2] = data1[iRGB + 2];
      }
      this.needsUpdate = true;
    }
    return this;
  }
  /**
   * Converts the LUT data into unsigned byte data.
   *
   * This is a lossy operation which should only be performed after all other transformations have been applied.
   *
   * @return {LookupTexture} This texture.
   */
  convertToUint8() {
    if (this.type === FloatType) {
      const floatData = this.image.data;
      const uint8Data = new Uint8Array(floatData.length);
      for (let i = 0, l = floatData.length; i < l; ++i) {
        uint8Data[i] = floatData[i] * 255 + 0.5;
      }
      this.image.data = uint8Data;
      this.type = UnsignedByteType;
      this.needsUpdate = true;
    }
    return this;
  }
  /**
   * Converts the LUT data into float data.
   *
   * @return {LookupTexture} This texture.
   */
  convertToFloat() {
    if (this.type === UnsignedByteType) {
      const uint8Data = this.image.data;
      const floatData = new Float32Array(uint8Data.length);
      for (let i = 0, l = uint8Data.length; i < l; ++i) {
        floatData[i] = uint8Data[i] / 255;
      }
      this.image.data = floatData;
      this.type = FloatType;
      this.needsUpdate = true;
    }
    return this;
  }
  /**
   * Converts this LUT into RGBA data.
   *
   * @deprecated LUTs are RGBA by default since three r137.
   * @return {LookupTexture} This texture.
   */
  convertToRGBA() {
    console.warn("LookupTexture", "convertToRGBA() is deprecated, LUTs are now RGBA by default");
    return this;
  }
  /**
   * Converts the output of this LUT into sRGB color space.
   *
   * @return {LookupTexture} This texture.
   */
  convertLinearToSRGB() {
    const data = this.image.data;
    if (this.type === FloatType) {
      for (let i = 0, l = data.length; i < l; i += 4) {
        c.fromArray(data, i).convertLinearToSRGB().toArray(data, i);
      }
      this.colorSpace = SRGBColorSpace;
      this.needsUpdate = true;
    } else {
      console.error("Color space conversion requires FloatType data");
    }
    return this;
  }
  /**
   * Converts the output of this LUT into linear color space.
   *
   * @return {LookupTexture} This texture.
   */
  convertSRGBToLinear() {
    const data = this.image.data;
    if (this.type === FloatType) {
      for (let i = 0, l = data.length; i < l; i += 4) {
        c.fromArray(data, i).convertSRGBToLinear().toArray(data, i);
      }
      this.colorSpace = LinearSRGBColorSpace;
      this.needsUpdate = true;
    } else {
      console.error("Color space conversion requires FloatType data");
    }
    return this;
  }
  /**
   * Converts this LUT into a 2D data texture.
   *
   * Please note that custom input domains are not carried over to 2D textures.
   *
   * @return {DataTexture} The texture.
   */
  toDataTexture() {
    const width = this.image.width;
    const height = this.image.height * this.image.depth;
    const texture = new DataTexture(this.image.data, width, height);
    texture.name = this.name;
    texture.type = this.type;
    texture.format = this.format;
    texture.minFilter = LinearFilter;
    texture.magFilter = LinearFilter;
    texture.wrapS = this.wrapS;
    texture.wrapT = this.wrapT;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    this.colorSpace = texture.colorSpace;
    return texture;
  }
  /**
   * Creates a new 3D LUT by copying a given LUT.
   *
   * Common image-based textures will be converted into 3D data textures.
   *
   * @param {Texture} texture - The LUT. Assumed to be cubic.
   * @return {LookupTexture} A new 3D LUT.
   */
  static from(texture) {
    const image = texture.image;
    const { width, height } = image;
    const size = Math.min(width, height);
    let data;
    if (image instanceof Image) {
      const rawImageData = RawImageData.from(image);
      const src = rawImageData.data;
      if (width > height) {
        data = new Uint8Array(src.length);
        for (let z = 0; z < size; ++z) {
          for (let y = 0; y < size; ++y) {
            for (let x = 0; x < size; ++x) {
              const i4 = (x + z * size + y * size * size) * 4;
              const j4 = (x + y * size + z * size * size) * 4;
              data[j4 + 0] = src[i4 + 0];
              data[j4 + 1] = src[i4 + 1];
              data[j4 + 2] = src[i4 + 2];
              data[j4 + 3] = src[i4 + 3];
            }
          }
        }
      } else {
        data = new Uint8Array(src.buffer);
      }
    } else {
      data = image.data.slice();
    }
    const lut = new _LookupTexture(data, size);
    lut.type = texture.type;
    lut.name = texture.name;
    texture.colorSpace = lut.colorSpace;
    return lut;
  }
  /**
   * Creates a neutral 3D LUT.
   *
   * @param {Number} size - The sidelength.
   * @return {LookupTexture} A neutral 3D LUT.
   */
  static createNeutral(size) {
    const data = new Float32Array(size ** 3 * 4);
    const sizeSq = size ** 2;
    const s = 1 / (size - 1);
    for (let r = 0; r < size; ++r) {
      for (let g = 0; g < size; ++g) {
        for (let b = 0; b < size; ++b) {
          const i4 = (r + g * size + b * sizeSq) * 4;
          data[i4 + 0] = r * s;
          data[i4 + 1] = g * s;
          data[i4 + 2] = b * s;
          data[i4 + 3] = 1;
        }
      }
    }
    const lut = new _LookupTexture(data, size);
    lut.name = "neutral";
    return lut;
  }
};

// src/enums/EdgeDetectionMode.js
var EdgeDetectionMode = {
  COLOR: 2
};

// src/enums/PredicationMode.js
var PredicationMode = {
  DISABLED: 0};

// src/enums/SMAAPreset.js
var SMAAPreset = {
  LOW: 0,
  MEDIUM: 1,
  HIGH: 2,
  ULTRA: 3
};

// src/enums/VignetteTechnique.js
var VignetteTechnique = {
  DEFAULT: 0,
  ESKIL: 1
};

// src/materials/glsl/edge-detection.frag
var edge_detection_default = "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}";

// src/materials/glsl/edge-detection.vert
var edge_detection_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/EdgeDetectionMaterial.js
var EdgeDetectionMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new edge detection material.
   *
   * TODO Remove parameters.
   * @param {Vector2} [texelSize] - The screen texel size.
   * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.
   */
  constructor(texelSize = new Vector2(), mode = EdgeDetectionMode.COLOR) {
    super({
      name: "EdgeDetectionMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
        EDGE_THRESHOLD: "0.1",
        DEPTH_THRESHOLD: "0.01",
        PREDICATION_MODE: "0",
        PREDICATION_THRESHOLD: "0.01",
        PREDICATION_SCALE: "2.0",
        PREDICATION_STRENGTH: "1.0",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        predicationBuffer: new Uniform(null),
        texelSize: new Uniform(texelSize)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: edge_detection_default,
      vertexShader: edge_detection_default2
    });
    this.edgeDetectionMode = mode;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The edge detection mode.
   *
   * @type {EdgeDetectionMode}
   */
  get edgeDetectionMode() {
    return Number(this.defines.EDGE_DETECTION_MODE);
  }
  set edgeDetectionMode(value) {
    this.defines.EDGE_DETECTION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @return {EdgeDetectionMode} The mode.
   */
  getEdgeDetectionMode() {
    return this.edgeDetectionMode;
  }
  /**
   * Sets the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @param {EdgeDetectionMode} value - The edge detection mode.
   */
  setEdgeDetectionMode(value) {
    this.edgeDetectionMode = value;
  }
  /**
   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.
   *
   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.
   *
   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a
   * direction, the perceptual contrast in the other neighbors will be hidden.
   *
   * @type {Number}
   */
  get localContrastAdaptationFactor() {
    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
  }
  set localContrastAdaptationFactor(value) {
    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the local contrast adaptation factor.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @return {Number} The factor.
   */
  getLocalContrastAdaptationFactor() {
    return this.localContrastAdaptationFactor;
  }
  /**
   * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @param {Number} value - The local contrast adaptation factor. Default is 2.0.
   */
  setLocalContrastAdaptationFactor(value) {
    this.localContrastAdaptationFactor = value;
  }
  /**
   * The edge detection threshold. Range: [0.0, 0.5].
   *
   * A lower value results in more edges being detected at the expense of performance.
   *
   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05
   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.
   *
   * If depth-based edge detection is used, the threshold will depend on the scene depth.
   *
   * @type {Number}
   */
  get edgeDetectionThreshold() {
    return Number(this.defines.EDGE_THRESHOLD);
  }
  set edgeDetectionThreshold(value) {
    this.defines.EDGE_THRESHOLD = value.toFixed("6");
    this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @return {Number} The threshold.
   */
  getEdgeDetectionThreshold() {
    return this.edgeDetectionThreshold;
  }
  /**
   * Sets the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].
   */
  setEdgeDetectionThreshold(value) {
    this.edgeDetectionThreshold = value;
  }
  /**
   * The predication mode.
   *
   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional
   * buffer such as a light accumulation or depth buffer.
   *
   * @type {PredicationMode}
   */
  get predicationMode() {
    return Number(this.defines.PREDICATION_MODE);
  }
  set predicationMode(value) {
    this.defines.PREDICATION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @return {PredicationMode} The mode.
   */
  getPredicationMode() {
    return this.predicationMode;
  }
  /**
   * Sets the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @param {PredicationMode} value - The predication mode.
   */
  setPredicationMode(value) {
    this.predicationMode = value;
  }
  /**
   * The predication buffer.
   *
   * @type {Texture}
   */
  set predicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * Sets a custom predication buffer.
   *
   * @deprecated Use predicationBuffer instead.
   * @param {Texture} value - The predication buffer.
   */
  setPredicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * The predication threshold.
   *
   * @type {Number}
   */
  get predicationThreshold() {
    return Number(this.defines.PREDICATION_THRESHOLD);
  }
  set predicationThreshold(value) {
    this.defines.PREDICATION_THRESHOLD = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @return {Number} The threshold.
   */
  getPredicationThreshold() {
    return this.predicationThreshold;
  }
  /**
   * Sets the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @param {Number} value - The threshold.
   */
  setPredicationThreshold(value) {
    this.predicationThreshold = value;
  }
  /**
   * The predication scale. Range: [1.0, 5.0].
   *
   * Determines how much the edge detection threshold should be scaled when using predication.
   *
   * @type {Boolean|Texture|Number}
   */
  get predicationScale() {
    return Number(this.defines.PREDICATION_SCALE);
  }
  set predicationScale(value) {
    this.defines.PREDICATION_SCALE = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @return {Number} The scale.
   */
  getPredicationScale() {
    return this.predicationScale;
  }
  /**
   * Sets the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @param {Number} value - The scale. Range: [1.0, 5.0].
   */
  setPredicationScale(value) {
    this.predicationScale = value;
  }
  /**
   * The predication strength. Range: [0.0, 1.0].
   *
   * Determines how much the edge detection threshold should be decreased locally when using predication.
   *
   * @type {Number}
   */
  get predicationStrength() {
    return Number(this.defines.PREDICATION_STRENGTH);
  }
  set predicationStrength(value) {
    this.defines.PREDICATION_STRENGTH = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @return {Number} The strength.
   */
  getPredicationStrength() {
    return this.predicationStrength;
  }
  /**
   * Sets the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @param {Number} value - The strength. Range: [0.0, 1.0].
   */
  setPredicationStrength(value) {
    this.predicationStrength = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/glsl/smaa-weights.frag
var smaa_weights_default = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}";

// src/materials/glsl/smaa-weights.vert
var smaa_weights_default2 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/SMAAWeightsMaterial.js
var SMAAWeightsMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new SMAA weights material.
   *
   * @param {Vector2} [texelSize] - The absolute screen texel size.
   * @param {Vector2} [resolution] - The resolution.
   */
  constructor(texelSize = new Vector2(), resolution = new Vector2()) {
    super({
      name: "SMAAWeightsMaterial",
      defines: {
        // Configurable settings:
        MAX_SEARCH_STEPS_INT: "16",
        MAX_SEARCH_STEPS_FLOAT: "16.0",
        MAX_SEARCH_STEPS_DIAG_INT: "8",
        MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
        CORNER_ROUNDING: "25",
        CORNER_ROUNDING_NORM: "0.25",
        // Non-configurable settings:
        AREATEX_MAX_DISTANCE: "16.0",
        AREATEX_MAX_DISTANCE_DIAG: "20.0",
        AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
        AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
        SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
        SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        searchTexture: new Uniform(null),
        areaTexture: new Uniform(null),
        resolution: new Uniform(resolution),
        texelSize: new Uniform(texelSize)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      fragmentShader: smaa_weights_default,
      vertexShader: smaa_weights_default2
    });
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The search lookup texture.
   *
   * @type {Texture}
   */
  get searchTexture() {
    return this.uniforms.searchTexture.value;
  }
  set searchTexture(value) {
    this.uniforms.searchTexture.value = value;
  }
  /**
   * The area lookup texture.
   *
   * @type {Texture}
   */
  get areaTexture() {
    return this.uniforms.areaTexture.value;
  }
  set areaTexture(value) {
    this.uniforms.areaTexture.value = value;
  }
  /**
   * Sets the search and area lookup textures.
   *
   * @deprecated Use searchTexture and areaTexture instead.
   * @param {Texture} search - The search lookup texture.
   * @param {Texture} area - The area lookup texture.
   */
  setLookupTextures(search, area2) {
    this.searchTexture = search;
    this.areaTexture = area2;
  }
  /**
   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   * Range: [0, 112].
   *
   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is
   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).
   *
   * @type {Number}
   */
  get orthogonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_INT);
  }
  set orthogonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 112);
    this.defines.MAX_SEARCH_STEPS_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   *
   * @deprecated Use orthogonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(value) {
    this.orthogonalSearchSteps = value;
  }
  /**
   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search
   * jumps one pixel at a time. Range: [0, 20].
   *
   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a
   * significant impact on older machines.
   *
   * @type {Number}
   */
  get diagonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
  }
  set diagonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 20);
    this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.
   *
   * @deprecated Use diagonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 20].
   */
  setDiagonalSearchSteps(value) {
    this.diagonalSearchSteps = value;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @type {Boolean}
   */
  get diagonalDetection() {
    return this.defines.DISABLE_DIAG_DETECTION === void 0;
  }
  set diagonalDetection(value) {
    if (value) {
      delete this.defines.DISABLE_DIAG_DETECTION;
    } else {
      this.defines.DISABLE_DIAG_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @deprecated Use diagonalDetection instead.
   * @return {Boolean} Whether diagonal pattern detection is enabled.
   */
  isDiagonalDetectionEnabled() {
    return this.diagonalDetection;
  }
  /**
   * Enables or disables diagonal pattern detection.
   *
   * @deprecated Use diagonalDetection instead.
   * @param {Boolean} value - Whether diagonal pattern detection should be enabled.
   */
  setDiagonalDetectionEnabled(value) {
    this.diagonalDetection = value;
  }
  /**
   * Specifies how much sharp corners will be rounded. Range: [0, 100].
   *
   * @type {Number}
   */
  get cornerRounding() {
    return Number(this.defines.CORNER_ROUNDING);
  }
  set cornerRounding(value) {
    const r = Math.min(Math.max(value, 0), 100);
    this.defines.CORNER_ROUNDING = r.toFixed("4");
    this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed("4");
    this.needsUpdate = true;
  }
  /**
   * Specifies how much sharp corners will be rounded.
   *
   * @deprecated Use cornerRounding instead.
   * @param {Number} value - The corner rounding amount. Range: [0, 100].
   */
  setCornerRounding(value) {
    this.cornerRounding = value;
  }
  /**
   * Indicates whether corner detection is enabled.
   *
   * @type {Number}
   */
  get cornerDetection() {
    return this.defines.DISABLE_CORNER_DETECTION === void 0;
  }
  set cornerDetection(value) {
    if (value) {
      delete this.defines.DISABLE_CORNER_DETECTION;
    } else {
      this.defines.DISABLE_CORNER_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether corner rounding is enabled.
   *
   * @deprecated Use cornerDetection instead.
   * @return {Boolean} Whether corner rounding is enabled.
   */
  isCornerRoundingEnabled() {
    return this.cornerDetection;
  }
  /**
   * Enables or disables corner rounding.
   *
   * @deprecated Use cornerDetection instead.
   * @param {Boolean} value - Whether corner rounding should be enabled.
   */
  setCornerRoundingEnabled(value) {
    this.cornerDetection = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.resolution.value.set(width, height);
  }
};

// src/textures/smaa/searchImageDataURL.js
var searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC";

// src/textures/smaa/areaImageDataURL.js
var areaImageDataURL_default = "data:image/png;base64,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";

// src/effects/glsl/smaa.frag
var smaa_default = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}";

// src/effects/glsl/smaa.vert
var smaa_default2 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}";

// src/effects/SMAAEffect.js
var SMAAEffect = class extends Effect {
  /**
   * Constructs a new SMAA effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.
   * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.
   * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.
   */
  constructor({
    blendFunction = BlendFunction.SRC,
    preset = SMAAPreset.MEDIUM,
    edgeDetectionMode = EdgeDetectionMode.COLOR,
    predicationMode = PredicationMode.DISABLED
  } = {}) {
    super("SMAAEffect", smaa_default, {
      vertexShader: smaa_default2,
      blendFunction,
      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["weightMap", new Uniform(null)]
      ])
    });
    let searchImage, areaImage;
    if (arguments.length > 1) {
      searchImage = arguments[0];
      areaImage = arguments[1];
      if (arguments.length > 2) {
        preset = arguments[2];
      }
      if (arguments.length > 3) {
        edgeDetectionMode = arguments[3];
      }
    }
    this.renderTargetEdges = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetEdges.texture.name = "SMAA.Edges";
    this.renderTargetWeights = this.renderTargetEdges.clone();
    this.renderTargetWeights.texture.name = "SMAA.Weights";
    this.uniforms.get("weightMap").value = this.renderTargetWeights.texture;
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());
    this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;
    this.edgeDetectionMaterial.predicationMode = predicationMode;
    this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());
    const loadingManager = new LoadingManager();
    loadingManager.onLoad = () => {
      const searchTexture = new Texture(searchImage);
      searchTexture.name = "SMAA.Search";
      searchTexture.magFilter = NearestFilter;
      searchTexture.minFilter = NearestFilter;
      searchTexture.generateMipmaps = false;
      searchTexture.needsUpdate = true;
      searchTexture.flipY = true;
      this.weightsMaterial.searchTexture = searchTexture;
      const areaTexture = new Texture(areaImage);
      areaTexture.name = "SMAA.Area";
      areaTexture.magFilter = LinearFilter;
      areaTexture.minFilter = LinearFilter;
      areaTexture.generateMipmaps = false;
      areaTexture.needsUpdate = true;
      areaTexture.flipY = false;
      this.weightsMaterial.areaTexture = areaTexture;
      this.dispatchEvent({ type: "load" });
    };
    loadingManager.itemStart("search");
    loadingManager.itemStart("area");
    if (searchImage !== void 0 && areaImage !== void 0) {
      loadingManager.itemEnd("search");
      loadingManager.itemEnd("area");
    } else if (typeof Image !== "undefined") {
      searchImage = new Image();
      areaImage = new Image();
      searchImage.addEventListener("load", () => loadingManager.itemEnd("search"));
      areaImage.addEventListener("load", () => loadingManager.itemEnd("area"));
      searchImage.src = searchImageDataURL_default;
      areaImage.src = areaImageDataURL_default;
    }
    this.applyPreset(preset);
  }
  /**
   * The edges texture.
   *
   * @type {Texture}
   */
  get edgesTexture() {
    return this.renderTargetEdges.texture;
  }
  /**
   * Returns the edges texture.
   *
   * @deprecated Use edgesTexture instead.
   * @return {Texture} The texture.
   */
  getEdgesTexture() {
    return this.edgesTexture;
  }
  /**
   * The edge weights texture.
   *
   * @type {Texture}
   */
  get weightsTexture() {
    return this.renderTargetWeights.texture;
  }
  /**
   * Returns the edge weights texture.
   *
   * @deprecated Use weightsTexture instead.
   * @return {Texture} The texture.
   */
  getWeightsTexture() {
    return this.weightsTexture;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   */
  get edgeDetectionMaterial() {
    return this.edgeDetectionPass.fullscreenMaterial;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   * @deprecated Use edgeDetectionMaterial instead.
   */
  get colorEdgesMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * Returns the edge detection material.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @return {EdgeDetectionMaterial} The material.
   */
  getEdgeDetectionMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * The edge weights material.
   *
   * @type {SMAAWeightsMaterial}
   */
  get weightsMaterial() {
    return this.weightsPass.fullscreenMaterial;
  }
  /**
   * Returns the edge weights material.
   *
   * @deprecated Use weightsMaterial instead.
   * @return {SMAAWeightsMaterial} The material.
   */
  getWeightsMaterial() {
    return this.weightsMaterial;
  }
  /**
   * Sets the edge detection sensitivity.
   *
   * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].
   */
  setEdgeDetectionThreshold(threshold) {
    this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;
  }
  /**
   * Sets the maximum amount of horizontal/vertical search steps.
   *
   * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.
   *
   * @deprecated Use weightsMaterial instead.
   * @param {Number} steps - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(steps) {
    this.weightsMaterial.orthogonalSearchSteps = steps;
  }
  /**
   * Applies the given quality preset.
   *
   * @param {SMAAPreset} preset - The preset.
   */
  applyPreset(preset) {
    const edgeDetectionMaterial = this.edgeDetectionMaterial;
    const weightsMaterial = this.weightsMaterial;
    switch (preset) {
      case SMAAPreset.LOW:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.15;
        weightsMaterial.orthogonalSearchSteps = 4;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.MEDIUM:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 8;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.HIGH:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 16;
        weightsMaterial.diagonalSearchSteps = 8;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
      case SMAAPreset.ULTRA:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.05;
        weightsMaterial.orthogonalSearchSteps = 32;
        weightsMaterial.diagonalSearchSteps = 16;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
    }
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.edgeDetectionMaterial.depthBuffer = depthTexture;
    this.edgeDetectionMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    this.clearPass.render(renderer, this.renderTargetEdges);
    this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);
    this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.edgeDetectionMaterial.setSize(width, height);
    this.weightsMaterial.setSize(width, height);
    this.renderTargetEdges.setSize(width, height);
    this.renderTargetWeights.setSize(width, height);
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    const { searchTexture, areaTexture } = this.weightsMaterial;
    if (searchTexture !== null && areaTexture !== null) {
      searchTexture.dispose();
      areaTexture.dispose();
    }
    super.dispose();
  }
  /**
   * The SMAA search image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get searchImageDataURL() {
    return searchImageDataURL_default;
  }
  /**
   * The SMAA area image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get areaImageDataURL() {
    return areaImageDataURL_default;
  }
};

// src/effects/glsl/vignette.frag
var vignette_default = "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}";

// src/effects/VignetteEffect.js
var VignetteEffect = class extends Effect {
  /**
   * Constructs a new Vignette effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
   * @param {VignetteTechnique} [options.technique=VignetteTechnique.DEFAULT] - The Vignette technique.
   * @param {Boolean} [options.eskil=false] - Deprecated. Use technique instead.
   * @param {Number} [options.offset=0.5] - The Vignette offset.
   * @param {Number} [options.darkness=0.5] - The Vignette darkness.
   */
  constructor({
    blendFunction,
    eskil = false,
    technique = eskil ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT,
    offset = 0.5,
    darkness = 0.5
  } = {}) {
    super("VignetteEffect", vignette_default, {
      blendFunction,
      defines: /* @__PURE__ */ new Map([
        ["VIGNETTE_TECHNIQUE", technique.toFixed(0)]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new Uniform(offset)],
        ["darkness", new Uniform(darkness)]
      ])
    });
  }
  /**
   * The Vignette technique.
   *
   * @type {VignetteTechnique}
   */
  get technique() {
    return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
  }
  set technique(value) {
    if (this.technique !== value) {
      this.defines.set("VIGNETTE_TECHNIQUE", value.toFixed(0));
      this.setChanged();
    }
  }
  /**
   * Indicates whether Eskil's Vignette technique is enabled.
   *
   * @type {Boolean}
   * @deprecated Use technique instead.
   */
  get eskil() {
    return this.technique === VignetteTechnique.ESKIL;
  }
  /**
   * Indicates whether Eskil's Vignette technique is enabled.
   *
   * @type {Boolean}
   * @deprecated Use technique instead.
   */
  set eskil(value) {
    this.technique = value ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT;
  }
  /**
   * Returns the Vignette technique.
   *
   * @deprecated Use technique instead.
   * @return {VignetteTechnique} The technique.
   */
  getTechnique() {
    return this.technique;
  }
  /**
   * Sets the Vignette technique.
   *
   * @deprecated Use technique instead.
   * @param {VignetteTechnique} value - The technique.
   */
  setTechnique(value) {
    this.technique = value;
  }
  /**
   * The Vignette offset.
   *
   * @type {Number}
   */
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(value) {
    this.uniforms.get("offset").value = value;
  }
  /**
   * Returns the Vignette offset.
   *
   * @deprecated Use offset instead.
   * @return {Number} The offset.
   */
  getOffset() {
    return this.offset;
  }
  /**
   * Sets the Vignette offset.
   *
   * @deprecated Use offset instead.
   * @param {Number} value - The offset.
   */
  setOffset(value) {
    this.offset = value;
  }
  /**
   * The Vignette darkness.
   *
   * @type {Number}
   */
  get darkness() {
    return this.uniforms.get("darkness").value;
  }
  set darkness(value) {
    this.uniforms.get("darkness").value = value;
  }
  /**
   * Returns the Vignette darkness.
   *
   * @deprecated Use darkness instead.
   * @return {Number} The darkness.
   */
  getDarkness() {
    return this.darkness;
  }
  /**
   * Sets the Vignette darkness.
   *
   * @deprecated Use darkness instead.
   * @param {Number} value - The darkness.
   */
  setDarkness(value) {
    this.darkness = value;
  }
};
var LUT3dlLoader = class extends Loader {
  /**
   * Loads a LUT.
   *
   * @param {String} url - The URL of the 3dl-file.
   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.
   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.
   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.
   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.
   */
  load(url, onLoad = () => {
  }, onProgress = () => {
  }, onError = null) {
    const externalManager = this.manager;
    const internalManager = new LoadingManager();
    const loader = new FileLoader(internalManager);
    loader.setPath(this.path);
    loader.setResponseType("text");
    return new Promise((resolve, reject) => {
      internalManager.onError = (url2) => {
        externalManager.itemError(url2);
        if (onError !== null) {
          onError(`Failed to load ${url2}`);
          resolve();
        } else {
          reject(`Failed to load ${url2}`);
        }
      };
      externalManager.itemStart(url);
      loader.load(url, (data) => {
        try {
          const result = this.parse(data);
          externalManager.itemEnd(url);
          onLoad(result);
          resolve(result);
        } catch (e) {
          console.error(e);
          internalManager.onError(url);
        }
      }, onProgress);
    });
  }
  /**
   * Parses the given data.
   *
   * @param {String} input - The LUT data.
   * @return {LookupTexture} The lookup texture.
   * @throws {Error} Fails if the data is invalid.
   */
  parse(input) {
    const regExpGridInfo = /^[\d ]+$/m;
    const regExpDataPoints = /^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;
    let result = regExpGridInfo.exec(input);
    if (result === null) {
      throw new Error("Missing grid information");
    }
    const gridLines = result[0].trim().split(/\s+/g).map((n) => Number(n));
    const gridStep = gridLines[1] - gridLines[0];
    const size = gridLines.length;
    const sizeSq = size ** 2;
    for (let i = 1, l = gridLines.length; i < l; ++i) {
      if (gridStep !== gridLines[i] - gridLines[i - 1]) {
        throw new Error("Inconsistent grid size");
      }
    }
    const data = new Float32Array(size ** 3 * 4);
    let maxValue = 0;
    let index = 0;
    while ((result = regExpDataPoints.exec(input)) !== null) {
      const r = Number(result[1]);
      const g = Number(result[2]);
      const b = Number(result[3]);
      maxValue = Math.max(maxValue, r, g, b);
      const bLayer = index % size;
      const gLayer = Math.floor(index / size) % size;
      const rLayer = Math.floor(index / sizeSq) % size;
      const d4 = (bLayer * sizeSq + gLayer * size + rLayer) * 4;
      data[d4 + 0] = r;
      data[d4 + 1] = g;
      data[d4 + 2] = b;
      data[d4 + 3] = 1;
      ++index;
    }
    const bits = Math.ceil(Math.log2(maxValue));
    const maxBitValue = Math.pow(2, bits);
    for (let i = 0, l = data.length; i < l; i += 4) {
      data[i + 0] /= maxBitValue;
      data[i + 1] /= maxBitValue;
      data[i + 2] /= maxBitValue;
    }
    return new LookupTexture(data, size);
  }
};
var LUTCubeLoader = class extends Loader {
  /**
   * Loads a LUT.
   *
   * @param {String} url - The URL of the CUBE-file.
   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.
   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.
   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.
   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.
   */
  load(url, onLoad = () => {
  }, onProgress = () => {
  }, onError = null) {
    const externalManager = this.manager;
    const internalManager = new LoadingManager();
    const loader = new FileLoader(internalManager);
    loader.setPath(this.path);
    loader.setResponseType("text");
    return new Promise((resolve, reject) => {
      internalManager.onError = (url2) => {
        externalManager.itemError(url2);
        if (onError !== null) {
          onError(`Failed to load ${url2}`);
          resolve();
        } else {
          reject(`Failed to load ${url2}`);
        }
      };
      externalManager.itemStart(url);
      loader.load(url, (data) => {
        try {
          const result = this.parse(data);
          externalManager.itemEnd(url);
          onLoad(result);
          resolve(result);
        } catch (e) {
          console.error(e);
          internalManager.onError(url);
        }
      }, onProgress);
    });
  }
  /**
   * Parses the given data.
   *
   * @param {String} input - The LUT data.
   * @return {LookupTexture} The lookup texture.
   * @throws {Error} Fails if the data is invalid.
   */
  parse(input) {
    const regExpTitle = /TITLE +"([^"]*)"/;
    const regExpSize = /LUT_3D_SIZE +(\d+)/;
    const regExpDomainMin = /DOMAIN_MIN +([\d.]+) +([\d.]+) +([\d.]+)/;
    const regExpDomainMax = /DOMAIN_MAX +([\d.]+) +([\d.]+) +([\d.]+)/;
    const regExpDataPoints = /^([\d.e+-]+) +([\d.e+-]+) +([\d.e+-]+) *$/gm;
    let result = regExpTitle.exec(input);
    const title = result !== null ? result[1] : null;
    result = regExpSize.exec(input);
    if (result === null) {
      throw new Error("Missing LUT_3D_SIZE information");
    }
    const size = Number(result[1]);
    const data = new Float32Array(size ** 3 * 4);
    const domainMin = new Vector3(0, 0, 0);
    const domainMax = new Vector3(1, 1, 1);
    result = regExpDomainMin.exec(input);
    if (result !== null) {
      domainMin.set(Number(result[1]), Number(result[2]), Number(result[3]));
    }
    result = regExpDomainMax.exec(input);
    if (result !== null) {
      domainMax.set(Number(result[1]), Number(result[2]), Number(result[3]));
    }
    if (domainMin.x > domainMax.x || domainMin.y > domainMax.y || domainMin.z > domainMax.z) {
      domainMin.set(0, 0, 0);
      domainMax.set(1, 1, 1);
      throw new Error("Invalid input domain");
    }
    let i = 0;
    while ((result = regExpDataPoints.exec(input)) !== null) {
      data[i++] = Number(result[1]);
      data[i++] = Number(result[2]);
      data[i++] = Number(result[3]);
      data[i++] = 1;
    }
    const lut = new LookupTexture(data, size);
    lut.domainMin.copy(domainMin);
    lut.domainMax.copy(domainMax);
    if (title !== null) {
      lut.name = title;
    }
    return lut;
  }
};

// src/materials/glsl/effect.frag
var effect_default = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if THREE_REVISION >= 137\nvec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEcolor0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}";

// src/materials/glsl/effect.vert
var effect_default2 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/EffectMaterial.js
var EffectMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new effect material.
   *
   * @param {Map<String, String>} [shaderParts] - Deprecated. Use setShaderData instead.
   * @param {Map<String, String>} [defines] - Deprecated. Use setShaderData instead.
   * @param {Map<String, Uniform>} [uniforms] - Deprecated. Use setShaderData instead.
   * @param {Camera} [camera] - A camera.
   * @param {Boolean} [dithering=false] - Deprecated.
   */
  constructor(shaderParts, defines, uniforms, camera, dithering = false) {
    super({
      name: "EffectMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        resolution: new Uniform(new Vector2()),
        texelSize: new Uniform(new Vector2()),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3),
        aspect: new Uniform(1),
        time: new Uniform(0)
      },
      blending: NoBlending,
      toneMapped: false,
      depthWrite: false,
      depthTest: false,
      dithering
    });
    if (shaderParts) {
      this.setShaderParts(shaderParts);
    }
    if (defines) {
      this.setDefines(defines);
    }
    if (uniforms) {
      this.setUniforms(uniforms);
    }
    this.copyCameraSettings(camera);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * Sets the shader data.
   *
   * @param {EffectShaderData} data - The shader data.
   * @return {EffectMaterial} This material.
   */
  setShaderData(data) {
    this.setShaderParts(data.shaderParts);
    this.setDefines(data.defines);
    this.setUniforms(data.uniforms);
    this.setExtensions(data.extensions);
  }
  /**
   * Sets the shader parts.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link EffectShaderSection}.
   * @return {EffectMaterial} This material.
   */
  setShaderParts(shaderParts) {
    this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || "").replace(EffectShaderSection.FRAGMENT_MAIN_UV, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "");
    this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, shaderParts.get(EffectShaderSection.VERTEX_HEAD) || "").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || "");
    this.fragmentShader = updateFragmentShader(this.fragmentShader);
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader macros.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.
   * @return {EffectMaterial} This material.
   */
  setDefines(defines) {
    for (const entry of defines.entries()) {
      this.defines[entry[0]] = entry[1];
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader uniforms.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, Uniform>} uniforms - A collection of uniforms.
   * @return {EffectMaterial} This material.
   */
  setUniforms(uniforms) {
    for (const entry of uniforms.entries()) {
      this.uniforms[entry[0]] = entry[1];
    }
    return this;
  }
  /**
   * Sets the required shader extensions.
   *
   * @deprecated Use setShaderData instead.
   * @param {Set<WebGLExtension>} extensions - A collection of extensions.
   * @return {EffectMaterial} This material.
   */
  setExtensions(extensions) {
    this.extensions = {};
    for (const extension of extensions) {
      this.extensions[extension] = true;
    }
    return this;
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @type {Boolean}
   */
  get encodeOutput() {
    return this.defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(value) {
    if (this.encodeOutput !== value) {
      if (value) {
        this.defines.ENCODE_OUTPUT = "1";
      } else {
        delete this.defines.ENCODE_OUTPUT;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @deprecated Use encodeOutput instead.
   * @return {Boolean} Whether output encoding is enabled.
   */
  isOutputEncodingEnabled(value) {
    return this.encodeOutput;
  }
  /**
   * Enables or disables output encoding.
   *
   * @deprecated Use encodeOutput instead.
   * @param {Boolean} value - Whether output encoding should be enabled.
   */
  setOutputEncodingEnabled(value) {
    this.encodeOutput = value;
  }
  /**
   * The time in seconds.
   *
   * @type {Number}
   */
  get time() {
    return this.uniforms.time.value;
  }
  set time(value) {
    this.uniforms.time.value = value;
  }
  /**
   * Sets the delta time.
   *
   * @deprecated Use time instead.
   * @param {Number} value - The delta time in seconds.
   */
  setDeltaTime(value) {
    this.uniforms.time.value += value;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the resolution.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.resolution.value.set(width, height);
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.aspect.value = width / height;
  }
  /**
   * An enumeration of shader code placeholders.
   *
   * @deprecated Use EffectShaderSection instead.
   * @type {Object}
   */
  static get Section() {
    return EffectShaderSection;
  }
};
function prefixSubstrings(prefix, substrings, strings) {
  for (const substring of substrings) {
    const prefixed = "$1" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);
    const regExp = new RegExp("([^\\.])(\\b" + substring + "\\b)", "g");
    for (const entry of strings.entries()) {
      if (entry[1] !== null) {
        strings.set(entry[0], entry[1].replace(regExp, prefixed));
      }
    }
  }
}
function integrateEffect(prefix, effect, data) {
  let fragmentShader = effect.getFragmentShader();
  let vertexShader = effect.getVertexShader();
  const mainImageExists = fragmentShader !== void 0 && /mainImage/.test(fragmentShader);
  const mainUvExists = fragmentShader !== void 0 && /mainUv/.test(fragmentShader);
  data.attributes |= effect.getAttributes();
  if (fragmentShader === void 0) {
    throw new Error(`Missing fragment shader (${effect.name})`);
  } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {
    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);
  } else if (!mainImageExists && !mainUvExists) {
    throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);
  } else {
    const functionRegExp = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g;
    const shaderParts = data.shaderParts;
    let fragmentHead = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || "";
    let fragmentMainUv = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "";
    let fragmentMainImage = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "";
    let vertexHead = shaderParts.get(EffectShaderSection.VERTEX_HEAD) || "";
    let vertexMainSupport = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || "";
    const varyings = /* @__PURE__ */ new Set();
    const names = /* @__PURE__ */ new Set();
    if (mainUvExists) {
      fragmentMainUv += `	${prefix}MainUv(UV);
`;
      data.uvTransformation = true;
    }
    if (vertexShader !== null && /mainSupport/.test(vertexShader)) {
      const needsUv = /mainSupport *\([\w\s]*?uv\s*?\)/.test(vertexShader);
      vertexMainSupport += `	${prefix}MainSupport(`;
      vertexMainSupport += needsUv ? "vUv);\n" : ");\n";
      for (const m2 of vertexShader.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)) {
        for (const n of m2[1].split(/\s*,\s*/)) {
          data.varyings.add(n);
          varyings.add(n);
          names.add(n);
        }
      }
      for (const m2 of vertexShader.matchAll(functionRegExp)) {
        names.add(m2[1]);
      }
    }
    for (const m2 of fragmentShader.matchAll(functionRegExp)) {
      names.add(m2[1]);
    }
    for (const d of effect.defines.keys()) {
      names.add(d.replace(/\([\w\s,]*\)/g, ""));
    }
    for (const u of effect.uniforms.keys()) {
      names.add(u);
    }
    names.delete("while");
    names.delete("for");
    names.delete("if");
    effect.uniforms.forEach((val, key) => data.uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    effect.defines.forEach((val, key) => data.defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    const shaders = /* @__PURE__ */ new Map([["fragment", fragmentShader], ["vertex", vertexShader]]);
    prefixSubstrings(prefix, names, data.defines);
    prefixSubstrings(prefix, names, shaders);
    fragmentShader = shaders.get("fragment");
    vertexShader = shaders.get("vertex");
    const blendMode = effect.blendMode;
    data.blendModes.set(blendMode.blendFunction, blendMode);
    if (mainImageExists) {
      if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {
        fragmentMainImage += effect.inputColorSpace === SRGBColorSpace ? "color0 = LinearTosRGB(color0);\n	" : "color0 = sRGBToLinear(color0);\n	";
      }
      if (effect.outputColorSpace !== NoColorSpace) {
        data.colorSpace = effect.outputColorSpace;
      } else if (effect.inputColorSpace !== null) {
        data.colorSpace = effect.inputColorSpace;
      }
      const depthParamRegExp = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      fragmentMainImage += `${prefix}MainImage(color0, UV, `;
      if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader)) {
        fragmentMainImage += "depth, ";
        data.readDepth = true;
      }
      fragmentMainImage += "color1);\n	";
      const blendOpacity = prefix + "BlendOpacity";
      data.uniforms.set(blendOpacity, blendMode.opacity);
      fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});

	`;
      fragmentHead += `uniform float ${blendOpacity};

`;
    }
    fragmentHead += fragmentShader + "\n";
    if (vertexShader !== null) {
      vertexHead += vertexShader + "\n";
    }
    shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);
    shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);
    if (effect.extensions !== null) {
      for (const extension of effect.extensions) {
        data.extensions.add(extension);
      }
    }
  }
}
var EffectPass = class extends Pass {
  /**
   * Constructs a new effect pass.
   *
   * @param {Camera} camera - The main camera.
   * @param {...Effect} effects - The effects that will be rendered by this pass.
   */
  constructor(camera, ...effects) {
    super("EffectPass");
    this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);
    this.listener = (event) => this.handleEvent(event);
    this.effects = [];
    this.setEffects(effects);
    this.skipRendering = false;
    this.minTime = 1;
    this.maxTime = Number.POSITIVE_INFINITY;
    this.timeScale = 1;
  }
  set mainScene(value) {
    for (const effect of this.effects) {
      effect.mainScene = value;
    }
  }
  set mainCamera(value) {
    this.fullscreenMaterial.copyCameraSettings(value);
    for (const effect of this.effects) {
      effect.mainCamera = value;
    }
  }
  /**
   * Indicates whether this pass encodes its output when rendering to screen.
   *
   * @type {Boolean}
   * @deprecated Use fullscreenMaterial.encodeOutput instead.
   */
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(value) {
    this.fullscreenMaterial.encodeOutput = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   */
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(value) {
    const material = this.fullscreenMaterial;
    material.dithering = value;
    material.needsUpdate = true;
  }
  /**
   * Sets the effects.
   *
   * @param {Effect[]} effects - The effects.
   * @protected
   */
  setEffects(effects) {
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
    }
    this.effects = effects.sort((a, b) => b.attributes - a.attributes);
    for (const effect of this.effects) {
      effect.addEventListener("change", this.listener);
    }
  }
  /**
   * Updates the compound shader material.
   *
   * @protected
   */
  updateMaterial() {
    const data = new EffectShaderData();
    let id = 0;
    for (const effect of this.effects) {
      if (effect.blendMode.blendFunction === BlendFunction.DST) {
        data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;
      } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {
        throw new Error(`Convolution effects cannot be merged (${effect.name})`);
      } else {
        integrateEffect("e" + id++, effect, data);
      }
    }
    let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);
    let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);
    let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);
    const blendRegExp = /\bblend\b/g;
    for (const blendMode of data.blendModes.values()) {
      fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + "\n";
    }
    if ((data.attributes & EffectAttribute.DEPTH) !== 0) {
      if (data.readDepth) {
        fragmentMainImage = "float depth = readDepth(UV);\n\n	" + fragmentMainImage;
      }
      this.needsDepthTexture = this.getDepthTexture() === null;
    } else {
      this.needsDepthTexture = false;
    }
    if (data.colorSpace === SRGBColorSpace) {
      fragmentMainImage += "color0 = sRGBToLinear(color0);\n	";
    }
    if (data.uvTransformation) {
      fragmentMainUv = "vec2 transformedUv = vUv;\n" + fragmentMainUv;
      data.defines.set("UV", "transformedUv");
    } else {
      data.defines.set("UV", "vUv");
    }
    data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    for (const [key, value] of data.shaderParts) {
      if (value !== null) {
        data.shaderParts.set(key, value.trim().replace(/^#/, "\n#"));
      }
    }
    this.skipRendering = id === 0;
    this.needsSwap = !this.skipRendering;
    this.fullscreenMaterial.setShaderData(data);
  }
  /**
   * Rebuilds the shader material.
   */
  recompile() {
    this.updateMaterial();
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
    for (const effect of this.effects) {
      effect.setDepthTexture(depthTexture, depthPacking);
    }
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    for (const effect of this.effects) {
      effect.update(renderer, inputBuffer, deltaTime);
    }
    if (!this.skipRendering || this.renderToScreen) {
      const material = this.fullscreenMaterial;
      material.inputBuffer = inputBuffer.texture;
      material.time += deltaTime * this.timeScale;
      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
      renderer.render(this.scene, this.camera);
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.fullscreenMaterial.setSize(width, height);
    for (const effect of this.effects) {
      effect.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.renderer = renderer;
    for (const effect of this.effects) {
      effect.initialize(renderer, alpha, frameBufferType);
    }
    this.updateMaterial();
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
  /**
   * Deletes disposable objects.
   */
  dispose() {
    super.dispose();
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
      effect.dispose();
    }
  }
  /**
   * Handles events.
   *
   * @param {Event} event - An event.
   */
  handleEvent(event) {
    switch (event.type) {
      case "change":
        this.recompile();
        break;
    }
  }
};

// Helper for passes that need to fill the viewport with a single quad.

new OrthographicCamera( -1, 1, 1, -1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

const _geometry = new BufferGeometry();
_geometry.setAttribute( 'position', new Float32BufferAttribute( [ -1, 3, 0, -1, -1, 0, 3, -1, 0 ], 3 ) );
_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

const $e4ca8dcb0218f846$var$_geometry = new BufferGeometry();
$e4ca8dcb0218f846$var$_geometry.setAttribute("position", new BufferAttribute(new Float32Array([
    -1,
    -1,
    3,
    -1,
    -1,
    3
]), 2));
$e4ca8dcb0218f846$var$_geometry.setAttribute("uv", new BufferAttribute(new Float32Array([
    0,
    0,
    2,
    0,
    0,
    2
]), 2));
// Recent three.js versions break setDrawRange or itemSize <3 position
$e4ca8dcb0218f846$var$_geometry.boundingSphere = new Sphere();
$e4ca8dcb0218f846$var$_geometry.computeBoundingSphere = function() {};
const $e4ca8dcb0218f846$var$_camera = new OrthographicCamera();
class $e4ca8dcb0218f846$export$dcd670d73db751f5 {
    constructor(material){
        this._mesh = new Mesh($e4ca8dcb0218f846$var$_geometry, material);
        this._mesh.frustumCulled = false;
    }
    render(renderer) {
        renderer.render(this._mesh, $e4ca8dcb0218f846$var$_camera);
    }
    get material() {
        return this._mesh.material;
    }
    set material(value) {
        this._mesh.material = value;
    }
    dispose() {
        this._mesh.material.dispose();
        this._mesh.geometry.dispose();
    }
}



const $1ed45968c1160c3c$export$c9b263b9a17dffd7 = {
    uniforms: {
        "sceneDiffuse": {
            value: null
        },
        "sceneDepth": {
            value: null
        },
        "sceneNormal": {
            value: null
        },
        "projMat": {
            value: new Matrix4()
        },
        "viewMat": {
            value: new Matrix4()
        },
        "projViewMat": {
            value: new Matrix4()
        },
        "projectionMatrixInv": {
            value: new Matrix4()
        },
        "viewMatrixInv": {
            value: new Matrix4()
        },
        "cameraPos": {
            value: new Vector3()
        },
        "resolution": {
            value: new Vector2()
        },
        "time": {
            value: 0.0
        },
        "samples": {
            value: []
        },
        "bluenoise": {
            value: null
        },
        "distanceFalloff": {
            value: 1.0
        },
        "radius": {
            value: 5.0
        },
        "near": {
            value: 0.1
        },
        "far": {
            value: 1000.0
        },
        "logDepth": {
            value: false
        },
        "ortho": {
            value: false
        },
        "screenSpaceRadius": {
            value: false
        },
        "frame": {
            value: 0.0
        }
    },
    depthWrite: false,
    depthTest: false,
    vertexShader: /* glsl */ `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1);
}`,
    fragmentShader: /* glsl */ `
    #define SAMPLES 16
    #define FSAMPLES 16.0
uniform sampler2D sceneDiffuse;
uniform highp sampler2D sceneNormal;
uniform highp sampler2D sceneDepth;
uniform mat4 projectionMatrixInv;
uniform mat4 viewMatrixInv;
uniform mat4 projMat;
uniform mat4 viewMat;
uniform mat4 projViewMat;
uniform vec3 cameraPos;
uniform vec2 resolution;
uniform float time;
uniform vec3[SAMPLES] samples;
uniform float radius;
uniform float distanceFalloff;
uniform float near;
uniform float far;
uniform float frame;
uniform bool logDepth;
uniform bool ortho;
uniform bool screenSpaceRadius;
uniform sampler2D bluenoise;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }

    vec3 getWorldPosLog(vec3 posS) {
      vec2 uv = posS.xy;
      float z = posS.z;
      float nearZ =near;
      float farZ = far;
      float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
      vec4 wpos = projectionMatrixInv * clipVec;
      return wpos.xyz / wpos.w;
    }
    vec3 getWorldPos(float depth, vec2 coord) {
      #ifdef LOGDEPTH
        return getWorldPosLog(vec3(coord, depth));
      #endif
      float z = depth * 2.0 - 1.0;
      vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
      vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
      // Perspective division
     vec4 worldSpacePosition = viewSpacePosition;
     worldSpacePosition.xyz /= worldSpacePosition.w;
      return worldSpacePosition.xyz;
  }

  vec3 computeNormal(vec3 worldPos, vec2 vUv) {
    ivec2 p = ivec2(vUv * resolution);
    float c0 = texelFetch(sceneDepth, p, 0).x;
    float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;

    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);

    vec3 ce = getWorldPos(c0, vUv).xyz;

    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;

    return normalize(cross(dpdx, dpdy));
}

mat3 makeRotationZ(float theta) {
	float c = cos(theta);
	float s = sin(theta);
	return mat3(c, - s, 0,
			s,  c, 0,
			0,  0, 1);
  }

void main() {
      vec4 diffuse = texture2D(sceneDiffuse, vUv);
      float depth = texture2D(sceneDepth, vUv).x;
      if (depth == 1.0) {
        gl_FragColor = vec4(vec3(1.0), 1.0);
        return;
      }
      vec3 worldPos = getWorldPos(depth, vUv);
      #ifdef HALFRES
        vec3 normal = texture2D(sceneNormal, vUv).rgb;
      #else
        vec3 normal = computeNormal(worldPos, vUv);
      #endif
      vec4 noise = texture2D(bluenoise, gl_FragCoord.xy / 128.0);
      vec2 harmoniousNumbers = vec2(
        1.618033988749895,
        1.324717957244746
      );
      noise.rg += harmoniousNumbers * frame;
      noise.rg = fract(noise.rg);
        vec3 helperVec = vec3(0.0, 1.0, 0.0);
        if (dot(helperVec, normal) > 0.99) {
          helperVec = vec3(1.0, 0.0, 0.0);
        }
        vec3 tangent = normalize(cross(helperVec, normal));
        vec3 bitangent = cross(normal, tangent);
        mat3 tbn = mat3(tangent, bitangent, normal) *  makeRotationZ(noise.r * 2.0 * 3.1415962) ;

      float occluded = 0.0;
      float totalWeight = 0.0;
      float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : radiusToUse * distanceFalloff * 0.2;
      float bias = (min(
        0.1,
        distanceFalloffToUse * 0.1
      ) / near) * fwidth(distance(worldPos, cameraPos)) / radiusToUse;
      float phi = 1.61803398875;
      float offsetMove = 0.0;
      float offsetMoveInv = 1.0 / FSAMPLES;
      for(float i = 0.0; i < FSAMPLES; i++) {
        vec3 sampleDirection = tbn * samples[int(i)];

        float moveAmt = fract(noise.g + offsetMove);
        offsetMove += offsetMoveInv;

        vec3 samplePos = worldPos + radiusToUse * moveAmt * sampleDirection;
        vec4 offset = projMat * vec4(samplePos, 1.0);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;
        
        vec2 diff = gl_FragCoord.xy - floor(offset.xy * resolution);
        // From Rabbid76's hbao
        vec2 clipRangeCheck = step(vec2(0.0),offset.xy) * step(offset.xy, vec2(1.0));
          float sampleDepth = textureLod(sceneDepth, offset.xy, 0.0).x;

          #ifdef LOGDEPTH

          float distSample = linearize_depth_log(sampleDepth, near, far);

          #else

          float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);

          #endif

          float distWorld = ortho ? linearize_depth_ortho(offset.z, near, far) : linearize_depth(offset.z, near, far);
          
          float rangeCheck = distSample == distWorld ? 0.0 : smoothstep(0.0, 1.0, distanceFalloffToUse / (abs(distSample - distWorld)));
          
          float sampleValid = (clipRangeCheck.x * clipRangeCheck.y);
          occluded += rangeCheck * float(sampleDepth != depth) * float(distSample + bias < distWorld) * step(
            1.0,
            dot(diff, diff)
          ) * sampleValid;
          
          totalWeight += sampleValid;
      }
      float occ = clamp(1.0 - occluded / (totalWeight == 0.0 ? 1.0 : totalWeight), 0.0, 1.0);
      gl_FragColor = vec4(occ, 0.5 + 0.5 * normal);
}`
};



const $12b21d24d1192a04$export$a815acccbd2c9a49 = {
    uniforms: {
        "sceneDiffuse": {
            value: null
        },
        "sceneDepth": {
            value: null
        },
        "tDiffuse": {
            value: null
        },
        "transparencyDWFalse": {
            value: null
        },
        "transparencyDWTrue": {
            value: null
        },
        "transparencyDWTrueDepth": {
            value: null
        },
        "transparencyAware": {
            value: false
        },
        "projMat": {
            value: new Matrix4()
        },
        "viewMat": {
            value: new Matrix4()
        },
        "projectionMatrixInv": {
            value: new Matrix4()
        },
        "viewMatrixInv": {
            value: new Matrix4()
        },
        "cameraPos": {
            value: new Vector3()
        },
        "resolution": {
            value: new Vector2()
        },
        "color": {
            value: new Vector3(0, 0, 0)
        },
        "blueNoise": {
            value: null
        },
        "downsampledDepth": {
            value: null
        },
        "time": {
            value: 0.0
        },
        "intensity": {
            value: 10.0
        },
        "renderMode": {
            value: 0.0
        },
        "gammaCorrection": {
            value: false
        },
        "logDepth": {
            value: false
        },
        "ortho": {
            value: false
        },
        "near": {
            value: 0.1
        },
        "far": {
            value: 1000.0
        },
        "screenSpaceRadius": {
            value: false
        },
        "radius": {
            value: 0.0
        },
        "distanceFalloff": {
            value: 1.0
        },
        "fog": {
            value: false
        },
        "fogExp": {
            value: false
        },
        "fogDensity": {
            value: 0.0
        },
        "fogNear": {
            value: Infinity
        },
        "fogFar": {
            value: Infinity
        },
        "colorMultiply": {
            value: true
        }
    },
    depthWrite: false,
    depthTest: false,
    vertexShader: /* glsl */ `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1);
		}`,
    fragmentShader: /* glsl */ `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform highp sampler2D downsampledDepth;
    uniform highp sampler2D transparencyDWFalse;
    uniform highp sampler2D transparencyDWTrue;
    uniform highp sampler2D transparencyDWTrueDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform vec2 resolution;
    uniform vec3 color;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform float intensity;
    uniform float renderMode;
    uniform float near;
    uniform float far;
    uniform bool gammaCorrection;
    uniform bool logDepth;
    uniform bool ortho;
    uniform bool screenSpaceRadius;
    uniform bool fog;
    uniform bool fogExp;
    uniform bool colorMultiply;
    uniform bool transparencyAware;
    uniform float fogDensity;
    uniform float fogNear;
    uniform float fogFar;
    uniform float radius;
    uniform float distanceFalloff;
    uniform vec3 cameraPos;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
       // if (logDepth) {
        #ifdef LOGDEPTH
          return getWorldPosLog(vec3(coord, depth));
        #endif
      //  }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }

    #include <common>
    #include <dithering_pars_fragment>
    void main() {
        //vec4 texel = texture2D(tDiffuse, vUv);//vec3(0.0);
        vec4 sceneTexel = texture2D(sceneDiffuse, vUv);
        float depth = texture2D(
            sceneDepth,
            vUv
        ).x;
        #ifdef HALFRES 
        vec4 texel;
        if (depth == 1.0) {
            texel = vec4(0.0, 0.0, 0.0, 1.0);
        } else {
        vec3 worldPos = getWorldPos(depth, vUv);
        vec3 normal = computeNormal(getWorldPos(depth, vUv), vUv);
       // vec4 texel = texture2D(tDiffuse, vUv);
       // Find closest depth;
       float totalWeight = 0.0;
       float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : distanceFalloff;
        for(float x = -1.0; x <= 1.0; x++) {
            for(float y = -1.0; y <= 1.0; y++) {
                vec2 offset = vec2(x, y);
                ivec2 p = ivec2(
                    (vUv * resolution * 0.5) + offset
                );
                vec2 pUv = vec2(p) / (resolution * 0.5);
                float sampleDepth = texelFetch(downsampledDepth,p, 0).x;
                vec4 sampleInfo = texelFetch(tDiffuse, p, 0);
                vec3 normalSample = sampleInfo.gba * 2.0 - 1.0;
                vec3 worldPosSample = getWorldPos(sampleDepth, pUv);
                float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
                float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0);
                float weight = rangeCheck;
                totalWeight += weight;
                texel += sampleInfo * weight;
            }
        }
        if (totalWeight == 0.0) {
            texel = texture2D(tDiffuse, vUv);
        } else {
            texel /= totalWeight;
        }
    }
        #else
        vec4 texel = texture2D(tDiffuse, vUv);
        #endif

        #ifdef LOGDEPTH
        texel.r = clamp(texel.r, 0.0, 1.0);
        if (texel.r == 0.0) {
          texel.r = 1.0;
        }
        #endif
     
        float finalAo = pow(texel.r, intensity);
        float fogFactor;
        float fogDepth = distance(
            cameraPos,
            getWorldPos(depth, vUv)
        );
        if (fog) {
            if (fogExp) {
                fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
            } else {
                fogFactor = smoothstep( fogNear, fogFar, fogDepth );
            }
        }
        if (transparencyAware) {
            float transparencyDWOff = texture2D(transparencyDWFalse, vUv).a;
            float transparencyDWOn = texture2D(transparencyDWTrue, vUv).a;
            float adjustmentFactorOff = transparencyDWOff;
            float adjustmentFactorOn = (1.0 - transparencyDWOn) * (
                texture2D(transparencyDWTrueDepth, vUv).r == texture2D(sceneDepth, vUv).r ? 1.0 : 0.0
            );
            float adjustmentFactor = max(adjustmentFactorOff, adjustmentFactorOn);
            finalAo = mix(finalAo, 1.0, adjustmentFactor);
        }
        finalAo = mix(finalAo, 1.0, fogFactor);
        vec3 aoApplied = color * mix(vec3(1.0), sceneTexel.rgb, float(colorMultiply));
        if (renderMode == 0.0) {
            gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 1.0) {
            gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 2.0) {
            gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
        } else if (renderMode == 3.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        } else if (renderMode == 4.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        }
        #include <dithering_fragment>
        if (gammaCorrection) {
            gl_FragColor = sRGBTransferOETF(gl_FragColor);
        }
    }
    `
};



const $e52378cd0f5a973d$export$57856b59f317262e = {
    uniforms: {
        "sceneDiffuse": {
            value: null
        },
        "sceneDepth": {
            value: null
        },
        "tDiffuse": {
            value: null
        },
        "projMat": {
            value: new Matrix4()
        },
        "viewMat": {
            value: new Matrix4()
        },
        "projectionMatrixInv": {
            value: new Matrix4()
        },
        "viewMatrixInv": {
            value: new Matrix4()
        },
        "cameraPos": {
            value: new Vector3()
        },
        "resolution": {
            value: new Vector2()
        },
        "time": {
            value: 0.0
        },
        "r": {
            value: 5.0
        },
        "blueNoise": {
            value: null
        },
        "radius": {
            value: 12.0
        },
        "worldRadius": {
            value: 5.0
        },
        "index": {
            value: 0.0
        },
        "poissonDisk": {
            value: []
        },
        "distanceFalloff": {
            value: 1.0
        },
        "near": {
            value: 0.1
        },
        "far": {
            value: 1000.0
        },
        "logDepth": {
            value: false
        },
        "screenSpaceRadius": {
            value: false
        }
    },
    depthWrite: false,
    depthTest: false,
    vertexShader: /* glsl */ `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1.0);
		}`,
    fragmentShader: /* glsl */ `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform vec2 resolution;
    uniform float r;
    uniform float radius;
     uniform float worldRadius;
    uniform float index;
     uniform float near;
     uniform float far;
     uniform float distanceFalloff;
     uniform bool logDepth;
     uniform bool screenSpaceRadius;
    varying vec2 vUv;

    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        highp float z_n = 2.0 * d - 1.0;
        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     return linearize_depth(linDepth, nearZ, farZ);
   }
   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
     return nearZ + (farZ - nearZ) * d;
   }
   vec3 getWorldPosLog(vec3 posS) {
     vec2 uv = posS.xy;
     float z = posS.z;
     float nearZ =near;
     float farZ = far;
     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
     vec4 wpos = projectionMatrixInv * clipVec;
     return wpos.xyz / wpos.w;
   }
    vec3 getWorldPos(float depth, vec2 coord) {
     #ifdef LOGDEPTH
          return getWorldPosLog(vec3(coord, depth));
     #endif
        
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
    #include <common>
    #define NUM_SAMPLES 16
    uniform vec2 poissonDisk[NUM_SAMPLES];
    void main() {
        const float pi = 3.14159;
        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);
        vec2 uv = vUv;
        vec4 data = texture2D(tDiffuse, vUv);
        float occlusion = data.r;
        float baseOcc = data.r;
        vec3 normal = data.gba * 2.0 - 1.0;
        float count = 1.0;
        float d = texture2D(sceneDepth, vUv).x;
        if (d == 1.0) {
          gl_FragColor = data;
          return;
        }
        vec3 worldPos = getWorldPos(d, vUv);
        float size = radius;
        float angle;
        if (index == 0.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;
        } else if (index == 1.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;
        } else if (index == 2.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;
        } else {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;
        }

        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        float radiusToUse = screenSpaceRadius ? distance(
          worldPos,
          getWorldPos(d, vUv +
            vec2(worldRadius, 0.0) / resolution)
        ) : worldRadius;
        float distanceFalloffToUse =screenSpaceRadius ?
        radiusToUse * distanceFalloff
    : radiusToUse * distanceFalloff * 0.2;


        for(int i = 0; i < NUM_SAMPLES; i++) {
            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;
            vec4 dataSample = texture2D(tDiffuse, uv + offset);
            float occSample = dataSample.r;
            vec3 normalSample = dataSample.gba * 2.0 - 1.0;
            float dSample = texture2D(sceneDepth, uv + offset).x;
            vec3 worldPosSample = getWorldPos(dSample, uv + offset);
            float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
            float rangeCheck = dSample == 1.0 ? 0.0 :exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0) * (1.0 - abs(occSample - baseOcc));
            occlusion += occSample * rangeCheck;
            count += rangeCheck;
        }
        if (count > 0.0) {
          occlusion /= count;
        }
        #ifdef LOGDEPTH
          occlusion = clamp(occlusion, 0.0, 1.0);
          if (occlusion == 0.0) {
            occlusion = 1.0;
          }
        #endif
        gl_FragColor = vec4(occlusion, 0.5 + 0.5 * normal);
    }
    `
};



const $26aca173e0984d99$export$1efdf491687cd442 = {
    uniforms: {
        "sceneDepth": {
            value: null
        },
        "resolution": {
            value: new Vector2()
        },
        "near": {
            value: 0.1
        },
        "far": {
            value: 1000.0
        },
        "viewMatrixInv": {
            value: new Matrix4()
        },
        "projectionMatrixInv": {
            value: new Matrix4()
        },
        "logDepth": {
            value: false
        }
    },
    depthWrite: false,
    depthTest: false,
    vertexShader: /* glsl */ `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1);
    }`,
    fragmentShader: /* glsl */ `
    uniform highp sampler2D sceneDepth;
    uniform vec2 resolution;
    uniform float near;
    uniform float far;
    uniform bool logDepth;
    uniform mat4 viewMatrixInv;
    uniform mat4 projectionMatrixInv;
    varying vec2 vUv;
    layout(location = 1) out vec4 gNormal;
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
        if (logDepth) {
          return getWorldPosLog(vec3(coord, depth));
        }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }
    void main() {
        vec2 uv = vUv - vec2(0.5) / resolution;
        vec2 pixelSize = vec2(1.0) / resolution;
        highp vec2[4] uvSamples;
        uvSamples[0] = uv;
        uvSamples[1] = uv + vec2(pixelSize.x, 0.0);
        uvSamples[2] = uv + vec2(0.0, pixelSize.y);
        uvSamples[3] = uv + pixelSize;
        float depth00 = texture2D(sceneDepth, uvSamples[0]).r;
        float depth10 = texture2D(sceneDepth, uvSamples[1]).r;
        float depth01 = texture2D(sceneDepth, uvSamples[2]).r;
        float depth11 = texture2D(sceneDepth, uvSamples[3]).r;
        float minDepth = min(min(depth00, depth10), min(depth01, depth11));
        float maxDepth = max(max(depth00, depth10), max(depth01, depth11));
        float targetDepth = minDepth;
        // Checkerboard pattern to avoid artifacts
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) > 0.5) { 
            targetDepth = maxDepth;
        }
        int chosenIndex = 0;
        float[4] samples;
        samples[0] = depth00;
        samples[1] = depth10;
        samples[2] = depth01;
        samples[3] = depth11;
        for(int i = 0; i < 4; ++i) {
            if (samples[i] == targetDepth) {
                chosenIndex = i;
                break;
            }
        }
        gl_FragColor = vec4(samples[chosenIndex], 0.0, 0.0, 1.0);
        gNormal = vec4(computeNormal(
            getWorldPos(samples[chosenIndex], uvSamples[chosenIndex]), uvSamples[chosenIndex]
        ), 0.0);
    }`
};









var $06269ad78f3c5fdf$export$2e2bcd8739ae039 = `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`;


const $87431ee93b037844$var$bluenoiseBits = Uint8Array.from(atob(($06269ad78f3c5fdf$export$2e2bcd8739ae039)), (c)=>c.charCodeAt(0));
/**
 * 
 * @param {*} timerQuery 
 * @param {THREE.WebGLRenderer} gl 
 * @param {N8AOPass} pass 
 */ function $87431ee93b037844$var$checkTimerQuery(timerQuery, gl, pass) {
    const available = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT_AVAILABLE);
    if (available) {
        const elapsedTimeInNs = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT);
        const elapsedTimeInMs = elapsedTimeInNs / 1000000;
        pass.lastTime = elapsedTimeInMs;
    } else // If the result is not available yet, check again after a delay
    setTimeout(()=>{
        $87431ee93b037844$var$checkTimerQuery(timerQuery, gl, pass);
    }, 1);
}
class $87431ee93b037844$export$2489f9981ab0fa82 extends (Pass) {
    /**
     * 
     * @param {THREE.Scene} scene
     * @param {THREE.Camera} camera 
     * @param {number} width 
     * @param {number} height
     *  
     * @property {THREE.Scene} scene
     * @property {THREE.Camera} camera
     * @property {number} width
     * @property {number} height
     */ constructor(scene, camera, width = 512, height = 512){
        super();
        this.width = width;
        this.height = height;
        this.clear = true;
        this.camera = camera;
        this.scene = scene;
        /**
         * @type {Proxy & {
         * aoSamples: number,
         * aoRadius: number,
         * denoiseSamples: number,
         * denoiseRadius: number,
         * distanceFalloff: number,
         * intensity: number,
         * denoiseIterations: number,
         * renderMode: 0 | 1 | 2 | 3 | 4,
         * color: THREE.Color,
         * gammaCorrection: boolean,
         * logarithmicDepthBuffer: boolean
         * screenSpaceRadius: boolean,
         * halfRes: boolean,
         * depthAwareUpsampling: boolean
         * colorMultiply: boolean
         * }
         */ this.autosetGamma = true;
        this.configuration = new Proxy({
            aoSamples: 16,
            aoRadius: 5.0,
            denoiseSamples: 8,
            denoiseRadius: 12,
            distanceFalloff: 1.0,
            intensity: 5,
            denoiseIterations: 2.0,
            renderMode: 0,
            color: new Color(0, 0, 0),
            gammaCorrection: true,
            logarithmicDepthBuffer: false,
            screenSpaceRadius: false,
            halfRes: false,
            depthAwareUpsampling: true,
            colorMultiply: true,
            transparencyAware: false,
            accumulate: false
        }, {
            set: (target, propName, value)=>{
                const oldProp = target[propName];
                target[propName] = value;
                if (value.equals) {
                    if (!value.equals(oldProp)) this.firstFrame();
                } else if (oldProp !== value) this.firstFrame();
                if (propName === "aoSamples" && oldProp !== value) this.configureAOPass(this.configuration.logarithmicDepthBuffer);
                if (propName === "denoiseSamples" && oldProp !== value) this.configureDenoisePass(this.configuration.logarithmicDepthBuffer);
                if (propName === "halfRes" && oldProp !== value) {
                    this.configureAOPass(this.configuration.logarithmicDepthBuffer);
                    this.configureHalfResTargets();
                    this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer);
                    this.setSize(this.width, this.height);
                }
                if (propName === "depthAwareUpsampling" && oldProp !== value) this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer);
                if (propName === "gammaCorrection") this.autosetGamma = false;
                if (propName === "transparencyAware" && oldProp !== value) {
                    this.autoDetectTransparency = false;
                    this.configureTransparencyTarget();
                }
                return true;
            }
        });
        /** @type {THREE.Vector3[]} */ this.samples = [];
        /** @type {THREE.Vector2[]} */ this.samplesDenoise = [];
        this.autoDetectTransparency = true;
        this.frames = 0;
        this.lastViewMatrix = new Matrix4();
        this.lastProjectionMatrix = new Matrix4();
        this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer);
        this.configureSampleDependentPasses();
        this.configureHalfResTargets();
        this.detectTransparency();
        this.configureTransparencyTarget();
        //   this.effectCompisterQuad = new FullScreenTriangle(new THREE.ShaderMaterial(EffectCompositer));
        this.copyQuad = new ($e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial({
            uniforms: {
                tDiffuse: {
                    value: null
                }
            },
            depthWrite: false,
            vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1);
            }
            `,
            fragmentShader: `
            uniform sampler2D tDiffuse;
            varying vec2 vUv;
            void main() {
                gl_FragColor = texture2D(tDiffuse, vUv);
            }
            `
        }));
        this.writeTargetInternal = new WebGLRenderTarget(this.width, this.height, {
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            depthBuffer: false
        });
        this.readTargetInternal = new WebGLRenderTarget(this.width, this.height, {
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            depthBuffer: false
        });
        this.outputTargetInternal = new WebGLRenderTarget(this.width, this.height, {
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            depthBuffer: false
        });
        this.accumulationRenderTarget = new WebGLRenderTarget(this.width, this.height, {
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            depthBuffer: false,
            format: RGBAFormat,
            type: HalfFloatType,
            stencilBuffer: false,
            depthBuffer: false,
            alpha: true
        });
        this.accumulationQuad = new ($e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial({
            uniforms: {
                frame: {
                    value: 0
                },
                tDiffuse: {
                    value: null
                }
            },
            transparent: true,
            opacity: 1,
            vertexShader: `
             varying vec2 vUv;
             void main() {
                 vUv = uv;
                 gl_Position = vec4(position, 1);
             }`,
            fragmentShader: `
             uniform sampler2D tDiffuse;
             uniform float frame;
                varying vec2 vUv;
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    gl_FragColor = vec4(color.rgb, 1.0 / (frame + 1.0));
                }
                `
        }));
        /** @type {THREE.DataTexture} */ this.bluenoise = new DataTexture($87431ee93b037844$var$bluenoiseBits, 128, 128);
        this.bluenoise.colorSpace = NoColorSpace;
        this.bluenoise.wrapS = RepeatWrapping;
        this.bluenoise.wrapT = RepeatWrapping;
        this.bluenoise.minFilter = NearestFilter;
        this.bluenoise.magFilter = NearestFilter;
        this.bluenoise.needsUpdate = true;
        this.lastTime = 0;
        this.needsDepthTexture = true;
        this.needsSwap = true;
        this._r = new Vector2();
        this._c = new Color();
    }
    configureHalfResTargets() {
        this.firstFrame();
        if (this.configuration.halfRes) {
            this.depthDownsampleTarget = REVISION > 161 ? new WebGLRenderTarget(this.width / 2, this.height / 2, {
                count: 2
            }) : new WebGLRenderTarget(this.width / 2, this.height / 2, 2);
            if (REVISION <= 161) this.depthDownsampleTarget.textures = this.depthDownsampleTarget.texture;
            this.depthDownsampleTarget.textures[0].format = RedFormat;
            this.depthDownsampleTarget.textures[0].type = FloatType;
            this.depthDownsampleTarget.textures[0].minFilter = NearestFilter;
            this.depthDownsampleTarget.textures[0].magFilter = NearestFilter;
            this.depthDownsampleTarget.textures[0].depthBuffer = false;
            this.depthDownsampleTarget.textures[1].format = RGBAFormat;
            this.depthDownsampleTarget.textures[1].type = HalfFloatType;
            this.depthDownsampleTarget.textures[1].minFilter = NearestFilter;
            this.depthDownsampleTarget.textures[1].magFilter = NearestFilter;
            this.depthDownsampleTarget.textures[1].depthBuffer = false;
            this.depthDownsampleQuad = new ($e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(($26aca173e0984d99$export$1efdf491687cd442)));
        } else {
            if (this.depthDownsampleTarget) {
                this.depthDownsampleTarget.dispose();
                this.depthDownsampleTarget = null;
            }
            if (this.depthDownsampleQuad) {
                this.depthDownsampleQuad.dispose();
                this.depthDownsampleQuad = null;
            }
        }
    }
    detectTransparency() {
        if (this.autoDetectTransparency) {
            let isTransparency = false;
            this.scene.traverse((obj)=>{
                if (obj.material && obj.material.transparent) isTransparency = true;
            });
            if (isTransparency) this.configuration.transparencyAware = true;
        }
    }
    configureTransparencyTarget() {
        if (this.configuration.transparencyAware) {
            this.transparencyRenderTargetDWFalse = new WebGLRenderTarget(this.width, this.height, {
                minFilter: LinearFilter,
                magFilter: NearestFilter,
                type: HalfFloatType,
                format: RGBAFormat
            });
            this.transparencyRenderTargetDWTrue = new WebGLRenderTarget(this.width, this.height, {
                minFilter: LinearFilter,
                magFilter: NearestFilter,
                type: HalfFloatType,
                format: RGBAFormat
            });
            this.transparencyRenderTargetDWTrue.depthTexture = new DepthTexture(this.width, this.height, UnsignedIntType);
            this.depthCopyPass = new ($e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial({
                uniforms: {
                    depthTexture: {
                        value: this.depthTexture
                    }
                },
                vertexShader: /* glsl */ `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1);
            }`,
                fragmentShader: /* glsl */ `
            uniform sampler2D depthTexture;
            varying vec2 vUv;
            void main() {
               gl_FragDepth = texture2D(depthTexture, vUv).r + 0.00001;
               gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            }
            `
            }));
        } else {
            if (this.transparencyRenderTargetDWFalse) {
                this.transparencyRenderTargetDWFalse.dispose();
                this.transparencyRenderTargetDWFalse = null;
            }
            if (this.transparencyRenderTargetDWTrue) {
                this.transparencyRenderTargetDWTrue.dispose();
                this.transparencyRenderTargetDWTrue = null;
            }
            if (this.depthCopyPass) {
                this.depthCopyPass.dispose();
                this.depthCopyPass = null;
            }
        }
    }
    renderTransparency(renderer) {
        const oldBackground = this.scene.background;
        const oldClearColor = renderer.getClearColor(new Color());
        const oldClearAlpha = renderer.getClearAlpha();
        const oldVisibility = new Map();
        const oldAutoClearDepth = renderer.autoClearDepth;
        this.scene.traverse((obj)=>{
            oldVisibility.set(obj, obj.visible);
        });
        // Override the state
        this.scene.background = null;
        renderer.autoClearDepth = false;
        renderer.setClearColor(new Color(0, 0, 0), 0);
        this.depthCopyPass.material.uniforms.depthTexture.value = this.depthTexture;
        // Render out transparent objects WITHOUT depth write
        renderer.setRenderTarget(this.transparencyRenderTargetDWFalse);
        this.scene.traverse((obj)=>{
            if (obj.material) obj.visible = oldVisibility.get(obj) && obj.material.transparent && !obj.material.depthWrite && !obj.userData.treatAsOpaque;
        });
        renderer.clear(true, true, true);
        this.depthCopyPass.render(renderer);
        renderer.render(this.scene, this.camera);
        // Render out transparent objects WITH depth write
        renderer.setRenderTarget(this.transparencyRenderTargetDWTrue);
        this.scene.traverse((obj)=>{
            if (obj.material) obj.visible = oldVisibility.get(obj) && obj.material.transparent && obj.material.depthWrite && !obj.userData.treatAsOpaque;
        });
        renderer.clear(true, true, true);
        this.depthCopyPass.render(renderer);
        renderer.render(this.scene, this.camera);
        // Restore
        this.scene.traverse((obj)=>{
            obj.visible = oldVisibility.get(obj);
        });
        renderer.setClearColor(oldClearColor, oldClearAlpha);
        this.scene.background = oldBackground;
        renderer.autoClearDepth = oldAutoClearDepth;
    }
    configureSampleDependentPasses() {
        this.configureAOPass(this.configuration.logarithmicDepthBuffer);
        this.configureDenoisePass(this.configuration.logarithmicDepthBuffer);
    }
    configureAOPass(logarithmicDepthBuffer = false) {
        this.firstFrame();
        this.samples = this.generateHemisphereSamples(this.configuration.aoSamples);
        const e = {
            ...($1ed45968c1160c3c$export$c9b263b9a17dffd7)
        };
        e.fragmentShader = e.fragmentShader.replace("16", this.configuration.aoSamples).replace("16.0", this.configuration.aoSamples + ".0");
        if (logarithmicDepthBuffer) e.fragmentShader = "#define LOGDEPTH\n" + e.fragmentShader;
        if (this.configuration.halfRes) e.fragmentShader = "#define HALFRES\n" + e.fragmentShader;
        if (this.effectShaderQuad) {
            this.effectShaderQuad.material.dispose();
            this.effectShaderQuad.material = new ShaderMaterial(e);
        } else this.effectShaderQuad = new ($e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(e));
    }
    configureDenoisePass(logarithmicDepthBuffer = false) {
        this.firstFrame();
        this.samplesDenoise = this.generateDenoiseSamples(this.configuration.denoiseSamples, 11);
        const p = {
            ...($e52378cd0f5a973d$export$57856b59f317262e)
        };
        p.fragmentShader = p.fragmentShader.replace("16", this.configuration.denoiseSamples);
        if (logarithmicDepthBuffer) p.fragmentShader = "#define LOGDEPTH\n" + p.fragmentShader;
        if (this.poissonBlurQuad) {
            this.poissonBlurQuad.material.dispose();
            this.poissonBlurQuad.material = new ShaderMaterial(p);
        } else this.poissonBlurQuad = new ($e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(p));
    }
    configureEffectCompositer(logarithmicDepthBuffer = false) {
        this.firstFrame();
        const e = {
            ...($12b21d24d1192a04$export$a815acccbd2c9a49)
        };
        if (logarithmicDepthBuffer) e.fragmentShader = "#define LOGDEPTH\n" + e.fragmentShader;
        if (this.configuration.halfRes && this.configuration.depthAwareUpsampling) e.fragmentShader = "#define HALFRES\n" + e.fragmentShader;
        if (this.effectCompositerQuad) {
            this.effectCompositerQuad.material.dispose();
            this.effectCompositerQuad.material = new ShaderMaterial(e);
        } else this.effectCompositerQuad = new ($e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(e));
    }
    /**
         * 
         * @param {Number} n 
         * @returns {THREE.Vector3[]}
         */ generateHemisphereSamples(n) {
        const points = [];
        for(let k = 0; k < n; k++){
            const theta = 2.399963 * k;
            const r = Math.sqrt(k + 0.5) / Math.sqrt(n);
            const x = r * Math.cos(theta);
            const y = r * Math.sin(theta);
            // Project to hemisphere
            const z = Math.sqrt(1 - (x * x + y * y));
            points.push(new Vector3(x, y, z));
        }
        return points;
    }
    /**
         * 
         * @param {number} numSamples 
         * @param {number} numRings 
         * @returns {THREE.Vector2[]}
         */ generateDenoiseSamples(numSamples, numRings) {
        const angleStep = 2 * Math.PI * numRings / numSamples;
        const invNumSamples = 1.0 / numSamples;
        const radiusStep = invNumSamples;
        const samples = [];
        let radius = invNumSamples;
        let angle = 0;
        for(let i = 0; i < numSamples; i++){
            samples.push(new Vector2(Math.cos(angle), Math.sin(angle)).multiplyScalar(Math.pow(radius, 0.75)));
            radius += radiusStep;
            angle += angleStep;
        }
        return samples;
    }
    setSize(width, height) {
        this.firstFrame();
        this.width = width;
        this.height = height;
        const c = this.configuration.halfRes ? 0.5 : 1;
        this.writeTargetInternal.setSize(width * c, height * c);
        this.readTargetInternal.setSize(width * c, height * c);
        this.accumulationRenderTarget.setSize(width * c, height * c);
        if (this.configuration.halfRes) this.depthDownsampleTarget.setSize(width * c, height * c);
        if (this.configuration.transparencyAware) {
            this.transparencyRenderTargetDWFalse.setSize(width, height);
            this.transparencyRenderTargetDWTrue.setSize(width, height);
        }
        this.outputTargetInternal.setSize(width, height);
    }
    setDepthTexture(depthTexture) {
        this.depthTexture = depthTexture;
    }
    firstFrame() {
        this.needsFrame = true;
    }
    render(renderer, inputBuffer, outputBuffer) {
        const xrEnabled = renderer.xr.enabled;
        renderer.xr.enabled = false;
        // Copy inputBuffer to outputBuffer
        //renderer.setRenderTarget(outputBuffer);
        //  this.copyQuad.material.uniforms.tDiffuse.value = inputBuffer.texture;
        //   this.copyQuad.render(renderer);
        if (renderer.capabilities.logarithmicDepthBuffer !== this.configuration.logarithmicDepthBuffer) {
            this.configuration.logarithmicDepthBuffer = renderer.capabilities.logarithmicDepthBuffer;
            this.configureAOPass(this.configuration.logarithmicDepthBuffer);
            this.configureDenoisePass(this.configuration.logarithmicDepthBuffer);
            this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer);
        }
        this.detectTransparency();
        if (inputBuffer.texture.type !== this.outputTargetInternal.texture.type || inputBuffer.texture.format !== this.outputTargetInternal.texture.format) {
            this.outputTargetInternal.texture.type = inputBuffer.texture.type;
            this.outputTargetInternal.texture.format = inputBuffer.texture.format;
            this.outputTargetInternal.texture.needsUpdate = true;
        }
        this.camera.updateMatrixWorld();
        if (this.lastViewMatrix.equals(this.camera.matrixWorldInverse) && this.lastProjectionMatrix.equals(this.camera.projectionMatrix) && this.configuration.accumulate && !this.needsFrame) this.frame++;
        else {
            renderer.setRenderTarget(this.accumulationRenderTarget);
            renderer.clear(true, true, true);
            this.frame = 0;
            this.needsFrame = false;
        }
        this.lastViewMatrix.copy(this.camera.matrixWorldInverse);
        this.lastProjectionMatrix.copy(this.camera.projectionMatrix);
        let gl;
        let ext;
        let timerQuery;
        if (this.debugMode) {
            gl = renderer.getContext();
            ext = gl.getExtension("EXT_disjoint_timer_query_webgl2");
            if (ext === null) {
                console.error("EXT_disjoint_timer_query_webgl2 not available, disabling debug mode.");
                this.debugMode = false;
            }
        }
        if (this.debugMode) {
            timerQuery = gl.createQuery();
            gl.beginQuery(ext.TIME_ELAPSED_EXT, timerQuery);
        }
        if (this.configuration.transparencyAware) this.renderTransparency(renderer);
        this._r.set(this.width, this.height);
        let trueRadius = this.configuration.aoRadius;
        if (this.configuration.halfRes && this.configuration.screenSpaceRadius) trueRadius *= 0.5;
        if (this.frame < 1024 / this.configuration.aoSamples) {
            if (this.configuration.halfRes) {
                renderer.setRenderTarget(this.depthDownsampleTarget);
                this.depthDownsampleQuad.material.uniforms.sceneDepth.value = this.depthTexture;
                this.depthDownsampleQuad.material.uniforms.resolution.value = this._r;
                this.depthDownsampleQuad.material.uniforms["near"].value = this.camera.near;
                this.depthDownsampleQuad.material.uniforms["far"].value = this.camera.far;
                this.depthDownsampleQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
                this.depthDownsampleQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
                this.depthDownsampleQuad.material.uniforms["logDepth"].value = this.configuration.logarithmicDepthBuffer;
                this.depthDownsampleQuad.render(renderer);
            }
            this.effectShaderQuad.material.uniforms["sceneDiffuse"].value = inputBuffer.texture;
            this.effectShaderQuad.material.uniforms["sceneDepth"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.depthTexture;
            this.effectShaderQuad.material.uniforms["sceneNormal"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[1] : null;
            this.effectShaderQuad.material.uniforms["projMat"].value = this.camera.projectionMatrix;
            this.effectShaderQuad.material.uniforms["viewMat"].value = this.camera.matrixWorldInverse;
            this.effectShaderQuad.material.uniforms["projViewMat"].value = this.camera.projectionMatrix.clone().multiply(this.camera.matrixWorldInverse.clone());
            this.effectShaderQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
            this.effectShaderQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
            this.effectShaderQuad.material.uniforms["cameraPos"].value = this.camera.getWorldPosition(new Vector3());
            this.effectShaderQuad.material.uniforms["resolution"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;
            this.effectShaderQuad.material.uniforms["time"].value = performance.now() / 1000;
            this.effectShaderQuad.material.uniforms["samples"].value = this.samples;
            this.effectShaderQuad.material.uniforms["bluenoise"].value = this.bluenoise;
            this.effectShaderQuad.material.uniforms["radius"].value = trueRadius;
            this.effectShaderQuad.material.uniforms["distanceFalloff"].value = this.configuration.distanceFalloff;
            this.effectShaderQuad.material.uniforms["near"].value = this.camera.near;
            this.effectShaderQuad.material.uniforms["far"].value = this.camera.far;
            this.effectShaderQuad.material.uniforms["logDepth"].value = renderer.capabilities.logarithmicDepthBuffer;
            this.effectShaderQuad.material.uniforms["ortho"].value = this.camera.isOrthographicCamera;
            this.effectShaderQuad.material.uniforms["screenSpaceRadius"].value = this.configuration.screenSpaceRadius;
            this.effectShaderQuad.material.uniforms["frame"].value = this.frame;
            // Start the AO
            renderer.setRenderTarget(this.writeTargetInternal);
            this.effectShaderQuad.render(renderer);
            // End the AO
            // Start the blur
            for(let i = 0; i < this.configuration.denoiseIterations; i++){
                [this.writeTargetInternal, this.readTargetInternal] = [
                    this.readTargetInternal,
                    this.writeTargetInternal
                ];
                this.poissonBlurQuad.material.uniforms["tDiffuse"].value = this.readTargetInternal.texture;
                this.poissonBlurQuad.material.uniforms["sceneDepth"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.depthTexture;
                this.poissonBlurQuad.material.uniforms["projMat"].value = this.camera.projectionMatrix;
                this.poissonBlurQuad.material.uniforms["viewMat"].value = this.camera.matrixWorldInverse;
                this.poissonBlurQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
                this.poissonBlurQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
                this.poissonBlurQuad.material.uniforms["cameraPos"].value = this.camera.getWorldPosition(new Vector3());
                this.poissonBlurQuad.material.uniforms["resolution"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;
                this.poissonBlurQuad.material.uniforms["time"].value = performance.now() / 1000;
                this.poissonBlurQuad.material.uniforms["blueNoise"].value = this.bluenoise;
                this.poissonBlurQuad.material.uniforms["radius"].value = this.configuration.denoiseRadius * (this.configuration.halfRes ? 0.5 : 1);
                this.poissonBlurQuad.material.uniforms["worldRadius"].value = trueRadius;
                this.poissonBlurQuad.material.uniforms["distanceFalloff"].value = this.configuration.distanceFalloff;
                this.poissonBlurQuad.material.uniforms["index"].value = i;
                this.poissonBlurQuad.material.uniforms["poissonDisk"].value = this.samplesDenoise;
                this.poissonBlurQuad.material.uniforms["near"].value = this.camera.near;
                this.poissonBlurQuad.material.uniforms["far"].value = this.camera.far;
                this.poissonBlurQuad.material.uniforms["logDepth"].value = renderer.capabilities.logarithmicDepthBuffer;
                this.poissonBlurQuad.material.uniforms["screenSpaceRadius"].value = this.configuration.screenSpaceRadius;
                renderer.setRenderTarget(this.writeTargetInternal);
                this.poissonBlurQuad.render(renderer);
            }
            renderer.setRenderTarget(this.accumulationRenderTarget);
            const oldAutoClear = renderer.autoClear;
            renderer.autoClear = false;
            this.accumulationQuad.material.uniforms["tDiffuse"].value = this.writeTargetInternal.texture;
            this.accumulationQuad.material.uniforms["frame"].value = this.frame;
            this.accumulationQuad.render(renderer);
            renderer.autoClear = oldAutoClear;
        }
        // Now, we have the blurred AO in writeTargetInternal
        // End the blur
        // Start the composition
        if (this.configuration.transparencyAware) {
            this.effectCompositerQuad.material.uniforms["transparencyDWFalse"].value = this.transparencyRenderTargetDWFalse.texture;
            this.effectCompositerQuad.material.uniforms["transparencyDWTrue"].value = this.transparencyRenderTargetDWTrue.texture;
            this.effectCompositerQuad.material.uniforms["transparencyDWTrueDepth"].value = this.transparencyRenderTargetDWTrue.depthTexture;
            this.effectCompositerQuad.material.uniforms["transparencyAware"].value = true;
        }
        this.effectCompositerQuad.material.uniforms["sceneDiffuse"].value = inputBuffer.texture;
        this.effectCompositerQuad.material.uniforms["sceneDepth"].value = this.depthTexture;
        this.effectCompositerQuad.material.uniforms["near"].value = this.camera.near;
        this.effectCompositerQuad.material.uniforms["far"].value = this.camera.far;
        this.effectCompositerQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
        this.effectCompositerQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
        this.effectCompositerQuad.material.uniforms["logDepth"].value = renderer.capabilities.logarithmicDepthBuffer;
        this.effectCompositerQuad.material.uniforms["ortho"].value = this.camera.isOrthographicCamera;
        this.effectCompositerQuad.material.uniforms["downsampledDepth"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.depthTexture;
        this.effectCompositerQuad.material.uniforms["resolution"].value = this._r;
        this.effectCompositerQuad.material.uniforms["blueNoise"].value = this.bluenoise;
        this.effectCompositerQuad.material.uniforms["intensity"].value = this.configuration.intensity;
        this.effectCompositerQuad.material.uniforms["renderMode"].value = this.configuration.renderMode;
        this.effectCompositerQuad.material.uniforms["screenSpaceRadius"].value = this.configuration.screenSpaceRadius;
        this.effectCompositerQuad.material.uniforms["radius"].value = trueRadius;
        this.effectCompositerQuad.material.uniforms["distanceFalloff"].value = this.configuration.distanceFalloff;
        this.effectCompositerQuad.material.uniforms["gammaCorrection"].value = this.autosetGamma ? this.renderToScreen : this.configuration.gammaCorrection;
        this.effectCompositerQuad.material.uniforms["tDiffuse"].value = this.accumulationRenderTarget.texture;
        this.effectCompositerQuad.material.uniforms["color"].value = this._c.copy(this.configuration.color).convertSRGBToLinear();
        this.effectCompositerQuad.material.uniforms["colorMultiply"].value = this.configuration.colorMultiply;
        this.effectCompositerQuad.material.uniforms["cameraPos"].value = this.camera.getWorldPosition(new Vector3());
        this.effectCompositerQuad.material.uniforms["fog"].value = !!this.scene.fog;
        if (this.scene.fog) {
            if (this.scene.fog.isFog) {
                this.effectCompositerQuad.material.uniforms["fogExp"].value = false;
                this.effectCompositerQuad.material.uniforms["fogNear"].value = this.scene.fog.near;
                this.effectCompositerQuad.material.uniforms["fogFar"].value = this.scene.fog.far;
            } else if (this.scene.fog.isFogExp2) {
                this.effectCompositerQuad.material.uniforms["fogExp"].value = true;
                this.effectCompositerQuad.material.uniforms["fogDensity"].value = this.scene.fog.density;
            } else console.error(`Unsupported fog type ${this.scene.fog.constructor.name} in SSAOPass.`);
        }
        renderer.setRenderTarget(/* this.renderToScreen ? null :
                 outputBuffer*/ this.outputTargetInternal);
        this.effectCompositerQuad.render(renderer);
        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
        this.copyQuad.material.uniforms["tDiffuse"].value = this.outputTargetInternal.texture;
        this.copyQuad.render(renderer);
        if (this.debugMode) {
            gl.endQuery(ext.TIME_ELAPSED_EXT);
            $87431ee93b037844$var$checkTimerQuery(timerQuery, gl, this);
        }
        renderer.xr.enabled = xrEnabled;
    }
    /**
         * Enables the debug mode of the AO, meaning the lastTime value will be updated.
         */ enableDebugMode() {
        this.debugMode = true;
    }
    /**
         * Disables the debug mode of the AO, meaning the lastTime value will not be updated.
         */ disableDebugMode() {
        this.debugMode = false;
    }
    /**
         * Sets the display mode of the AO
         * @param {"Combined" | "AO" | "No AO" | "Split" | "Split AO"} mode - The display mode. 
         */ setDisplayMode(mode) {
        this.configuration.renderMode = [
            "Combined",
            "AO",
            "No AO",
            "Split",
            "Split AO"
        ].indexOf(mode);
    }
    /**
         * 
         * @param {"Performance" | "Low" | "Medium" | "High" | "Ultra"} mode 
         */ setQualityMode(mode) {
        if (mode === "Performance") {
            this.configuration.aoSamples = 8;
            this.configuration.denoiseSamples = 4;
            this.configuration.denoiseRadius = 12;
        } else if (mode === "Low") {
            this.configuration.aoSamples = 16;
            this.configuration.denoiseSamples = 4;
            this.configuration.denoiseRadius = 12;
        } else if (mode === "Medium") {
            this.configuration.aoSamples = 16;
            this.configuration.denoiseSamples = 8;
            this.configuration.denoiseRadius = 12;
        } else if (mode === "High") {
            this.configuration.aoSamples = 64;
            this.configuration.denoiseSamples = 8;
            this.configuration.denoiseRadius = 6;
        } else if (mode === "Ultra") {
            this.configuration.aoSamples = 64;
            this.configuration.denoiseSamples = 16;
            this.configuration.denoiseRadius = 6;
        }
    }
}



Uint8Array.from(atob(($06269ad78f3c5fdf$export$2e2bcd8739ae039)), (c)=>c.charCodeAt(0));

// https://www.shadertoy.com/view/4t2fRz
const LensDistortionShader = {
	useSrgbEncoding: false,

	defines: {
		// 0: NONE, 1: RGB, 2: RYGCBV
		BAND_MODE: 2,

		CHROMA_SAMPLES: 4
	},

	uniforms: {
		tDiffuse: { value: null },
		baseIor: { value: 0.95 },
		bandOffset: { value: 0.001125 },
		jitterIntensity: { value: 5 },
		jitterOffset: { value: 0.0 }
	},

	vertexShader: /* glsl */ `

		varying vec2 vUv;
		varying vec3 viewDir;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			viewDir = normalize( ( modelViewMatrix * vec4( position, 1.0 ) ).xyz );

		}

	`,

	fragmentShader: /* glsl */ `

		varying vec2 vUv;
		varying vec3 viewDir;
		uniform float baseIor;
		uniform float bandOffset;
		uniform float jitterIntensity;
		uniform float jitterOffset;
		uniform sampler2D tDiffuse;

		#include <common>

		void main() {

			vec3 normal = vec3( ( 2.0 * vUv - vec2( 1.0 ) ), 1.0 );
			normal.z = 1.0;
			normal = normalize( normal );

			vec3 color;

			// if NO BANDS
			#if BAND_MODE == 0

			vec3 refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor );
			color = texture2D( tDiffuse, vUv + refracted.xy ).rgb;

			// if RGB or RYGCBV BANDS
			#else

			float index, randValue, offsetValue;
			float r, g, b, r_ior, g_ior, b_ior;
			vec3 r_refracted, g_refracted, b_refracted;
			vec4 r_sample, g_sample, b_sample;

			#if BAND_MODE == 2
			float y, c, v, y_ior, c_ior, v_ior;
			vec3 y_refracted, c_refracted, v_refracted;
			vec4 y_sample, c_sample, v_sample;
			#endif

			for ( int i = 0; i < CHROMA_SAMPLES; i ++ ) {

				index = float( i );
				randValue = rand( sin( index + 1. ) * gl_FragCoord.xy + vec2( jitterOffset, - jitterOffset ) ) - 0.5;
				offsetValue = index / float( CHROMA_SAMPLES ) + randValue * jitterIntensity;
				#if BAND_MODE == 1
				randValue *= 2.0;
				#endif

				// Paper describing functions for creating yellow, cyan, and violet bands and reforming
				// them into RGB:
				// https://web.archive.org/web/20061108181225/http://home.iitk.ac.in/~shankars/reports/dispersionraytrace.pdf
				r_ior = 1.0 + bandOffset * ( 0.0 + offsetValue );
				g_ior = 1.0 + bandOffset * ( 2.0 + offsetValue );
				b_ior = 1.0 + bandOffset * ( 4.0 + offsetValue );

				r_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / r_ior );
				g_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / g_ior );
				b_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / b_ior );

				r_sample = texture2D( tDiffuse, vUv + r_refracted.xy );
				g_sample = texture2D( tDiffuse, vUv + g_refracted.xy );
				b_sample = texture2D( tDiffuse, vUv + b_refracted.xy );

				#if BAND_MODE == 2
				y_ior = 1.0 + bandOffset * ( 1.0 + offsetValue );
				c_ior = 1.0 + bandOffset * ( 3.0 + offsetValue );
				v_ior = 1.0 + bandOffset * ( 5.0 + offsetValue );

				y_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / y_ior );
				c_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / c_ior );
				v_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / v_ior );

				y_sample = texture2D( tDiffuse, vUv + y_refracted.xy );
				c_sample = texture2D( tDiffuse, vUv + c_refracted.xy );
				v_sample = texture2D( tDiffuse, vUv + v_refracted.xy );

				r = r_sample.r / 2.0;
				y = ( 2.0 * y_sample.r + 2.0 * y_sample.g - y_sample.b ) / 6.0;
				g = g_sample.g / 2.0;
				c = ( 2.0 * c_sample.g + 2.0 * c_sample.b - c_sample.r ) / 6.0;
				b = b_sample.b / 2.0;
				v = ( 2.0 * v_sample.b + 2.0 * v_sample.r - v_sample.g ) / 6.0;

				color.r += r + ( 2.0 * v + 2.0 * y - c ) / 3.0;
				color.g += g + ( 2.0 * y + 2.0 * c - v ) / 3.0;
				color.b += b + ( 2.0 * c + 2.0 * v - y ) / 3.0;
				#else
				color.r += r_sample.r;
				color.g += g_sample.g;
				color.b += b_sample.b;
				#endif

			}

			color /= float( CHROMA_SAMPLES );

			#endif

			gl_FragColor = vec4( color, 1.0 );

		}

	`,
	onBeforeCompile(shader, ...args) {
		if (typeof super.onBeforeCompile === "function") super.onBeforeCompile(shader, ...args);

		if (this.useSrgbEncoding === true) {
			shader.fragmentShader = shader.fragmentShader.replace(
				"gl_FragColor = vec4( color, 1.0 );",
				"gl_FragColor = LinearTosRGB(vec4( color, 1.0 ));"
			);
		}
	}
};

class Composer extends EffectComposer {



	constructor( renderer, scene, camera, controls, size ) {
		renderer.getPixelRatio();

		super( renderer, { stencilBuffer: true, depthBuffer: true, frameBufferType: HalfFloatType } );

		renderer.autoClear = false;

		this.enabled = false;

		const renderPass = new RenderPass( scene, camera );
		renderPass.name = 'render';
		renderPass.clearPass.setClearFlags(true, true, true);
		this.addPass(renderPass);

		const n8aopass = new $87431ee93b037844$export$2489f9981ab0fa82( scene, camera, size.w, size.h );
		n8aopass.name = 'n8ao';
		n8aopass.configuration.aoRadius = 5.0;
        n8aopass.configuration.distanceFalloff = 1.0;
        n8aopass.configuration.transparencyAware = true;
        n8aopass.configuration.intensity = 5.0;
        n8aopass.configuration.aoSamples = 16.0;
        n8aopass.configuration.denoiseRadius = 12.0;
        n8aopass.configuration.denoiseSamples = 8.0;
        n8aopass.configuration.stencil = true;
        n8aopass.configuration.renderMode = 0;//["Combined", "AO", "No AO", "Split", "Split AO"]
        n8aopass.configuration.color = new Color(0, 0, 0);
        n8aopass.configuration.screenSpaceRadius = false;
        n8aopass.configuration.halfRes = false;
        n8aopass.configuration.depthAwareUpsampling = true;
        n8aopass.configuration.colorMultiply = true;
        n8aopass.configuration.accumulate = false;

	    this.addPass(n8aopass);


	    const lens = new ShaderMaterial();
		Object.assign(lens, LensDistortionShader);
		lens.defines.CHROMA_SAMPLES = 1;//24
		lens.uniforms.baseIor.value = 0.86;//965
		lens.uniforms.bandOffset.value = 0;//0.0015
		lens.uniforms.jitterIntensity.value = 0;//5.375
		const lensDistortionPass = new ShaderPass( lens );
		lensDistortionPass.name = 'lens';
		const lensDistortionPassRender = lensDistortionPass.render;
		lensDistortionPass.render = (renderer, inputBuffer, ...args) => {
			lens.uniforms.tDiffuse.value = inputBuffer.texture;
			lensDistortionPassRender.call(lensDistortionPass, renderer, inputBuffer, ...args);
		};

		lensDistortionPass.enabled = false;

	    this.addPass( lensDistortionPass );

	    new BloomEffect({
			intensity: 1,
			mipmapBlur: true,
			luminanceSmoothing: 0.5,
			luminanceThreshold: 0.75,
			kernelSize: KernelSize.MEDIUM
		});

		//this.addPass( bloomEffect );

		new VignetteEffect({
			darkness: 0.8,
			offset: 0.3
		});

		// real
		//const velocityDepthNormalPass = new VelocityDepthNormalPass(scene, camera)
	    //this.addPass(velocityDepthNormalPass)

	    //const ssgiEffect = new SSGIEffect(scene, camera, velocityDepthNormalPass, sgiOption )

	    //const ssgiEffect = new SSGIEffect(this, scene, camera, { ...sgiOption, velocityDepthNormalPass })



	    const smaa = new EffectPass(camera,new SMAAEffect({ preset: SMAAPreset.ULTRA }));
	    smaa.name = 'smaa';


	    this.addPass( smaa );


	    console.log(this.passes);

	/*	const options = {
			threeVue:false,
			distance: 2.7200000000000104,
			thickness: 1.2999999999999972,
			autoThickness: false,
			importanceSampling:true,
			maxRoughness: 1,
			blend: 0.95,
			denoiseIterations: 3,
			denoiseKernel: 3,
			denoiseDiffuse: 25,
			denoiseSpecular: 25.54,
			depthPhi: 5,
			normalPhi: 28,
			roughnessPhi: 18.75,
			envBlur: 0.55,
			importanceSampling: true,
			directLightMultiplier: 1,
			maxEnvLuminance: 50,
			steps: 20,
			refineSteps: 4,
			spp: 1,
			resolutionScale: 1,
			missedRays: false
		}

	//	const pass = {}


		/*
		pass.velocity = new VelocityDepthNormalPass(scene, camera)
		this.addPass( pass.velocity )

		

        

		this.bloomEffect = new BloomEffect({
			intensity: 1,
			mipmapBlur: true,
			luminanceSmoothing: 0.75,
			luminanceThreshold: 0.75,
			kernelSize: KernelSize.HUGE
		})

		this.vignetteEffect = new VignetteEffect({
			darkness: 0.8,
			offset: 0.3
		})

		

		this.motionBlurEffect = new MotionBlurEffect(pass.velocity, {
			jitter: 1
		})



		this.traaEffect = new TRAAEffect(scene, camera, pass.velocity, {})
		this.traaPass = new EffectPass(camera, this.traaEffect)



		this.ssgiEffect = new SSGIEffect(scene, camera, pass.velocity, options)
		pass.ssgi = new EffectPass(camera, this.ssgiEffect)
		this.addPass(pass.ssgi)


		new LUT3dlLoader().load('./assets/luts/realism.3dl').then(lutTexture => {

			
			pass.lut = new LUT3DEffect(lutTexture);
			this.addPass( new EffectPass(camera, this.motionBlurEffect, this.bloomEffect, this.vignetteEffect, pass.lut) )
	    })

*/

	  //  this.pass = pass





		//

		/*const sizeFX = renderer.getDrawingBufferSize( new THREE.Vector2() );
		console.log( sizeFX, size.w*px, size.h*px )
		//let RTClass = WebGLRenderTarget
*/
		/*const renderTarget = new WebGLRenderTarget( size.w*px, size.h*px , {
			//minFilter: LinearFilter,
			//magFilter: LinearFilter,
			//format: RGBAFormat,//??? slow down
			//encoding: sRGBEncoding,
			//type:FloatType ,
		})

		if( renderTarget.samples ){ 
			//renderer.autoClear = false;
			//renderTarget.samples = 4
		}

		super( renderer, renderTarget );

	    this.renderTarget = renderTarget;

	    //this.needNormal = false
	    //this.needDepth = false

	    this.normalTarget = renderTarget.clone()
	    this.depthTarget = renderTarget.clone()
	    //this.beautyTarget = renderTarget.clone()

	    this.normalTarget.texture.minFilter = NearestFilter
	    this.normalTarget.texture.magFilter = NearestFilter
	    //this.normalTarget.texture.format=RGBFormat

	    //this.saoEnable = true

	    this.lutCubeLoader = null;
	    this.lut3DLoader = null;


		this.v = new Vector3();

		this.torad = Math.PI / 180;
		this.todeg = 180 / Math.PI;

		this.isGl2 = isGl2
		this._pixelRatio = px

		this.scene = scene
		this.camera = camera
		this.controls = controls
		this.size = size

		this._width = size.w
		this._height = size.h

		this.enabled = false

		this.options = {

			// focus
			focus: 2.0,
			aperture: 2.5,
			maxblur: 0.01,

			// bloom
			threshold:0.85,
			strength:1.5,
			bloomRadius: 0,


			// sao
			saoBias:0.5,
			saoIntensity:0.06,
			saoScale:40,
			saoKernelRadius:50,
			saoMinResolution:0,

			// ssao
			kernelRadius:0.1,
			minDistance:0.0001,
			maxDistance:2,

			// lut
			lutIntensity:1,

			// sharpen
			power: 0.1,

		}

		

		this.pass.render = new RenderPass( scene, camera )
		this.addPass( this.pass.render )


		// SAO PASS
		this.pass.sao = new SAOPass( scene, camera, this.isGl2, true );
		this.pass.sao.params = {
			output: 0,
			saoBias: this.options.saoBias,//0.5,
			saoIntensity: this.options.saoIntensity,
			saoScale: this.options.saoScale,//1,
			saoKernelRadius: this.options.saoKernelRadius,//100,
			saoMinResolution: this.options.saoMinResolution,
			saoBlur: true,
			saoBlurRadius: 4,//8,
			saoBlurStdDev: 2,//4,
			saoBlurDepthCutoff: 0.01,//0.01
		}

		this.pass.sao.setNormalTarget( this.normalTarget )
		if(!this.isGl2) this.pass.sao.setDepthTarget( this.depthTarget )

		this.pass.sao.enabled = true

		this.lutMap = null
		this.pass.lut = new LUTPass()
		//this.loadLut( 'premium', 'cube' )
		this.loadLut( 'realism', '3dl' )

		this.pass.lut.intensity = this.options.lutIntensity
		
		this.pass.lut.enabled = true


		// SSAO PASS
		/*this.pass.ssao = new SSAOPass( scene, camera, this._width, this._height, true );
		this.pass.ssao.output = 0
		this.pass.ssao.kernelRadius = this.options.kernelRadius;
		this.pass.ssao.minDistance = this.options.minDistance;
		this.pass.ssao.maxDistance = this.options.maxDistance;

		this.pass.ssao.setNormalTarget( this.normalTarget )
		this.pass.ssao.setDepthTarget( this.depthTarget )
		this.pass.ssao.setBeautyTarget( this.beautyTarget )
		this.addPass( this.pass.ssao );*/

		
		/*this.pass.sharpen = new ShaderPass( SharpenShader )
		this.pass.sharpen.setSize = function (w,h){ this.uniforms[ 'resolution' ].value.set(w,h) }	
		this.pass.sharpen.enabled = true
		

		
		this.pass.focus = new BokehPass( this.scene, this.camera, { focus: 20.0, aperture: 0.2, maxblur: 2, width: size.w, height: size.h } );
		this.addPass( this.pass.focus )
		this.pass.focus.enabled = false
		



		this.pass.distortion = new ShaderPass( DistortionShader );
		this.setDistortion()
		
		this.pass.distortion.enabled = true



		/*this.pass.bloom = new UnrealBloomPass( new Vector2( size.w, size.h ), 1.5, 0.4, 0.85, true, Env )
		
		this.pass.bloom.enabled = true*/

		/*this.bloomPass = new UnrealBloomPass( new Vector2( size.w, size.h ), this.options.strength, this.options.bloomRadius, this.options.threshold, true )
		this.bloomPass.enabled = true

		this.bloomComposer = new EffectComposer( renderer, renderTarget )
		this.bloomComposer.renderToScreen = false
		this.bloomComposer.addPass( this.pass.render )
		this.bloomComposer.addPass( this.bloomPass )



		this.pass.bloom = new ShaderPass( BloomMix )
		this.pass.bloom.enabled = true
		this.pass.bloom.needsSwap = true
		this.pass.bloom.uniforms[ "bloomTexture" ].value = this.bloomComposer.renderTarget2.texture;






		
		this.addPass( this.pass.bloom )
		this.addPass( this.pass.sao )
		this.addPass( this.pass.distortion )
		this.addPass( this.pass.lut )
		this.addPass( this.pass.sharpen )
		this.addPass( this.pass.focus )

		/*this.pass.tone = new ShaderPass( ToneMapShader )
		this.addPass( this.pass.tone )
		this.pass.tone.enabled = true

		this.pass.gamma = new ShaderPass( GammaCorrectionShader )
		this.addPass( this.pass.gamma )
		this.pass.gamma.enabled = true*/


	/*	if( !this.isGl2 ){
			this.pass.fxaa = new ShaderPass( FXAAShader );
			this.pass.fxaa.setSize = function (w,h){ this.uniforms[ 'resolution' ].value.set(1/w,1/h) }
			this.addPass( this.pass.fxaa )
		}


		*/

		//this.setSize( this.size.w, this.size.h );
		//this.update()
		
	}


	/*renderNormal () {

		//if( !this.needNormal ) return
		//if( this.normalTarget === null  ) this.normalTarget = this.renderTarget.clone()
		Shader.up( {renderMode:2} )
		Env.setBackgroud(0x7777ff)
		this.scene.helper.visible = false
	    this.renderer.setRenderTarget( this.normalTarget )
	    //this.renderer.clear();
	    this.renderer.render( this.scene, this.camera )


	}

	renderDepth () {
		
		//if( !this.needDepth ) return
		//if( this.depthTarget === null  ) this.depthTarget = this.renderTarget.clone()
		Shader.up( {renderMode:1} )
		Env.setBackgroud(0x000000)
		this.scene.helper.visible = false

	    this.renderer.setRenderTarget( this.depthTarget )
	    //this.renderer.clear();
	    this.renderer.render( this.scene, this.camera )

	}

	renderBeauty() {
		
		//if( this.depthTarget === null  ) this.depthTarget = this.renderTarget.clone()
		Shader.up( {renderMode:0} )
		Env.setBackgroud()
		this.scene.helper.visible = true

		this.renderer.setRenderTarget( null )

	    //this.renderer.setRenderTarget( this.beautyTarget )
	    //this.renderer.render( this.scene, this.camera )

	}

	setDistortion () {

		//console.log(this.camera.fov)

		let horizontalFOV = 100;//140
		let strength = 0.5;
		let cylindricalRatio = 2;
		let height = Math.tan( ( horizontalFOV * this.torad ) *0.5 ) / this.camera.aspect;

		//this.camera.fov = Math.floor( Math.atan(height) * 2 * this.todeg );
		//this.camera.updateProjectionMatrix();
		//console.log(this.camera.fov)

		this.pass.distortion.uniforms[ "strength" ].value = strength;
		this.pass.distortion.uniforms[ "height" ].value = height;
		this.pass.distortion.uniforms[ "aspectRatio" ].value = this.camera.ratio;
		this.pass.distortion.uniforms[ "cylindricalRatio" ].value = cylindricalRatio;

	}

	update (){

		if( this.pass.focus ){
			this.pass.focus.uniforms[ "focus" ].value = this.options.focus;//this.camera.dist //
			this.pass.focus.uniforms[ "aperture" ].value = this.options.aperture * 0.001;
			this.pass.focus.uniforms[ "maxblur" ].value = this.options.maxblur;
			//this.pass.focus.uniforms[ "aspect" ].value = this.camera.aspect;
		}

		if( this.bloomPass ){
			this.bloomPass.threshold = this.options.threshold;
			this.bloomPass.strength = this.options.strength;
			this.bloomPass.radius = this.options.bloomRadius; 

			this.bloomPass.applyValue()

		}

		/*if( this.pass.bloom ){
			this.pass.bloom.threshold = this.options.threshold;
			this.pass.bloom.strength = this.options.strength;
			this.pass.bloom.bloomRadius = this.options.bloomRadius; 
		}*/

		/*if(this.pass.sao){

			this.pass.sao.params.saoBias = this.options.saoBias
			this.pass.sao.params.saoIntensity = this.options.saoIntensity
			this.pass.sao.params.saoScale = this.options.saoScale
			this.pass.sao.params.saoKernelRadius = this.options.saoKernelRadius
			this.pass.sao.params.saoMinResolution = this.options.saoMinResolution

			this.pass.sao.applyValue()
		}

		if(this.pass.sharpen){
			this.pass.sharpen.uniforms[ "power" ].value = this.options.power
		}

		

		/*if(this.pass.ssaoPass){
			this.pass.ssao.kernelRadius = this.options.kernelRadius;
			this.pass.ssao.minDistance = this.options.minDistance;
			this.pass.ssao.maxDistance = this.options.maxDistance;
		}*/

	/*}*/

	changeLut ( txt, name, type ) {

		type = type.toLowerCase();

		if( this.lutMap !== null ){
			if(this.lutMap.texture)this.lutMap.texture.dispose();
			if(this.lutMap.texture3D)this.lutMap.texture3D.dispose();
		}

		switch(type){
			case 'cube':
				if( this.lutCubeLoader === null ) this.lutCubeLoader = new LUTCubeLoader();
				this.lutMap = this.lutCubeLoader.parse( txt );
			break;
			case '3dl':
				if( this.lut3DLoader === null ) this.lut3DLoader = new LUT3dlLoader();
				this.lutMap = this.lut3DLoader.parse( txt );
			break;
		}

		this.setLut();

	}

	loadLut ( name, type ){

		switch(type){
			case 'cube':
				if( this.lutCubeLoader === null ) this.lutCubeLoader = new LUTCubeLoader();
				this.lutCubeLoader.load( 'assets/luts/' + name + '.cube', function ( result ) {
					this.lutMap = result;
					this.setLut();
				}.bind(this) );
			break;
			case '3dl':
				if( this.lut3DLoader === null ) this.lut3DLoader = new LUT3dlLoader();
				this.lut3DLoader.load( 'assets/luts/' + name + '.3dl', function ( result ) {
						this.lutMap = result;
						this.setLut();
				}.bind(this) );
			break;
		}

	}

	setLut (){

		this.pass.lut.lut = this.isGl2 ? this.lutMap.texture : this.lutMap.texture3D;

	}

	resize ( size ) {

		if( !this.enabled ) return;

		this.size = size;
		this.setSize( this.size.w, this.size.h );
		//this.bloomComposer.setSize( this.size.w, this.size.h )

	}

	dispose() {
		this.enabled = false;
		super.dispose();
	}

	getPass(){
		return this.passes;
	}

	render ( deltaTime ) {


		/*if( this.pass.bloom.enabled ){ 
			this.bloomPass.enabled = true

			Env.setBackgroud(0x000000)
			this.scene.helper.visible = false
			if( this.scene.ground ) this.scene.ground.setBlack( true )
			this.bloomComposer.render( deltaTime )
		    if( this.scene.ground ) this.scene.ground.setBlack( false )
		    this.scene.helper.visible = true
			Env.setBackgroud()
		} else {
			this.bloomPass.enabled = false
		}

		if( this.pass.sao.isDirectNormal || this.pass.sao.isDirectDepth ){

			this.renderNormal()
	       // this.renderDepth()
	        this.renderBeauty()

		}*/



		//Env.setBackgroud(0x111111)

		
		//let d = this.controls.target.distanceTo( this.camera.position );
		//this.pass.focus.uniforms[ "focus" ].value = d;

		super.render( deltaTime );

	}

}

class Vignette extends Mesh {

    constructor( o = {} ) {

        super();

        this.geometry = new PlaneGeometry( 2,2, 1,1 );
        this.material = new ShaderMaterial( {

            name: 'VignetteShader',

            uniforms: {

                color: { value: new Color( 0.01, 0.01, 0.01 ) },
                darkness: { value: 1 },
                offset: { value: 1.05  },
                grain: { value: 0.1  }
                
            },

            vertexShader:`
            

            varying vec2 vUv;
            varying vec3 pos;

            void main() {
                vUv = uv;
                pos = position;
                gl_Position = vec4(position, 1.);
            }
            `,
            fragmentShader:`
            #include <common>
            #include <dithering_pars_fragment>

            uniform vec3 color;
            uniform float offset;
            uniform float grain;
            uniform float darkness;

            varying vec2 vUv;
            varying vec3 pos;

            void main() {
                
                vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
                float alpha = smoothstep( 0.0, 1.0, dot( uv, uv ) )-(1.0 - darkness);
                gl_FragColor = vec4( color, alpha );

                // film grain noise
                if(grain!=0.0){
                    float noise = (fract(sin(dot(uv, vec2(12.9898,78.233)*2.0)) * 43758.5453));
                    gl_FragColor += vec4(0.0,0.0,0.0, noise * grain )*(0.5+alpha);
                }

                #include <dithering_fragment>
                
            }
            `, 
            transparent:true,
            depthWrite:false,
            depthTest:false,
            dithering:true,
            //toneMapped:false,

        });


        Object.defineProperties(this, {

            color: {
                enumerable: true,
                get: () => ( this.material.uniforms.color.value.getHex() ),
                set: ( v ) => { this.material.uniforms.color.value.setHex( v ); },
            },
            offset: {
                enumerable: true,
                get: () => ( this.material.uniforms.offset.value ),
                set: ( v ) => { this.material.uniforms.offset.value = v; },
            },
            darkness: {
                enumerable: true,
                get: () => ( this.material.uniforms.darkness.value ),
                set: ( v ) => { this.material.uniforms.darkness.value = v; },
            },
            grain: {
                enumerable: true,
                get: () => ( this.material.uniforms.grain.value ),
                set: ( v ) => { this.material.uniforms.grain.value = v; },
            },
        });

        this.frustumCulled = false;
        this.renderOrder = Infinity;
        this.matrixAutoUpdate = false;

    }

    raycast() {

        return

    }

    dispose () {

        this.parent.remove(this);
        this.geometry.dispose();
        this.material.dispose();
        
    }

}

//import RenderTarget from '../../jsm/renderers/common/RenderTarget.js';

//import WebGPUTextureRenderer from '../jsm/renderers/webgpu/WebGPUTextureRenderer.js';


/**
 * @author Slayvin / http://slayvin.net
 */

//export var Reflector = function ( o ) {
class Reflector extends Mesh {

	constructor( o = {} ) {

		//let geometry = o.geometry !== undefined ? o.geometry : new PlaneGeometry( 1, 1, 1, 1 );
		//geometry.setAttribute( 'uv2', geometry.attributes.uv );

		//super( geometry );
		super();

		this.geometry = new PlaneGeometry( 1, 1, 1, 1 );
		//this.geometry.setAttribute( 'uv2', this.geometry.attributes.uv );

		//console.log('ground is add')

		this.settings = {
			size: [30,30],
			gAlpha:true,
			opacity:1,

		};

		//this.scale.set( 30, 30, 1 )
		
		this.rotateX( -Math.PI / 2 );
		this.castShadow = false;
		this.receiveShadow = true;

		this.type = 'Reflector';

		this.isShow = true;

		const scope = this;

		o = o || {};

		this.map = o.map || null;
		this.color = o.color || 0x808080;
		this.reflect = o.reflect !== undefined ? o.reflect : 0.4;
		//this.opacity = o.opacity !== undefined ? o.opacity : 1;
		this.isWater = o.water !== undefined ? o.water : false;
		this.uv = o.uv || 1;
		this.normalScale = o.normalScale || 1;

		this.multisample = o.multisample !== undefined ? o.multisample : 4;



		/*if( this.isWater ){ 
			this.material.normalMap = Pool.directTexture('./assets/textures/terrain/water_n.jpg', { flip:false, repeat:[30,30] });
			this.reflect = 1
			//this.opacity = 0.5
		} else {
			this.normalMap = Pool.directTexture('./assets/textures/floor.png', { flip:false, repeat:[200,200] });
		}*/

		//this.normalMap = null

		//if(o.normal){
			//new TextureLoader().load( './assets/textures/floor.png' );
			//this.normalMap.wrapS = this.normalMap.wrapT = RepeatWrapping
			//this.normalMap.repeat.x = this.normalMap.repeat.y = 200
		//}
		
		//normalMap.offset.x=normalMap.offset.y=0.5

		//this.encoding = o.encoding || false;

		this.textureSize = o.textureSize || 512;

		this.renderTarget = null;

		
		const clipBias = o.clipBias || 0;

		const reflectorPlane = new Plane();
		const normal = new Vector3();
		const reflectorWorldPosition = new Vector3();
		const cameraWorldPosition = new Vector3();
		const rotationMatrix = new Matrix4();
		const lookAtPosition = new Vector3( 0, 0, -1 );
		const clipPlane = new Vector4();

		const view = new Vector3();
		const target = new Vector3();
		const q = new Vector4();

		const textureMatrix = new Matrix4();
		const virtualCamera = new PerspectiveCamera();


		this.material = new MeshStandardMaterial({ //new MeshStandardMaterial({ 
			name:'Ground', 
			color:this.color,
			//emissive:0xFFFFFF,
			//map:this.map, 
			roughness:0.8,//0.25, 
			metalness:0,//1, 
			opacity:1,
			transparent:true,
			depthWrite:false,
			normalMap: null,//this.normalMap,
			dithering:true,
			//blending:AdditiveBlending,
			///blending:MultiplyBlending,
			//aoMap: normalMap,
	        //depthTest: false, 
	        //premultipliedAlpha:true,
	        //format:sRGBEncoding,

		});


		

		//this.material.reflect = o.reflect !== undefined ? o.reflect : 0.35;

		//this.material.color.convertSRGBToLinear();


		this.groundAlpha();
		this.renderOrder = -1;

		//if( this.isWater ) this.setWater();

		this.material.userData = {
			reflectif: { value: this.reflect },
			mirrorMap:{ value: null },
			blackAll:{ value: 0 }
		};


		Object.defineProperty( this.material, 'reflectif', {
			  get() { return this.userData.reflectif.value; },
			  set( value ) { this.userData.reflectif.value = value; }
		});

		this.textureRenderer = null;

		this.setTarget();

		const self = this;

		this.material.onBeforeCompile = function ( shader ) {

			var uniforms = shader.uniforms;

			//uniforms['fogTime'] = { value: 0 };
			
			//var uniforms = THREE.UniformsUtils.clone( THREE.ShaderLib[ 'standard' ].uniforms );
			uniforms[ "mirrorMap" ] = this.userData.mirrorMap;//{ value: scope.renderTarget.texture };
			//uniforms[ "mirrorPower" ] = { value: scope.reflect };
			uniforms[ "textureMatrix" ] = { value: textureMatrix };
			uniforms[ "reflectif" ] =  this.userData.reflectif;

			uniforms[ "blackAll" ] = this.userData.blackAll;
			//uniforms[ "shadowPower" ] =  { value: 0.01 };
			shader.uniforms = uniforms;

			//shader.uniforms.reflectif = this.userData.reflectif;

			var vertex = shader.vertexShader;
		
			vertex = vertex.replace( '#include <common>', ['#include <common>', 'varying vec4 vUvR;', 'uniform mat4 textureMatrix;'].join("\n") );
			vertex = vertex.replace( '#include <uv_vertex>', ['#include <uv_vertex>', 'vUvR = textureMatrix * vec4( position, 1.0 );'].join("\n") );
			shader.vertexShader = vertex;

			var fragment = shader.fragmentShader;
			fragment = fragment.replace( 'uniform vec3 diffuse;', ['uniform vec3 diffuse;', 'varying vec4 vUvR;', 'uniform float reflectif;', 'uniform sampler2D mirrorMap;', 'uniform int blackAll;'].join("\n") );
			//fragment = fragment.replace( '#include <map_fragment>', ReflectShader.map_fragment );
			fragment = fragment.replace( '#include <lights_fragment_maps>', ReflectShader.lights_fragment_maps );
			fragment = fragment.replace( '#include <fog_fragment>', ReflectShader.fog_fragment );

			//fragment = fragment.replace( '#include <alphamap_fragment>', ReflectShader.alphamap_fragment );

			//fragment = fragment.replace( '#include <normal_fragment_maps>', ReflectShader.normal_fragment_maps );

			//fragment = fragment.replace( '#include <aomap_pars_fragment>', '' );
			//fragment = fragment.replace( '#include <aomap_fragment>', '' );
			//fragment = fragment.replace( '#include <emissivemap_fragment>', '' );
			//fragment = fragment.replace( '#include <clearcoat_normal_fragment_begin>', '' );
			//fragment = fragment.replace( '#include <clearcoat_normal_fragment_maps>', '' );
			//fragment = fragment.replace( '#include <clearcoat_pars_fragment>', '' );
			fragment = fragment.replace( '#include <bumpmap_pars_fragment>', '' );

			//fragment = fragment.replace( '#include <alphamap_fragment>', '' );

			shader.fragmentShader = fragment;

			//Shader.modify( shader );

		};




		//Shader.setDefines( this.material )

		//Pool.set( 'Ground', this.material, 'material', true );
		
		this.onBeforeRender = function ( renderer, scene, camera ) {

			if( !this.isShow ) return;
			if( self.reflect === 0 ) return;

			if( self.isWater ) {
				self.material.normalMap.offset.x+=0.0005;
				self.material.normalMap.offset.y+=0.00025;
			}

			let isWebGPU = renderer.isWebGPURenderer || false;

			reflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );
			cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

			rotationMatrix.extractRotation( scope.matrixWorld );

			normal.set( 0, 0, 1 );
			normal.applyMatrix4( rotationMatrix );

			view.subVectors( reflectorWorldPosition, cameraWorldPosition );

			// Avoid rendering when reflector is facing away

			if ( view.dot( normal ) > 0 ) return;

			view.reflect( normal ).negate();
			view.add( reflectorWorldPosition );

			rotationMatrix.extractRotation( camera.matrixWorld );

			lookAtPosition.set( 0, 0, -1 );
			lookAtPosition.applyMatrix4( rotationMatrix );
			lookAtPosition.add( cameraWorldPosition );

			target.subVectors( reflectorWorldPosition, lookAtPosition );
			target.reflect( normal ).negate();
			target.add( reflectorWorldPosition );

			virtualCamera.position.copy( view );
			virtualCamera.up.set( 0, 1, 0 );
			virtualCamera.up.applyMatrix4( rotationMatrix );
			virtualCamera.up.reflect( normal );
			virtualCamera.lookAt( target );

			virtualCamera.far = camera.far; // Used in WebGLBackground

			virtualCamera.updateMatrixWorld();
			virtualCamera.projectionMatrix.copy( camera.projectionMatrix );

			// Update the texture matrix
			textureMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);
			textureMatrix.multiply( virtualCamera.projectionMatrix );
			textureMatrix.multiply( virtualCamera.matrixWorldInverse );
			textureMatrix.multiply( scope.matrixWorld );

			// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
			// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
			reflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );
			reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );

			clipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );

			const projectionMatrix = virtualCamera.projectionMatrix;

			q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
			q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
			q.z = -1;
			q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

			// Calculate the scaled plane vector
			clipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );

			// Replacing the third row of the projection matrix
			projectionMatrix.elements[ 2 ] = clipPlane.x;
			projectionMatrix.elements[ 6 ] = clipPlane.y;
			projectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;
			projectionMatrix.elements[ 14 ] = clipPlane.w;

			// Render

			scope.visible = false;

			const currentFog = scene.fog;
			const currentRenderTarget = renderer.getRenderTarget();

			const currentXrEnabled = renderer.xr.enabled;
			const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;

			scene.fog = null;
			if(currentXrEnabled) renderer.xr.enabled = false; // Avoid camera modification and recursion

			// bug with HAIR ????
			//renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows
			//renderer.toneMapping = NoToneMapping;

			renderer.setRenderTarget( scope.renderTarget );
			
			if( !isWebGPU ) renderer.state.buffers.depth.setMask( true );// make sure depth buffer is writable

			if( renderer.autoClear === false ) renderer.clear();
			renderer.render( scene, virtualCamera );
			
			renderer.xr.enabled = currentXrEnabled;
		    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
			//renderer.toneMapping = currentToneMapping;
			scene.fog = currentFog;

			//renderer.shadowMap.needsUpdate = true

			renderer.setRenderTarget( currentRenderTarget );

			// Restore viewport
			const viewport = camera.viewport;
			
			if ( viewport !== undefined ) renderer.state.viewport( viewport );

			scope.visible = true;

		};

	}

	reset(){
		//console.log('reset map')
		if( this.material.map ) this.material.map.dispose();
		//if( this.material.alphaMap ) this.material.alphaMap.dispose()
		if( this.material.normalMap ) this.material.normalMap.dispose();

		//this.groundAutoColor = true;
        //this.material.color = null;
		this.material.map = null;
		//this.material.alphaMap = null;
		this.material.normalMap = null;

	}
//}

//Reflector.prototype = Object.create( THREE.Mesh.prototype );
//Reflector.prototype.constructor = THREE.Reflector;

//Reflector.prototype = Object.assign( Object.create( Mesh.prototype ), {

	//constructor: Reflector,

	dispose() {

		this.onBeforeRender = function (){};

		if( this.material.map ) this.material.map.dispose();
		if( this.material.alphaMap ) this.material.alphaMap.dispose();
		if( this.material.normalMap ) this.material.normalMap.dispose();
		if( this.renderTarget ) this.renderTarget.dispose();

		if( this.parent ) this.parent.remove(this);
		this.geometry.dispose();
		this.material.dispose();

	}

	getRenderTarget () {
		return this.renderTarget;
	}

	setTarget () {

		if( this.renderTarget ) this.renderTarget.dispose();

		/*var parameters = {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			//format: RGBFormat,
			stencilBuffer: false,
			//colorSpace : this.encoding ? SRGBColorSpace : LinearEncoding,
			generateMipmaps:true,
		};*/
		

		var parameters = { samples: this.multisample, type: HalfFloatType };

        this.renderTarget = new WebGLRenderTarget( this.textureSize, this.textureSize, parameters );
		//this.renderTarget = new RenderTarget( this.textureSize, this.textureSize, parameters );
		//this.material.alphaMap = this.renderTarget.texture;

		this.material.userData.mirrorMap.value = this.renderTarget.texture;

	}

	setAlphaMap ( b = true ) {

		if( b === this.settings.gAlpha ) return
		this.settings.gAlpha = b;
		this.material.alphaMap = b ? this.alphaMap : null;
		if( b ) this.material.alphaMap.needsUpdate = true;
		this.material.needsUpdate = true;
		
	}

	setSize ( s = [ 200, 200 ] ){

		if( s === this.settings.size ) return
		this.settings.size = s;
		this.scale.set( s[0], s[1], 1 );

	}

	setColor ( v, srgb ) {

		

		//return;
		this.color = v !== undefined ? v : 0xa87232;
		this.material.color.setHex( this.color );

		//if(srgb) this.material.color.convertSRGBToLinear()

	}

	setMapRepeat ( v ) {
		
		if(!this.map) return;
		this.map.repeat.set( v, v );

	}

	setMap ( v ) {

		this.map = v;
		this.material.map = this.map;
		this.material.needsUpdate = true;

	}

	setWater ( b, repeat, scale ) {

		if( b!==undefined ) this.isWater = b;

		if( this.isWater ) {
			this.uv = 30;
			var r = repeat !== undefined ? repeat : this.uv;
			var s = scale !== undefined ? scale : this.normalScale;
			this.material.normalMap = Pool.texture( { url:'./assets/textures/terrain/water_n.jpg', flip:false, repeat:[r,r] });//null;//Tools.loadTextures('./textures/terrain/water_n.jpg', { repeat:[r,r], anisotropy:4, generateMipmaps:true });
			this.material.normalScale.set( s, s );
			this.material.roughness = 0.;
			this.material.metalness = 0.;
			this.material.opacity = 0.8;
			this.material.side = DoubleSide;
			//console.log('water')
		} else {
			//this.material.normalMap = Pool.texture( { url:'./assets/textures/floor.png', flip:false, repeat:[200,200] });
			//this.material.normalMap.channel = 1;
			//this.material.normalMap = null;
			this.material.roughness = 0.8;//0.8;
			this.material.metalness = 0;//0.2;
			this.material.side = FrontSide;
		}

	}

	

	setOpacity ( v = 1 ) {

		if( v === this.settings.opacity ) return

		this.settings.opacity = v;
		this.material.opacity = this.settings.opacity;
	    //this.material.transparent = this.settings.opacity < 1 ? true : false;

	}

	setReflect ( v ) {

		this.reflect = v !== undefined ? v : 0.35;
		this.material.userData.reflectif.value = this.reflect;

	}

	show ( b ) {

		this.isShow = b;
		this.visible = b;

	}

	groundAlpha () {

		let c = document.createElement('canvas');
		c.width = c.height = 512;
        let ctx = c.getContext('2d');

        let grd = ctx.createRadialGradient( 256,256, 128, 256,256,256 );

		grd.addColorStop(0, 'white');
		grd.addColorStop(.2, 'white');
		grd.addColorStop(1, 'black');

		ctx.fillStyle = grd;
		ctx.fillRect(0, 0, 512, 512);

		var img = new Image( 512, 512 );
	    img.src = c.toDataURL( 'image/png' );

	    this.alphaMap = new Texture( img );
	   // this.alphaMap.channel = 1;
	    this.material.alphaMap = this.alphaMap;//new Texture( img );

	    img.onload = function (){
		    this.alphaMap.needsUpdate = true;
	    }.bind(this);

	}

	setBlack ( b ){

		this.isShow = !b  ;
		this.material.userData.blackAll.value = b ? 1 : 0 ;

	}

}

const ReflectShader = {

	lights_fragment_maps :/* glsl */`
	#include <lights_fragment_maps>

	if( reflectif != 0.0 ){
		vec3 reflector = texture2DProj( mirrorMap, vUvR ).rgb;

	    //totalEmissiveRadiance.rgb = mix( totalEmissiveRadiance.rgb, totalEmissiveRadiance.rgb + reflector.rgb, reflectif );
	    totalEmissiveRadiance.rgb += reflector * reflectif;
	}
	`,

	fog_fragment :/* glsl */`
	#include <fog_fragment>
	if( blackAll == 1 ) gl_FragColor = vec4( vec3(0.0), diffuseColor.a );
	`};

//import { Shader } from '../Shader.js';


class Building extends MeshStandardMaterial {

	constructor( o = {}, extra = {} ) {

		o.metalness = 1;
		o.roughness = 0.2;
		o.side = DoubleSide;
		//o.opacity = 0.9;
		//o.side = DoubleSide;
		//o.transparent = true;
		o.envMapIntensity = 1;
		//o.premultipliedAlpha = true;
		o.normalScale = new Vector2(2,2);
		//o.opacity = 1.0;

		super( o );

		this.onBeforeCompile = function ( shader ) {

			var uniforms = shader.uniforms;

			uniforms[ "insideMap" ] = { value: extra.insideMap || null };
			uniforms[ "wallFreq" ] = { value: new Vector3().fromArray( extra.freq || [1,1,1])  };
			uniforms[ "wallsBias" ] = { value: extra.bias || 0.01 };

			uniforms[ "time" ] = { value: extra.time || 1 };
			uniforms[ "lightning" ] = { value: 1 };
			uniforms[ "isNoise" ] = { value: 1 };
			uniforms[ "isNoSection" ] = { value: 0 };

			shader.uniforms = uniforms;

			var vertex = shader.vertexShader;
			vertex = vertex.replace( 'varying vec3 vViewPosition;', vertAdd$2  );
			vertex = vertex.replace( '#include <fog_vertex>', vertMainAdd$2 );
			shader.vertexShader = vertex;

			//console.log(vertex)

			var fragment = shader.fragmentShader;
			fragment = fragment.replace( 'void main() {', fragAdd$2 );
			//fragment = fragment.replace( 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', fragMainAdd );

			fragment = fragment.replace( '#include <map_fragment>', fragMap$1 );
			fragment = fragment.replace( '#include <normal_fragment_maps>', fragNormal );
			fragment = fragment.replace( '#include <emissivemap_fragment>', fragLuma );

			shader.fragmentShader = fragment;


		};
	}
}

const vertAdd$2 =/* glsl */`
varying vec3 vViewPosition;

varying mat4 invMat;
varying mat4 modelMatrixOn;

varying vec3 oP; // surface position in object space
varying vec3 oE; // position of the eye in object space
varying vec3 oI; // incident ray direction in object space
varying vec3 oN; // surface normal

`;

const vertMainAdd$2 =/* glsl */`
#include <fog_vertex>

mat4 modelViewMatrixInverse = inverse( modelViewMatrix );

// surface position in object space
oP = position;

// position of the eye in object space
oE = modelViewMatrixInverse[3].xyz;

// incident ray direction in object space
oI = oP - oE;

// surface normal
oN = normalize( vec3( normal ) );

`;



const fragAdd$2 =/* glsl */`

varying vec3 oP; // surface position in object space
varying vec3 oE; // position of the eye in object space
varying vec3 oI; // incident ray direction in object space
varying vec3 oN; // surface normal

uniform sampler2D insideMap;
uniform vec3 wallFreq;
uniform float wallsBias;

uniform float time;
uniform float lightning;
uniform bool isNoise;
uniform bool isNoSection;

float randomized( vec2 co ){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec2 tileUV( vec2 uv, vec2 pos, vec2 ntile ){

	pos.y = ntile.y-pos.y-1.0;
	vec2 div = 1.0/ntile;
	vec2 v = vec2(uv*div)+(pos*div);
	return v;
	
}

void main() {

`;


const fragMap$1 =/* glsl */`

#ifdef USE_MAP

	//vec4 texelColor = texture2D( map, vUv );

	//texelColor = mapTexelToLinear( texelColor );
	//diffuseColor *= texelColor;


vec3 wallFrequencies = wallFreq - wallsBias;

// calculate wall locations
vec3 wallFrame = floor( oP * wallFrequencies);
vec3 walls = ( wallFrame + step( vec3( 0.0 ), oI )) / wallFrequencies;

// how much of the ray is needed to get from the oE to each of the walls

vec3 rayFractions = ( walls - oE ) / oI;

// texture-coordinates of intersections
vec2 uvXY = fract((oE + rayFractions.z * oI).xy * wallFrequencies.xy);
vec2 uvXZ = fract((oE + rayFractions.y * oI).xz * wallFrequencies.xz);
vec2 uvZY = fract((oE + rayFractions.x * oI).zy * wallFrequencies.zy);

vec2 nuv = vec2( 2.0, 4.0 );

// floor / ceiling  

vec4 tmp_color_1 = texture2D( insideMap, tileUV( uvXZ, vec2(1.0,0.0), nuv ) );// floor
vec4 tmp_color_2 = texture2D( insideMap, tileUV( uvXZ, vec2(0.0,0.0), nuv ) );// ceilling
vec4 verticalColour = mix( tmp_color_1, tmp_color_2, step(0.0, oI.y));

tmp_color_1 = texture2D( insideMap, tileUV( uvXY, vec2(0.0,2.0), nuv ) ); // back
tmp_color_2 = texture2D( insideMap, tileUV( uvXY, vec2(1.0,2.0), nuv ) ); // front
vec4 wallXYColour = mix( tmp_color_1, tmp_color_2, step(oI.z, 0.0));

tmp_color_1 = texture2D( insideMap, tileUV( uvZY, vec2(0.0,3.0), nuv ) ); // left
tmp_color_2 = texture2D( insideMap, tileUV( uvZY, vec2(1.0,3.0), nuv ) ); // right
vec4 wallZYColour = mix( tmp_color_1, tmp_color_2, step(oI.x, 0.0) );

// add some noise

vec4 noiseColor = vec4( 0.0 );

if( isNoise ){
	float t = time*0.00000001;
	noiseColor.xyz = vec3( vec3( randomized(wallFrame.xy+t) ) + vec3( randomized(wallFrame.zy) ) + vec3( randomized(wallFrame.xz+t)) ) / 3.0;
	wallXYColour *= noiseColor;
    wallZYColour *= noiseColor;
    verticalColour *= noiseColor;
}

// intersect walls

vec4 insideColor = vec4(0.0);
if( isNoSection ){
	//insideColor = ( wallXYColour + wallZYColour + verticalColour ) / 3.0;
	///insideColor.a = alph;

	insideColor = mix( wallXYColour, wallZYColour, step(wallXYColour.a, wallZYColour.a) );
	insideColor = mix( insideColor, verticalColour, step(insideColor.a, verticalColour.a)  );
	//insideColor = verticalColour;
	//insideColor = mix( insideColor, verticalColour, insideColor.a );

} else {

    float xVSz = step( rayFractions.x, rayFractions.z );
	insideColor = mix( wallXYColour, wallZYColour, xVSz );

	float rayFraction_xVSz = mix( rayFractions.z, rayFractions.x, xVSz );
	float xzVSy = step( rayFraction_xVSz, rayFractions.y );
	insideColor = mix( verticalColour, insideColor, xzVSy );

}



// exterior

vec2 nuvo = vec2( 2.0, 4.0 );// texture reapeat

vec4 Ftop = texture2D( map, tileUV( fract( oP.xz * wallFrequencies.xz ) , vec2(1.0,2.0), nuv ) );
vec4 Fleft = texture2D( map, tileUV( fract( oP.zy * wallFrequencies.zy ) , vec2(1.0,1.0), nuv ) );
vec4 Ffront = texture2D( map, tileUV( fract( oP.xy * wallFrequencies.xy ) , vec2(0.0,0.0), nuv ) );

float n = abs(oN.z) > abs(oN.x) ? 1.0 : 0.0;
float ny = abs(oN.y) > ( abs(oN.x) + abs(oN.z) * 0.5 ) ? 1.0 : 0.0;

vec4 outsideColor =  mix( Fleft, Ffront, n );
//outsideColor =  mix( outsideColor, Ftop, ny );


//vec4 building_color = mapTexelToLinear(vec4( mix( insideColor, outsideColor, outsideColor.a ).xyz, 1.0));
vec4 building_color = mapTexelToLinear( mix( insideColor, outsideColor, outsideColor.a ));

//if(building_color.a < 0.01) discard;

diffuseColor *= building_color;

#endif


`;
const fragLuma =/* glsl */`
vec4 emissiveColor = vec4( mix( insideColor, vec4(0.0, 0.0, 0.0, 1.0), outsideColor.a ).xyz, 1.0);
//emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor.rgb );
totalEmissiveRadiance = emissiveColor.xyz*lightning*noiseColor.xyz;
`;


const fragNormal =/* glsl */`
#ifdef USE_NORMALMAP

vec3 nWallFrequencies = wallFreq - wallsBias;
vec2 nuvn = vec2( 2.0, 4.0 );
vec3 Ntop = texture2D( normalMap, tileUV( fract( oP.xz * nWallFrequencies.xz ) , vec2(1.0,2.0), nuvn ) ).rgb;
vec3 Nleft = texture2D( normalMap, tileUV( fract( oP.zy * nWallFrequencies.zy ) , vec2(1.0,1.0), nuvn ) ).rgb;
vec3 Nfront = texture2D( normalMap, tileUV( fract( oP.xy * nWallFrequencies.xy ) , vec2(0.0,0.0), nuvn ) ).rgb;

float nn = abs(oN.z) > abs(oN.x) ? 1.0 : 0.0;
float nny = abs(oN.y) > ( abs(oN.x) + abs(oN.z) * 0.5 ) ? 1.0 : 0.0;

vec3 tmpNormal =  mix( Nleft, Nfront, nn );
//tmpNormal =  mix( tmpNormal, Ntop, nny );
tmpNormal = tmpNormal * 2.0 - 1.0;


vec3 eye_pos = -vViewPosition;
vec3 surf_norm = normal;

vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
vec2 st0 = dFdx( vUv.st );
vec2 st1 = dFdy( vUv.st );

float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude

vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
vec3 N = normalize( surf_norm );
mat3 tsn = mat3( S, T, N );

vec3 mapN = tmpNormal;//texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;

mapN.xy *= normalScale;
mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

normal = normalize( tsn * mapN );

#endif
`;

/**
 * Utility class for sampling weighted random points on the surface of a mesh.
 *
 * Building the sampler is a one-time O(n) operation. Once built, any number of
 * random samples may be selected in O(logn) time. Memory usage is O(n).
 *
 * References:
 * - http://www.joesfer.com/?p=84
 * - https://stackoverflow.com/a/4322940/1314762
 */

const _face = new Triangle();
const _color = new Vector3();
const _uva = new Vector2(), _uvb = new Vector2(), _uvc = new Vector2();

class MeshSurfaceSampler {

	constructor( mesh ) {

		this.geometry = mesh.geometry;
		this.randomFunction = Math.random;

		this.indexAttribute = this.geometry.index;
		this.positionAttribute = this.geometry.getAttribute( 'position' );
		this.normalAttribute = this.geometry.getAttribute( 'normal' );
		this.colorAttribute = this.geometry.getAttribute( 'color' );
		this.uvAttribute = this.geometry.getAttribute( 'uv' );
		this.weightAttribute = null;

		this.distribution = null;

	}

	setWeightAttribute( name ) {

		this.weightAttribute = name ? this.geometry.getAttribute( name ) : null;

		return this;

	}

	build() {

		const indexAttribute = this.indexAttribute;
		const positionAttribute = this.positionAttribute;
		const weightAttribute = this.weightAttribute;

		const totalFaces = indexAttribute ? ( indexAttribute.count / 3 ) : ( positionAttribute.count / 3 );
		const faceWeights = new Float32Array( totalFaces );

		// Accumulate weights for each mesh face.

		for ( let i = 0; i < totalFaces; i ++ ) {

			let faceWeight = 1;

			let i0 = 3 * i;
			let i1 = 3 * i + 1;
			let i2 = 3 * i + 2;

			if ( indexAttribute ) {

				i0 = indexAttribute.getX( i0 );
				i1 = indexAttribute.getX( i1 );
				i2 = indexAttribute.getX( i2 );

			}

			if ( weightAttribute ) {

				faceWeight = weightAttribute.getX( i0 )
					+ weightAttribute.getX( i1 )
					+ weightAttribute.getX( i2 );

			}

			_face.a.fromBufferAttribute( positionAttribute, i0 );
			_face.b.fromBufferAttribute( positionAttribute, i1 );
			_face.c.fromBufferAttribute( positionAttribute, i2 );
			faceWeight *= _face.getArea();

			faceWeights[ i ] = faceWeight;

		}

		// Store cumulative total face weights in an array, where weight index
		// corresponds to face index.

		const distribution = new Float32Array( totalFaces );
		let cumulativeTotal = 0;

		for ( let i = 0; i < totalFaces; i ++ ) {

			cumulativeTotal += faceWeights[ i ];
			distribution[ i ] = cumulativeTotal;

		}

		this.distribution = distribution;
		return this;

	}

	setRandomGenerator( randomFunction ) {

		this.randomFunction = randomFunction;
		return this;

	}

	sample( targetPosition, targetNormal, targetColor, targetUV ) {

		const faceIndex = this.sampleFaceIndex();
		return this.sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV );

	}

	sampleFaceIndex() {

		const cumulativeTotal = this.distribution[ this.distribution.length - 1 ];
		return this.binarySearch( this.randomFunction() * cumulativeTotal );

	}

	binarySearch( x ) {

		const dist = this.distribution;
		let start = 0;
		let end = dist.length - 1;

		let index = -1;

		while ( start <= end ) {

			const mid = Math.ceil( ( start + end ) / 2 );

			if ( mid === 0 || dist[ mid - 1 ] <= x && dist[ mid ] > x ) {

				index = mid;

				break;

			} else if ( x < dist[ mid ] ) {

				end = mid - 1;

			} else {

				start = mid + 1;

			}

		}

		return index;

	}

	sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV ) {

		let u = this.randomFunction();
		let v = this.randomFunction();

		if ( u + v > 1 ) {

			u = 1 - u;
			v = 1 - v;

		}

		// get the vertex attribute indices
		const indexAttribute = this.indexAttribute;
		let i0 = faceIndex * 3;
		let i1 = faceIndex * 3 + 1;
		let i2 = faceIndex * 3 + 2;
		if ( indexAttribute ) {

			i0 = indexAttribute.getX( i0 );
			i1 = indexAttribute.getX( i1 );
			i2 = indexAttribute.getX( i2 );

		}

		_face.a.fromBufferAttribute( this.positionAttribute, i0 );
		_face.b.fromBufferAttribute( this.positionAttribute, i1 );
		_face.c.fromBufferAttribute( this.positionAttribute, i2 );

		targetPosition
			.set( 0, 0, 0 )
			.addScaledVector( _face.a, u )
			.addScaledVector( _face.b, v )
			.addScaledVector( _face.c, 1 - ( u + v ) );

		if ( targetNormal !== undefined ) {

			if ( this.normalAttribute !== undefined ) {

				_face.a.fromBufferAttribute( this.normalAttribute, i0 );
				_face.b.fromBufferAttribute( this.normalAttribute, i1 );
				_face.c.fromBufferAttribute( this.normalAttribute, i2 );
				targetNormal.set( 0, 0, 0 ).addScaledVector( _face.a, u ).addScaledVector( _face.b, v ).addScaledVector( _face.c, 1 - ( u + v ) ).normalize();

			} else {

				_face.getNormal( targetNormal );

			}

		}

		if ( targetColor !== undefined && this.colorAttribute !== undefined ) {

			_face.a.fromBufferAttribute( this.colorAttribute, i0 );
			_face.b.fromBufferAttribute( this.colorAttribute, i1 );
			_face.c.fromBufferAttribute( this.colorAttribute, i2 );

			_color
				.set( 0, 0, 0 )
				.addScaledVector( _face.a, u )
				.addScaledVector( _face.b, v )
				.addScaledVector( _face.c, 1 - ( u + v ) );

			targetColor.r = _color.x;
			targetColor.g = _color.y;
			targetColor.b = _color.z;

		}

		if ( targetUV !== undefined && this.uvAttribute !== undefined ) {

			_uva.fromBufferAttribute( this.uvAttribute, i0 );
			_uvb.fromBufferAttribute( this.uvAttribute, i1 );
			_uvc.fromBufferAttribute( this.uvAttribute, i2 );
			targetUV.set( 0, 0 ).addScaledVector( _uva, u ).addScaledVector( _uvb, v ).addScaledVector( _uvc, 1 - ( u + v ) );

		}

		return this;

	}

}

class Sparkle extends Points {

	constructor( o = {} ) {

        super();

        this.num = o.num || 12;

        this.controler = o.controler || null;

        this.sampler = new MeshSurfaceSampler( new Mesh( new BoxGeometry().toNonIndexed() ) );
        this.v = new Vector3();

        this.objectList = o.objectList;
        this.lng = this.objectList.length;

        this.numParticle = this.lng * this.num;

	    this.range = o.range || [2, 2, 2];
	    this.speed = o.speed || [0.002, 0.001];

	    this.disp = o.disp || [0.5, 0.5, 0.5];

        let cc = new Color();
        this.velocities = [];
        this.pos = [];

        let alphas = [];
        let sizes = [];
        let angles = [];
        let position = [];
        let color = [];

        this.tt = [];

        let i = this.numParticle, j, n, c;

        while( i-- ){

        	position.push( 0,0,0 );
            color.push( 1,1,1 );
	        sizes.push( math$1.rand(0.2, 1.5) );
	        alphas.push( math$1.rand(0, 1) );
	        angles.push( 0 );
	        //this.ba.push( math.rand( 0, Math.PI * 2 ) )
	        this.tt.push( math$1.randInt(-300,1) );
	        
	    }

	    // point on geometry
	    i = this.lng;

	    while( i-- ){

            this.setSamplerGeometry( this.objectList[i].children[0].geometry );

	    	c = this.objectList[i].children[0].material.color;
	    	
	    	//g = this.objectList[i].children[0].geometry.attributes.position;
	    	//glng = g.count;
	    	j = this.num;

	    	while( j-- ){

	    		n = ((i*this.num) + j) * 3;
	    		//m = math.randInt(1, glng-1) * 3;

	    		this.v.set(math$1.rand(-5,5), math$1.rand(-5,5), math$1.rand(-5,5));
	    		this.sampler.sample( this.v );

                this.v.toArray( this.pos, n);

	    		cc.copy(c);

	    		color[n] = c.r;
	    		color[n+1] = c.g;
	    		color[n+2] = c.b;

	    	}
	    }



	    this.positions = new Float32Array(position);
	    this.angles = new Float32Array(angles);
	    this.alphas = new Float32Array(alphas);
        this.sizes = new Float32Array(sizes);

	    this.geometry.setAttribute('position', new BufferAttribute( this.positions, 3 ) );
        this.geometry.setAttribute('color', new BufferAttribute( new Float32Array(color), 3 ) );
        this.geometry.setAttribute('sizer', new BufferAttribute( this.sizes, 1 ) );
        this.geometry.setAttribute('alphas', new BufferAttribute( this.alphas, 1 ) );
        this.geometry.setAttribute('angles', new BufferAttribute( this.angles, 1 ) );

        this.texture = this.makeTexture();

        this.material = new PointsMaterial({

	        name:'snow',
	        size: 1,
	        color: 0xffffff,
	        vertexColors: true,
	        map: this.texture,
	        blending: AdditiveBlending,
	        transparent: true,
	        // opacity: 0.8,
	        fog: false,
	        //depthWrite: false,
	        //depthTest: false,
	        depthWrite: false,

            premultipliedAlpha : true,
            alphaToCoverage : true,
	        /*polygonOffset: true,
	        polygonOffsetFactor: -1,
            polygonOffsetUnits: -4*/
	    });

	    this.material.onBeforeCompile = function ( shader ) {

	    	var vertex = shader.vertexShader;
			vertex = vertex.replace( '#include <clipping_planes_pars_vertex>', vertAdd$1 );
			vertex = vertex.replace( '#include <fog_vertex>', vertMainAdd$1 );
			shader.vertexShader = vertex;

			var fragment = shader.fragmentShader;
			fragment = fragment.replace( '#include <clipping_planes_pars_fragment>', fragAdd$1 );

            fragment = fragment.replace( '#include <output_fragment>', '#include <output_fragment>' + fragMainAdd$1 );
			//fragment = fragment.replace( 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', fragMainAdd );

			fragment = fragment.replace( '#include <map_particle_fragment>', fragMap );

			shader.fragmentShader = fragment;


        };

	    this.mTime = 0.0;
	    this.castShadow = false;
	    this.receiveShadow = false;
	    //this.renderDepth = -1;

    }

    setSamplerGeometry( g ) {

        this.sampler.geometry.dispose();

        this.sampler.geometry = g.clone().toNonIndexed();
        this.sampler.positionAttribute = this.sampler.geometry.getAttribute( 'position' );
        //this.sampler.colorAttribute = this.sampler.geometry.getAttribute( 'color' );

        this.sampler.build();

    }

    makeTexture (){

    	let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');

        let d = 64;
        canvas.width = d;
        canvas.height = d;
        let mid = d * 0.5;

        //ctx.save();
        let g1 = ctx.createRadialGradient(mid,mid,0,mid,mid,mid);
        g1.addColorStop(0, 'rgba(255,255,255,0.4)');
        g1.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        g1.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g1;
        ctx.fillRect(0,0,d,d);
        //ctx.restore();

        g1 = ctx.createRadialGradient(mid,mid,0,mid,mid,mid);
        g1.addColorStop(0, 'rgba(255,255,255,1.0)');
        g1.addColorStop(0.5, 'rgba(255,255,255,0.5)');
        g1.addColorStop(1, 'rgba(255,255,255,0)');

        ctx.strokeStyle = g1;
        ctx.beginPath();
        ctx.moveTo(0, mid);
        ctx.lineTo(d, mid);
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(mid, 0);
        ctx.lineTo(mid, d );
        ctx.lineWidth = 2;
        ctx.stroke();

        g1 = ctx.createRadialGradient(mid,mid,0,mid,mid,mid);
        g1.addColorStop(0, 'rgba(255,255,255,0.4)');
        g1.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        g1.addColorStop(1, 'rgba(255,255,255,0)');

        ctx.strokeStyle = g1;

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(d, d );
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(d, 0);
        ctx.lineTo(0, d );
        ctx.lineWidth = 1;
        ctx.stroke();

        var texture = new Texture(canvas);
        //texture.type = FloatType;
        texture.colorSpace = SRGBColorSpace;
        texture.needsUpdate = true;
        return texture;

    }

    updateMatrixWorld ( force ) {

    	let dt = 0.01666;
        let v = this.v;

        this.mTime += dt;

        let angular = 0;
        if(this.controler) angular = this.controler.getAzimuthalAngle();

        let i = this.lng, j, p, n, q, a, t;
        while(i--){

        	//this.m.copy( this.objectList[i].matrix )//.invert();

        	p = this.objectList[i].position;
        	q = this.objectList[i].quaternion;
        	//v.copy(p).applyQuaternion( q )//.add( p );
        	//
        	//p.applyNormalMatrix(this.m);
        	j = this.num;

        	while( j-- ){

        		n = ((i*this.num) + j);

        		a = this.alphas[ n ];
        		t = this.tt[n];

        		if(t===0){
        			a += dt*0.1;
        			if( a>0.5 ) t = 1;
        		} else if(t===1){
        			a -= dt*0.1;
        			if( a<0 ){ 
        				t = math$1.randInt(-300,0);
        				//this.ba[n] = math.rand( 0, Math.PI * 2 );
                        this.sizes[n] = math$1.rand(0.2, 1.5);
        			}
        		} else {
        			t++;
        		}

        		this.alphas[ n ] = math$1.clamp(a,0,1);
        		this.tt[n] = t;

        		//this.angles[ n ] = this.ba[n] - angular;

                this.angles[ n ] = - angular;

        		
        		if(this.alphas[ n ]>1) this.alphas[ n ] = math$1.rand(-5, 0);

        		n *= 3;
                v.fromArray( this.pos, n ).applyQuaternion( q ).add( p );
                v.toArray( this.positions, n);

        	}

        }


        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.alphas.needsUpdate = true;
        this.geometry.attributes.angles.needsUpdate = true;
        this.geometry.attributes.sizer.needsUpdate = true;

    }

    dispose () {

    	this.parent.remove(this);
        this.geometry.dispose();
        this.material.map.dispose();
        this.material.dispose();
        
    }

    raycast( raycaster, intersects ) {
        return
    }

}


const vertAdd$1 =/* glsl */`
#include <clipping_planes_pars_vertex>

attribute float sizer;
attribute float alphas;
attribute float angles;

varying float aaa;
varying float ang;
`;

const vertMainAdd$1 =/* glsl */`
#include <fog_vertex>

aaa = alphas;
ang = angles;

gl_PointSize *= sizer;

`;


const fragAdd$1 =/* glsl */`
#include <clipping_planes_pars_fragment>

varying float aaa;
varying float ang;

vec2 rotUV(vec2 uv, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat2 r = mat2( c, -s, s, c);
    r *= 0.5; r += 0.5; r = r * 2.0 - 1.0;
    uv -= 0.5; uv = uv * r; uv += 0.5;
    return uv;
}
`;

const fragMainAdd$1 =/* glsl */`

gl_FragColor.a *= aaa;

//gl_FragColor = vec4( outgoingLight, diffuseColor.a * aaa  );
//gl_FragColor = vec4( outgoingLight, aaa );

`;


const fragMap =/* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, rotUV( uv, ang ) );
	diffuseColor *= mapTexel;

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`;

//import { Shader } from '../Shader.js';

class Planet extends Mesh {

    constructor( o = {} ) {

        super();

        o = o == undefined ? {} : o;

        this.radius = o.radius !== undefined ? o.radius : 100;
        this.resolution = o.resolution !== undefined ? o.resolution : 10;

        this.data = {
            level: o.level || [1,0.25],
            frequency: o.frequency || [0.1,0.5],
            expo: o.expo || 2,
            height: o.height || 4,
        };

        this.uvx = o.uv || [2,2];

        let typer = ['cliff', 'crater', 'desert', 'ice', 'plate', 'rock', 'rock2', 'mud', 'snow'];

        const tname = typer[ math$1.randInt(0, typer.length-1) ];

        this.m1 = Pool.texture({ url:'./assets/textures/terrain/'+tname+'_c.jpg', flip:false, repeat:this.uvx, encoding:true });
        this.m2 = Pool.texture({ url:'./assets/textures/terrain/'+tname+'_n.jpg', flip:false, repeat:this.uvx });

        this.material = new MeshStandardMaterial({ 
            name:'planet',
            vertexColors:true,
            map:this.m1, 
            normalMap:this.m2,
            normalScale:new Vector2(1,1), 
            roughness:0.6, 
            metalness:0.5,
         });


        

        this.makeGeometry();

        //root.garbage.push( this.geometry );

        this.name = o.name || 'planet';

        this.castShadow = true;
        this.receiveShadow = true;

    }

    makeGeometry () {

        this.geometry = new BoxGeometry( 1, 1, 1, this.resolution, this.resolution, this.resolution );

        this.lng = this.geometry.attributes.position.count;

        this.colors = new Float32Array( this.lng * 3 );
        this.geometry.setAttribute( 'color', new BufferAttribute( this.colors, 3 ) );


        var i = this.lng, n, w = new Vector3();
        this.vertices = this.geometry.attributes.position.array;
        this.s = [];

        while( i-- ) {

            n = i*3;

            w.set( this.vertices[n], this.vertices[n+1], this.vertices[n+2] ).normalize().multiplyScalar( this.radius );

            this.s.push( w.x, w.y, w.z );

        }

        this.update();

    }

    update(){

        var i = this.lng, c, hh, n, w = new Vector3();

        while(i--){

            n = i*3;

            w.set( this.s[n], this.s[n+1], this.s[n+2] );

            c = math$1.noise( w, this.data );

            c = Math.pow( c, this.data.expo );

            c = c>1 ? 1:c;
            c = c<0 ? 0:c;

            w.normalize().multiplyScalar( c * this.data.height );

            this.vertices[n] = this.s[n] + w.x;
            this.vertices[n+1] = this.s[n+1] + w.y;
            this.vertices[n+2] = this.s[n+2] +  w.z;

            hh = (c*0.75)+0.25;

            this.colors[n] = hh;
            this.colors[n+1] = hh;
            this.colors[n+2] = hh;

        }

        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.color.needsUpdate = true;
        this.geometry.computeVertexNormals();

        math$1.resetPerlin();

    }

    dispose () {

        this.geometry.dispose();
        this.material.dispose();
        
    }
}

//import { Shader } from '../Shader.js';
//import { Main } from '../../Main.js';


class Diamond extends MeshPhysicalMaterial {

	constructor( o = {}, extra = {} ) {

		o.metalness = 0;
		o.roughness = 0;

        o.clearcoat = 1;
        //o.clearcoatRoughness = 0.01

        o.iridescenceIOR = 2.33;
        o.iridescence = 1;

        //o.flatShading = true


        
		
		//o.side = DoubleSide
		
		//o.envMapIntensity = 1
        o.reflectivity = 1.0;
        o.envMapIntensity = 1.3;
        //o.iridescence = 1.0
        //o.ior=1.7

        //o.transparent = true
        //o.opacity = 0.9


        //o.transmission = 1
        //o.thickness = 2.5

        //o.depthTest = false
        //o.depthWrite = false
		//o.premultipliedAlpha = true
        //o.alphaToCoverage = true

        /*o.polygonOffset = true
        o.polygonOffsetFactor = 1
        o.polygonOffsetUnits = 4.0*/

		super( o );

        this.normal = this.cubeNormal( extra );

        //this.color.convertSRGBToLinear();

		this.onBeforeCompile = function ( shader ) {

			var uniforms = shader.uniforms;
			uniforms[ "normalCube" ] = { value: this.normal.texture };
			uniforms[ "bDebugBounces" ] = { value: 0 };

			uniforms[ "mFresnelBias" ] = { value: 0.02 };
			uniforms[ "mFresnelScale" ] = { value: 0.1 };
			uniforms[ "mFresnelPower" ] = { value: 1 };

			uniforms[ "aberration" ] = { value: 0.012 };
			uniforms[ "refraction" ] = { value: 2.417 };

			uniforms[ "normalOffset" ] = { value: 0.0 };
			uniforms[ "squashFactor" ] = { value: 0.98 };
			uniforms[ "distanceOffset" ] = { value: 0 };
			uniforms[ "geometryFactor" ] = { value: 0.28 };

			uniforms[ "absorbption" ] = { value: new Color(0,0,0) };
			uniforms[ "correction" ] = { value: new Color( o.color || 0xFFFFFF ) };
			uniforms[ "boost" ] = { value: new Color(.892, .892, .98595025) };

			uniforms[ "radius" ] = { value: 1.5 };
			uniforms[ "centreOffset" ] = { value: new Vector3(0, 0, 0) };

			shader.uniforms = uniforms;

			//shader.uniforms.reflectif = this.userData.reflectif;

			var vertex = shader.vertexShader;
			vertex = vertex.replace( 'varying vec3 vViewPosition;',  vertAdd );
			vertex = vertex.replace( '#include <fog_vertex>', vertMainAdd );
			shader.vertexShader = vertex;

			//console.log(vertex)

			var fragment = shader.fragmentShader;
			fragment = fragment.replace( 'void main() {', fragAdd );
			//fragment = fragment.replace( 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', fragMainAdd );
            //fragment = fragment.replace( '#include <output_fragment>', '#include <output_fragment>' + fragMainAdd );
            fragment = fragment.replace( '#include <opaque_fragment>', '#include <opaque_fragment>' + fragMainAdd );

			shader.fragmentShader = fragment;

			//Shader.modify( shader );

		};

	}

	cubeNormal ( o = {} ){

        let target = new WebGLCubeRenderTarget( 1024, { format:RGBAFormat/*, anisotropy:1, generateMipmaps:false, minFilter:LinearMipmapLinearFilter*/ });

        //console.log(target)

        let camera = new CubeCamera( 0.01, 10, target );
        let scene = new Scene();
        scene.add( camera );

        let normal = new ShaderMaterial({
            vertexShader: ["varying vec3 vNormalm;", "void main() {", "vNormalm = normal;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["varying vec3 vNormalm;", "void main() {", "vec3 color = normalize(vNormalm);", "color = color * 0.5 + 0.5;", "gl_FragColor = vec4( color.xyz, 1.0 );", "}"].join("\n"),
            side: BackSide
        });

        //console.log(normal)

        let m = new Mesh( o.geometry, normal );
        m.scale.set(10,10,10);
        m.frustumCulled = false;
        m.geometry.center();
        scene.add( m );

        camera.update( window.renderer, scene );

        scene.remove( m );
        scene.remove( camera );

        m.material.dispose();
        m.geometry.dispose();

        return target;

    }

    dispose() {
        this.normal.dispose();
        this.dispatchEvent( { type: 'dispose' } );
    }

}

const vertAdd =/* glsl */`
varying vec3 vViewPosition;

varying mat4 invMat;
varying mat4 modelMatrixOn;

varying vec3 worldNormal;
varying vec3 vecPos;
//varying vec3 vEye;
varying vec3 vI;
`;

const vertMainAdd =/* glsl */`
#include <fog_vertex>

modelMatrixOn = modelMatrix;
invMat = inverse( modelMatrix );
vecPos = worldPosition.xyz;//(modelMatrix * vec4(position, 1.0 )).xyz;
//worldNormal = (modelMatrix * vec4(normal,0.0)).xyz;
worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
//vEye = normalize(-cameraPosition);
vI = normalize( worldPosition.xyz - cameraPosition );//vecPos - cameraPosition;

`;

const fragMainAdd =/* glsl */`
#ifdef USE_ENVMAP
float vReflectionFactor = mFresnelBias + mFresnelScale * pow( abs((1.0 + dot( normalize( vI ), vNormal ))), mFresnelPower );

vec3 refractedColor = traceRayTest( vecPos, vI, normalize( worldNormal ) );

vec3 finalColor = mix( refractedColor, refractedColor*outgoingLight, clamp( vReflectionFactor, 0.0, 1.0 ) );
//vec3 finalColor = outgoingLight * refractedColor;
gl_FragColor = vec4( finalColor, diffuseColor.a);
//reflectedColor.rgb = textureCube( envMap, vec3( -vReflect.x, vReflect.yz ) ).rgb;
#endif

`;

const fragAdd =/* glsl */`

#define RAY_BOUNCES 5

varying mat4 invMat;
varying mat4 modelMatrixOn;
varying vec3 worldNormal;
varying vec3 vecPos;
//varying vec3 vEye;
varying vec3 vI;

uniform samplerCube normalCube;
uniform bool bDebugBounces;

uniform float mFresnelBias;
uniform float mFresnelScale;
uniform float mFresnelPower;

uniform float refraction;
uniform float aberration;

uniform float normalOffset;
uniform float squashFactor;
uniform float distanceOffset;
uniform float geometryFactor;

uniform vec3 absorbption;
uniform vec3 correction;
uniform vec3 boost;

uniform float radius;
uniform vec3 centreOffset;

#ifdef USE_ENVMAP

vec3 BRDF_Specular_GGX_EnvironmentTest( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
    float dotNV = abs( dot( normal, viewDir ) );
    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
    vec4 r = roughness * c0 + c1; 
    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
    return specularColor * AB.x + AB.y;
}

vec4 SampleSpecularReflectionTest( vec4 specularColor, vec3 direction ) {
    direction.x *= -1.0;
    direction.z *= -1.0;
    vec4 sampleColorRGB = envMapIntensity * textureCubeUV( envMap, direction, 0.0 );
    sampleColorRGB = clamp( sampleColorRGB, 0.0, 1.0);
    return sampleColorRGB;
}

vec4 SampleSpecularContributionTest( vec4 specularColor, vec3 direction ) { 
    direction = normalize(direction);
    direction.x *= -1.0; 
    direction.z *= -1.0;
    vec4 sampleColorRGB = envMapIntensity * textureCubeUV( envMap, direction, 0.0 );

    //sampleColorRGB.a = 1.0;

    sampleColorRGB = clamp( sampleColorRGB, 0.0, 1.0);
    return sampleColorRGB;
}

vec3 intersectSphereTest( vec3 origin, vec3 direction ) {
    origin -= centreOffset;
    direction.y /= squashFactor;
    float A = dot(direction, direction);
    float B = 2.0*dot(origin, direction);
    float C = dot(origin, origin) - radius * radius;
    float disc = B*B - 4.0 * A * C;
    if(disc > 0.0){ 
        disc = sqrt(disc);
        float t1 = (-B + disc)*geometryFactor/A;
        float t2 = (-B - disc)*geometryFactor/A;
        float t = (t1 > t2) ? t1 : t2;
        direction.y *= squashFactor;
        return vec3(origin + centreOffset + direction * t);
     }
     return vec3(0.0); 
}

vec3 debugBounces( int count ) { 
    vec3 color = vec3(1.,1.,1.);
    if(count == 1) color = vec3(0.0,1.0,0.0);
    else if(count == 2) color = vec3(0.0,0.0,1.0);
    else if(count == 3) color = vec3(1.0,1.0,0.0);
    else if(count == 4) color = vec3(0.0,1.0,1.0);
    else color = vec3(0.0,1.0,0.0); 
    if(count == 0) color = vec3(1.0,0.0,0.0);
    return color;
}

vec3 traceRayTest( vec3 origin, vec3 direction, vec3 normal ) { 

    mat4 invModelMat = invMat;

    vec3 outColor = vec3(0.0); 
    // Reflect/Refract ray entering the diamond 
    const float n1 = 1.0; 
    const float epsilon = 1e-8;
    float f0 = (2.4- n1)/(2.4 + n1);
    f0 *= f0;
    vec3 attenuationFactor = vec3(1.0);
    vec3 newDirection = refract( direction, normal, n1/refraction ); 
    vec3 reflectedDirection = reflect(direction, normal);
    vec3 brdfReflected = BRDF_Specular_GGX_EnvironmentTest(reflectedDirection, normal, vec3(f0), 0.0);
    vec3 brdfRefracted = BRDF_Specular_GGX_EnvironmentTest(newDirection, -normal, vec3(f0), 0.0);
    attenuationFactor *= ( vec3(1.0) - brdfRefracted);
    outColor += SampleSpecularReflectionTest(vec4(1.0), reflectedDirection ).rgb * brdfReflected;
    int count = 0;

    newDirection = (invModelMat * vec4(newDirection, 0.0)).xyz; 
    newDirection = normalize(newDirection);
    origin = (invModelMat * vec4(origin, 1.0)).xyz;

    // ray bounces 
    for( int i=0; i<RAY_BOUNCES; i++) { 

        vec3 intersectedPos = intersectSphereTest(origin + vec3(epsilon), newDirection);
        vec3 dist = intersectedPos - origin;
        vec3 d = normalize(intersectedPos - centreOffset);
        vec3 mappedNormal = textureCube( normalCube, d ).xyz;

        //vec3 mappedNormal = normalize( vNormal ) * -1.0;


        mappedNormal = 2. * mappedNormal - 1.0;
        //mappedNormal.y += normalOffset;
        mappedNormal = normalize(mappedNormal);
        dist = (modelMatrixOn * vec4(dist, 1.)).xyz;
        float r = sqrt(dot(dist, dist));
        attenuationFactor *= exp(-r*absorbption);
        // refract the ray at first intersection 
        vec3 oldOrigin = origin;
        origin = intersectedPos - normalize(intersectedPos - centreOffset) * distanceOffset;
        vec3 oldDir = newDirection;
        newDirection = refract(newDirection, mappedNormal, refraction/n1);
         
        if( dot(newDirection, newDirection) == 0.0) { // Total Internal Reflection. Continue inside the diamond
            newDirection = reflect(oldDir, mappedNormal);
             //If the ray got trapped even after max iterations, simply sample along the outgoing refraction!
            if( i == RAY_BOUNCES-1 ) {
                vec3 brdfReflected = BRDF_Specular_GGX_EnvironmentTest(-oldDir, mappedNormal, vec3(f0), 0.0);
                vec3 d1 = (modelMatrixOn * vec4(oldDir, 0.0)).xyz;
                outColor += SampleSpecularContributionTest( vec4(1.0), d1 ).rgb * correction * attenuationFactor  * boost * (vec3(1.0) - brdfReflected);
                //outColor = vec3(1.,0.,0.);
                //if(d1.y > 0.95) outColor += d1.y * vec3(1.,0.,0) * attenuationFactor * (vec3(1.0) - brdfReflected) * boost;
            } 
        
        } else { // Add the contribution from outgoing ray, and continue the reflected ray inside the diamond 
           vec3 brdfRefracted = BRDF_Specular_GGX_EnvironmentTest(newDirection, -mappedNormal, vec3(f0), 0.0);
           // outgoing(refracted) ray's contribution
           vec3 d1 = (modelMatrixOn * vec4(newDirection, 0.0)).xyz;
           vec3 colorG = SampleSpecularContributionTest(vec4(1.0), d1 ).rgb * ( vec3(1.0) - brdfRefracted);
           vec3 dir1 = refract(oldDir, mappedNormal, (refraction+aberration)/n1);
           vec3 dir2 = refract(oldDir, mappedNormal, (refraction-aberration)/n1);
           vec3 d2 = (modelMatrixOn * vec4(dir1, 0.0)).xyz;
           vec3 d3 = (modelMatrixOn * vec4(dir2, 0.0)).xyz;
           vec3 colorR = SampleSpecularContributionTest(vec4(1.0), d2 ).rgb * ( vec3(1.0) - brdfRefracted);
           vec3 colorB = SampleSpecularContributionTest(vec4(1.0), d3 ).rgb * ( vec3(1.0) - brdfRefracted);
           outColor += vec3(colorR.r, colorG.g, colorB.b) * correction * attenuationFactor * boost;
           //outColor = oldDir;
           //new reflected ray inside the diamond
           newDirection = reflect(oldDir, mappedNormal);
           vec3 brdfReflected = BRDF_Specular_GGX_EnvironmentTest(newDirection, mappedNormal, vec3(f0), 0.0);
           attenuationFactor *= brdfReflected * boost;
           count++;
        } 
    }
    if(bDebugBounces) outColor = debugBounces(count); 
    //outColor = (textureCube( tCubeMapNormals, direction )).rgb;
    //outColor = texture2D( sphereMap, vUv ).rgb

    return outColor;
    
}
#endif
void main() {

`;

//import { Shader } from '../Shader.js';
//import { Main } from '../../Main.js';

class Fluid extends MeshPhysicalMaterial {

	constructor( o = {}, extra = {} ) {

		o.metalness = 0.5;
		o.roughness = 0;

        o.clearcoat = 1;
        //o.clearcoatRoughness = 0.25
        //o.transmission = 1
        //o.thickness = 0.02
		
		o.side = DoubleSide;
		
		o.envMapIntensity = 1.2;
        o.reflectivity = 1.0;
        //o.ior=1.7

        o.transparent = true;
        //o.depthWrite = false
        o.opacity = 0.7;
		//o.premultipliedAlpha = true
        o.alphaToCoverage = true;

        o.sheenColor = 0xffffff;

        o.sheen = 0.5;

        let fillAmount = o.fillAmount || -0.5;
        delete o.fillAmount;


		super( o );

        this.fillAmount = fillAmount;


        this.isModif = false;

        this.modif( o );

        //return

		/**/


	}


    modif( o ){

        if(this.isModif) return

        let self = this;
        this.fillAmount;

        this.onBeforeCompile = function ( shader ) {

            let uniforms = shader.uniforms;
            uniforms[ "time" ] = { value: 0 };
            uniforms[ "fillAmount" ] = { value: -0.5 };
            //uniforms[ "wobbleX" ] = { value: 0.0 }
            //uniforms[ "wobbleZ" ] = { value: 0.0 }
            uniforms[ "topColor" ] = { value: new Vector4(1,0,0, 0.7) };
            uniforms[ "rimColor" ] = { value: new Vector4(0,1,0, 0.5) };
            uniforms[ "foamColor" ] = { value: new Vector4(1,1,1, 0.9) };
            uniforms[ "tint" ] = { value: new Vector4(1,1,0,0.8) };
            uniforms[ "rim" ] = { value: 0.1 };
            uniforms[ "rimPower" ] = { value: 0.5 };
            uniforms[ "Line" ] = { value: 0.01 };
            uniforms[ "LineSmooth" ] = { value: 0.1 };

            /*uniforms[ "normalCube" ] = { value: self.normal.texture };
            uniforms[ "bDebugBounces" ] = { value: 0 };

            uniforms[ "mFresnelBias" ] = { value: 0.02 };
            uniforms[ "mFresnelScale" ] = { value: 0.1 };
            uniforms[ "mFresnelPower" ] = { value: 1 };

            uniforms[ "aberration" ] = { value: 0.012 };
            uniforms[ "refraction" ] = { value: 2.417 };

            uniforms[ "normalOffset" ] = { value: 0.0 };
            uniforms[ "squashFactor" ] = { value: 0.98 };
            uniforms[ "distanceOffset" ] = { value: 0 };
            uniforms[ "geometryFactor" ] = { value: 0.28 };

            uniforms[ "absorbption" ] = { value: new Color(0,0,0) };
            uniforms[ "correction" ] = { value: new Color( 0xFFFFFF ) };
            uniforms[ "boost" ] = { value: new Color(.892, .892, .98595025) };

            uniforms[ "radius" ] = { value: 1.5 };
            uniforms[ "centreOffset" ] = { value: new Vector3(0, 0, 0) };*/

            shader.uniforms = uniforms;

            //shader.uniforms.reflectif = this.userData.reflectif;

            var vertex = shader.vertexShader;

            vertex = vertexAdd + vertex;
            vertex = vertex.replace( '#include <color_vertex>', vertexColor  );
            vertex = vertex.replace( '#include <worldpos_vertex>', vertexWorld  );
            //vertex = vertex.replace( '#include <fog_vertex>', vertMainAdd );
            shader.vertexShader = vertex;

            //console.log(vertex)

            var fragment = shader.fragmentShader;

            fragment = fragmentAdd + fragment;

            //console.log(fragment)
            /*fragment = fragment.replace( 'void main() {', `
                #include <extra_fragment>
                void main() {` );

            //fragment = fragment.replace( 'void main() {', fragAdd );*/
            fragment = fragment.replace( '#include <color_fragment>', fragmentColor );

            shader.fragmentShader = fragment;

            self.userData.shader = shader;

            //Shader.modify( shader );

        };
/*
        this.customProgramCacheKey = function () {

            return fillAmount;

        };*/

        this.isModif = true;
    }


    dispose() {
        //this.normal.dispose()
        this.dispatchEvent( { type: 'dispose' } );

    }

}

const vertexAdd = `
uniform float time;
uniform float fillAmount;

#define PII 3.1415926538

varying vec3 fillPosition;
varying vec4 vvWorldPosition;

vec4 RotateAroundYInDegrees(vec4 vertex, float degrees)
{
   float alpha = degrees * PII / 180.0;
   float sina = sin(alpha);
   float cosa = cos(alpha);
   mat2 m = mat2(cosa, sina, -sina, cosa);
   return vec4(vertex.yz , m * vertex.xz).xzyw ;                
}

vec3 RotateAround(vec3 In, vec3 Axis, float degrees )
{
    float alpha = degrees * PII / 180.0;
    float s = sin(alpha);
    float c = cos(alpha);
    float one_minus_c = 1.0 - c;
            
    mat3 rot_mat = mat3(
        one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s,
        one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s,
        one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c
    );

    vec3 Out = In * rot_mat;
    return Out;

}
`;
const vertexColor = `
#ifdef USE_COLOR
    vColor = color;
#endif
#ifdef USE_INSTANCING_COLOR
    vColor.xyz = instanceColor.xyz;
#endif
`;

const vertexWorld = `
vec4 worldPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
    worldPosition = instanceMatrix * worldPosition;
#endif
worldPosition = modelMatrix * worldPosition;

vec3 filling = vec3(0.0,fillAmount,0.0);
vec3 worldPosOffset = worldPosition.xyz - filling;
// rotate it around XY
//vec3 worldPosX = RotateAroundYInDegrees(vec4(transformed, 0.0), 360.0).xyz;
vec3 worldPosX = RotateAround( worldPosOffset, vec3(0.0,0.0,1.0), 90.0 );
// rotate around XZ
//vec3 worldPosZ = vec3(worldPosX.y, worldPosX.z, worldPosX.x);
vec3 worldPosZ = RotateAround( worldPosOffset, vec3(1.0,0.0,0.0), 90.0 );
// combine rotations with worldPos, based on sine wave from script
#ifdef USE_INSTANCING_COLOR
vec3 worldPosAdjusted = worldPosition.xyz + (worldPosX * vColor.x) + (worldPosZ * vColor.z);
// how high up the liquid is
fillPosition = worldPosAdjusted - filling;
fillPosition.y -= vColor.y;
#endif
vvWorldPosition = worldPosition;
`;


const fragmentAdd = `
uniform vec4 topColor;
uniform vec4 rimColor;
uniform vec4 foamColor;
uniform vec4 tint;
uniform float rim;
uniform float rimPower;
uniform float Line;
uniform float LineSmooth;

varying vec3 fillPosition;
varying vec4 vvWorldPosition;

`;
const fragmentColor = `
// -------- INIT LIQUID SHADER --------
vec4 col = tint;
//float dotProduct = 1.0 - pow(dot(worldNormal, viewDirection), rimPower);
//vec4 RimResult = vec4(smoothstep(0.5, 1.0, dotProduct));
//RimResult *= rimColor;
//RimResult *= rimColor.w;

float wobble = 0.0;//sin((i.fillPosition.x * _Freq) + (i.fillPosition.z * _Freq ) + ( _Time.y)) * (_Amplitude *wobbleIntensity);  
float movingfillPosition = fillPosition.y + wobble;

// foam edge
float cutoffTop = step(movingfillPosition, 0.5);
float foam = cutoffTop * smoothstep(0.5 - Line - LineSmooth, 0.5 - Line , movingfillPosition);
vec4 foamColored = foam * foamColor;

// rest of the liquid minus the foam
float result = cutoffTop - foam;
vec4 resultColored = result * col;


// both together, with the texture
vec4 finalResult = resultColored + foamColored;
vec4 _topColor = topColor * (foam + result);
//finalResult.rgb += RimResult.rgb;
//finalResult *= _topColor;

diffuseColor.rgb *= finalResult.rgb;
//diffuseColor *= gl_FrontFacing ? finalResult : _topColor;//_topColor;
//diffuseColor = finalResult;
`;

const PI = Math.PI;
const torad$3 = PI / 180;
const todeg$1 = 180 / PI;
const EPSILON = Number.EPSILON;//0.00001;
const PI90 = PI*0.5;


const M$1 = {

    //-----------------------
    //  LIGHT
    //-----------------------

    luminousPowers : {
        '110000 lm (1000W)': 110000,
        '3500 lm (300W)': 3500,
        '1700 lm (100W)': 1700,
        '800 lm (60W)': 800,
        '400 lm (40W)': 400,
        '180 lm (25W)': 180,
        '20 lm (4W)': 20,
        'Off': 0
    },

    // ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
    luminousIrradiances : {
        '0.0001 lx (Moonless Night)': 0.0001,
        '0.002 lx (Night Airglow)': 0.002,
        '0.5 lx (Full Moon)': 0.5,
        '3.4 lx (City Twilight)': 3.4,
        '50 lx (Living Room)': 50,
        '100 lx (Very Overcast)': 100,
        '350 lx (Office Room)': 350,
        '400 lx (Sunrise/Sunset)': 400,
        '1000 lx (Overcast)': 1000,
        '18000 lx (Daylight)': 18000,
        '50000 lx (Direct Sun)': 50000
    },

    exposure : (v) => ( Math.pow( v, 5.0 ) ),
    //Candela is default three light intensity
    candelaToLumens : (v) => ( v * 4 * Math.PI ),
    lumensToCandela : (v) => ( v / ( 4 * Math.PI ) ),

    //-----------------------
    //  MATH
    //-----------------------

    todeg:todeg$1,
    torad:torad$3,

    toFixed: ( x, n = 3 ) => ( x.toFixed(n) * 1 ),
    toRound: ( x, n = 3 ) => ( Math.trunc(x) ),

    clamp: ( v, min = 0, max = 1 ) => {
        v = v < min ? min : v;
        v = v > max ? max : v;
        return v;
    },

    clampA: ( v, min, max ) => ( Math.max( min, Math.min( max, v ) ) ),

    lerp: ( x, y, t ) => ( ( 1 - t ) * x + t * y ),
    damp: ( x, y, lambda, dt ) => ( M$1.lerp( x, y, 1 - Math.exp( - lambda * dt ) ) ),

    nearAngle: ( s1, s2, deg = false ) => ( s2 + Math.atan2(Math.sin(s1-s2), Math.cos(s1-s2)) * (deg ? todeg$1 : 1) ),

    unwrapDeg: ( r ) => ( r - (Math.floor((r + 180)/360))*360 ), 
    //unwrapRad: ( r ) => (r - (Math.floor((r + Math.PI)/(2*Math.PI)))*2*Math.PI),
    unwrapRad: ( r ) => ( Math.atan2(Math.sin(r), Math.cos(r)) ),

    nearEquals: ( a, b, t ) => ( Math.abs(a - b) <= t ? true : false ),

    autoSize: ( s = [ 1, 1, 1 ], type = 'box' ) => {

        if ( s.length === 1 ) s[ 1 ] = s[ 0 ];
        let radius = s[0];
        let height = s[1];
        if( type === 'sphere' ) s = [ radius, radius, radius ];
        if( type === 'cylinder' || type === 'wheel' || type === 'capsule' ) s = [ radius, height, radius ];
        if( type === 'cone' || type === 'pyramid' ) s = [ radius, height, radius ];
        if ( s.length === 2 ) s[ 2 ] = s[ 0 ];
        return s;

    },

    shuffle: (array) => {

        let shuffled = array
        .map(value => ({ value, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort)
        .map(({ value }) => value);

        return shuffled

    },

    /*distance: ( a, b = { x:0, y:0, z:0 } ) => { // rotation array in degree

        const dx = a.x ? a.x - b.x : 0
        const dy = a.y ? a.y - b.y : 0
        const dz = a.z ? a.z - b.z : 0
        return Math.sqrt( dx * dx + dy * dy + dz * dz );

    },*/


    //-----------------------
    //  RANDOM
    //-----------------------

    randomSign: () => ( Math.random() < 0.5 ? -1 : 1 ),
    randSpread: ( range ) => ( range * ( 0.5 - Math.random() ) ),
    rand: ( low = 0, high = 1 ) => ( low + Math.random() * ( high - low ) ),
    randInt: ( low, high ) => ( low + Math.floor( Math.random() * ( high - low + 1 ) ) ),

    randIntUnic:  ( low, high, num ) => {
        var arr = [];
        while( arr.length < num ){
            var r = M$1.randInt(low, high);
            if( arr.indexOf(r) === -1 ) arr.push(r);
        }
        return arr;
    },

    //-----------------------
    //  EXTRA
    //-----------------------

    fromTransform: ( p1, q1, p2, q2 = [0,0,0,1], inv = false ) => {

        let m1 = M$1.composeMatrixArray( p1, q1 );
        let m2 = M$1.composeMatrixArray( p2, q2 );
        if( inv ) m1 = M$1.invertMatrixArray(m1);
        m1 = M$1.multiplyMatrixArray( m1, m2 );
        return [ m1[12],m1[13],m1[14]]

    },

    fromTransformToQ: ( p, q, inv = false ) => {

        let m = M$1.composeMatrixArray( p, q );
        let res = M$1.decomposeFullMatrixArray( m );
        let q1 = res.q;
        if(inv) q1 = M$1.quatInvert(q1);
        return q1

    },

    //-----------------------
    //  MATRIX
    //-----------------------

    composeMatrixArray: ( p, q, s = [1,1,1] ) => {

        const x = q[0], y = q[1], z = q[2], w = q[3];
        const x2 = x + x,  y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        const sx = s[0], sy = s[1], sz = s[2];
        return [
            ( 1 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0,
            ( xy - wz ) * sy, ( 1 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0,
            ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1 - ( xx + yy ) ) * sz, 0,
            p[0], p[1], p[2], 1
        ]

    },

    multiplyMatrixArray: ( a, b ) => {

        const ae = a;
        const be = b;
        const te = [];

        const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
        const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
        const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
        const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

        const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
        const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
        const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
        const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

        te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

        te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

        te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

        te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

        return te;

    },

    invertMatrixArray: ( m ) => {

        const te = m,

            n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
            n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
            n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
            n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

            t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
            t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
            t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
            t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

        if ( det === 0 ) return [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];

        const detInv = 1 / det;

        te[ 0 ] = t11 * detInv;
        te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
        te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
        te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

        te[ 4 ] = t12 * detInv;
        te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
        te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
        te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

        te[ 8 ] = t13 * detInv;
        te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
        te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
        te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

        te[ 12 ] = t14 * detInv;
        te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
        te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
        te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

        return te;

    },

    matrixArrayDeterminant: ( m ) => {
        const te = m;

        const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
        const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
        const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
        const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

        return (
            n41 * (
                + n14 * n23 * n32
                 - n13 * n24 * n32
                 - n14 * n22 * n33
                 + n12 * n24 * n33
                 + n13 * n22 * n34
                 - n12 * n23 * n34
            ) +
            n42 * (
                + n11 * n23 * n34
                 - n11 * n24 * n33
                 + n14 * n21 * n33
                 - n13 * n21 * n34
                 + n13 * n24 * n31
                 - n14 * n23 * n31
            ) +
            n43 * (
                + n11 * n24 * n32
                 - n11 * n22 * n34
                 - n14 * n21 * n32
                 + n12 * n21 * n34
                 + n14 * n22 * n31
                 - n12 * n24 * n31
            ) +
            n44 * (
                - n13 * n22 * n31
                 - n11 * n23 * n32
                 + n11 * n22 * n33
                 + n13 * n21 * n32
                 - n12 * n21 * n33
                 + n12 * n23 * n31
            )

        );
    },

    decomposeMatrixArray: ( m ) => {

        return [
            m[12],m[13],m[14],
        ]
    },

    decomposeFullMatrixArray: ( m ) => {

        const te = m;

        let sx = M$1.lengthArray( [te[ 0 ], te[ 1 ], te[ 2 ]] );//_v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
        const sy = M$1.lengthArray( [te[ 4 ], te[ 5 ], te[ 6 ]] );//_v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
        const sz = M$1.lengthArray( [te[ 8 ], te[ 9 ], te[ 10 ]] );//_v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

        // if determine is negative, we need to invert one scale
        const det = M$1.matrixArrayDeterminant(m);
        if ( det < 0 ) sx = - sx;

        let m1 = [...m];
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;

        m1[ 0 ] *= invSX;
        m1[ 1 ] *= invSX;
        m1[ 2 ] *= invSX;

        m1[ 4 ] *= invSY;
        m1[ 5 ] *= invSY;
        m1[ 6 ] *= invSY;

        m1[ 8 ] *= invSZ;
        m1[ 9 ] *= invSZ;
        m1[ 10 ] *= invSZ;

        let q = M$1.quatFromRotationMatrix(m1); 

        return {
            p:[m[12],m[13],m[14]],
            q:q,
            s:[sx,sy,sz]
        }
        
    },

    // for physx substep 

    applyTransformArray: ( v, p, q, s = [1,1,1] ) => {
        const e = M$1.composeMatrixArray( p, q, s );
        const x = v[0], y = v[1], z = v[2];
        const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );
        return [
            ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w, 
            ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w,
            ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w
        ]
    },

    

    slerpQuatArray: ( a, b, t ) => {

        if ( t === 0 ) return a;
        if ( t === 1 ) return b;
        let r = [...a];
        const x = a[0], y = a[1], z = a[2], w = a[3];
        const qx = b[0], qy = b[1], qz = b[2], qw = b[3];
        let cosHalfTheta = w * qw + x * qx + y * qy + z * qz;

        if ( cosHalfTheta < 0 ) {
            r = [ -qx, -qy, -qz, -qw ];
            cosHalfTheta = - cosHalfTheta;
        } else {
            r = [...b];
        }

        if ( cosHalfTheta >= 1.0 ) return a
        
        const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

        if ( sqrSinHalfTheta <= EPSILON ) {

            const s = 1 - t;
            r[3] = s * w + t * r[3];
            r[0] = s * x + t * r[0];
            r[1] = s * y + t * r[1];
            r[2] = s * z + t * r[2];
            return M$1.quatNomalize(r);

        }

        const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
        const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
        const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta, ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

        r[3] = ( w * ratioA + r[3] * ratioB );
        r[0] = ( x * ratioA + r[0] * ratioB );
        r[1] = ( y * ratioA + r[1] * ratioB );
        r[2] = ( z * ratioA + r[2] * ratioB );

        return r;

    },


    //-----------------------
    //  QUAT
    //-----------------------

    toLocalQuatArray: ( rot = [0,0,0], b ) => { // rotation array in degree

        let q1 = M$1.quatFromEuler( rot );
        let q2 = M$1.quatInvert( b.quaternion.toArray() );
        return M$1.quatMultiply( q2, q1 )

        /*quat.setFromEuler( euler.fromArray( math.vectorad( rot ) ) )
        quat.premultiply( b.quaternion.invert() );
        return quat.toArray();*/

    },

    quatFromRotationMatrix: ( m ) => {

        let q = [0,0,0,1];

        const te = m,

            m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
            m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
            m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

            trace = m11 + m22 + m33;

        if ( trace > 0 ) {

            const s = 0.5 / Math.sqrt( trace + 1.0 );

            q[3] = 0.25 / s;
            q[0] = ( m32 - m23 ) * s;
            q[1] = ( m13 - m31 ) * s;
            q[2] = ( m21 - m12 ) * s;

        } else if ( m11 > m22 && m11 > m33 ) {

            const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

            q[3] = ( m32 - m23 ) / s;
            q[0] = 0.25 * s;
            q[1] = ( m12 + m21 ) / s;
            q[2] = ( m13 + m31 ) / s;

        } else if ( m22 > m33 ) {

            const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

            q[3] = ( m13 - m31 ) / s;
            q[0] = ( m12 + m21 ) / s;
            q[1] = 0.25 * s;
            q[2] = ( m23 + m32 ) / s;

        } else {

            const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

            q[3] = ( m21 - m12 ) / s;
            q[0] = ( m13 + m31 ) / s;
            q[1] = ( m23 + m32 ) / s;
            q[2] = 0.25 * s;

        }

        return q;

    },

    quatFromEuler: ( r = [0,0,0], isDeg = true ) => {

        const cos = Math.cos;
        const sin = Math.sin;
        const n = isDeg ? torad$3 : 1; 
        const x = (r[0]*n) * 0.5, y = (r[1]*n) * 0.5, z = (r[2]*n) * 0.5;
        const c1 = cos( x ), c2 = cos( y ), c3 = cos( z );
        const s1 = sin( x ), s2 = sin( y ), s3 = sin( z );

        return [
            s1 * c2 * c3 + c1 * s2 * s3,
            c1 * s2 * c3 - s1 * c2 * s3,
            c1 * c2 * s3 + s1 * s2 * c3,
            c1 * c2 * c3 - s1 * s2 * s3
        ]
        
    },

    quatFromAxis: ( r = [0,0,0], angle, isDeg = true ) => {

        const n = isDeg ? torad$3 : 1; 
        const halfAngle = (angle * 0.5) * n, s = Math.sin( halfAngle );
        return [
            r[0] * s,
            r[1] * s,
            r[2] * s,
            Math.cos( halfAngle )
        ]
        
    },

    quatNomalize: ( q ) => {
        let l = M$1.lengthArray( q );
        if ( l === 0 ) {
            return [0,0,0,1]
        } else {
            l = 1 / l;
            return M$1.scaleArray(q, l, 4)
        }
    },

    quatInvert: ( q ) => {
        return [-q[0],-q[1],-q[2], q[3]]
    },

    quatMultiply:( a, b ) => {
        const qax = a[0], qay = a[1], qaz = a[2], qaw = a[3];
        const qbx = b[0], qby = b[1], qbz = b[2], qbw = b[3];
        return [
            qax * qbw + qaw * qbx + qay * qbz - qaz * qby,
            qay * qbw + qaw * qby + qaz * qbx - qax * qbz,
            qaz * qbw + qaw * qbz + qax * qby - qay * qbx,
            qaw * qbw - qax * qbx - qay * qby - qaz * qbz
        ]
    },

    quatToAxis:( q ) => {

        let w = 2 * Math.acos( q[3] );
        const s = Math.sqrt( 1 - q[3] * q[3] );
        if ( s < 0.0001 ) {
            return [1,0,0]
        } else {
             return [ q[0] / s, q[1] / s, q[2] / s, w ]
        }
    },

    eulerFromMatrix: (te) => {

        const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
        te[ 1 ]; const m22 = te[ 5 ], m23 = te[ 9 ];
        te[ 2 ]; const m32 = te[ 6 ], m33 = te[ 10 ];

        let ar = [0,0,0];
        ar[1] = Math.asin( M$1.clamp( m13, -1, 1 ) );
        if ( Math.abs( m13 ) < 0.9999999 ) {
            ar[0] = Math.atan2( - m23, m33 );
            ar[2] = Math.atan2( - m12, m11 );
        } else {
            ar[0] = Math.atan2( m32, m22 );
            ar[2] = 0;
        }
        return ar

    },

    angleTo: ( a, b ) => {

        return 2 * Math.acos( Math.abs( M$1.clamp( M$1.dotArray(a,b), -1, 1 ) ) );

    },


    //-----------------------
    //  ARRAY
    //-----------------------

    getSize: ( r ) => ( ( r.byteLength * 0.001 ) +'kb' ),

    // Creates a vector normal (perpendicular) to the current Vector3

    perpendicularArray: ( v ) => { 

        const radius = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        let theta = Math.acos(v[1] / radius);
        const phi = Math.atan2(v[2], v[0]);
        //makes angle 90 degs to current vector
        if( theta > PI90 ) theta -= PI90;
        else theta += PI90;
        //Calculates resutant normal vector from spherical coordinate of perpendicular vector
        const x = radius * Math.sin(theta) * Math.cos(phi);
        const y = radius * Math.cos(theta);
        const z = radius * Math.sin(theta) * Math.sin(phi);

        return [x, y, z];

    },

    crossArray: ( a, b ) => { 

        const ax = a[0], ay = a[1], az = a[2];
        const bx = b[0], by = b[1], bz = b[2];
        let x = ay * bz - az * by;
        let y = az * bx - ax * bz;
        let z = ax * by - ay * bx;
        return [x, y, z];

    },

    applyQuaternion: ( v, q ) => { 

        // quaternion q is assumed to have unit length

        const vx = v[0], vy = v[1], vz = v[2];
        const qx = q[0], qy = q[1], qz = q[2], qw = q[3];

        // t = 2 * cross( q.xyz, v );
        const tx = 2 * ( qy * vz - qz * vy );
        const ty = 2 * ( qz * vx - qx * vz );
        const tz = 2 * ( qx * vy - qy * vx );

        // v + q.w * t + cross( q.xyz, t );
        let x = vx + qw * tx + qy * tz - qz * ty;
        let y = vy + qw * ty + qz * tx - qx * tz;
        let z = vz + qw * tz + qx * ty - qy * tx;

        return [x,y,z];

    },

    // ARRAY OPERATION

    nullArray: ( a, n, i ) => { 
        let j = 0;
        while( i-- ) j += a[n+i];
        return j;
    },

    equalArray: ( a, b ) => {
        let i = a.length;
        while(i--){ if(a[i]!==b[i]) return false; }
        return true;
    },
    
    lerpArray: ( a, b, t ) => {
        if ( t === 0 ) return a;
        if ( t === 1 ) return b;
        let i = a.length;
        let r = [];
        while(i--){ r[i] = a[i]; r[i] += ( b[i] - r[i] ) * t; }
        return r;
    },

    zeroArray: ( a, n = 0, i ) => {
        i = i ?? a.length;
        while ( i-- ) a[n+i] = 0;
        return a;
    },

    lengthArray: ( r ) => {
        let i = r.length, l=0;
        while( i-- ) l += r[i] * r[i];
        return Math.sqrt( l );
    },

    dotArray: ( a, b ) => {
        let i = a.length, r = 0;
        while ( i-- ) r += a[ i ] * b[ i ];
        return r;
    },

    addArray: ( a, b, i ) => {
        i = i ?? a.length;
        let r = [];
        while ( i-- ) r[i] = a[i] + b[i];
        return r;
    },

    subArray: ( a, b, i ) => {
        i = i ?? a.length;
        let r = [];
        while ( i-- ) r[i] = a[i] - b[i];
        return r;
    },

    mulArray: ( a, b, i ) => {
        
        let ar = b instanceof Array;
        if( !ar ){ 
            return a.map((x) => x * b);
        } else { 
            let r = [];
            i = i ?? a.length;
            while ( i-- ) r[i] = a[i] * b[i];
            return r;
        }
        
    },

    divArray: ( r, s, i ) => ( M$1.mulArray( r, 1/s, i ) ),

    scaleArray: ( r, s, i ) => ( M$1.mulArray( r, s, i ) ),

    fillArray: ( a, b, n = 0, i ) => {
        i = i ?? a.length;
        while( i-- ) b[n+i] = a[i];
    },

    copyArray: ( a, b ) => { [...b]; },

    cloneArray: ( a ) => ( [...a] ),

    distanceArray: ( a, b = [0,0,0] ) => ( M$1.lengthArray( M$1.subArray( a, b ) ) ),

    normalizeArray: ( a ) => ( M$1.divArray( a, M$1.lengthArray(a) || 1 ) ),

    normalArray: ( a, b = [0,0,0] ) => ( M$1.normalizeArray( M$1.subArray( b, a ) ) ),

    //-----------------------
    //  VOLUME
    //-----------------------

    getVolume: ( type, size, vertex = null ) => {

        let volume = 1;
        let s = size;

        switch(type){
            
            case 'sphere' : volume = (4*Math.PI*s[0]*s[0]*s[0])/3; break;
            case 'cone' : volume = Math.PI * s[0] * (s[1] * 0.5) * 2; break;
            case 'box' : volume = 8 * (s[0]*0.5)*(s[1]*0.5)*(s[2]*0.5); break;
            case 'cylinder' : volume = Math.PI * s[0] * s[0] * (s[1] * 0.5) * 2; break;
            case 'capsule' : volume = ( (4*Math.PI*s[0]*s[0]*s[0])/3) + ( Math.PI * s[0] * s[0] * (s[1] * 0.5) * 2 ); break;
            case 'convex' : case 'mesh' : volume = M$1.getConvexVolume( vertex ); break;

        }

        return volume;

    },

    getConvexVolume: ( v ) => {

        let i = v.length / 3, n;
        let min = [0, 0, 0];
        let max = [0, 0, 0];

        while(i--){

            n = i*3;
            if ( v[n] < min[0] ) min[0] = v[n];
            else if (v[n] > max[0]) max[0] = v[n];
            if ( v[n+1] < min[1] ) min[1] = v[n+1];
            else if (v[n+1] > max[1]) max[1] = v[n+1];
            if ( v[n+2] < min[2] ) min[2] = v[n+2];
            else if (v[n+2] > max[2]) max[2] = v[n+2];

        }

        let s = [ max[0]-min[0], max[1]-min[1], max[2]-min[2] ];

        return 8 * (s[0]*0.5)*(s[1]*0.5)*(s[2]*0.5);
        //return (max[0]-min[0])*(max[1]-min[1])*(max[2]-min[2])

    },

    massFromDensity: ( density, volume ) =>  ( density * volume ),
    densityFromMass: ( mass, volume ) =>  ( mass / volume ),


    // GEOMETRY
    toNonIndexed: ( g ) => ( !g.index ? g : g.clone().toNonIndexed() ),

    getIndex: ( g, noIndex ) => {

        if( !g.index || noIndex ) return null
        return g.index.array || null

    },

    getVertex: ( g, noIndex ) => {
        
        let c = g.attributes.position.array;

        if( noIndex && g.index ){
            g = g.clone().toNonIndexed();
            c = g.attributes.position.array;
        }

        return c;

    },

    getNormal: ( g ) => {

        //if( noIndex && g.index ) g = g.clone().toNonIndexed();
        
        let c = g.attributes.normal.array;
        //console.log(c)
        return c;

    },

    getFaces: ( g ) => {

        let faces = [];
        if( g.index ){
            let index = g.getIndex();
            for ( let i = 0; i < index.count; i += 3 ) {
                faces.push( [index.getX(i), index.getX(i+1), index.getX(i+2)] );
            }
        }else {
            let lng = g.getAttribute( 'position' ).count;
            for ( let i = 0; i < lng; i += 3 ) {
                faces.push([i, i+1, i+2] );
            }
        }
        return faces;

    },

    reduce: ( x ) => {
    },

    barycentric: ( simplex, point ) => {
    },

    solve: ( simplex, point ) => {
    }

};

const MathTool = M$1;

// point weight blend space javascript

/*
get_blend_space_2d_node_influences :: (using space : *Blend_Space_2d, position : Vec2) -> []f32 #must
{
    weights           := alloc_array (f32, nodes.count, temp_allocator);
    sqrd_distances    := alloc_array (f32, nodes.count, temp_allocator);
    angular_distances := alloc_array (f32, nodes.count, temp_allocator);

    total_sqrd_distance, total_angular_distance := 0.0;
    for nodes
    {
        sqrd_distance := dot (position - it.position, position - it.position);
        if sqrd_distance > 0
        {
            angular_distance := -(clamp (dot (normalize (position), normalize (it.position)), -1, 1) - 1) * 0.5;
            total_sqrd_distance += 1 / sqrd_distance;
            if angular_distance > 0 then total_angular_distance += 1 / angular_distance;
            sqrd_distances[it_index] = sqrd_distance;
            angular_distances[it_index] = angular_distance;
        }
        else    // The distance is 0 so it.position == position
        {
            // Weights are already initialized to 0
            weights[it_index] = 1;

            return weights;
        }
    }

    for i : 0..nodes.count - 1
    {
        sqrd_distance    := total_sqrd_distance    * sqrd_distances[i];
        angular_distance := total_angular_distance * angular_distances[i];
        if sqrd_distance > 0 && angular_distance > 0
            weights[i] = (1 / sqrd_distance) * 0.5 + (1 / angular_distance) * 0.5;
        else if sqrd_distance > 0
            weights[i] = (1 / sqrd_distance) * 0.5 + 0.5;
        else
            weight = 0;
    }

    return weights;
}
*/

const WithMassCenter = ['PHYSX', 'HAVOK'];


const Max = {
	body:4000,
    joint:1000,
    contact:4000,
    ray:100,
    character:100,
    vehicle:50,
    solver:20,
};

const Num = {
	bodyFull:14,
    body:8,
    joint:16,
    contact:1,
    ray:11,
    character:16,
    vehicle:72,//max 8 wheels
    solver:128,
};


// Define how many body phy can manage

const getArray = function ( engine, full = false ){

    const ArPos = {};

    let counts = {
        body: Max.body * ( full ? Num.bodyFull : Num.body ),
        joint: Max.joint * Num.joint,
        ray: Max.ray * Num.ray,
        contact: Max.contact * Num.contact,
        character: Max.character * Num.character
    };

    if( engine === 'PHYSX' || engine === 'AMMO' ){ 
        counts['vehicle'] = Max.vehicle * Num.vehicle;
    }

    if( engine === 'PHYSX' ){ 
        counts['solver'] = Max.solver * Num.solver;
    }

    if( engine === 'HAVOK' || engine === 'RAPIER' || engine === 'JOLT' ){ 
        Num.joint = 0;
    }

    let prev = 0;

    for( let m in counts ){ 

        ArPos[m] = prev;
        prev += counts[m];

    }

    ArPos['total'] = prev;

    return ArPos;

};


// Convert type for all engine

const getType = function ( o ) {
    switch( o.type ){
        case 'plane': case 'box': case 'sphere': case 'highSphere': case 'customSphere': case 'cylinder': case 'stair':case 'particle':
        case 'cone': case 'capsule': case 'mesh': case 'convex': case 'compound': case 'null':
            //if ( ( !o.mass || !o.density ) && !o.kinematic ) return 'solid'
            if ( !o.mass && !o.density && !o.kinematic ) return 'solid'
            else return 'body'
        case 'fixe':
        case 'generic': case 'universal': case "dof": case "d6": 
        case 'hinge': case 'revolute': 
        case "prismatic": 
        case 'cylindrical': case 'slider':
        case 'spherical':
        case 'ragdoll': 
        case "distance":
            return 'joint'
        default: 
            return o.type;
    }
};

class CircleHelper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		let size=0.6;

		const indices = new Uint16Array( [ 
			0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 0,   
			6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 6,
			12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 12,
			18,19, 20,21, 22, 23,
			] );
		const positions = [

		

		 0.5, 0.0, 0.0,
		0.25, 0.433, 0.0,
		-0.25, 0.433, 0.0,
		-0.5, 0.0, 0.0,
		-0.25, -0.433, 0.0,
		0.25, -0.433, 0.0, 

		 0.5, 0.0,0.0, 
		0.25,  0.0,0.433,
		-0.25,  0.0,0.433,
		-0.5, 0.0, 0.0,
		-0.25,0.0, -0.433, 
		0.25, 0.0, -0.433, 

		0.0,0.5, 0.0,
		0.0,0.25, 0.433, 
		0.0,-0.25, 0.433, 
		0.0,-0.5, 0.0, 
		0.0,-0.25, -0.433, 
		0.0,0.25, -0.433, 

		0, 0, 0,	size, 0, 0,
		0, 0, 0,	0, size, 0,
		0, 0, 0,	0, 0, size,

		
		];

		const colors = [

		0, 0, 1,
		0, 0, 1,
		0, 0, 1,
		0, 0, 1,
		0, 0, 1,
		0, 0, 1,
		
		0, 1, 0,
		0, 1, 0,
		0, 1, 0,
		0, 1, 0,
		0, 1, 0,
		0, 1, 0,

        1, 0, 0,
		1, 0, 0,
		1, 0, 0,
		1, 0, 0,
		1, 0, 0,
		1, 0, 0,

		1, 0, 0,	1, 0, 0,
		0, 1, 0,	0, 1, 0,
		0, 0, 1,	0, 0, 1,

		];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } ) );

		this.box = box;

		this.type = 'CircleHelper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

//-------------------
//
//  GEOMETRY POOL
//
//-------------------

let Geo$1 = class Geo {

	constructor(){

		this.geoN = 0;
		this.geo = {};

	}

	unic ( g ) {
        //console.log(g)
		this.geo[ 'geo' + this.geoN++ ] = g;

	}

	set( g ) {

		this.geo[g.name] = g;

	}

	get( name, o = {} ) {

		if( !this.geo[name] ){
			let g;
			switch( name ){
				case 'plane':    g = new PlaneGeometry(1,1); g.rotateX( -Math.PI * 0.5 ); break
				case 'box':      g = new BoxGeometry(1,1,1); break
				case 'sphere':   g = new SphereGeometry( 1, 16, 12 ); break
				case 'cylinder': g = new CylinderGeometry( 1, 1, 1 , 16 ); break
				//case 'wheel':    g = new CylinderGeometry( 1, 1, 1 , 16 ); g.rotateX( -Math.PI * 0.5 ); break
				case 'cone':     g = new CylinderGeometry( 0.001, 1, 1 , 16 ); break
				//case 'joint':    g = new Box3Helper().geometry; g.scale( 0.05,0.05,0.05 ); break
				case 'particle': g = new SphereGeometry( 1.0, 8, 6 ); break
				case 'joint':    g = new CircleHelper().geometry; break
				default: return null;
			}
			this.geo[name] = g;
		}

		return this.geo[name]
		
	}

	dispose () {

		// TODO BUG with Start demo and HAVOK !!!
		
		//console.log( geo )
		for( let n in this.geo ){
		    if( this.geo[n].isBufferGeometry ) this.geo[n].dispose();
		    else console.log(this.geo[n]);
		}
		this.geo = {};
		this.geoN = 0;

	}

};

class CarbonTexture {

	constructor( normal, c1='rgb(69,69,69)', c2='rgb(39,39,39)'  ) {

		let s = 128;

		const canvas = document.createElement( 'canvas' );
		canvas.width = canvas.height = s;

		const ctx = canvas.getContext( '2d' );
		ctx.fillStyle = c1;
		ctx.fillRect( 0, 0, s, s );

		if( !normal ){

			ctx.beginPath();
			ctx.fillStyle = c2;
		    ctx.rect(0, 0, 32, 64);
		    ctx.rect(32, 32, 32, 64);
		    ctx.rect(64, 64, 32, 64);
		    ctx.rect(96, 96, 32, 64);
		    ctx.rect(96, -32, 32, 64);
		    ctx.fill();

	    } else {

	    	let i, j, n, d;
	    	let pos = [ [0, 0], [32, 32],[64, 64],[96, 96],[96, -32] ];
	    	let deg = [ [0, 64], [32, 96],[64, 128],[96, 160],[-32, 32] ];

	    	let f1 = normal ? 'rgb(128,128,255)' : c1;
	    	let f2 = normal ? 'rgb(160,100,255)' : c2;
	    	let f3 = normal ? 'rgba(100,160,255, 0.5)' : 'rgba(0,0,0, 0.1)';

	    	ctx.strokeStyle = f3;
	    	ctx.lineWidth = 1;

	    	for( i = 0; i<5; i++ ){

	    		d = ctx.createLinearGradient(0, deg[i][0], 0, deg[i][1]);
				d.addColorStop(0, f2);
				d.addColorStop(1, f1);

				ctx.beginPath();
				ctx.fillStyle = d;
				ctx.rect(pos[i][0], pos[i][1], 32, 64);
				ctx.fill();

				for( let j = 0; j<8; j++ ){   

					n = (Math.random()-0.5) * 2; 
				           
				    ctx.beginPath();
					ctx.moveTo(pos[i][0]+n+2+j*4, pos[i][1]);
					ctx.lineTo(pos[i][0]+n+2+j*4, pos[i][1]+64);
					ctx.stroke();
				}

	    	}

	    	pos = [ [32, 0], [64, 32],[96, 64],[-32, 64],[0, 96] ];
	    	deg = [ [32, 96], [64, 128],[96, 160],[-32, 32],[0, 64] ];

	    	for( i = 0; i<5; i++ ){

	    		d = ctx.createLinearGradient(deg[i][0], 0, deg[i][1], 0);
				d.addColorStop(0, f1);
				d.addColorStop(1, f2);

				ctx.beginPath();
				ctx.fillStyle = d;
				ctx.rect(pos[i][0], pos[i][1], 64, 32);
				ctx.fill();

				for( j = 0; j<8; j++ ){

					n = (Math.random()-0.5) * 2; 
					ctx.beginPath();
					ctx.moveTo(pos[i][0], pos[i][1]+n+2+j*4);
					ctx.lineTo(pos[i][0]+64, pos[i][1]+n+2+j*4);
					ctx.stroke();
				}

	    	}

	    }

		//return canvas;

		const texture = new CanvasTexture( canvas ); //new CarbonTexture('#ffffff', '#CCCCCC') )
		texture.wrapS = texture.wrapT = RepeatWrapping;
		texture.repeat.x = texture.repeat.y = 60;

		if(!normal) texture.colorSpace = SRGBColorSpace;

		return texture;

	}

}

/**
 * ------------------------------------------------------------------------------------------
 * Subsurface Scattering shader
 * Based on GDC 2011 – Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look
 * https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/
 *------------------------------------------------------------------------------------------
 */

class MeshSssMaterial extends MeshPhysicalMaterial {

	constructor( parameters ) {

		super();

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': '',
			'SUBSURFACE': '',
			'USE_UV': '',

		};

		this.extra = {};

		this.addParametre( 'sssMap', null );
		this.addParametre( 'sssColor', new Color( 0,0,0 ) );
		this.addParametre( 'sssAmbient', 0.5 );
		this.addParametre( 'sssDistortion', 0.6 );
		this.addParametre( 'sssAttenuation', 0.1 );
		this.addParametre( 'sssPower', 1.0 );
		this.addParametre( 'sssScale', 6.0 );
		
		this.setValues( parameters );

		let self = this;

        self.onBeforeCompile = function ( shader ) {
        	for(let name in self.extra ) {
				shader.uniforms[ name ] = { value: self.extra[name] };
			}

			shader.fragmentShader = shader.fragmentShader.replace( '#include <common>', shaderChange.common );
			shader.fragmentShader = shader.fragmentShader.replace( '#include <lights_fragment_begin>', 
				self.replaceAll(
					lights_fragment_begin,
					'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
					shaderChange.light
				)
			);

			self.userData.shader = shader;
        };

	}

	addParametre( name, value ){

		this.extra[ name ] = value;

		Object.defineProperty( this, name, {
			get: () => ( this.extra[ name ] ),
			set: ( v ) => {
				this.extra[ name ] = v;
				if( this.userData.shader ) this.userData.shader.uniforms[name].value = this.extra[ name ];
			}
		});
	}

	replaceAll( string, find, replace ) {

		return string.split( find ).join( replace );

	}

	/*customProgramCacheKey(){

		return self

	} */

	/*onBeforeCompile( shader ){

		for(let name in this.extra ) {
			shader.uniforms[ name ] = { value: this.extra[name] };
		}

		shader.fragmentShader = shader.fragmentShader.replace( '#include <common>', shaderChange.common );
		shader.fragmentShader = shader.fragmentShader.replace( '#include <lights_fragment_begin>', 
			this.replaceAll(
				THREE.ShaderChunk[ 'lights_fragment_begin' ],
				'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
				shaderChange.light
			)
		);

		this.userData.shader = shader;

	}*/

}

const shaderChange = {

	common : /* glsl */`
	#include <common>
	uniform sampler2D sssMap;
	uniform float sssPower;
	uniform float sssScale;
	uniform float sssDistortion;
	uniform float sssAmbient;
	uniform float sssAttenuation;
	uniform vec3 sssColor;

	void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
		vec3 thickness = sssColor * texture2D(sssMap, uv).r;
		vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * sssDistortion));
		float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), sssPower) * sssScale;
		vec3 scatteringIllu = (scatteringDot + sssAmbient) * thickness;
		reflectedLight.directDiffuse += scatteringIllu * sssAttenuation * directLight.color;
	}
	`,
	light : /* glsl */`
	RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	#if defined( SUBSURFACE ) && defined( USE_UV )
		RE_Direct_Scattering(directLight, vUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
	#endif
	`
};


const lights_fragment_begin = /* glsl */`

vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE

	float dotNVi = saturate( dot( normal, geometryViewDir ) );

	if ( material.iridescenceThickness == 0.0 ) {

		material.iridescence = 0.0;

	} else {

		material.iridescence = saturate( material.iridescence );

	}

	if ( material.iridescence > 0.0 ) {

		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );

		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );

	}

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif

		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif

		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`;

//import { EnhanceShaderLighting } from '../../3TH/shaders/EnhanceShaderLighting.js';
//import { EnhanceLighting } from '../../3TH/shaders/EnhanceLighting.js';
//import { FakeGlowMaterial } from '../../3TH/materials/FakeGlowMaterial.js';


//-------------------
//
//  MATERIAL
//
//-------------------

const matExtra = {

	//clearcoat:1.0,
	//clearcoatRoughness:0.1,
	metalness: 0.1,
	roughness: 0.9,
	//normalScale: new Vector2(0.25,0.25),

};

/*export const RealismLightOption = {
	enableESL:true,
	exposure:1,
	envMapIntensity:1,

	aoColor: new Color(0x000000),
	hemisphereColor: new Color(0xffffff),
    irradianceColor: new Color(0xffffff),
    radianceColor: new Color(0xffffff),

    aoPower: 9.7,//6,
    aoSmoothing: 0.26,
    aoMapGamma: 0.89,
    lightMapGamma: 0.9,//1,
    lightMapSaturation: 1,
    envPower: 1,//2
    roughnessPower: 1,//1.45,
    sunIntensity: 0,
    mapContrast: 1,//0.93,
    lightMapContrast: 1.03,
    smoothingPower: 0.76,
    irradianceIntensity: 6.59,
    radianceIntensity: 4.62,
    hardcodeValues: false

}*/

const Colors = {
    body:new Color( "hsl(45, 15%, 90%)" ),//0xefefd4
    sleep:new Color( "hsl(33, 15%, 54%)" ),//0x9FBFBD
    solid:new Color( 0x6C6A68 ),//
    base:new Color( 0xc9c8c7 ),
    black:new Color( "hsl(220, 8%, 15%)" ),
    gold:new Color( 0.944, 0.776, 0.373 ),
    gold2:new Color( 0.998, 0.981, 0.751 ),
    copper:new Color( 0.96467984, 0.37626296, 0.25818297 ),
    carPaint:new Color( 0.1037792, 0.59212029, 0.85064936 ),
    clay:new Color( "hsl(12, 30%, 40%)" ),
    clayWhite:new Color( 0xa9a9a9 ),
    concrete:new Color( 0xa9a9a9 ),

    Raw_Fire:new Color( "hsl(40, 18%, 54%)" ),
    Raw_Buff:new Color( "hsl(33, 15%, 54%)" ),
    Raw_Terracotta:new Color( "hsl(12, 30%, 40%)" ),
    Raw_Porcelain:new Color( "hsl(45, 15%, 90%)" ),

};

const ThreeVariable = {

	No: NoBlending,
	Normal: NormalBlending,
	Additive: AdditiveBlending,
	Subtractive: SubtractiveBlending,
	Multiply: MultiplyBlending,

	Eadd: AddEquation,
	Esub: SubtractEquation,
	Erev: ReverseSubtractEquation,
	Emin: MinEquation,
	Emaw: MaxEquation,

	Fzero: ZeroFactor,
	Fone:  OneFactor,
	Fcolor: SrcColorFactor,
	Fcolorm: OneMinusSrcColorFactor,
	Falpha: SrcAlphaFactor,
	Falpham: OneMinusSrcAlphaFactor,
	Fdstalpha: DstAlphaFactor,
	Fdstalpham: OneMinusDstAlphaFactor,
	Fdstcolor: DstColorFactor,
	Fdstcolorm: OneMinusDstColorFactor,
	Falphasaturate: SrcAlphaSaturateFactor, // ! not for destination

	Front: FrontSide,
	Back: BackSide,
	Double: DoubleSide,

};
/*
const addRenderMode = ()=>{

	let s = ShaderChunk.common;
	s = s.replace( '#define EPSILON 1e-6', `
		#define EPSILON 1e-6
		uniform int renderMode;
		uniform int depthPacking;
		varying vec2 vZW;
    `);
    ShaderChunk.common = s;

    ShaderChunk.clipping_planes_vertex = `
        #if NUM_CLIPPING_PLANES > 0
            vClipPosition = - mvPosition.xyz;
        #endif
        vZW = gl_Position.zw;
    `;

    s = ShaderChunk.dithering_fragment;
	s = s.replace( '#endif', `
		#endif

        #ifdef STANDARD

        if( renderMode == 1 ){ // depth render
            float fz = 0.5 * vZW[0] / vZW[1] + 0.5;
            fz=pow(fz, 10.0);
            gl_FragColor = depthPacking == 1 ? packDepthToRGBA( fz ) : vec4( vec3( 1.0 - fz ), opacity );
        }
        if( renderMode == 2 ) gl_FragColor = vec4(  packNormalToRGB( normal ), opacity );// normal render
        //if( renderMode == 3 ) gl_FragColor = vec4(  shadowColor, opacity );// normal render

        #else

        if( renderMode != 0 ) discard;

        #endif
    `);
    ShaderChunk.dithering_fragment = s;


}*/

let Mat$3 = class Mat {

	constructor(){

		this.renderMode = { value: 0 };
		this.depthPacking = { value: 0 };
		this.extendMat = false;

		this.isRealism=false;
		this.realismOption={};
		this.envMapIntensity=1.0;

		this.mat = {};
		this.TmpMat = [];

	}

	changeRenderMode (n) {

		this.renderMode.value = n;

	}

	initExtandShader () {
		//addRenderMode()
		//this.extendMat = true;
	}
	

	useRealLight (o) {

		/*this.isRealism = true;

		// apply color setting number
		for(let c in o){
			if(c.search('Color')!==-1){
				if(!o[c].isColor){
					RealismLightOption[c].set( o[c] );
					delete o[c];
				}
			} 
		}

		this.realismOption = { ...RealismLightOption, ...o };*/

	}

	setColor( o ) {

		/*if(!this.isRealism) return;

		//console.log(o)

		RealismLightOption.aoColor.set(o.minLuma).convertLinearToSRGB()
		RealismLightOption.hemisphereColor.set(o.maxLuma).convertLinearToSRGB()
		RealismLightOption.irradianceColor.set(o.sun).convertLinearToSRGB()
		RealismLightOption.radianceColor.set(o.vibrant).convertLinearToSRGB()*/

	}

	set( m, direct, beforeCompile = null ) {

		if(!beforeCompile) beforeCompile = m.onBeforeCompile;
		//if(!direct) this.extendShader( m, beforeCompile );
		this.mat[m.name] = m;

	}

	extendShader( m, beforeCompile = null ) { 

		//let oldCompile = null;
		//if( m.onBeforeCompile ) oldCompile = m.onBeforeCompile;

		/*if( this.isRealism ){
			m.onBeforeCompile = function ( shader ) {
				//shader.uniforms.renderMode = this.renderMode;
				//shader.uniforms.depthPacking = this.depthPacking;

				EnhanceLighting( shader, this.realismOption );
		        m.userData.isRealism = true;
		        m.userData.shader = shader;
	            if( beforeCompile ) beforeCompile( shader );
	        }

		} else {
			m.onBeforeCompile = function ( shader ) {

				shader.uniforms.renderMode = this.renderMode;
				shader.uniforms.depthPacking = this.depthPacking;

	            if( beforeCompile ) beforeCompile( shader );
	            m.userData.shader = shader;
	        }
		}*/
		
	}

	addToTmp( m ) {

		this.TmpMat.push( m );

	}

	create( o ) {

		let m, beforeCompile = null;

		if( o.isMaterial ){
			m = o;
		} else {

			let type = o.type !== undefined ? o.type : 'Standard';
			if( o.type ) delete o.type;

			//if( !o.shadowSide ) o.shadowSide = 'double'

			beforeCompile = o.beforeCompile || null;
		    if( o.beforeCompile ) delete o.beforeCompile;

			if( o.thickness || o.sheen || o.clearcoat || o.transmission || o.specularColor ) type = 'Physical';

			if(o.normalScale){
				if( !o.normalScale.isVector2 ) o.normalScale = new Vector2().fromArray(o.normalScale);
			}

		    if( o.side ) o.side = this.findValue( o.side );
		    if( o.shadowSide ) o.shadowSide = this.findValue( o.shadowSide );
		    if( o.blending ) o.blending = this.findValue( o.blending );
		    if( o.blendEquation ) o.blendEquation = this.findValue( o.blendEquation );
		    if( o.blendEquationAlpha ) o.blendEquationAlpha = this.findValue( o.blendEquationAlpha );
		    if( o.blendSrc ) o.blendSrc = this.findValue( o.blendSrc );
		    if( o.blendDst ) o.blendDst = this.findValue( o.blendDst );
		    if( o.blendDstAlpha ) o.blendDstAlpha = this.findValue( o.blendDstAlpha );
		    if( o.blendSrcAlpha ) o.blendSrcAlpha = this.findValue( o.blendSrcAlpha );

		    if(o.clearcoatNormalScale){
				if( !o.clearcoatNormalScale.isVector2 ) o.clearcoatNormalScale = new Vector2().fromArray( o.clearcoatNormalScale );
			}

		    type = type.toLowerCase();

		    switch( type ){

				case 'physical': 
					m = new MeshPhysicalMaterial( o ); 
					m.defines = {
						'STANDARD': '',
						'PHYSICAL': '',
						'USE_UV':'',
						'USE_SPECULAR':''
					};
				break;
				case 'phong': m = new MeshPhongMaterial( o ); break;
				case 'lambert': m = new MeshLambertMaterial( o ); break;
				case 'basic': m = new MeshBasicMaterial( o ); break;
				case 'line': m = new LineBasicMaterial( o ); break;
				case 'toon': m = new MeshToonMaterial( o ); break;
				case 'shadow': m = new ShadowMaterial( o ); break;
				case 'sss': m = new MeshSssMaterial( o ); break;
				default: m = new MeshStandardMaterial( o ); break;

			}

			///Mat.upEnvmapIntensity( m );

		} 

		if( this.mat[ m.name ] ) return null;
	    this.set( m, false, beforeCompile );
		return m;

	}

	findValue(v) { 
		return v === 'string' ? ThreeVariable[ v.charAt(0).toUpperCase() + v.slice(1) ] : v 
	}

	addToMat( o ) {

		if( this.isRealism ){
			for(let m in o){
				o[m].shadowSide = DoubleSide;
				o[m].onBeforeCompile = function ( shader ) {
		            EnhanceLighting( shader, this.realismOption );
		            o[m].userData.isRealism = true;
		            o[m].userData.shader = shader;
		        };
			}


		}

		this.mat = { ...this.mat, ...o };

	}

	changeType() {



	}

	directIntensity ( v ) {

		for( let name in this.mat ) {
		//	if( mat[name].envMapIntensity ) mat[name].envMapIntensity = v;
		}
		
	}

	
	getList () {

		let l = {...this.mat};
		const ignor = ['line', 'debug', 'hide', 'svg'];
		let i = ignor.length;
		while(i--) delete l[ignor[i]];

		return l

	}

	get( name ) {

		if( !this.mat[name] ){
			switch( name ){

				case 'body': this.create({name:'body', color:Colors.body, ...matExtra }); break
			    case 'sleep':  this.create({ name:'sleep', color:Colors.sleep, ...matExtra }); break//0x46B1C9
			    case 'solid':  this.create({ name:'solid', color:Colors.solid, ...matExtra }); break
			    case 'base':   this.create({ name:'base', color:Colors.base, ...matExtra }); break

			    case 'clay':  this.create({ name:'clay', color:Colors.clay, metalness: 0.1, roughness: 0.7 }); break
			    case 'clayWhite':  this.create({ name:'clayWhite', color:Colors.clayWhite, metalness: 0.1, roughness: 0.7 }); break

			    case 'concrete':  this.create({ name:'concrete', color:Colors.concrete, metalness: 0.0, roughness: 0.9, }); break

			    case 'black':   this.create({ name:'black', color:Colors.black, metalness: 0, roughness: 0.25 }); break

			    

			    // metal
			    case 'chrome': this.create({ name:'chrome', color:0xCCCCCC, metalness: 1, roughness:0.075 }); break
			    case 'silver': this.create({ name:'silver', color:0xAAAAAA, metalness: 0.8, roughness:0.22 }); break
			    case 'gold': this.create({ name:'gold', color:Colors.gold, specularColor:Colors.gold2, metalness: 1, roughness:0.02 }); break
			    case 'copper': this.create({ name:'copper', color:Colors.copper, metalness: 1, roughness:0.25, clearcoat: 1.0, clearcoatRoughness: 0.2 }); break

			    case 'carPaint': this.create({ name:'carPaint', color:Colors.carPaint, metalness: 0, anisotropy:new Vector2(0.5,0.5), roughness:0.4, clearcoat: 1.0, clearcoatRoughness: 0, }); break

				//case 'simple': m = this.create({ name:'simple', color:0x808080, metalness: 0, roughness: 1 }); break

				case 'carbon': this.create({ name:'carbon', map:new CarbonTexture(), normalMap:new CarbonTexture(true), clearcoat: 1.0, clearcoatRoughness: 0.1, roughness: 0.5 }); break
				case 'cloth': this.create({ name:'cloth', color:0x8009cf, roughness: 0.5, sheenColor:0xcb7cff, sheen:1, sheenRoughness:0.2 }); break


				//case 'clear':  m = new MeshStandardMaterial({ color:0xFFFFFF, metalness: 0.5, roughness: 0 }); break
				//case 'wood':   m = this.create({ name:'wood', color:0xe8c2a1, metalness: 0, roughness: 1 }); break
				
				//case 'hero':   m = new MeshStandardMaterial({ color:0x00FF88, ...matExtra }); break
				case 'skinny':   this.create({ name:'skinny', color:0xe0ac69, ...matExtra }); break
				
				case 'glass':  this.create({ name:'glass', color:0xFFFFff, transparent:true, roughness:0.02, metalness:0.0, side:DoubleSide, alphaToCoverage:true, premultipliedAlpha:true, transmission:1, clearcoat:1, thickness:0.01  }); break
				case 'glassX':  this.create({ name:'glassX', color:0xeeeeee, transparent:false, opacity:1.0, roughness:0.03, metalness:0,  side:DoubleSide, transmission:1.0, clearcoat:1, clearcoatRoughness:0.0, thickness:0.02, ior:1.52, shadowSide:1, reflectivity:0.5, iridescence:0 }); break
				case 'plexi':  this.create({ name:'plexi', blending:AdditiveBlending, color:0x010101, transparent:true, opacity:0.7, reflectivity:0.3, metalness:0.6, roughness:0.1, clearcoat:0.2, clearcoatRoughness: 0.02, side:DoubleSide, alphaToCoverage:true, premultipliedAlpha:true }); break
				case 'plexi2':  this.create({ name:'plexi2', blending:AdditiveBlending, color:0x010101, transparent:false, opacity:0.7, reflectivity:0.3, metalness:0.6, roughness:0.1, clearcoat:0.2, clearcoatRoughness: 0.02, side:DoubleSide, alphaToCoverage:false, premultipliedAlpha:true }); break
				case 'glass2': this.create({ name:'glass2', color:0xEEEEEE, transparent:true, roughness:0, alphaToCoverage:true, opacity:0.3  }); break
				case 'glass3': this.create({ name:'glass3', color:0x000000, transparent:true, roughness:0, alphaToCoverage:true, opacity:0.4  }); break
				case 'glass_red': this.create({ name:'glass_red', color:0xFF0000, transparent:true, roughness:0, alphaToCoverage:true, opacity:0.8  }); break
				
				
				case 'car':   this.create({ name:'car', color:0x303030, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03, sheen: 0.5 }); break
				case 'carGlass':   this.create({ name:'carGlass', color: 0xffffff, metalness: 0, roughness: 0, transmission: 1.0, ior:1.52 }); break

				case 'outline': 
				//if( !this.mat[ 'outline' ] ) this.mat[ 'outline' ] = new FakeGlowMaterial();
				//m = this.mat[ 'outline' ]
				//m = this.create({ name:'outline', color:0xFFFFFF, type:'Basic', side:BackSide, toneMapped:false, wireframe:false }); 
				this.create({ name:'outline', color:0xFFFFFF, type:'Basic', side:BackSide, toneMapped:false, wireframe:true, transparent:true, opacity:0.25 }); 
				break
				case 'debug': this.create({ name:'debug', type:'Basic', color:0xF37042, wireframe:true, toneMapped: false, transparent:true, opacity:0.5 }); break
				//case 'debug': m = this.create({ name:'debug', color:0xF37042, wireframe:true, toneMapped: false, transparent:true, opacity:0.5 }); break
				
				//case 'debug2': m = this.create({ name:'debug2', type:'Basic', color:0x00FFFF, wireframe:true, toneMapped: false }); break
				//case 'debug3':  m = this.create({ name:'debug3', type:'Basic', color:0x000000, wireframe:true, transparent:true, opacity:0.1, toneMapped: false }); break
				//case 'shadows': m = this.create({ name:'shadows', type:'Basic', transparent:true, opacity:0.01 }); break

				//case 'simple': m = this.create({ name:'simple', type:'basic'  }); break

				case 'shadow': this.create({ name:'shadow', type:'shadow', color:0x000000, opacity:0.5 }); break


				case 'bones':  this.create({ name:'bones', color:0xfde7d6,  wireframe:true }); break
				case 'bones2':  this.create({ name:'bones2', type:'basic', color:0xdfc4a8, transparent:true, opacity:0.5, depthTest:true, depthWrite:false, alphaToCoverage:true }); break

				
				case 'button':  this.create({ name:'button', color:0xFF404B, ...matExtra }); break
				//case 'hide': m = new MeshBasicMaterial({ visible:false }); break

				case 'line':
				    this.create({ name:'line', type:'line', vertexColors: true, toneMapped: false });
			    break
			    case 'liner':
				    this.create({ name:'liner', type:'line', vertexColors: true, toneMapped: false, depthTest:true, depthWrite:true, alphaToCoverage:true });
			    break
				case 'hide':
				    this.create({ name:'hide', type:'basic', visible:false });
			    break
			    case 'particle':
				    this.create({ name:'particle', type:'basic', toneMapped: false, color:0x00ff00 });
			    break
			    case 'svg':
				    this.create({ name:'svg', type:'basic', toneMapped:false, vertexColors:true, transparent:false, side:DoubleSide });
			    break

			}
			
		}

		return this.mat[name]

	}

	dispose() {

		this.isRealism = false;

		for(let m in this.mat){
			this.mat[m].dispose();
			delete this.mat[m];
		}

		let i = this.TmpMat.length;
		while( i-- ) { this.TmpMat[i].dispose(); }
		this.TmpMat = [];

	}

	upShader() {

		let option = this.realismOption;
		//if(!option.enable) option = 

		for( let name in this.mat ){

			const m = this.mat[name];
			const shader = m.userData.shader;

			for( let o in option ){

				
				// undate shader uniforme
				if(shader){ 
					/*if(o==='enable'){ 
						shader.defines.ENHANCE_SHADER_LIGHTING = option[o] ? "" : undefined;
						//console.log(shader.defines.ENHANCE_SHADER_LIGHTING)
					}*/
					if(shader.uniforms[o]!==undefined) shader.uniforms[o].value = option[o]; 
				}
				// update material option
				if( m[o] ) m[o] = option[o];
			}


		}

	}

};


/*const outliner = new ShaderMaterial({
    uniforms: {
        color: {type: 'c', value: new Color(0xFFFFFF) },
        power: {type: 'f', value: 0.01 },
    },
    vertexShader:`
        uniform float power;
        void main(){
            //vec3 pos = position + normal * power;
            vec3 pos = position + normalize( normal ) * power;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );
        }
    `,
    fragmentShader:`
        uniform vec3 color;
        void main(){
           gl_FragColor = vec4( color, 0.1 );
        }
    `,
    side:BackSide,
    toneMapped: false,
    //wireframe:true,
    //transparent:true,
    //opacity:0.1,

});*/

class Timer {

	constructor( framerate = -1 ) {

		this.perf = window.performance;
		this.time = { now:0, delta:0, then:0, interval: 0, tmp:0, n:0, dt:0 };
		this.fps = 0;
		this.delta = 0;
		this.elapsedTime = 0;
		this.unlimited = false;
		this.setFramerate( framerate );
		this.force = false;

	} 

	up ( stamp ) {

		let t = this.time;

		if(this.unlimited) this.force = true;

		t.now = stamp !== undefined ? stamp : this.now();
		t.delta = t.now - t.then;

		if( this.force ) {
			t.delta = t.interval;
			this.force = false;
		}
		
		if ( t.delta >= t.interval || this.unlimited ) {

		    t.then = this.unlimited ? t.now : t.now - ( t.delta % t.interval );
		    //if(t.delta>)
		    //this.delta = t.delta * 0.001 // bug on outside
		    this.delta = t.interval * 0.001;
		    //if(this.delta>this.time.interval)this.delta=this.time.interval
		    this.elapsedTime += this.delta;
		    
		    //if ( t.now - 1000 > t.tmp ){ t.tmp = t.now; this.fps = t.n; t.n = 0; }; t.n++;
			return true

		}

		return false

	}

	setFramerate ( framerate ){
		
		this.elapsedTime = 0;
		this.framerate = framerate;
		this.unlimited = this.framerate < 0;
		this.time.interval = 1000 / framerate;
		if( framerate === 60 ) this.time.interval = 16.67;

	}

    static now () {
    	return this.perf ? this.perf.now() : Date.now();
    }

    static format_time ( time ) {
	    if (time > 1000)  return (time / 1000) + " sec";
	    return time + " ms";
	}
	
}

class User {

	// key map
    // 0 : axe L | left:right  -1>1
    // 1 : axe L | top:down    -1>1
    // 2 : axe R | left:right  -1>1
    // 3 : axe R | top:down    -1>1
    // 4 : bouton A             0-1  jump / space
    // 5 : bouton B             0-1  roulade / shift ctrl
    // 6 : bouton X             0-1  arme principale / E
    // 7 : bouton Y             0-1  arme secondaire
    // 8 : gachette L up        0-1  
    // 9 : gachette R up        0-1
    // 10 : gachette L down     0>1
    // 11 : gachette R down     0>1
    // 12 : bouton setup        0-1
    // 13 : bouton menu         0-1
    // 14 : axe button left     0-1
    // 15 : axe button right    0-1
    // 16 : Xcross axe top      0-1
    // 17 : Xcross axe down     0-1
    // 18 : Xcross axe left     0-1
    // 19 : Xcross axe right    0-1

    // 20 : Keyboard or Gamepad    0-1

	constructor () {

		this.key = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        this.key2 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

		this.gamepad = new Gamepad( this.key ); 

		this.useGamepad = false;
		this.sameAxis = true;

		document.addEventListener( 'keydown', function(e){this.keyDown(e);}.bind(this), false );
        document.addEventListener( 'keyup', function(e){this.keyUp(e);}.bind(this), false );

	}

    setKey( i, v ){
        this.key[i] = v;
    }

	update () {

		this.gamepad.update();

        if( this.gamepad.ready ){ 
            if( !this.useGamepad ) this.useGamepad = true;
            this.gamepad.getValue(0);
        }

        if( this.sameAxis ){
            this.key[ 2 ] = this.key[ 0 ];
            this.key[ 3 ] = this.key[ 1 ];
        }

        //this.axeL[ 0 ] = this.key[ 0 ];
        //this.axeL[ 1 ] = this.key[ 1 ];

        return this.key

	}

	keyDown (e) {

		var key = this.key;
        var key2 = this.key2;
        e = e || window.event;

        if( this.sameAxis ){

            switch ( e.which ) {
                // axe L
                case 65: case 81: case 37: key[0] = -1; key2[0] = 1; break;//key[0]<=-1 ? -1:key[0]-= 0.1; break; // left, A, Q
                case 68:  case 39:         key[0] = 1;  key2[1] = 1; break; // right, D
                case 87: case 90:  case 38: key[1] = -1; break; // up, W, Z
                case 83: case 40:          key[1] = 1;  break; // down, S

                case 32:          key[4] = 1; break; // space
                case 17: case 67: key[5] = 1; break; // ctrl, C
                case 69:          key[6] = 1; break; // E
                
                case 16:          key[7] = 1; break; // shift
                //case 71:          view.hideGrid(); break; // G
                //case 121:         noui(); break; // f10
                //case 122:         fscreen(); break; // f11
            }

        } else {

            switch ( e.which ) {
                // axe L
                case 65: case 81: key[0] = -1; key2[0] = 1; break;//key[0]<=-1 ? -1:key[0]-= 0.1; break; // left, A, Q
                case 68:          key[0] = 1; key2[1] = 1; break; // right, D
                case 87: case 90: key[1] = -1; break; // up, W, Z
                case 83:          key[1] = 1;  break; // down, S
                // axe R
                case 37:          key[2] = -1;  key2[0] = 1;break; // left
                case 39:          key[2] = 1;  key2[1] = 1;break; // right
                case 38:          key[3] = -1; break; // up
                case 40:          key[3] = 1;  break; // down
                

                case 32:          key[4] = 1; break; // space
                case 17: case 67: key[5] = 1; break; // ctrl, C
                case 69:          key[6] = 1; break; // E
                
                case 16:          key[7] = 1; break; // shift
                //case 121:         noui(); break; // f10
                //case 122:         fscreen(); break; // f11
                
                //case 71:          view.hideGrid(); break; // G
            }
        }

        this.gamepad.reset();
        //e.preventDefault();

	}

	keyUp (e) {

		var key = this.key;
        var key2 = this.key2;
        e = e || window.event;

        if( this.sameAxis ){

            switch ( e.which ) {
                 // axe L
                case 65: case 81: case 37: key[0] = key[0]<0 ? 0:key[0]; key2[0] = 0; break; // left, A, Q
                case 68: case 39:         key[0] = key[0]>0 ? 0:key[0]; key2[1] = 0; break; // right, D
                case 87: case 90: case 38:key[1] = key[1]<0 ? 0:key[1]; break; // up, W, Z
                case 83: case 40:         key[1] = key[1]>0 ? 0:key[1]; break; // down, S

                case 32:          key[4] = 0; break; // space
                case 17: case 67: key[5] = 0; break; // ctrl, C
                case 69:          key[6] = 0; break; // E
                
                case 16:          key[7] = 0; break; // shift
            }

        } else {

            switch( e.which ) {
                
                // axe L
                case 65: case 81: key[0] = key[0]<0 ? 0:key[0]; key2[0] = 0; break; // left, A, Q
                case 68:          key[0] = key[0]>0 ? 0:key[0]; key2[1] = 0; break; // right, D
                case 87: case 90: key[1] = key[1]<0 ? 0:key[1]; break; // up, W, Z
                case 83:          key[1] = key[1]>0 ? 0:key[1]; break; // down, S
                // axe R
                case 37:          key[2] = key[2]<0 ? 0:key[2]; key2[0] = 0;break; // left
                case 39:          key[2] = key[2]>0 ? 0:key[2]; key2[1] = 0;break; // right
                case 38:          key[3] = key[3]<0 ? 0:key[3]; break; // up
                case 40:          key[3] = key[3]>0 ? 0:key[3]; break; // down

                case 32:          key[4] = 0; break; // space
                case 17: case 67: key[5] = 0; break; // ctrl, C
                case 69:          key[6] = 0; break; // E
                
                case 16:          key[7] = 0; break; // shift

                
            }
        }

        //e.preventDefault();
		
	}


}


class Gamepad {

	constructor ( key ) {

		this.values = []; 
        this.ready = 0;
        this.key = key;

	}

	update () {

		var i,j,k,l, v, pad;
        var fix = this.fix;
        var gamepads = navigator.getGamepads();

        for (i = 0; i < gamepads.length; i++) {

            pad = gamepads[i];
            if(pad){
                k = pad.axes.length;
                l = pad.buttons.length;
                if(l){
                    if(!this.values[i]) this.values[i] = [];
                    // axe
                    for (j = 0; j < k; j++) {
                        v = fix(pad.axes[j], 0.08 );
                        if(this.ready == 0 && v !== 0 ) this.ready = 1;
                        this.values[i][j] = v;
                        //if(i==0) this.key[j] = fix( pad.axes[j], 0.08 );
                    }
                    // button
                    for (j = 0; j < l; j++) {
                        v = fix(pad.buttons[j].value); 
                        if(this.ready == 0 && v !== 0 ) this.ready = 1;
                        this.values[i][k+j] = v;
                        //if(i==0) this.key[k+j] = fix( pad.buttons[j].value );
                    }
                    //info += 'gamepad '+i+'| ' + this.values[i]+ '<br>';
                } else {
                    if(this.values[i]) this.values[i] = null;
                }
            }
        }

	}

	getValue (n) {

		var i = 19, v;
        while(i--){
            v = this.values[n][i];
            if(this.ready == 0 && v !== 0 ) this.ready = 1;
            this.key[i] = v;
        }

	}

	reset () {

		this.ready = 0;
		
	}

	fix (v, dead) {

		let n = Number((v.toString()).substring(0, 5));
        if(dead && n<dead && n>-dead) n = 0;
        return n;
		
	}


}

class Item {

	constructor () {

		this.id = 0;
		this.list = [];
		this.type = 'item';
		this.Utils = null;

	}

	reset () {

		let i = this.list.length;
		while( i-- ) this.dispose( this.list[i] );
		this.list = [];
	    this.id = 0;

	}

	byName ( name ) {

		return this.Utils.byName( name );

	}

	setName ( o = {} ) {

		let name = o.name !== undefined ? o.name : this.type + this.id ++;

		// clear old item if existe keep same id
		o.id = this.remove( name, true );
		o.name = name;
		return name;

	}

	addToWorld ( b, id = -1 ) {

		this.Utils.add( b );
		if( id !== -1 ) this.list[id] = b;
		else this.list.push( b );

	}

	remove ( name, remplace ) {

		let b = this.byName( name );
		if( !b ) return -1;
		return this.clear( b, remplace );

	}

	clear ( b, remplace ) {

		let n = this.list.indexOf( b );
		if ( n !== -1 && !remplace ) this.list.splice( n, 1 );
		else this.list[n] = null;
		this.dispose( b );
		return n;

	}

	dispose ( b ) {

		if( b !== null ) this.Utils.remove( b );

	}

	add ( o = {} ) {}

	set ( o = {} ) {}

	step ( AR, N ) {}

}

// THREE RAY

class Ray extends Item {

	constructor ( motor ) {

		super();

		this.motor = motor;

		this.Utils = this.motor.utils;
		this.type = 'ray';
		this.iType = 'ray';

	}

	step (AR, N) {

		let i = this.list.length, r, n;

		while( i-- ){

			r = this.list[i];
			n = N + ( i * Num.ray );
			r.update( AR, n, this.motor.reflow.ray[i] || null );

		}

	}

	add ( o = {} ) {

		this.setName( o );

		let r = new ExtraRay( o, this.motor );

		r.visible = o.visible !== undefined ? o.visible : true;

		// add to world
		this.addToWorld( r, o.id );

		if(o.parent){
			if( typeof o.parent !== 'string' ) o.parent = o.parent.name;
		}

		if( o.callback ) delete o.callback;

		

		// add to worker 
		this.motor.post( { m:'add', o:o } );

		return r;

	}

	set ( o = {}, r = null ) {

		if( r === null ) r = this.byName( o.name );
		if( r === null ) return;

		r.setRay(o);

	}

}


class ExtraRay extends Line$1 {

	constructor( o = {}, motor ) {

	    super( new BufferGeometry(), motor.getMat('line') );

	    this.motor = motor;
		this.Utils = this.motor.utils;

	    this.isRay = true;

	    this.data = {

			hit:false,
			body: '',
			point: [0,0,0],
			normal: [0,0,0],
			distance: 0,
			angle:0,
			parent:null

		};

	    this.type = 'ray';
	    this.name = o.name;

	    this.parentMesh = null;
	    if(o.parent){
	    	this.parentMesh = typeof o.parent === 'string' ?  this.Utils.byName( o.parent ) : o.parent;
	    	this.data.parent = this.parentMesh;
	    }

	    this.callback = o.callback || null;

	    // color
		this.c0 = [ 0.1, 0.1, 0.3 ];
		this.c1 = [ 0.1, 0.4, 0.6 ];
		this.c2 = [ 1.0, 0.1, 0.1 ];
		this.c3 = [ 0.1, 1.0, 0.1 ];

	    this.begin = new Vector3();
	    this.end = new Vector3(0,1,0);
	    this.tmp = new Vector3();
	    this.vnormal = new Vector3();
	    this.vv1 = new Vector3();
	    this.vv2 = new Vector3();

	    this.fullDistance = 0;

	    this.setRay( o );

	    const positions = [0,0,0, 0,0,0, 0,0,0];
	    const colors = [0,0,0, 0,0,0, 0,0,0];

	    //this.geometry = new BufferGeometry();
	    this.geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	    this.geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	    //this.geometry.computeBoundingSphere();

	    this.vertices = this.geometry.attributes.position;
	    this.colors = this.geometry.attributes.color;
	    this.local = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];

	    this.matrixAutoUpdate = false;
	    this.frustumCulled = false;

	}

	setRay( o ){

		if( o.begin ) this.begin.fromArray( o.begin );
	    if( o.end ) this.end.fromArray( o.end );
	    this.fullDistance = this.begin.distanceTo( this.end );

	}

	update ( r, n = 0, body = null ) {

		this.data.hit = r[n] !== 0 ? true : false;
		this.data.body = body ? body : '';

		this.data.distance = r[n+1];

		if( this.data.hit ){

			this.local[0] = r[n+2];
			this.local[1] = r[n+3];
			this.local[2] = r[n+4];

			this.tmp.fromArray( r, n+5 );
			this.vnormal.fromArray( r, n+8 );

			this.data.point = this.tmp.toArray();
			this.data.normal = this.vnormal.toArray();
			//this.data.distance = this._begin.distanceTo( this.tmp )

			this.tmp.toArray( this.local, 3 );
			this.vv1.fromArray( this.local ).sub(this.tmp).normalize(); 
			this.tmp.addScaledVector( this.vnormal, this.fullDistance - this.data.distance );
			this.tmp.toArray( this.local, 6 );

			
			//vv1.fromArray( r, n+5 ); 

			this.data.angle = Math.floor( MathTool.angleTo( this.vv1.toArray(), this.data.normal ) * todeg$1 );
			//let angle = MathTool.angleTo( [this.local[0], this.local[2], this.local[2]], [this.local[3], this.local[4], this.local[5]] ) * todeg
			//console.log(this.data.angle)

		} else {
			if( this.parentMesh ){
				//this.data.parent = this.parentMesh;
				//this.parentMesh.updateWorldMatrix(false,false )
				const mtx = this.parentMesh.matrixWorld;
				this.tmp.copy( this.begin ).applyMatrix4(mtx).toArray( this.local, 0 );
				this.tmp.copy( this.end ).applyMatrix4(mtx);
				this.tmp.toArray( this.local, 3 );
				this.tmp.toArray( this.local, 6 );
			} else {
				this.begin.toArray( this.local, 0 );
				this.end.toArray( this.local, 3 );
				this.end.toArray( this.local, 6 );
			}
		}

		this.updateGeometry();
		this.updateMatrix();

		if(this.callback) this.callback( this.data );

	}

	dispose(){
		
		this.callback = null;
		this.parentMesh = null;
		this.data = {};
		this.geometry.dispose();

	}

	raycast(){
		return
	}

	updateGeometry(){

		if ( !this.visible ) return;

		let v = this.vertices.array;
		let c = this.colors.array;
		let l = this.local;
		let hit = this.data.hit;
		let c1 = hit ? this.c2 : this.c1;
		let c2 = hit ? this.c3 : this.c1;

		c[ 3 ] = c1[0];
		c[ 4 ] = c1[1];
		c[ 5 ] = c1[2];

		c[ 6 ] = c2[0];
		c[ 7 ] = c2[1];
		c[ 8 ] = c2[2];

		v[ 0 ] = l[ 0 ];
		v[ 1 ] = l[ 1 ];
		v[ 2 ] = l[ 2 ];

		v[ 3 ] = l[ 3 ];
		v[ 4 ] = l[ 4 ];
		v[ 5 ] = l[ 5 ];
		
		v[ 6 ] = l[ 6 ];
		v[ 7 ] = l[ 7 ];
		v[ 8 ] = l[ 8 ];

		this.vertices.needsUpdate = true;
	    this.colors.needsUpdate = true;
	}

}

//ExtraRay.prototype.isRay = true;

let _object3DId = 0;

const _v1$2 = new Vector3();
const _q1 = new Quaternion$1();
const _m1 = new Matrix4();
const _target = new Vector3();

const _position = new Vector3();
const _scale = new Vector3();
const _quaternion = new Quaternion$1();

const _xAxis = new Vector3( 1, 0, 0 );
const _yAxis = new Vector3( 0, 1, 0 );
const _zAxis = new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

class Basic3D extends EventDispatcher {

	constructor() {

		super();

		this.isObject3D = true;

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );
		this.uuid = MathUtils.generateUUID();
		
	    this.isRay = true;
	    this.matrix = new Matrix4();
	    this.matrixWorld = new Matrix4();
		
		this.name = '';
		this.type = 'Object3D';

		this.children = [];
		this.parent = null;
		
		
		this.position = new Vector3();
		this.quaternion = new Quaternion$1();
		this.tmpRotation = new Euler();
		this.scale = new Vector3( 1, 1, 1 );

		this.isKinematic = false;
		
		this.matrixAutoUpdate = false;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;
		this.isVisible = true;

		//this.castShadow = false;
		//this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		//this.animations = [];

		this.userData = {};

		this.mass = 0;
		this.density = 0;
		// TODO 
		this.inertia = new Vector3(1, 1, 1);

		
		this.shapetype = 'box';
		this.size = [1,1,1];
		//this.data = {}
		//this._size = new Vector3(1,1,1)
		this.velocity = new Vector3();
		this.angular = new Vector3();
		
		this.defMat = false;
		this.actif = false;
		this.auto = false;
		this.sleep = false;

		// only for high mesh
		this.mesh = null;
		this.meshSize = 1;

		// if object is link by joint
		this.linked = [];

		this.isOver = false;
		this.overMaterial = null;

	}

	// ADD

	clearOutLine() {

		if( !this.overMaterial ) return;
		if( !this.outline ) return;
		this.remove(this.outline);
		this.outline = null;

	}

	addOutLine() {

		if( !this.overMaterial ) return;
		if( !this.children[0].isMesh ) return;
		/*if(this.children[0].geometry.boundingBox){
			let tt = new Vector3()
			this.children[0].geometry.boundingBox.getSize(tt);
			s = tt.length() * 0.01
		}*/
		//this.children[0].geometry.boundingBox.getSize(tt);
		//let gSize = tt.length() * 0.5
		//let mScale = this.children[0].scale.length() * 0.5
		//console.log( mScale)

		this.outline = new Mesh().copy( this.children[0] );
		//this.outline.geometry.computeVertexNormals()
		//this.outline.geometry.normalizeNormals()
		this.outline.name = "outline";
		this.outline.material = this.overMaterial;
		//if( this.shapetype==='sphere' ) this.meshSize = 0.5
		//if(this.overMaterial.uniforms.power)this.overMaterial.uniforms.power.value = s / this.meshSize;
		this.outline.matrixAutoUpdate = false;
		this.outline.receiveShadow = false;
		this.outline.castShadow = false;
		this.outline.raycast = () => ( false );
		this.add( this.outline );

	}

	over ( b ) {

		if( b && !this.isOver ){ 

            this.isOver = true;
            this.addOutLine();

        }

        if( !b && this.isOver ){ 

            this.isOver = false;
            this.clearOutLine();

        }

		//if(b) this.addOutLine();
		//else this.clearOutLine();

    }

	select ( b ) {

		//console.log(b)

    }

    dispose () {

    	this.clearOutLine();
    	this.traverse( function ( node ) {
			if( node.isMesh && node.unic ) node.geometry.dispose();
		});

		this.children = [];

    }

	/*set size( value ){
		this._size.fromArray( value )
	}

	get size(){
		return this._size.toArray()
	}*/

	set receiveShadow( value ){
		this.traverse( function ( node ) {
			if( node.isMesh ) node.receiveShadow = value;
		});
	}

	get receiveShadow(){
		if( this.children[0] ) return this.children[0].receiveShadow;
		else return false
	}

	set castShadow( value ){
		this.traverse( function ( node ) {
			if( node.isMesh ) node.castShadow = value;
		});
	}

	get castShadow(){
		if( this.children[0] ) return this.children[0].castShadow;
		else return false
	}

	set material( value ){
		this.traverse( function ( node ) {
			if( node.isMesh ){ 
				if( node.name !== 'outline' ) node.material = value;
			}
		});
	}

	get material(){
		this.children;
		if( this.children[0] ) return this.children[0].material;
		else return null;
	}

    set rotation( v ){
    	this.tmpRotation = v;
		quaternion.setFromEuler( this.tmpRotation, false );
	}

	get rotation(){
		return this.tmpRotation.setFromQuaternion( this.quaternion, undefined, false );
	}

    //////


	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$2.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$2.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		return vector.applyMatrix4( _m1.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1.lookAt( _position, _target, this.up );

		} else {

			_m1.lookAt( _target, _position, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1 );

		if ( parent ) {

			_m1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== -1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		const children = this.children;
		let i = children.length;

		while( i-- ){
		//for ( let i = 0; i < this.children.length; i ++ ) {

			const object = children[ i ];
			object.parent = null;
			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform
		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		const children = this.children;
		let i = children.length;

		while( i-- ){
		//for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, target, _scale );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, _quaternion, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	setRaycast(v){
		if( v !== undefined ) this.isRay = v;
		if(!this.isRay){
			let i =  this.children.length;
			while( i-- ) {
				let j =  this.children[i].children.length;
				while( j-- ) this.children[i].children[j].raycast = () => {}; 
				this.children[i].raycast = () => {};
			}
		}
	}

	// direct raycast avoid recursive !!
	raycast( raycaster, intersects ) {

		if( !this.isRay ) return

		const children = this.children;
		let i = children.length;

		while( i-- ){

			if ( children[i].layers.test( raycaster.layers ) ) {

				children[i].raycast( raycaster, intersects );

			}

		}
	}

	traverse( callback ) {

		callback( this );

		const children = this.children;
		let i = children.length;

		//for ( let i = 0, l = children.length; i < l; i ++ ) {
		while( i-- ){

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;
		let i = children.length;

		//for ( let i = 0, l = children.length; i < l; i ++ ) {
		while( i-- ){

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	/*setTransform( p, q, s ) {

		this.position.fromArray( p )
		this.quaternion.fromArray( q )

		this.matrix.copy( m );
		this.matrix.decompose( this.position, this.quaternion, this.scale );
		this.matrixWorldNeedsUpdate = true;

	}

	setColor( color ) {

		if( this.isInstance ){
		    this.instance.setColorAt( this.instanceId, color );
		}
		
	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );
	    this.matrixWorldNeedsUpdate = true;

		if( this.isInstance ) {
			this.instance.setTransformAt( this.instanceId, this.position.toArray(), this.quaternion.toArray(), this.size )
			return;
		} else {
			
		}

		

		//if( this.isInstance ) this.instance.setMatrixAt( this.instanceId, this.matrix );
		//else this.matrixWorldNeedsUpdate = true;

	}*/

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );
		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;
		let i = children.length;

		while( i-- ){
		//for ( let i = 0, l = children.length; i < l; i ++ ) {
			children[ i ].updateMatrixWorld( force );

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;
			let i = children.length;

			while( i-- ){
			//for ( let i = 0, l = children.length; i < l; i ++ ) {
				children[ i ].updateWorldMatrix( false, true );

			}

		}

	}

}

class Instance extends InstancedMesh {

	constructor( geometry, material, count = 0 ) {

        super( geometry, material, count );

        //this.instanceMatrix = null;
        this.matrixAutoUpdate = false; 
        this.tmpMatrix = new Matrix4();
        this.tmpQuat = new Quaternion$1();

        this.instanceUv = null;
        this.instanceColor = null;
        this.needSphereUp = false;
        this.isRay = true;

        this.overMaterial = null;
        this.currentOver = -1;
        this.isOver = false;

        this.outline = null;

        this.tmpElement = [];
        
    }

    clearOutLine() {

        if( !this.overMaterial ) return;
        if( !this.outline ) return;
        //let i = this.outline.length
        this.parent.remove( this.outline );
        this.outline = null;
        this.currentOver = -1;

    }

    addOutLine( obj ) {

        if( !this.overMaterial ) return;

        if(!this.outline)this.outline = new Mesh( this.geometry, this.overMaterial );
        // if(this.overMaterial.uniforms.power)this.overMaterial.uniforms.power.value = 0.01;
        this.outline.matrixAutoUpdate = false;
        this.tmpMatrix.fromArray( this.instanceMatrix.array, obj.id*16 );
        this.outline.matrix.copy( this.tmpMatrix );
        this.outline.matrixWorldNeedsUpdate = true;
        this.parent.add( this.outline );
        this.currentOver = obj.id;

    }

    over ( b ) {

        if( b && !this.instance.isOver ){ 

            this.instance.isOver = true;
            this.instance.addOutLine( this );

        }

        if( !b && this.instance.isOver ){ 

            this.instance.isOver = false;
            this.instance.clearOutLine();

        }

    }

    /*getInfo( index ) {

        this.tmpMatrix.fromArray( this.instanceMatrix.array, index * 16 );
        let pos = {x:0, y:0, z:0 };
        let scale = { x:0, y:0, z:0 };
        this.tmpMatrix.decompose( pos, this.tmpQuat, scale );
        return{
            pos:[pos.x, pos.y, pos.z],
            quat:this.tmpQuat.toArray(),
            scale:[scale.x, scale.y, scale.z],
            //worldMatrix:this.tmpMatrix.toArray(),
        }
    }*/

    

    setColorAt( index, color ) {

        if ( this.instanceColor === null ) {

            this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );

        }

        if( color.isColor ) color = color.toArray();
        
        let id = index * 3;
        this.instanceColor.array[id] = color[0];
        this.instanceColor.array[id +1] = color[1];
        this.instanceColor.array[id +2] = color[2];
        //color.toArray( this.instanceColor.array, index * 3 );

    }

    /*setUvAt( index, uv ) {

        if ( this.instanceUv === null ) this.instanceUv = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 2 ), 2 );
        
        if( uv.isVector2 ) uv = uv.toArray()
        let id = index * 2
        this.instanceUv.array[id] = uv[0]
        this.instanceUv.array[id +1] = uv[1]

    }*/

    add( bref, position = [0,0,0], rotation = [0,0,0,1], scale = [1,1,1], color = null, uv = null ) {

        if( rotation.length === 3 ) rotation = this.tmpQuat.setFromEuler( {_x:rotation[0], _y:rotation[1], _z:rotation[2], _order:'XYZ'}, false ).toArray();
        if(color){ 
            if( color.isColor ) color = color.toArray();
            if ( this.instanceColor === null ) this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );
        }
        /*if(uv){ 
            if( uv.isVector2 ) uv = uv.toArray()
            if ( this.instanceUv === null ) this.instanceUv = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 2 ), 2 );
        }*/
        this.expand( position, rotation, scale, color, uv );

        //console.log(bref.id)
        this.tmpElement.push( bref );
    }

    slice( ar, begin, end ) {

        let target = new Float32Array(end - begin);
        for (let i = 0; i < begin + end; ++i) {
            target[i] = ar[begin + i];
        }
        return target

    }

    remove( id ) {

        if(!this.count) return;
        
        this.tmpElement.splice( id, 1 );

        let old = [...this.instanceMatrix.array];
        old.splice( id*16, 16 );
        this.instanceMatrix = new InstancedBufferAttribute( new Float32Array(old), 16 );
        //this.instanceMatrix.array = new Float32Array(old);

        //this.instanceMatrix.array = this.slice( this.instanceMatrix.array, id*16, 16 );
        //this.instanceMatrix.needsUpdate = true;

        if ( this.instanceColor !== null ) {
            old = [...this.instanceColor.array];
            old.splice( id*3, 3 );
            this.instanceColor = new InstancedBufferAttribute( new Float32Array(old), 3 );
            //this.instanceColor.array = new Float32Array(old);
        }

        if ( this.instanceUv !== null ) {
            old = [...this.instanceUv.array];
            old.splice( id*2, 2 );
            this.instanceUv = new InstancedBufferAttribute( new Float32Array(old), 2 );
            //this.instanceUv.array = new Float32Array(old);
        }
        this.count--;

        this.reDistribute();

    }

    reDistribute() {

        let i = this.count;
        while(i--) this.tmpElement[i].id = i;
        
    }

    getIDName( index ) {

        return this.tmpElement[index].name;

    }

    getBodyList(){

        let bodyNames = [];
        let i = this.count;
        while(i--) bodyNames.push( this.tmpElement[i].name );
        return bodyNames;

    }

    expand( p, q, s, c = [1,1,1], uv ) {

        let old = this.instanceMatrix !== null ? this.instanceMatrix.array : [];
        this.tmpMatrix.compose({x:p[0], y:p[1], z:p[2]}, {_x:q[0], _y:q[1], _z:q[2], _w:q[3]}, {x:s[0], y:s[1], z:s[2]});
        this.instanceMatrix = new InstancedBufferAttribute( new Float32Array([...old, ...this.tmpMatrix.toArray()]), 16 );
        //this.instanceMatrix.setUsage( DynamicDrawUsage );
        if ( this.instanceColor !== null ) {
            old = this.instanceColor.array;
            this.instanceColor = new InstancedBufferAttribute( new Float32Array([...old, ...c ]), 3 );
        }
       /* if ( this.instanceUv !== null ) {
            old = this.instanceUv.array;
            this.instanceUv = new InstancedBufferAttribute( new Float32Array([...old, ...uv ]), 2 );
        }*/
        this.count ++;

    }

    setTransformAt( index, p, q, s ) {

        this.tmpMatrix.compose({ x:p[0], y:p[1], z:p[2] }, {_x:q[0], _y:q[1], _z:q[2], _w:q[3]}, {x:s[0], y:s[1], z:s[2]});
        this.tmpMatrix.toArray( this.instanceMatrix.array, index * 16 );
        this.needSphereUp = true;



        if( !this.outline ) return;
        if(this.currentOver === index ){
            this.outline.matrix.copy(this.tmpMatrix);
            //this.outline.updateMatrix()
            this.outline.matrixWorldNeedsUpdate = true;
        }

    }

    dispose() {

        this.clearOutLine();
        this.parent.remove(this);
        this.geometry.dispose();
        //this.instanceMatrix = null;
        this.instanceColor = null;
        this.count = 0;
        this.tmpElement = [];
        //console.log(this.name+" is dispose")
        this.dispatchEvent( { type: 'dispose' } );

    }

    setRaycast(v) {

        if( v !== undefined ) this.isRay = v;

    }

    raycast( raycaster, intersects ) {

        if(!this.isRay) return
        this.instanceMatrix.needsUpdate = true;
        super.raycast( raycaster, intersects );

    }

    update(){

        
        if( this.instanceMatrix ) this.instanceMatrix.needsUpdate = true;
        if( this.instanceColor ) this.instanceColor.needsUpdate = true;
        if( this.needSphereUp )this.computeBoundingSphere();
        //if( this.instanceUv ) this.instanceUv.needsUpdate = true;
        this.needSphereUp = false;
        this.updateMatrix();

    }

}

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.isQuaternion = true;
		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;
		return this;

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];
		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;
		return array;

	}
}

/**
* SPHERE BOX GEOMETRY
*/
class SphereBox extends BufferGeometry {

    constructor( radius=1, widthSegs=10, heightSegs=10, depthSegs=10, roundness=1 ) {

        super();

        this.type = 'SphereBox';
        this.name = 'SphereBox_' + radius +'_'+widthSegs+'_'+heightSegs+'_'+depthSegs+'_'+roundness;

        radius = radius || 1;

        // segments

        widthSegs = Math.floor( widthSegs );
        heightSegs = Math.floor( heightSegs );
        depthSegs = Math.floor( depthSegs );        
        let g = new BoxGeometry( 1,1,1, widthSegs, heightSegs, depthSegs ), v = new Vector3(), r = new Vector3(), n;

        let ar = g.attributes.position.array;
        let nm = g.attributes.normal.array;

        for ( let i = 0, l = g.attributes.position.count; i < l; i ++ ) {

            n = i*3;
            v.set( ar[n], ar[n+1], ar[n+2] );
            r.copy( v ).normalize();

            v.lerp( r, roundness ).multiplyScalar( radius );

            ar[n] = v.x;
            ar[n+1] = v.y;
            ar[n+2] = v.z;

            v.normalize();

            nm[n] = v.x;
            nm[n+1] = v.y;
            nm[n+2] = v.z;
            
        }

        this.copy(g);

    }
}

/**
* CAPSULE GEOMETRY
*/
class Capsule extends BufferGeometry {

    constructor( radius = 1, height = 1, radialSegs = 12, heightSegs = 1 ) {

        super();

    	this.type = 'CapsuleGeometry';
        //this.name = 'Capsule_' + radius +'_'+height+'_'+radialSegs+'_'+heightSegs;

        let pi = Math.PI;

        let th = (radius*2) + height;
        let sy = radius / th;
        let hy = 1 - (2*sy);

        radialSegs = Math.floor( radialSegs );
        heightSegs = Math.floor( heightSegs );

        let sHeight = Math.floor( radialSegs * 0.5 );
        let o0 = Math.PI * 2;
        let o1 = Math.PI * 0.5;
        let m0 = new CylinderGeometry( radius, radius, height, radialSegs, heightSegs, true );
        //let m0 = new CylinderGeometryFix2( radius, radius, height, radialSegs, heightSegs, true );
        //let m0 = new CylinderGeometry( radius, radius, height, radialSegs, heightSegs, true );
        scaleUV( m0, 0, sy, 1, hy );
        let m1 = new SphereGeometry( radius, radialSegs, sHeight, 0, o0, 0, o1);
        scaleUV( m1, 0, 1-sy, 1, sy );
        let m2 = new SphereGeometry( radius, radialSegs, sHeight, 0, o0, o1, o1);
        scaleUV( m2, 0, 0, 1, sy );
        let mtx0 = new Matrix4().makeRotationY( -pi*0.5 );
        let mtx1 = new Matrix4().makeTranslation(0, height*0.5,0);
        let mtx2 = new Matrix4().makeTranslation(0, -height*0.5,0);
        m0.applyMatrix4( mtx0 );
        m1.applyMatrix4( mtx1 );
        m2.applyMatrix4( mtx2 );


        let g = mergeVertices( mergeGeometries( [ m0, m1, m2] ) );
        this.copy( g );

        /*m0.dispose()
        m1.dispose()
        m2.dispose()
        g.dispose()*/

    }
}


/**
* TORUS EXTRA GEOMETRY
*/
class TorusGeometryFix extends BufferGeometry {

    constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc= Math.PI * 2, thetaStart=0, thetaLength=Math.PI ) {

        super();

        this.type = 'TorusGeometryFix';

        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };

        radialSegments = Math.floor( radialSegments );
        tubularSegments = Math.floor( tubularSegments );

        // buffers

        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];

        // helper variables

        const center = new Vector3();
        const vertex = new Vector3();
        const normal = new Vector3();

        let j, i;

        // generate vertices, normals and uvs

        for ( j = 0; j <= radialSegments; j ++ ) {

            for ( i = 0; i <= tubularSegments; i ++ ) {

                const u = i / tubularSegments * arc;
                //const v = j / radialSegments * Math.PI * 2;

                const v = (j / radialSegments) * thetaLength + thetaStart;

                // vertex

                vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
                vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
                vertex.z = tube * Math.sin( v );

                vertices.push( vertex.x, vertex.y, vertex.z );

                // normal

                center.x = radius * Math.cos( u );
                center.y = radius * Math.sin( u );
                normal.subVectors( vertex, center ).normalize();

                normals.push( normal.x, normal.y, normal.z );

                // uv

                uvs.push( i / tubularSegments );
                uvs.push( j / radialSegments );

            }

        }

        // generate indices

        for ( j = 1; j <= radialSegments; j ++ ) {

            for ( i = 1; i <= tubularSegments; i ++ ) {

                // indices

                const a = ( tubularSegments + 1 ) * j + i - 1;
                const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
                const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
                const d = ( tubularSegments + 1 ) * j + i;

                // faces

                indices.push( a, b, d );
                indices.push( b, c, d );

            }

        }

        // build geometry

        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    }
}


/**
* CHAMFER CYLINDRE GEOMETRY
*/
class ChamferCyl extends BufferGeometry {

    constructor( radiusTop = 1, radiusBottom = 1, height = 1, filet =0.01, radialSegs = 12, heightSegs = 1, filetSegs = 2 ) {

        super();

        this.type = 'ChamferCyl';
        //this.name = 'ChamferCyl_' + radiusTop +'_'+radiusBottom+'_'+height+'_'+filet+'_'+radialSegs+'_'+heightSegs+'_'+filetSegs;

        radialSegs = Math.floor( radialSegs );
        heightSegs = Math.floor( heightSegs );
        filetSegs = Math.floor( filetSegs );

        let mr = new Matrix4();
        let mt = new Matrix4();

        let pi = Math.PI;
        let p90 = pi * 0.5;
        let twoPi = pi * 2;

        let start = 0;//(twoPi / radialSegs)*(3/radialSegs)//;

        let th = height;
        let sy = filet / th;
        let hy = 1 - (2*sy);
        //console.log(start)

        //let mid = new CylinderGeometryFix( radiusBottom, radiusTop, height-(filet*2), radialSegs, heightSegs, true, start );
        let mid = new CylinderGeometry( radiusTop, radiusBottom, height-(filet*2), radialSegs, heightSegs, true, start );
        mr.makeRotationY( p90 );
        mid.applyMatrix4( mr );

        scaleUV( mid, 0, sy, 1, hy );

        // top
        let c1 = new TorusGeometryFix( radiusTop-filet, filet, filetSegs, radialSegs, twoPi, 0, p90 );
        let c2 = new CircleGeometry( radiusTop-filet, radialSegs );

        mt.makeTranslation( 0,0, filet );
        c2.applyMatrix4( mt );

        scaleUV( c1, 0, 1-sy, 1, sy );

        let top = mergeGeometries( [ c1, c2 ] );

        mr.makeTranslation( 0,0,( (height*0.5) - filet) );
        mt.makeRotationX( -p90 );

        top.applyMatrix4( mt.multiply(mr) );

        /*c1.dispose();
        c2.dispose();*/

        // bottom
        c1 = new TorusGeometryFix( radiusBottom-filet, filet, filetSegs, radialSegs, twoPi, 0, p90 );
        c2 = new CircleGeometry( radiusBottom-filet, radialSegs );

        mt.makeTranslation( 0,0, filet );
        c2.applyMatrix4( mt );

        scaleUV( c1, 0, 1-sy, 1, sy, true );

        let low = mergeGeometries( [ c1, c2 ] );

        mr.makeTranslation( 0,0,( (height*0.5) - filet) );
        mt.makeRotationX( p90 );
        low.applyMatrix4( mt.multiply(mr) );

        /*c1.dispose();
        c2.dispose();*/

        let g = mergeVertices( mergeGeometries( [ top, mid, low ] ) );

        /*mid.dispose();
        top.dispose();
        low.dispose();*/

        this.copy(g);
        //g.dispose();

    }
}

//ChamferCyl.prototype = Object.create( THREE.BufferGeometry.prototype );

/**
* CHAMFER BOX GEOMETRY
*/
class ChamferBox extends BufferGeometry {

    constructor( width  = 1, height = 1, depth = 1, filet = 0.01, widthSegs = 1, heightSegs = 1, depthSegs = 1, filetSegs = 2 ) {

        super();

        this.type = 'ChamferBox';
        //this.name = 'ChamferBox_' + width +'_'+height+'_'+depth+'_'+filet+'_'+widthSegs+'_'+heightSegs+'_'+depthSegs+'_'+filetSegs;

        widthSegs = Math.floor( widthSegs );
        heightSegs = Math.floor( heightSegs );
        depthSegs = Math.floor( depthSegs );
        filetSegs = Math.floor( filetSegs );

        let pi = Math.PI;
        let p90 = pi * 0.5;
        let twoFilet = filet * 2;

        let midWidth = width * 0.5;
        let midHeight = height * 0.5;
        let midDepth = depth * 0.5;

        let mr = new Matrix4();
        let mt = new Matrix4();
        let mp = new Matrix4();

        // uv calc

        let tw = width;
        let sw = filet / tw;
        let vw = 1 - (2*sw);

        let th = height;
        let sh = filet / th;
        let vh = 1 - (2*sw);

        let td = depth;
        let sd = filet / td;
        let vd = 1 - (2*sd);

        let f = new PlaneGeometry( width-twoFilet, height-twoFilet, widthSegs, heightSegs );
        let c1 = new CylinderGeometry( filet, filet, width-twoFilet, filetSegs, widthSegs, true, 0, p90 );
        let c2 = new CylinderGeometry( filet, filet, height-twoFilet, filetSegs, heightSegs, true, 0, p90 );
        let s1 = new SphereGeometryFix( filet, filetSegs, filetSegs, 0, p90, 0, -p90 );
        let s2 = new SphereGeometryFix( filet, filetSegs, filetSegs, 0, p90, 0, -p90 );

        scaleUV( f, -sw, sh, vw, vh );
        scaleUV( c1, 0, sw, sh, vw );
       //scaleUV( c2, 0, -sw, vw, sw )

        mt.makeTranslation( 0, midHeight - filet, 0 );
        mr.makeRotationX( p90 );
        s1.applyMatrix4( mt.multiply(mr) );

        mt.makeTranslation( 0, -midHeight + filet, 0 );
        mr.makeRotationX( p90 );
        mp.makeRotationY( -p90 );
        s2.applyMatrix4( mt.multiply(mr).multiply(mp) );

        let tra = mergeGeometries( [ c2, s1, s2 ] );
        let trc = tra.clone();

        /*c2.dispose();
        s1.dispose();
        s2.dispose();*/
        
        mt.makeTranslation( midWidth - filet, 0, -filet );

        tra.applyMatrix4( mt );

        mt.makeTranslation( -midWidth + filet, 0, -filet );
        mr.makeRotationZ( pi );

        trc.applyMatrix4( mt.multiply(mr) );

        // cylinder

        let c3 = c1.clone();

        mr.makeRotationZ( p90 );
        mt.makeTranslation( 0, midHeight - filet, -filet );
        c1.applyMatrix4( mt.multiply(mr) );
        mt.makeTranslation( 0, -midHeight + filet, -filet );
        mr.makeRotationZ( -p90 );
        c3.applyMatrix4( mt.multiply(mr) );

        let rf = mergeGeometries( [ c1, c3, f, tra, trc ] );
        let rg = rf.clone();

        mt.makeTranslation( 0, 0, midDepth );
        rf.applyMatrix4( mt );

        mt.makeTranslation( 0, 0, -midDepth );
        mr.makeRotationY( pi );
        rg.applyMatrix4( mt.multiply(mr) );

        // side left

        /*f.dispose();
        c1.dispose();
        c3.dispose();*/

        f = new PlaneGeometry( depth-twoFilet, height-twoFilet, depthSegs, heightSegs );
        c1 = new CylinderGeometry( filet, filet, depth-twoFilet, filetSegs, depthSegs, true, 0, p90 );
        c3 = c1.clone();

        scaleUV( f, -sd, sh, vd, vh );

        mt.makeTranslation( 0, -(midHeight - filet), -filet, 0 );
        mr.makeRotationZ( -p90 );

        c1.applyMatrix4( mt.multiply(mr) );

        mt.makeTranslation( 0, midHeight - filet, -filet, 0 );
        mr.makeRotationZ( p90 );

        c3.applyMatrix4( mt.multiply(mr) );


        let rr = mergeGeometries( [ c1, c3, f ] );
        let rb = rr.clone();

        /*f.dispose();
        c1.dispose();
        c3.dispose()*/

        mt.makeTranslation( -midWidth, 0, 0 );
        mr.makeRotationY( -p90 );

        rr.applyMatrix4( mt.multiply(mr) );

        // side right

        mt.makeTranslation( midWidth, 0, 0 );
        mr.makeRotationY( p90 );

        rb.applyMatrix4( mt.multiply(mr) );

        // top
        f = new PlaneGeometry( width-twoFilet, depth-twoFilet, widthSegs, depthSegs );
        scaleUV( f, -sw, sd, vw, vd );
        let f2 = f.clone();



        mt.makeTranslation( 0, midHeight, 0);
        mr.makeRotationX( -p90 );
        f.applyMatrix4( mt.multiply(mr) );

        // bottom
        mt.makeTranslation( 0, -midHeight, 0);
        mr.makeRotationX( p90 );
        f2.applyMatrix4( mt.multiply(mr) );

        let g = mergeVertices( mergeGeometries( [ rf, rg, rr, rb, f, f2 ] ) );

        /*rf.dispose();
        rg.dispose();
        rr.dispose();
        rb.dispose();
        f2.dispose();
        f.dispose();*/
        //g.computeVertexNormals()
        //g = g.toNonIndexed()
        //

        createUV(g, 'box');

        this.copy(g);
        /*g.dispose();*/

    }
}

class SphereGeometryFix extends BufferGeometry {

    constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

        super();

        this.type = 'SphereGeometryFix';

        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        widthSegments =  Math.floor( widthSegments );
        heightSegments =  Math.floor( heightSegments );

        const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

        let index = 0;
        const grid = [];

        const vertex = new Vector3();
        const normal = new Vector3();

        // buffers

        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];

        // generate vertices, normals and uvs

        for ( let iy = 0; iy <= heightSegments; iy ++ ) {

            const verticesRow = [];

            const v = iy / heightSegments;

            // special case for the poles

            let uOffset = 0;

            if ( iy == 0 && thetaStart == 0 ) {

                uOffset = 0.5 / widthSegments;

            } else if ( iy == heightSegments && thetaEnd == Math.PI ) {

                uOffset = -0.5 / widthSegments;

            }

            for ( let ix = 0; ix <= widthSegments; ix ++ ) {

                const u = ix / widthSegments;

                // vertex

                vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
                vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
                vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

                vertices.push( vertex.x, vertex.y, vertex.z );

                // normal

                normal.copy( vertex ).normalize();
                normals.push( normal.x, normal.y, normal.z );

                // uv

                uvs.push( u + uOffset, 1 - v );

                verticesRow.push( index ++ );

            }

            grid.push( verticesRow );

        }

        // indices

        for ( let iy = 0; iy < heightSegments; iy ++ ) {

            for ( let ix = 0; ix < widthSegments; ix ++ ) {

                const a = grid[ iy ][ ix + 1 ];
                const b = grid[ iy ][ ix ];
                const c = grid[ iy + 1 ][ ix ];
                const d = grid[ iy + 1 ][ ix + 1 ];

                if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
                if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

            }

        }

        // build geometry

        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    }

}

// { SphereGeometryFix };


// UV 

function scaleUV( geometry, x=0, y=0, dx=1, dy=1, reverse ) {

    let uv = geometry.attributes.uv;
    let ar = uv.array;
    let i = uv.count, n =0;

    while( i-- ){
        n=i*2;
        ar[n] = (ar[n]*dx)-x;
        ar[n+1] = (ar[n+1]*dy)+y;

        if(reverse){
            ar[n] = 1 - ar[n];
            ar[n+1] = 1 - ar[n+1];
        }
    }


}

function createUV( geometry, type = 'sphere', boxSize, pos = [0,0,0], quat = [0,0,0,1], transformMatrix ) {

    //type = type || 'sphere';

    if ( transformMatrix === undefined ) transformMatrix = new Matrix4();
    transformMatrix.compose( {x:pos[0], y:pos[1], z:pos[2] }, { _x:quat[0], _y:quat[1], _z:quat[2], _w:quat[3] }, {x:1, y:1, z:1 });



    if ( boxSize === undefined ) {
        if( !geometry.boundingBox ) geometry.computeBoundingBox();
        let bbox = geometry.boundingBox;
        boxSize = Math.max( bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y, bbox.max.z - bbox.min.z );
    }

    //.expandByScalar(0.9);//new THREE.Box3( new THREE.Vector3(-boxSize / 2, -boxSize / 2, -boxSize / 2), new THREE.Vector3(boxSize / 2, boxSize / 2, boxSize / 2));
    //_applyBoxUV( bufferGeometry, transformMatrix, uvBbox, boxSize );

    let uvBbox = new Box3(new Vector3(-boxSize / 2, -boxSize / 2, -boxSize / 2), new Vector3(boxSize / 2, boxSize / 2, boxSize / 2));
    //let uvBbox = new Box3(new Vector3(-(boxSize / 2)/3, -(boxSize / 2)/3, -(boxSize / 2)/3), new Vector3((boxSize / 2)/3, (boxSize / 2)/3, (boxSize / 2)/3));
    //let uvBbox = bbox
    


    let coords = [];
    //coords.length = 2 * geometry.attributes.position.array.length / 3;
    coords.length = 2 * geometry.attributes.position.count;

    //if ( geometry.attributes.uv === undefined ) geometry.addAttribute('uv', new Float32BufferAttribute(coords, 2));
    if ( geometry.attributes.uv === undefined ) geometry.setAttribute('uv', new Float32BufferAttribute(coords, 2));
    
    let makeSphereUVs = function( v0, v1, v2 ) {

        //pre-rotate the model so that cube sides match world axis
        v0.applyMatrix4(transformMatrix);
        v1.applyMatrix4(transformMatrix);
        v2.applyMatrix4(transformMatrix);

        let invTwoPi = 1 / (2.0 * Math.PI);
        let invPi = 1 / Math.PI;

        v0.normalize();
        v1.normalize();
        v2.normalize();

        return {
            uv0: new Vector2( .5 - Math.atan( v0.z, - v0.x ) * invTwoPi, .5 - Math.asin( v0.y ) * invPi ),
            uv1: new Vector2( .5 - Math.atan( v1.z, - v1.x ) * invTwoPi, .5 - Math.asin( v1.y ) * invPi ),
            uv2: new Vector2( .5 - Math.atan( v2.z, - v2.x ) * invTwoPi, .5 - Math.asin( v2.y ) * invPi ),
        };

    };


  
    //maps 3 verts of 1 face on the better side of the cube
    //side of the cube can be XY, XZ or YZ
    let makeCubeUVs = function( v0, v1, v2 ) {

        //pre-rotate the model so that cube sides match world axis
        v0.applyMatrix4(transformMatrix);
        v1.applyMatrix4(transformMatrix);
        v2.applyMatrix4(transformMatrix);

        //get normal of the face, to know into which cube side it maps better
        let n = new Vector3();
        n.crossVectors( v1.clone().sub(v0), v1.clone().sub(v2) ).normalize();
        if(n.x<0 || n.y<0 || n.z<0) ;

        n.x = Math.abs(n.x);
        n.y = Math.abs(n.y);
        n.z = Math.abs(n.z);

        let uv0 = new Vector2();
        let uv1 = new Vector2();
        let uv2 = new Vector2();
        let max = 1/boxSize;

        
        // xz mapping
        if ( n.y > n.x && n.y > n.z ) {

            uv0.set( v0.x - uvBbox.min.x, uvBbox.max.z - v0.z ).multiplyScalar( max );
            uv1.set( v1.x - uvBbox.min.x, uvBbox.max.z - v1.z ).multiplyScalar( max );
            uv2.set( v2.x - uvBbox.min.x, uvBbox.max.z - v2.z ).multiplyScalar( max );

        } else if ( n.x > n.y && n.x > n.z ) {

            uv0.set( v0.z - uvBbox.min.z, v0.y - uvBbox.min.y ).multiplyScalar( max );
            uv1.set( v1.z - uvBbox.min.z, v1.y - uvBbox.min.y ).multiplyScalar( max );
            uv2.set( v2.z - uvBbox.min.z, v2.y - uvBbox.min.y ).multiplyScalar( max );

        } else if ( n.z > n.y && n.z > n.x ) {

            uv0.set( v0.x - uvBbox.min.x, v0.y - uvBbox.min.y ).multiplyScalar( max );
            uv1.set( v1.x - uvBbox.min.x, v1.y - uvBbox.min.y ).multiplyScalar( max );
            uv2.set( v2.x - uvBbox.min.x, v2.y - uvBbox.min.y ).multiplyScalar( max );

        }

        return { uv0: uv0, uv1: uv1, uv2: uv2 } 
    };



    let i, id0, id1, id2, uvs;
    let v0 = new Vector3();
    let v1 = new Vector3();
    let v2 = new Vector3();

    new Vector3();
    new Vector3();
    new Vector3();

    const positionAttribute = geometry.getAttribute( 'position' );
    geometry.getAttribute( 'normal' );

    if ( geometry.index ) { // is it indexed buffer geometry

        for (i = 0; i < geometry.index.count; i+=3 ) {

            //console.log('is index')

            //n = i*3;
            id0 = geometry.index.getX( i + 0 );
            id1 = geometry.index.getX( i + 1 );
            id2 = geometry.index.getX( i + 2 );

            v0.fromBufferAttribute( positionAttribute, id0 );
            v1.fromBufferAttribute( positionAttribute, id1 );
            v2.fromBufferAttribute( positionAttribute, id2 );

            /*nn0.fromBufferAttribute( normalAttribute, id0 );
            nn1.fromBufferAttribute( normalAttribute, id1 );
            nn2.fromBufferAttribute( normalAttribute, id2 )*/



            if( type === 'sphere' ) uvs = makeSphereUVs( v0, v1, v2 );
            else uvs = makeCubeUVs( v0, v1, v2);

            coords[2 * id0] = uvs.uv0.x;
            coords[2 * id0 + 1] = uvs.uv0.y;

            coords[2 * id1] = uvs.uv1.x;
            coords[2 * id1 + 1] = uvs.uv1.y;

            coords[2 * id2] = uvs.uv2.x;
            coords[2 * id2 + 1] = uvs.uv2.y;
        }
    } else {

        for ( i = 0; i < positionAttribute.count; i += 3) {

            v0.fromBufferAttribute( positionAttribute, i + 0 );
            v1.fromBufferAttribute( positionAttribute, i + 1 );
            v2.fromBufferAttribute( positionAttribute, i + 2 );

            if( type === 'sphere' ) uvs = makeSphereUVs( v0, v1, v2 );
            else uvs = makeCubeUVs( v0, v1, v2 );

            let idx0 = i;//vi / 3;
            let idx1 = i+1;//idx0 + 1;
            let idx2 = i+2;//idx0 + 2;

            coords[2 * idx0] = uvs.uv0.x;
            coords[2 * idx0 + 1] = uvs.uv0.y;

            coords[2 * idx1] = uvs.uv1.x;
            coords[2 * idx1 + 1] = uvs.uv1.y;

            coords[2 * idx2] = uvs.uv2.x;
            coords[2 * idx2 + 1] = uvs.uv2.y;
        }

    }

    geometry.attributes.uv.array = new Float32Array( coords );
    geometry.attributes.uv.needsUpdate = true;

}


/*
export function calcNormal( normals, normal, angle ){

    let allowed = normals.filter( n => n.angleTo( normal ) < angle * Math.PI / 180 );
    return allowed.reduce( (a, b) => a.clone().add( b ) ).normalize();

}

export function computeVertexNormals(geometry, angle){

    geometry.computeFaceNormals();
    
    var vertices = geometry.vertices.map( () => [] ); // vertices with normals array

    geometry.faces.map( face => {
        vertices[ face.a ].push( face.normal );
        vertices[ face.b ].push( face.normal );
        vertices[ face.c ].push( face.normal );
    });

    geometry.faces.map( face => {
        face.vertexNormals[ 0 ] = calcNormal( vertices[ face.a ], face.normal, angle );
        face.vertexNormals[ 1 ] = calcNormal( vertices[ face.b ], face.normal, angle );
        face.vertexNormals[ 2 ] = calcNormal( vertices[ face.c ], face.normal, angle );
    });

    if ( geometry.faces.length > 0 ) geometry.normalsNeedUpdate = true;

}*/

/*

BufferGeometry.prototype.computeMorphFaceNormals = function () {

        var i, il, f, fl, face;

        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

            face = this.faces[ f ];

            if ( ! face.__originalFaceNormal ) {

                face.__originalFaceNormal = face.normal.clone();

            } else {

                face.__originalFaceNormal.copy( face.normal );

            }

        }

        // use temp geometry to compute face normals for each morph

        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;

        for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

            // create on first access

            if ( ! this.morphNormals[ i ] ) {

                this.morphNormals[ i ] = {};
                this.morphNormals[ i ].faceNormals = [];

                var dstNormalsFace = this.morphNormals[ i ].faceNormals;

                var faceNormal;

                for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                    faceNormal = new Vector3();

                    dstNormalsFace.push( faceNormal );

                }

            }

            var morphNormals = this.morphNormals[ i ];

            // set vertices to morph target

            tmpGeo.vertices = this.morphTargets[ i ].vertices;

            // compute morph normals

            tmpGeo.computeFaceNormals();

            // store morph normals

            var faceNormal;

            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                face = this.faces[ f ];

                faceNormal = morphNormals.faceNormals[ f ];

                faceNormal.copy( face.normal );
            }

        }

        // restore original normals

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

            face = this.faces[ f ];

            face.normal = face.__originalFaceNormal;

        }

    }
    */

/**
 * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)
 */

const Visible = 0;
const Deleted = 1;

const _v1$1 = new Vector3();
const _line3 = new Line3();
const _plane = new Plane();
const _closestPoint = new Vector3();
const _triangle = new Triangle();

class ConvexHull {

	constructor() {

		this.tolerance = -1;

		this.faces = []; // the generated faces of the convex hull
		this.newFaces = []; // this array holds the faces that are generated within a single iteration

		// the vertex lists work as follows:
		//
		// let 'a' and 'b' be 'Face' instances
		// let 'v' be points wrapped as instance of 'Vertex'
		//
		//     [v, v, ..., v, v, v, ...]
		//      ^             ^
		//      |             |
		//  a.outside     b.outside
		//
		this.assigned = new VertexList();
		this.unassigned = new VertexList();

		this.vertices = []; 	// vertices of the hull (internal representation of given geometry data)

	}

	setFromPoints( points ) {

		// The algorithm needs at least four points.

		if ( points.length >= 4 ) {

			this.makeEmpty();

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				this.vertices.push( new VertexNode( points[ i ] ) );

			}

			this.compute();

		}

		return this;

	}

	setFromObject( object ) {

		const points = [];

		object.updateMatrixWorld( true );

		object.traverse( function ( node ) {

			const geometry = node.geometry;

			if ( geometry !== undefined ) {

				const attribute = geometry.attributes.position;

				if ( attribute !== undefined ) {

					for ( let i = 0, l = attribute.count; i < l; i ++ ) {

						const point = new Vector3();

						point.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

						points.push( point );

					}

				}

			}

		} );

		return this.setFromPoints( points );

	}

	containsPoint( point ) {

		const faces = this.faces;

		for ( let i = 0, l = faces.length; i < l; i ++ ) {

			const face = faces[ i ];

			// compute signed distance and check on what half space the point lies

			if ( face.distanceToPoint( point ) > this.tolerance ) return false;

		}

		return true;

	}

	intersectRay( ray, target ) {

		// based on "Fast Ray-Convex Polyhedron Intersection" by Eric Haines, GRAPHICS GEMS II

		const faces = this.faces;

		let tNear = - Infinity;
		let tFar = Infinity;

		for ( let i = 0, l = faces.length; i < l; i ++ ) {

			const face = faces[ i ];

			// interpret faces as planes for the further computation

			const vN = face.distanceToPoint( ray.origin );
			const vD = face.normal.dot( ray.direction );

			// if the origin is on the positive side of a plane (so the plane can "see" the origin) and
			// the ray is turned away or parallel to the plane, there is no intersection

			if ( vN > 0 && vD >= 0 ) return null;

			// compute the distance from the ray’s origin to the intersection with the plane

			const t = ( vD !== 0 ) ? ( - vN / vD ) : 0;

			// only proceed if the distance is positive. a negative distance means the intersection point
			// lies "behind" the origin

			if ( t <= 0 ) continue;

			// now categorized plane as front-facing or back-facing

			if ( vD > 0 ) {

				// plane faces away from the ray, so this plane is a back-face

				tFar = Math.min( t, tFar );

			} else {

				// front-face

				tNear = Math.max( t, tNear );

			}

			if ( tNear > tFar ) {

				// if tNear ever is greater than tFar, the ray must miss the convex hull

				return null;

			}

		}

		// evaluate intersection point

		// always try tNear first since its the closer intersection point

		if ( tNear !== - Infinity ) {

			ray.at( tNear, target );

		} else {

			ray.at( tFar, target );

		}

		return target;

	}

	intersectsRay( ray ) {

		return this.intersectRay( ray, _v1$1 ) !== null;

	}

	makeEmpty() {

		this.faces = [];
		this.vertices = [];

		return this;

	}

	// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face

	addVertexToFace( vertex, face ) {

		vertex.face = face;

		if ( face.outside === null ) {

			this.assigned.append( vertex );

		} else {

			this.assigned.insertBefore( face.outside, vertex );

		}

		face.outside = vertex;

		return this;

	}

	// Removes a vertex from the 'assigned' list of vertices and from the given face

	removeVertexFromFace( vertex, face ) {

		if ( vertex === face.outside ) {

			// fix face.outside link

			if ( vertex.next !== null && vertex.next.face === face ) {

				// face has at least 2 outside vertices, move the 'outside' reference

				face.outside = vertex.next;

			} else {

				// vertex was the only outside vertex that face had

				face.outside = null;

			}

		}

		this.assigned.remove( vertex );

		return this;

	}

	// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list

	removeAllVerticesFromFace( face ) {

		if ( face.outside !== null ) {

			// reference to the first and last vertex of this face

			const start = face.outside;
			let end = face.outside;

			while ( end.next !== null && end.next.face === face ) {

				end = end.next;

			}

			this.assigned.removeSubList( start, end );

			// fix references

			start.prev = end.next = null;
			face.outside = null;

			return start;

		}

	}

	// Removes all the visible vertices that 'face' is able to see

	deleteFaceVertices( face, absorbingFace ) {

		const faceVertices = this.removeAllVerticesFromFace( face );

		if ( faceVertices !== undefined ) {

			if ( absorbingFace === undefined ) {

				// mark the vertices to be reassigned to some other face

				this.unassigned.appendChain( faceVertices );


			} else {

				// if there's an absorbing face try to assign as many vertices as possible to it

				let vertex = faceVertices;

				do {

					// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference
					// will be changed by upcoming method calls

					const nextVertex = vertex.next;

					const distance = absorbingFace.distanceToPoint( vertex.point );

					// check if 'vertex' is able to see 'absorbingFace'

					if ( distance > this.tolerance ) {

						this.addVertexToFace( vertex, absorbingFace );

					} else {

						this.unassigned.append( vertex );

					}

					// now assign next vertex

					vertex = nextVertex;

				} while ( vertex !== null );

			}

		}

		return this;

	}

	// Reassigns as many vertices as possible from the unassigned list to the new faces

	resolveUnassignedPoints( newFaces ) {

		if ( this.unassigned.isEmpty() === false ) {

			let vertex = this.unassigned.first();

			do {

				// buffer 'next' reference, see .deleteFaceVertices()

				const nextVertex = vertex.next;

				let maxDistance = this.tolerance;

				let maxFace = null;

				for ( let i = 0; i < newFaces.length; i ++ ) {

					const face = newFaces[ i ];

					if ( face.mark === Visible ) {

						const distance = face.distanceToPoint( vertex.point );

						if ( distance > maxDistance ) {

							maxDistance = distance;
							maxFace = face;

						}

						if ( maxDistance > 1000 * this.tolerance ) break;

					}

				}

				// 'maxFace' can be null e.g. if there are identical vertices

				if ( maxFace !== null ) {

					this.addVertexToFace( vertex, maxFace );

				}

				vertex = nextVertex;

			} while ( vertex !== null );

		}

		return this;

	}

	// Computes the extremes of a simplex which will be the initial hull

	computeExtremes() {

		const min = new Vector3();
		const max = new Vector3();

		const minVertices = [];
		const maxVertices = [];

		// initially assume that the first vertex is the min/max

		for ( let i = 0; i < 3; i ++ ) {

			minVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];

		}

		min.copy( this.vertices[ 0 ].point );
		max.copy( this.vertices[ 0 ].point );

		// compute the min/max vertex on all six directions

		for ( let i = 0, l = this.vertices.length; i < l; i ++ ) {

			const vertex = this.vertices[ i ];
			const point = vertex.point;

			// update the min coordinates

			for ( let j = 0; j < 3; j ++ ) {

				if ( point.getComponent( j ) < min.getComponent( j ) ) {

					min.setComponent( j, point.getComponent( j ) );
					minVertices[ j ] = vertex;

				}

			}

			// update the max coordinates

			for ( let j = 0; j < 3; j ++ ) {

				if ( point.getComponent( j ) > max.getComponent( j ) ) {

					max.setComponent( j, point.getComponent( j ) );
					maxVertices[ j ] = vertex;

				}

			}

		}

		// use min/max vectors to compute an optimal epsilon

		this.tolerance = 3 * Number.EPSILON * (
			Math.max( Math.abs( min.x ), Math.abs( max.x ) ) +
			Math.max( Math.abs( min.y ), Math.abs( max.y ) ) +
			Math.max( Math.abs( min.z ), Math.abs( max.z ) )
		);

		return { min: minVertices, max: maxVertices };

	}

	// Computes the initial simplex assigning to its faces all the points
	// that are candidates to form part of the hull

	computeInitialHull() {

		const vertices = this.vertices;
		const extremes = this.computeExtremes();
		const min = extremes.min;
		const max = extremes.max;

		// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation
		// (max.x - min.x)
		// (max.y - min.y)
		// (max.z - min.z)

		let maxDistance = 0;
		let index = 0;

		for ( let i = 0; i < 3; i ++ ) {

			const distance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );

			if ( distance > maxDistance ) {

				maxDistance = distance;
				index = i;

			}

		}

		const v0 = min[ index ];
		const v1 = max[ index ];
		let v2;
		let v3;

		// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'

		maxDistance = 0;
		_line3.set( v0.point, v1.point );

		for ( let i = 0, l = this.vertices.length; i < l; i ++ ) {

			const vertex = vertices[ i ];

			if ( vertex !== v0 && vertex !== v1 ) {

				_line3.closestPointToPoint( vertex.point, true, _closestPoint );

				const distance = _closestPoint.distanceToSquared( vertex.point );

				if ( distance > maxDistance ) {

					maxDistance = distance;
					v2 = vertex;

				}

			}

		}

		// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'

		maxDistance = -1;
		_plane.setFromCoplanarPoints( v0.point, v1.point, v2.point );

		for ( let i = 0, l = this.vertices.length; i < l; i ++ ) {

			const vertex = vertices[ i ];

			if ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {

				const distance = Math.abs( _plane.distanceToPoint( vertex.point ) );

				if ( distance > maxDistance ) {

					maxDistance = distance;
					v3 = vertex;

				}

			}

		}

		const faces = [];

		if ( _plane.distanceToPoint( v3.point ) < 0 ) {

			// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron

			faces.push(
				Face.create( v0, v1, v2 ),
				Face.create( v3, v1, v0 ),
				Face.create( v3, v2, v1 ),
				Face.create( v3, v0, v2 )
			);

			// set the twin edge

			for ( let i = 0; i < 3; i ++ ) {

				const j = ( i + 1 ) % 3;

				// join face[ i ] i > 0, with the first face

				faces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );

				// join face[ i ] with face[ i + 1 ], 1 <= i <= 3

				faces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );

			}

		} else {

			// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron

			faces.push(
				Face.create( v0, v2, v1 ),
				Face.create( v3, v0, v1 ),
				Face.create( v3, v1, v2 ),
				Face.create( v3, v2, v0 )
			);

			// set the twin edge

			for ( let i = 0; i < 3; i ++ ) {

				const j = ( i + 1 ) % 3;

				// join face[ i ] i > 0, with the first face

				faces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );

				// join face[ i ] with face[ i + 1 ]

				faces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );

			}

		}

		// the initial hull is the tetrahedron

		for ( let i = 0; i < 4; i ++ ) {

			this.faces.push( faces[ i ] );

		}

		// initial assignment of vertices to the faces of the tetrahedron

		for ( let i = 0, l = vertices.length; i < l; i ++ ) {

			const vertex = vertices[ i ];

			if ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {

				maxDistance = this.tolerance;
				let maxFace = null;

				for ( let j = 0; j < 4; j ++ ) {

					const distance = this.faces[ j ].distanceToPoint( vertex.point );

					if ( distance > maxDistance ) {

						maxDistance = distance;
						maxFace = this.faces[ j ];

					}

				}

				if ( maxFace !== null ) {

					this.addVertexToFace( vertex, maxFace );

				}

			}

		}

		return this;

	}

	// Removes inactive faces

	reindexFaces() {

		const activeFaces = [];

		for ( let i = 0; i < this.faces.length; i ++ ) {

			const face = this.faces[ i ];

			if ( face.mark === Visible ) {

				activeFaces.push( face );

			}

		}

		this.faces = activeFaces;

		return this;

	}

	// Finds the next vertex to create faces with the current hull

	nextVertexToAdd() {

		// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'

		if ( this.assigned.isEmpty() === false ) {

			let eyeVertex, maxDistance = 0;

			// grap the first available face and start with the first visible vertex of that face

			const eyeFace = this.assigned.first().face;
			let vertex = eyeFace.outside;

			// now calculate the farthest vertex that face can see

			do {

				const distance = eyeFace.distanceToPoint( vertex.point );

				if ( distance > maxDistance ) {

					maxDistance = distance;
					eyeVertex = vertex;

				}

				vertex = vertex.next;

			} while ( vertex !== null && vertex.face === eyeFace );

			return eyeVertex;

		}

	}

	// Computes a chain of half edges in CCW order called the 'horizon'.
	// For an edge to be part of the horizon it must join a face that can see
	// 'eyePoint' and a face that cannot see 'eyePoint'.

	computeHorizon( eyePoint, crossEdge, face, horizon ) {

		// moves face's vertices to the 'unassigned' vertex list

		this.deleteFaceVertices( face );

		face.mark = Deleted;

		let edge;

		if ( crossEdge === null ) {

			edge = crossEdge = face.getEdge( 0 );

		} else {

			// start from the next edge since 'crossEdge' was already analyzed
			// (actually 'crossEdge.twin' was the edge who called this method recursively)

			edge = crossEdge.next;

		}

		do {

			const twinEdge = edge.twin;
			const oppositeFace = twinEdge.face;

			if ( oppositeFace.mark === Visible ) {

				if ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {

					// the opposite face can see the vertex, so proceed with next edge

					this.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );

				} else {

					// the opposite face can't see the vertex, so this edge is part of the horizon

					horizon.push( edge );

				}

			}

			edge = edge.next;

		} while ( edge !== crossEdge );

		return this;

	}

	// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order

	addAdjoiningFace( eyeVertex, horizonEdge ) {

		// all the half edges are created in ccw order thus the face is always pointing outside the hull

		const face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );

		this.faces.push( face );

		// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )

		face.getEdge( -1 ).setTwin( horizonEdge.twin );

		return face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex


	}

	//  Adds 'horizon.length' faces to the hull, each face will be linked with the
	//  horizon opposite face and the face on the left/right

	addNewFaces( eyeVertex, horizon ) {

		this.newFaces = [];

		let firstSideEdge = null;
		let previousSideEdge = null;

		for ( let i = 0; i < horizon.length; i ++ ) {

			const horizonEdge = horizon[ i ];

			// returns the right side edge

			const sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );

			if ( firstSideEdge === null ) {

				firstSideEdge = sideEdge;

			} else {

				// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )

				sideEdge.next.setTwin( previousSideEdge );

			}

			this.newFaces.push( sideEdge.face );
			previousSideEdge = sideEdge;

		}

		// perform final join of new faces

		firstSideEdge.next.setTwin( previousSideEdge );

		return this;

	}

	// Adds a vertex to the hull

	addVertexToHull( eyeVertex ) {

		const horizon = [];

		this.unassigned.clear();

		// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list

		this.removeVertexFromFace( eyeVertex, eyeVertex.face );

		this.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );

		this.addNewFaces( eyeVertex, horizon );

		// reassign 'unassigned' vertices to the new faces

		this.resolveUnassignedPoints( this.newFaces );

		return	this;

	}

	cleanup() {

		this.assigned.clear();
		this.unassigned.clear();
		this.newFaces = [];

		return this;

	}

	compute() {

		let vertex;

		this.computeInitialHull();

		// add all available vertices gradually to the hull

		while ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {

			this.addVertexToHull( vertex );

		}

		this.reindexFaces();

		this.cleanup();

		return this;

	}

}

//

class Face {

	constructor() {

		this.normal = new Vector3();
		this.midpoint = new Vector3();
		this.area = 0;

		this.constant = 0; // signed distance from face to the origin
		this.outside = null; // reference to a vertex in a vertex list this face can see
		this.mark = Visible;
		this.edge = null;

	}

	static create( a, b, c ) {

		const face = new Face();

		const e0 = new HalfEdge( a, face );
		const e1 = new HalfEdge( b, face );
		const e2 = new HalfEdge( c, face );

		// join edges

		e0.next = e2.prev = e1;
		e1.next = e0.prev = e2;
		e2.next = e1.prev = e0;

		// main half edge reference

		face.edge = e0;

		return face.compute();

	}

	getEdge( i ) {

		let edge = this.edge;

		while ( i > 0 ) {

			edge = edge.next;
			i --;

		}

		while ( i < 0 ) {

			edge = edge.prev;
			i ++;

		}

		return edge;

	}

	compute() {

		const a = this.edge.tail();
		const b = this.edge.head();
		const c = this.edge.next.head();

		_triangle.set( a.point, b.point, c.point );

		_triangle.getNormal( this.normal );
		_triangle.getMidpoint( this.midpoint );
		this.area = _triangle.getArea();

		this.constant = this.normal.dot( this.midpoint );

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) - this.constant;

	}

}

// Entity for a Doubly-Connected Edge List (DCEL).

class HalfEdge {


	constructor( vertex, face ) {

		this.vertex = vertex;
		this.prev = null;
		this.next = null;
		this.twin = null;
		this.face = face;

	}

	head() {

		return this.vertex;

	}

	tail() {

		return this.prev ? this.prev.vertex : null;

	}

	length() {

		const head = this.head();
		const tail = this.tail();

		if ( tail !== null ) {

			return tail.point.distanceTo( head.point );

		}

		return -1;

	}

	lengthSquared() {

		const head = this.head();
		const tail = this.tail();

		if ( tail !== null ) {

			return tail.point.distanceToSquared( head.point );

		}

		return -1;

	}

	setTwin( edge ) {

		this.twin = edge;
		edge.twin = this;

		return this;

	}

}

// A vertex as a double linked list node.

class VertexNode {

	constructor( point ) {

		this.point = point;
		this.prev = null;
		this.next = null;
		this.face = null; // the face that is able to see this vertex

	}

}

// A double linked list that contains vertex nodes.

class VertexList {

	constructor() {

		this.head = null;
		this.tail = null;

	}

	first() {

		return this.head;

	}

	last() {

		return this.tail;

	}

	clear() {

		this.head = this.tail = null;

		return this;

	}

	// Inserts a vertex before the target vertex

	insertBefore( target, vertex ) {

		vertex.prev = target.prev;
		vertex.next = target;

		if ( vertex.prev === null ) {

			this.head = vertex;

		} else {

			vertex.prev.next = vertex;

		}

		target.prev = vertex;

		return this;

	}

	// Inserts a vertex after the target vertex

	insertAfter( target, vertex ) {

		vertex.prev = target;
		vertex.next = target.next;

		if ( vertex.next === null ) {

			this.tail = vertex;

		} else {

			vertex.next.prev = vertex;

		}

		target.next = vertex;

		return this;

	}

	// Appends a vertex to the end of the linked list

	append( vertex ) {

		if ( this.head === null ) {

			this.head = vertex;

		} else {

			this.tail.next = vertex;

		}

		vertex.prev = this.tail;
		vertex.next = null; // the tail has no subsequent vertex

		this.tail = vertex;

		return this;

	}

	// Appends a chain of vertices where 'vertex' is the head.

	appendChain( vertex ) {

		if ( this.head === null ) {

			this.head = vertex;

		} else {

			this.tail.next = vertex;

		}

		vertex.prev = this.tail;

		// ensure that the 'tail' reference points to the last vertex of the chain

		while ( vertex.next !== null ) {

			vertex = vertex.next;

		}

		this.tail = vertex;

		return this;

	}

	// Removes a vertex from the linked list

	remove( vertex ) {

		if ( vertex.prev === null ) {

			this.head = vertex.next;

		} else {

			vertex.prev.next = vertex.next;

		}

		if ( vertex.next === null ) {

			this.tail = vertex.prev;

		} else {

			vertex.next.prev = vertex.prev;

		}

		return this;

	}

	// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b

	removeSubList( a, b ) {

		if ( a.prev === null ) {

			this.head = b.next;

		} else {

			a.prev.next = b.next;

		}

		if ( b.next === null ) {

			this.tail = a.prev;

		} else {

			b.next.prev = a.prev;

		}

		return this;

	}

	isEmpty() {

		return this.head === null;

	}

}

class ConvexGeometry extends BufferGeometry {

	constructor( points = [] ) {

		super();

		// buffers

		const vertices = [];
		const normals = [];

		const convexHull = new ConvexHull().setFromPoints( points );

		// generate vertices and normals

		const faces = convexHull.faces;

		for ( let i = 0; i < faces.length; i ++ ) {

			const face = faces[ i ];
			let edge = face.edge;

			// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)

			do {

				const point = edge.head().point;

				vertices.push( point.x, point.y, point.z );
				normals.push( face.normal.x, face.normal.y, face.normal.z );

				edge = edge.next;

			} while ( edge !== face.edge );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

	}

}

class CapsuleHelper extends Object3D {

	

	constructor( r, h, useDir, material, c1 = [0,1,0], c2 = [0,0.5,0], full = false ) {

		

		super();
		// TODO bug with hero skeleton !! create new CapsuleHelper on over ??
		if(!r) return
		if(!h) return

		

		const geometry = new BufferGeometry();

		let py = (h*0.5)-r;
		let side = 12;//32;
		let dir = r*0.2;


		let colors = [];

		const positions = [
		    r, py, 0 ,   r, -py, 0,
		    -r, py, 0 ,   -r, -py, 0,
		    0, py, r-dir ,   0, py, r+dir,
		];



		//console.log( r )

		colors.push(
			...c1,...c2,
			...c1,...c2,
			...c2,...c2
		);

		if(full){ 
			positions.push(
				0, py, r, 0, -py, r,
				0, py, -r, 0, -py, -r 
			);
			colors.push(
				...c1,...c2,
				...c1,...c2,
			);
		}


		// circle top / bottom

		for ( let i = 0, j = 1; i < side; i ++, j ++ ) {

			const p1 = ( i / side ) * Math.PI * 2;
			const p2 = ( j / side ) * Math.PI * 2;

			positions.push(
				r*Math.cos( p1 ), py, r*Math.sin( p1 ),
				r*Math.cos( p2 ), py, r*Math.sin( p2 ),

				r*Math.cos( p1 ), -py, r*Math.sin( p1 ),
				r*Math.cos( p2 ), -py, r*Math.sin( p2 ),
			);

			colors.push(
				...c1,...c1,
				...c2,...c2,
			);

		}

		// circle start / end

		for ( let i = 0, j = 1; i < side; i ++, j ++ ) {

			const p1 = ( i / side ) * Math.PI * 2;
			const p2 = ( j / side ) * Math.PI * 2;

			let s = j <= side*0.5 ? 1 : -1; 

			positions.push(
				r*Math.cos( p1 ), py*s + r*Math.sin( p1 ),0,
				r*Math.cos( p2 ), py*s + r*Math.sin( p2 ),0,
			);

			if(s===1) colors.push( ...c1,...c1 );
			else colors.push( ...c2,...c2 );

			if(full){
				positions.push(
					0, py*s + r*Math.sin( p1 ),r*Math.cos( p1 ),
					0, py*s + r*Math.sin( p2 ),r*Math.cos( p2 ),
				);
				if(s===1) colors.push( ...c1,...c1 );
			    else colors.push( ...c2,...c2 );
			}

		}

		//console.log( positions )

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		geometry.computeBoundingSphere();

		this.colors = geometry.attributes.color.array;
		this.colorsbase = [...this.colors];
		this.geometry = geometry;

		//const material = new LineBasicMaterial( { color:0x00ff00, fog: false, toneMapped: false } );


		
		this.cone = new LineSegments( geometry, material );
		this.cone.raycast = function(){return false };
		this.cone.updateMorphTargets = ()=>{};
		this.cone.name = 'cone';
		this.add( this.cone );

		this.isOver = false;
		this.matrixAutoUpdate = false;
		this.type = 'CapsuleHelper';

		if(!useDir) return

		const geometry2 = new BufferGeometry();

		const positions2 = [
		    dir*0.5, -py, r-dir ,   dir*0.5, -py, r+dir,
		    -dir*0.5, -py, r-dir ,   -dir*0.5, -py, r+dir,
		    dir*0.5, -py, r-dir,  -dir*0.5, -py, r-dir,

		    -dir*0.5, -py, r+dir , -dir, -py, r+dir ,
		    dir*0.5, -py, r+dir , dir, -py, r+dir ,

		    -dir, -py, r+dir , 0, -py, r+dir*2 ,
		    dir, -py, r+dir , 0, -py, r+dir*2 ,
		];

		colors = [];
		let cc = positions2.length/3;
		while(cc--){
			colors.push(1,0,0);
		}

		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );



		//const material2 = new LineBasicMaterial( { color:0xFF0000, fog: false, toneMapped: false } );

		this.direction = new LineSegments( geometry2, material );
		this.direction.raycast = function(){return false};
		this.add( this.direction );

	}

	over(b){

		if(b){
			if(!this.isOver){
				this.isOver = true;
				this.changeColor(this.isOver);
			}
		}else {
			if(this.isOver){
				this.isOver = false;
				this.changeColor(this.isOver);
		    }
		}
		

		//console.log('yo')

	}

	changeColor(b) {

		let i = this.colors.length;
		while(i--) this.colors[i] = b ? 1 : this.colorsbase[i];
		if( this.geometry ) this.geometry.attributes.color.needsUpdate = true;

	}

	setDirection(r) {

		if(!this.direction) return
		//this.rotation.y = r
		this.direction.rotation.y = r;

	}

	dispose() {

		this.geometry.dispose();

		this.cone.geometry.dispose();
		//this.cone.material.dispose();

		if(this.direction){
			this.direction.geometry.dispose();
			//this.direction.material.dispose();
		}

	}

	raycast(){
		return false
	}

	update() {

		/*this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector );*/

		/*if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}*/

	}

}

let Geo = null;
let Mat$2 = null;

// THREE BODY

class Body extends Item {

	constructor ( motor ) {

		super();

		this.motor = motor;
		this.engine = this.motor.engine;
		this.Utils = this.motor.utils;

		Geo = this.motor.geo;
		Mat$2 = this.motor.mat;

		this.type = 'body';
		this.num = Num[this.type];
		this.full = false;
		//this.extraConvex = false;
		this.needMatrix = this.engine ==='RAPIER' || this.engine ==='HAVOK';
		//this.tmpVolume = 0

	}

	setFull( full ){

		this.num = Num[ full ? 'bodyFull':'body' ];
		this.full = full;
		
	}

	step (AR, N) {

		const list = this.list;
		let i = list.length, b, n, vv;
		
		while( i-- ){

			b = list[i];

			if( b === null ) continue;

			n = N + ( i * this.num );

			// update only when physics actif buggy
			if( !b.actif ){
				// a = MathTool.nullArray( AR, n, this.num );
				//a = AR[n+0]+AR[n+1]+AR[n+2]+AR[n+3]+ AR[n+4]+AR[n+5]+AR[n+6]+AR[n+7];
				//if( a === 0 ) continue
				//if( MathTool.nullArray( AR, n, this.num ) === 0 ) continue;
				//else 
				b.actif = true;
			}

		    // test is object sleep
			b.sleep = AR[n] > 0 ? false : true;

			// update default material
	        if( b.defMat ){

	        	if( b.isInstance ){
	        		b.instance.setColorAt( b.id, b.sleep ? Colors.sleep : Colors.body );
	        	} else {
	        		if ( !b.sleep && b.material.name === 'sleep' ) b.material = Mat$2.get('body');
			        if ( b.sleep && b.material.name === 'body' ) b.material = Mat$2.get('sleep');
	        	}
			    
			}

			if( b.sleep && !b.isKinematic ) continue; 

			

			// update position / rotation

			b.position.fromArray( AR, n + 1 );
	        b.quaternion.fromArray( AR, n + 4 );

	        // update velocity

	        if( this.full ){
		        b.velocity.fromArray( AR, n + 8 );
		        b.angular.fromArray( AR, n + 11 );
		    } else {
	    		if( b.getVelocity ){
	    			vv = this.motor.reflow.velocity[b.name];
	    			if(vv){
	    				b.velocity.fromArray(vv, 0 );
	    				b.angular.fromArray(vv, 3 );
	    			}
	    		}
	    	}

	    	//

	    	if( b.isInstance ){ 
		    	if( b.speedMat ){ 
		    		//b.instance.setColorAt( b.id, [ Math.abs(AR[n+8])*0.5, Math.abs(AR[n+9])*0.5, Math.abs(AR[n+10])*0.5] );
		    		let v = AR[n]*0.01;///255; //MathTool.lengthArray([AR[n+8], AR[n+9], AR[n+10]]) * 0.062;
		    		b.instance.setColorAt( b.id, [ v,v,v ] );
		    	}
		    	b.instance.setTransformAt( b.id, [AR[n+1],AR[n+2],AR[n+3]], [AR[n+4],AR[n+5],AR[n+6],AR[n+7]], b.noScale ? [1,1,1] : b.size );
		    	if( this.needMatrix ) b.matrixWorld.compose( b.position, b.quaternion, {x:1, y:1, z:1}); 
		    	
		    }else { 

		        if( !b.auto ) b.updateMatrix();

		    }
		}

	}

	///

	geometry ( o = {}, b = null, material = null ) {

		let g, i, n, s = o.size, gName='';
		let t = o.type;
		let noScale = false, unic = false;
		let seg = o.seg || 16;

		const noIndex = this.engine === 'OIMO' || this.engine === 'JOLT' || this.engine === 'AMMO' || this.engine === 'CANNON';

		//if( o.instance && t!== 'capsule'&& !o.radius) s = o.instanceSize || [1,1,1]

		if( o.instance && t === 'compound'){ 
			t = o.shapes[0].type;
			s = o.shapes[0].size;
			o.translate = o.shapes[0].pos;
		}

		if( t==='mesh' || t==='convex' ){
			if( o.shape ){
				if( o.shape.isMesh ) o.shape = o.shape.geometry;
			} else {
				if( o.mesh && !o.v ) o.shape = o.mesh.geometry;
			}	
		}

		if( o.radius ){
			if( !o.breakable ){
				if( t === 'box' ) t = 'ChamferBox';
				if( t === 'cylinder' ) t = 'ChamferCyl';
			}
		}

		if( o.geometry ){
			if( t === 'convex' ) o.shape = o.geometry;
			else t = 'direct';
		} 


	    if( this.engine === 'PHYSX' && o.type==='cylinder' ){
			// convert geometry to convex if not in physics
	    	let geom = new CylinderGeometry( o.size[ 0 ], o.size[ 0 ], o.size[ 1 ], seg, 1 );//24
	    	if( o.isWheel ) geom.rotateZ( -PI90 );
	    	o.v = MathTool.getVertex( geom );
	    	o.type = 'convex';

	    }

	    if( ( this.engine === 'PHYSX' || this.engine === 'HAVOK' || this.engine === 'JOLT' ) && o.type==='cone' ){
	    	// convert geometry to convex if not in physics
	    	//if( !o.size[2] ) o.size[2] = 0;
	    	//console.log(o.size[2])
	    	let geom = new CylinderGeometry( 0, o.size[ 0 ], o.size[ 1 ], seg, 1 );//24

	    	//o.size[2] = o.size[0]
	    	o.v = MathTool.getVertex( geom );
	    	o.type = 'convex';

	    }

	    if( o.type==='stair' ){
	    	o.type = 'box';
	    	t = 'box';
	    }

		switch( t ){

			case 'direct':

			    g = o.geometry.clone();
			    if( o.size ) g.scale( o.size[0], o.size[1], o.size[2] );

			    unic = true;
			    noScale = true;

			break;

			case 'convex':

				if( o.v ){ 

					if( o.nogeo ) g = new BufferGeometry();
					else {
						let vv = [];
						i = Math.floor( o.v.length/3 );
						while( i-- ){
							n = i*3;
							vv.push( new Vector3( o.v[n], o.v[n+1], o.v[n+2] ) );
						}
						g = new ConvexGeometry( vv );
						//o.v = math.getVertex( g )
						//o.index = math.getIndex( g )
						//console.log(o.v, o.index)
					}
					unic = true;
					noScale = true;
				}

				if( o.shape ){

					g = o.shape.clone();
					if( o.size ) g.scale( o.size[0], o.size[0], o.size[0] );
					if( o.shapeScale ) g.scale( o.shapeScale[0], o.shapeScale[1], o.shapeScale[2] );

					let tg = noIndex ? MathTool.toNonIndexed(g) : null;
					o.v = MathTool.getVertex( tg || g, noIndex );
					o.index = MathTool.getIndex( tg || g, noIndex );
					if(this.engine === 'CANNON');

					unic = true;
					noScale = true;
				}

				if(!g.boundingBox) g.computeBoundingBox();
				let bx = g.boundingBox;
			    o.boxSize = [ -bx.min.x + bx.max.x, -bx.min.y + bx.max.y, -bx.min.z + bx.max.z ];

			break;

			case 'mesh':

				g = o.shape.clone();
				if( o.size ) g.scale( o.size[0], o.size[0], o.size[0] );
				
				o.v = MathTool.getVertex( g, noIndex );
				o.index = MathTool.getIndex( g, noIndex );
				
				
				unic = true;
				noScale = true;
			
			break;

			case 'customSphere':

			    gName = 'customSphere_' + s[ 0 ];

			    g = Geo.get( gName );
			    if(!g){
			    	g = new SphereGeometry( s[ 0 ], o.seg1 || 32, o.seg2 || 16 );
					g.name = gName;
			    } else {
					gName = '';
				}
			    noScale = true;
			    o.type = 'sphere';

			break;

			case 'highSphere':

			    gName = 'highSphere_' + s[ 0 ];

			    g = Geo.get( gName );
			    if(!g){
			    	g = new SphereBox( s[ 0 ] );
					g.name = gName;
			    } else {
					gName = '';
				}
			    noScale = true;
			    o.type = 'sphere';

			break;

			case 'capsule':

			    gName = 'capsule_' + s[ 0 ] +'_'+s[ 1 ] + '_' + seg; 

			    g = Geo.get( gName );
			    if(!g){
			    	//if( o.helper ) g = new CapsuleHelperGeometry( s[ 0 ], s[ 1 ] )
					//else 
					g = new Capsule( s[ 0 ], s[ 1 ], seg );
					g.name = gName;
				} else {
					gName = '';
				}
				noScale = true;
			break;

			case 'ChamferBox':

			    gName = 'ChamferBox_' + s[ 0 ] +'_'+ s[ 1 ] +'_'+ s[ 2 ] + '_' + o.radius; 

			    //console.log(s, o.radius)
			    g = Geo.get( gName );
			    if(!g){
					g = new ChamferBox( s[ 0 ], s[ 1 ], s[ 2 ], o.radius );
					g.name = gName;
				} else {
					gName = '';
				}
				noScale = true;
			break;

			case 'ChamferCyl':

			    gName = 'ChamferCyl_' + s[ 0 ] +'_'+ s[ 1 ] +'_'+ s[ 2 ] + '_' + o.radius + '_' + seg;

			    g = Geo.get( gName );
			    if(!g){
					g = new ChamferCyl( s[ 0 ], s[ 0 ], s[ 1 ], o.radius, seg );
					g.name = gName;
				} else {
					gName = '';
				}
				noScale = true;
			break;

			default:
			    if( !o.breakable ) g = Geo.get(t); //geo[ t ];
			    else {
			    	g = Geo.get(t).clone();
			    	g.scale( s[0], s[1], s[2] );
			    	unic = true;
			    	noScale = true;
			    }
			break;

		}


		if( o.translate ) g.translate( o.translate[0], o.translate[1], o.translate[2]);


		// clear untranspherable variable for phy
    	if( o.shape ) delete o.shape;
    	if( o.geometry ) delete o.geometry;


    	if ( g.attributes.uv === undefined || o.autoUV ){
				//console.log(o.shape)
				createUV(g, 'box', 5.0, o.pos, o.quat );
		}


    	// reuse complex geometry
    	if( gName !== '' ) Geo.set( g );

    	if( o.isWheel ){
    		g = g.clone();
    		g.rotateZ( -PI90 );
    		unic = true;
    	}
    	
    	// unic geometry dispose on reset 
    	if( unic ) Geo.unic(g);

    	


    	if( b === null && material === null ){
    		g.noScale = noScale; 
    		return g
    	}

    	if( o.meshRemplace && o.debug ) material = Mat$2.get( 'debug' );
    	//if( o.debug ) material = Mat.get( 'debug' )
    	//if( o.helper ) material = Mat.get( 'hide' )

    	//if( o.instance ) return

    	//console.log( material.name )

		let m = new Mesh( g, material );

		if( o.button ) m.isButton = true;

		//if( o.helper ) m.add( new LineSegments( new CapsuleHelperGeometry( s[ 0 ], s[ 1 ] ),  Mat.get( 'line' ) ))
		if( o.helper ) {

			let hcolor = o.hcolor || [0.3,0.1,0.0];
			let hcolor2 = o.hcolor2 || [0.8,0.2,0.0];

			// TODO bug with character
			let hh = new CapsuleHelper( s[ 0 ], s[ 1 ]+(s[ 0 ]*2), false, Mat$2.get( 'liner' ), hcolor, hcolor2, true );
			m.add( hh );
			m.userData['helper'] = hh;

		}

		if( o.localRot ) o.localQuat = MathTool.quatFromEuler(o.localRot); //math.toQuatArray( o.localRot )
		if( o.localPos ) m.position.fromArray( o.localPos );
		if( o.localQuat ) m.quaternion.fromArray( o.localQuat );

    	if( !noScale ) m.scale.fromArray( o.size );
    	//if( unic ) m.unic = true

    	// disable raycast
    	if(o.ray !== undefined){
    		if( !o.ray ) m.raycast = () => {return};
    	}

    	// add or not add
    	if( !o.meshRemplace || o.debug ){ 
    		b.add( m );
    		if(m.userData.helper) b.over = (b)=>{ m.userData.helper.over(b); };
    	}

	}

	add ( o = {} ) {

		if(o.worldScale){
			o = this.scaler( o, o.worldScale );
			delete o.worldScale;
		}

		//this.tmpVolume = 0

		//console.log('add', o.type )

		let i, n, name, volume = 0;

		if( !o.instance ) name = this.setName( o );

		o.type = o.type === undefined ? 'box' : o.type;

		if( o.type === 'plane' && !o.visible ) o.visible = false;

		if( o.type === 'stair'){ 

			let v1 = new Vector3(0,0,o.size[2]);
			let v2 = new Vector3(0, o.size[1]*0.5,o.size[2]*0.5);
			let angle = v1.angleTo(v2);
			let dist = v1.distanceTo(v2);
			o.rot = [angle * todeg$1,0,0];
			o.size[1] *= o.div || 0.2;
			o.size[2] = dist*2;
		
		    let p1 = new Vector3(0,-o.size[1]*0.5,0);
		    p1.applyAxisAngle({x:1, y:0, z:0}, angle);
			o.pos[1] += p1.y;
			o.pos[2] += p1.z;

		}


		// change default center of mass 
		// if engine don't have massCenter option
		// is convert to compound
		
		if( o.massCenter && !WithMassCenter.indexOf(this.engine) ){
			if( o.type !== 'compound' ){
				//o.localPos = o.massCenter
				o.shapes = [{ type:o.type, pos:o.massCenter, size:o.size }];
				if( o.seg ) o.shapes[0].seg = o.seg;
				if( o.radius ) o.shapes[0].radius = o.radius;
				delete o.size; // ?? TODO
				o.type = 'compound';
			} else {
				for ( i = 0; i < o.shapes.length; i ++ ) {
					n = o.shapes[ i ];
					if( n.pos ) n.pos = MathTool.addArray( n.pos, o.massCenter );
					else n.pos = o.massCenter;
					//Geo.unic(n);
				}
			}
		}

		if( o.collision !== undefined ){
			if(o.collision === false){
				if( this.engine === 'PHYSX' ) o.flags = 0;
				if( this.engine === 'OIMO' ) o.mask = 0;
				//o.mask = 0
			}
			
		}

		//----------------------------
		//  Position, Rotation, Size
		//----------------------------

		o.pos = o.pos === undefined ? [ 0, 0, 0 ] : o.pos;

		// rotation is in degree or Quaternion
	    o.quat = o.quat === undefined ? [ 0, 0, 0, 1 ] : o.quat;
	    // convert euler degree to Quaternion
	    if( o.rot !== undefined ) o.quat = MathTool.quatFromEuler(o.rot);
	    if( o.meshRot !== undefined ) o.meshQuat = MathTool.quatFromEuler(o.meshRot);

	    //o.size = o.size == undefined ? [ 1, 1, 1 ] : math.correctSize( o.size );
	    o.size = MathTool.autoSize( o.size, o.type );
	    if( o.meshScale ) o.meshScale = MathTool.autoSize( o.meshScale );


	    //--------------------
		//  Material
		//--------------------

	    let material, noMat = false;

	    if( o.visible === false ) o.material = 'hide';

	    if ( o.material !== undefined ) {
	    	if ( o.material.constructor === String ) material = Mat$2.get( o.material );
	    	else material = o.material;
	    } else {
	    	noMat = true;
	    	//defMat = this.type === 'body'
	    	material = Mat$2.get( this.type );
	    	if( o.instance ) material = Mat$2.get( 'base' );
	    }

	    if( o.unicMat ) {
	    	material = material.clone();
	    	Mat$2.addToTmp( material );
	    }


	    //--------------------
		//  Define Object
		//--------------------

	    let b = o.instance ? {} : new Basic3D();

	    if( o.mesh && !o.instance ){

	    	//if( o.isTerrain ) o.noClone = true
	    	if( o.mesh.type === 'terrain' ) o.noClone = true;

	    	let mm = o.noClone ? o.mesh : o.mesh.clone();

	    	mm.position.fromArray( o.meshPos || [0,0,0]);
	    	//if( o.meshRot ) { o.meshQuat = MathTool.quatFromEuler(o.meshRot); delete o.meshRot; }
	    	if( o.meshQuat ) mm.quaternion.fromArray( o.meshQuat );
	    	if( o.meshSize ) mm.scale.set(1,1,1).multiplyScalar(o.meshSize);
	    	if( o.meshScale ) mm.scale.fromArray( o.meshScale );
	    	
	    	if( !noMat ){ 
	    		mm.material = material;
	    		if(mm.children && !o.nofullmat ) for(let k in mm.children) mm.children[k].material = material;
	    	}

	    	this.motor.tmpMesh.push(mm);

	    	o.meshRemplace = true;
	    	b.add( mm );

	    }

	    //--------------------
		//  Define Geometry
		//--------------------

	    switch( o.type ){

	    	case 'null': break;

	    	case 'compound':

	    	    for ( i = 0; i < o.shapes.length; i ++ ) {

					n = o.shapes[ i ];

					n.type = n.type === undefined ? 'box' : n.type;
					//n.size = n.size === undefined ? [ 1, 1, 1 ] : math.correctSize( n.size );
					n.size = MathTool.autoSize( n.size, n.type );

					if( n.pos ) n.localPos = n.pos;
					if( n.rot !== undefined ) n.quat = MathTool.quatFromEuler(n.rot);
					if( n.quat ) n.localQuat = n.quat;
					
					n.debug = o.debug;
					n.meshRemplace = o.meshRemplace || false;

					if( !o.instance ) this.geometry( n, b, material );
					else if( n.type === 'convex' ){ 
				    	n.v = MathTool.getVertex( n.shape, false );
				    }
					volume += MathTool.getVolume( n.type, n.size, n.v );
					//console.log(n.type, n.size)

				}

				//console.log(volume, name)

	    	break;
	    	default:

			    if( !o.instance ) this.geometry( o, b, material );
			    // TODO fix that 
			    else if( o.type === 'convex' ){ 
			    	o.v = MathTool.getVertex( o.shape, false );
			    }
			    // TODO bug with instance !!!
			    //else o.size = MathTool.autoSize( o.size, o.type );
			    volume = MathTool.getVolume( o.type, o.size, o.v );

			break;

	    }



	    
	    b.type = this.type;
	    b.size = o.size;
		b.shapetype = o.type;
		b.isKinematic = o.kinematic || false;
		b.link = 0;

		b.meshSize = o.meshSize ? o.meshSize : 1;


		

		// for buttton only
		if( o.button ) b.isButton = true;

	    // enable or disable raycast
	    b.isRay = true;//b.type === 'body' || b.isButton ? true : false
	    //if( o.ray !== undefined ) b.isRay = o.ray; 
	    if( o.ray !== undefined ) b.setRaycast( o.ray );
	    if( !o.instance ) b.setRaycast();


	    // NO NEED ??
		//if( !noMat ) b.material = material
		b.defMat = false;
		
		if( b.material && noMat ) b.defMat = b.material.name === 'body';


	    //--------------------
		//  Instance
		//--------------------

		if( o.instance ){ 

			b.isInstance = true;
			b.instance = this.getInstance( o, material );
			b.instance.isRay = b.isRay;

			b.over = b.instance.over;
			b.isRay = false;
			b.isOver = false;

			b.speedMat = o.speedMat || false;

			b.defMat = b.instance.material.name === 'base';
			
			b.id = b.instance.count;
			//b.unicId = MathUtils.generateUUID();

			//b.mass = o.mass || 0

			//b.refName = b.instance.name + b.id;
			b.name = o.name ? o.name : b.instance.name + b.id;
			o.name = b.name;

			b.noScale = b.instance.noScale;//false//o.type!=='box' || o.type!=='ChamferBox' || o.type!=='sphere';
			if(o.sizeByInstance) b.noScale = false;
			//if(o.type === 'sphere') b.noScale = false
		    //if( o.type === 'capsule' ) b.noScale = true
		    //if( o.type === 'box' ) b.noScale = true
			//if(o.radius) b.noScale = true

			let color = o.color;
			if( b.defMat ) color = o.sleep ? Colors.sleep : Colors.body;

			b.instance.add( b, o.pos, o.quat, b.noScale ? [1,1,1] : b.size, color );

			b.position = new Vector3().fromArray(o.pos); //{x:o.pos[0], y:o.pos[1], z:o.pos[2]};
			b.quaternion = new Quaternion().fromArray(o.quat); //{_x:o.quat[0], _y:o.quat[1], _z:o.quat[2], _w:o.quat[3]};
		    b.velocity = new Vector3(); //{x:0, y:0, z:0};
		    b.angular = new Vector3(); //{x:0, y:0, z:0};
		    //b.link = 0;
		    if( this.needMatrix ) b.matrixWorld = new Matrix4();

			// for convex
			if(b.instance.v) o.v = b.instance.v;
			if(b.instance.index) o.index = b.instance.index;
		    o.type = b.instance.type;

			/*if( this.extraConvex && ( o.type==='cylinder' || o.type==='cone') ){
		    	o.v = b.instance.v;
		    	o.type = 'convex';
		    }*/


			//console.log( b )

		} else {

			b.name = name;

			if( o.renderOrder ) b.renderOrder = o.renderOrder;
			if( o.visible === undefined ) o.visible = true;
			if( o.shadow === undefined ) o.shadow = o.visible;

			b.visible = o.visible !== undefined ? o.visible : true;
		    b.receiveShadow = o.shadow;
		    b.castShadow = o.shadow;

		    b.overMaterial = Mat$2.get( 'outline' );

		    // apply option
			this.set( o, b );

		}




		//---------------------------
		//  Breakable
		//---------------------------

    	if( o.breakable ){

    		this.motor.addBreaker();
			let child = b.children[0];
			b.remove(child);
			b = child;
			b.name = name;
			b.type = this.type;
			b.density = o.density;
			b.breakable = true;
			b.breakOption = o.breakOption !== undefined ? o.breakOption : [ 250, 1, 2, 1 ];
			//b.userData.mass = o.mass;
		}

		// for skeleton mesh

		/*if( o.bone ){

			b.userData.decal = o.decal;
            b.userData.decalinv = o.decalinv;
            b.userData.bone = o.bone;
		    

		    delete o.bone
		    delete o.decal
		    delete o.decalinv
		}*/

		//o.volume = this.tmpVolume

		//---------------------------
		//  Mass and Density
		//---------------------------

		b.mass = o.mass || 0;
		b.density = o.density || 0;

		if( b.density && !b.mass ) b.mass = MathTool.massFromDensity( b.density, volume );
		else if( b.mass && !b.density ){ 
			b.density = MathTool.densityFromMass( b.mass, volume );
			//  force density for engin don't have mass
			if( this.engine === 'RAPIER' || this.engine === 'OIMO') o.density = b.density;
		}


		if( o.massInfo ) console.log( '%c'+b.name+ ' %c' + 'density:' + b.density + ' mass:'+ b.mass, "font-size:16px", "font-size:12px" );


		if( o.getVelocity ) b.getVelocity = true;

		//---------------------------
		// add to three world
		//---------------------------

		this.addToWorld( b, o.id );

		if( o.onlyMakeMesh ) return b;

		if( o.phySize ) o.size = o.phySize;
		if( o.phyPos ) o.pos = o.phyPos;

		//---------------------------
		//  Clear uneed object value
		//---------------------------

		if( o.rot ) delete o.rot;
		if( o.mesh ) delete o.mesh;
	    if( o.meshRot ) delete o.meshRot;
	    if( o.instance ) delete o.instance;
	    if( o.material ) delete o.material;
		if( o.parent ) delete o.parent;


		if( o.solver && this.engine === 'PHYSX' ){
			// physx only have mass for solver bone
			o.mass = b.mass;
			// keep name reference of bones
			const solver = this.byName( o.solver );
			solver.addBone( o.name );

		}

	    //---------------------------
		// send to physic engine 
		//---------------------------

		this.motor.post( { m:'add', o:o } );

		//---------------------------
		// return three object3d
		//---------------------------

		return b;

	}

	set ( o = {}, b = null ) {

		if( b === null ) b = this.byName( o.name );
		if( b === null ) return;

		if( o.getVelocity !== undefined ) b.getVelocity = o.getVelocity;

		if(b.isInstance){

			if( o.pos ) b.position.fromArray(o.pos);// = {x:o.pos[0], y:o.pos[1], z:o.pos[2]}
		    if( o.quat ) b.quaternion.fromArray(o.quat);// = {_x:o.quat[0], _y:o.quat[1], _z:o.quat[2], _w:o.quat[3]};
			if( o.pos || o.quat ) b.instance.setTransformAt( b.id, b.position, b.quaternion, b.noScale ? [1,1,1] : b.size );

		}else {

			if( o.pos ) b.position.fromArray( o.pos );
		    if( o.quat ) b.quaternion.fromArray( o.quat );

		    b.auto = o.auto || false;

		    if( !b.auto ) {
		    	b.matrixAutoUpdate = false;
			    b.updateMatrix();
			} else {
				b.matrixAutoUpdate = true;
			}
		}

	}

	clearInstance( name ){

		let instance = this.motor.instanceMesh[name];
		let bodyList = instance.getBodyList();

		this.motor.remove( bodyList );
		instance.dispose();
		delete this.motor.instanceMesh[name];

	}

	getInstance ( o, material ) {

		if( this.motor.instanceMesh[o.instance] ) return this.motor.instanceMesh[o.instance];

		// Create new instance 

		o = {...o};

		if( o.sizeByInstance ) o.size = [1,1,1];
		let g = this.geometry( o );

		if( o.mesh ) {
			if( !o.material && o.mesh.material ) material = o.mesh.material;
			g = o.mesh.isObject3D ? o.mesh.geometry.clone() : o.mesh.clone();
			if( o.meshSize ) g.scale( o.meshSize, o.meshSize, o.meshSize );
			if( o.meshScale ) g.scale( o.meshScale[0], o.meshScale[1], o.meshScale[2] );
			g.noScale = true;
		}

		let bb = new Instance( g, material, 0 );

		bb.type = o.type;
		bb.noScale = g.noScale;

		if( bb.type === 'convex' ) bb.v = o.v;
		if( o.index ) bb.index = o.index;
		

		//if( bb.type==='convex' ) bb.v = MathTool.getVertex( bb.geometry )

    	//bb.matrixAutoUpdate = false
    	//bb.instanceMatrix.setUsage( DynamicDrawUsage )
    	bb.receiveShadow = o.shadow !== undefined ? o.shadow : true;
    	bb.castShadow = o.shadow !== undefined ? o.shadow : true;

    	bb.overMaterial = Mat$2.get( 'outline' );

    	bb.name = o.instance;
		this.motor.scene.add( bb );
		this.motor.instanceMesh[ o.instance ] = bb;

		//console.log('add instance')

    	return bb;

	}

	scaler ( o, s ) {

	    if(o.size) o.size = math.scaleArray( o.size, s );
	    if(o.pos) o.pos = math.scaleArray( o.pos, s );
	    if(o.type === 'convex') o.shapeScale = [s,s,s];
	    if(o.shapes){
	        let i = o.shapes.length, sh;
	        while(i--){
	            sh = o.shapes[i];
	            if(sh.size) sh.size = math.scaleArray( sh.size, s );
	            if(sh.pos) sh.pos = math.scaleArray( sh.pos, s );
	            if(sh.type === 'convex') sh.shapeScale = [s,s,s];
	        }
	    }
	    if(o.mesh) o.meshScale = [s,s,s];
	    return o;

	}

}

const COLOR_SPACE_SVG = SRGBColorSpace;

class SVGLoader extends Loader {

	constructor( manager ) {

		super( manager );

		// Default dots per inch
		this.defaultDPI = 90;

		// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'
		this.defaultUnit = 'px';

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( text ) {

		const scope = this;

		function parseNode( node, style ) {

			if ( node.nodeType !== 1 ) return;

			const transform = getNodeTransform( node );

			let isDefsNode = false;

			let path = null;

			switch ( node.nodeName ) {

				case 'svg':
					style = parseStyle( node, style );
					break;

				case 'style':
					parseCSSStylesheet( node );
					break;

				case 'g':
					style = parseStyle( node, style );
					break;

				case 'path':
					style = parseStyle( node, style );
					if ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );
					break;

				case 'rect':
					style = parseStyle( node, style );
					path = parseRectNode( node );
					break;

				case 'polygon':
					style = parseStyle( node, style );
					path = parsePolygonNode( node );
					break;

				case 'polyline':
					style = parseStyle( node, style );
					path = parsePolylineNode( node );
					break;

				case 'circle':
					style = parseStyle( node, style );
					path = parseCircleNode( node );
					break;

				case 'ellipse':
					style = parseStyle( node, style );
					path = parseEllipseNode( node );
					break;

				case 'line':
					style = parseStyle( node, style );
					path = parseLineNode( node );
					break;

				case 'defs':
					isDefsNode = true;
					break;

				case 'use':
					style = parseStyle( node, style );

					const href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';
					const usedNodeId = href.substring( 1 );
					const usedNode = node.viewportElement.getElementById( usedNodeId );
					if ( usedNode ) {

						parseNode( usedNode, style );

					} else {

						console.warn( 'SVGLoader: \'use node\' references non-existent node id: ' + usedNodeId );

					}

					break;
					// console.log( node );

			}

			if ( path ) {

				if ( style.fill !== undefined && style.fill !== 'none' ) {

					path.color.setStyle( style.fill, COLOR_SPACE_SVG );

				}

				transformPath( path, currentTransform );

				paths.push( path );

				path.userData = { node: node, style: style };

			}

			const childNodes = node.childNodes;

			for ( let i = 0; i < childNodes.length; i ++ ) {

				const node = childNodes[ i ];

				if ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {

					// Ignore everything in defs except CSS style definitions
					// and nested defs, because it is OK by the standard to have
					// <style/> there.
					continue;

				}

				parseNode( node, style );

			}


			if ( transform ) {

				transformStack.pop();

				if ( transformStack.length > 0 ) {

					currentTransform.copy( transformStack[ transformStack.length - 1 ] );

				} else {

					currentTransform.identity();

				}

			}

		}

		function parsePathNode( node ) {

			const path = new ShapePath();

			const point = new Vector2();
			const control = new Vector2();

			const firstPoint = new Vector2();
			let isFirstPoint = true;
			let doSetFirstPoint = false;

			const d = node.getAttribute( 'd' );

			if ( d === '' || d === 'none' ) return null;

			// console.log( d );

			const commands = d.match( /[a-df-z][^a-df-z]*/ig );

			for ( let i = 0, l = commands.length; i < l; i ++ ) {

				const command = commands[ i ];

				const type = command.charAt( 0 );
				const data = command.slice( 1 ).trim();

				if ( isFirstPoint === true ) {

					doSetFirstPoint = true;
					isFirstPoint = false;

				}

				let numbers;

				switch ( type ) {

					case 'M':
						numbers = parseFloats( data );
						for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {

							point.x = numbers[ j + 0 ];
							point.y = numbers[ j + 1 ];
							control.x = point.x;
							control.y = point.y;

							if ( j === 0 ) {

								path.moveTo( point.x, point.y );

							} else {

								path.lineTo( point.x, point.y );

							}

							if ( j === 0 ) firstPoint.copy( point );

						}

						break;

					case 'H':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j ++ ) {

							point.x = numbers[ j ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'V':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j ++ ) {

							point.y = numbers[ j ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'L':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {

							point.x = numbers[ j + 0 ];
							point.y = numbers[ j + 1 ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'C':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {

							path.bezierCurveTo(
								numbers[ j + 0 ],
								numbers[ j + 1 ],
								numbers[ j + 2 ],
								numbers[ j + 3 ],
								numbers[ j + 4 ],
								numbers[ j + 5 ]
							);
							control.x = numbers[ j + 2 ];
							control.y = numbers[ j + 3 ];
							point.x = numbers[ j + 4 ];
							point.y = numbers[ j + 5 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'S':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {

							path.bezierCurveTo(
								getReflection( point.x, control.x ),
								getReflection( point.y, control.y ),
								numbers[ j + 0 ],
								numbers[ j + 1 ],
								numbers[ j + 2 ],
								numbers[ j + 3 ]
							);
							control.x = numbers[ j + 0 ];
							control.y = numbers[ j + 1 ];
							point.x = numbers[ j + 2 ];
							point.y = numbers[ j + 3 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'Q':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {

							path.quadraticCurveTo(
								numbers[ j + 0 ],
								numbers[ j + 1 ],
								numbers[ j + 2 ],
								numbers[ j + 3 ]
							);
							control.x = numbers[ j + 0 ];
							control.y = numbers[ j + 1 ];
							point.x = numbers[ j + 2 ];
							point.y = numbers[ j + 3 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'T':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {

							const rx = getReflection( point.x, control.x );
							const ry = getReflection( point.y, control.y );
							path.quadraticCurveTo(
								rx,
								ry,
								numbers[ j + 0 ],
								numbers[ j + 1 ]
							);
							control.x = rx;
							control.y = ry;
							point.x = numbers[ j + 0 ];
							point.y = numbers[ j + 1 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'A':
						numbers = parseFloats( data, [ 3, 4 ], 7 );

						for ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {

							// skip command if start point == end point
							if ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;

							const start = point.clone();
							point.x = numbers[ j + 5 ];
							point.y = numbers[ j + 6 ];
							control.x = point.x;
							control.y = point.y;
							parseArcCommand(
								path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point
							);

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'm':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {

							point.x += numbers[ j + 0 ];
							point.y += numbers[ j + 1 ];
							control.x = point.x;
							control.y = point.y;

							if ( j === 0 ) {

								path.moveTo( point.x, point.y );

							} else {

								path.lineTo( point.x, point.y );

							}

							if ( j === 0 ) firstPoint.copy( point );

						}

						break;

					case 'h':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j ++ ) {

							point.x += numbers[ j ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'v':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j ++ ) {

							point.y += numbers[ j ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'l':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {

							point.x += numbers[ j + 0 ];
							point.y += numbers[ j + 1 ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'c':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {

							path.bezierCurveTo(
								point.x + numbers[ j + 0 ],
								point.y + numbers[ j + 1 ],
								point.x + numbers[ j + 2 ],
								point.y + numbers[ j + 3 ],
								point.x + numbers[ j + 4 ],
								point.y + numbers[ j + 5 ]
							);
							control.x = point.x + numbers[ j + 2 ];
							control.y = point.y + numbers[ j + 3 ];
							point.x += numbers[ j + 4 ];
							point.y += numbers[ j + 5 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 's':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {

							path.bezierCurveTo(
								getReflection( point.x, control.x ),
								getReflection( point.y, control.y ),
								point.x + numbers[ j + 0 ],
								point.y + numbers[ j + 1 ],
								point.x + numbers[ j + 2 ],
								point.y + numbers[ j + 3 ]
							);
							control.x = point.x + numbers[ j + 0 ];
							control.y = point.y + numbers[ j + 1 ];
							point.x += numbers[ j + 2 ];
							point.y += numbers[ j + 3 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'q':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {

							path.quadraticCurveTo(
								point.x + numbers[ j + 0 ],
								point.y + numbers[ j + 1 ],
								point.x + numbers[ j + 2 ],
								point.y + numbers[ j + 3 ]
							);
							control.x = point.x + numbers[ j + 0 ];
							control.y = point.y + numbers[ j + 1 ];
							point.x += numbers[ j + 2 ];
							point.y += numbers[ j + 3 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 't':
						numbers = parseFloats( data );

						for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {

							const rx = getReflection( point.x, control.x );
							const ry = getReflection( point.y, control.y );
							path.quadraticCurveTo(
								rx,
								ry,
								point.x + numbers[ j + 0 ],
								point.y + numbers[ j + 1 ]
							);
							control.x = rx;
							control.y = ry;
							point.x = point.x + numbers[ j + 0 ];
							point.y = point.y + numbers[ j + 1 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'a':
						numbers = parseFloats( data, [ 3, 4 ], 7 );

						for ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {

							// skip command if no displacement
							if ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;

							const start = point.clone();
							point.x += numbers[ j + 5 ];
							point.y += numbers[ j + 6 ];
							control.x = point.x;
							control.y = point.y;
							parseArcCommand(
								path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point
							);

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'Z':
					case 'z':
						path.currentPath.autoClose = true;

						if ( path.currentPath.curves.length > 0 ) {

							// Reset point to beginning of Path
							point.copy( firstPoint );
							path.currentPath.currentPoint.copy( point );
							isFirstPoint = true;

						}

						break;

					default:
						console.warn( command );

				}

				// console.log( type, parseFloats( data ), parseFloats( data ).length  )

				doSetFirstPoint = false;

			}

			return path;

		}

		function parseCSSStylesheet( node ) {

			if ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;

			for ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {

				const stylesheet = node.sheet.cssRules[ i ];

				if ( stylesheet.type !== 1 ) continue;

				const selectorList = stylesheet.selectorText
					.split( /,/gm )
					.filter( Boolean )
					.map( i => i.trim() );

				for ( let j = 0; j < selectorList.length; j ++ ) {

					// Remove empty rules
					const definitions = Object.fromEntries(
						Object.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )
					);

					stylesheets[ selectorList[ j ] ] = Object.assign(
						stylesheets[ selectorList[ j ] ] || {},
						definitions
					);

				}

			}

		}

		/**
		 * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
		 * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion
		 * From
		 * rx ry x-axis-rotation large-arc-flag sweep-flag x y
		 * To
		 * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation
		 */

		function parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {

			if ( rx == 0 || ry == 0 ) {

				// draw a line if either of the radii == 0
				path.lineTo( end.x, end.y );
				return;

			}

			x_axis_rotation = x_axis_rotation * Math.PI / 180;

			// Ensure radii are positive
			rx = Math.abs( rx );
			ry = Math.abs( ry );

			// Compute (x1', y1')
			const dx2 = ( start.x - end.x ) / 2.0;
			const dy2 = ( start.y - end.y ) / 2.0;
			const x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;
			const y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;

			// Compute (cx', cy')
			let rxs = rx * rx;
			let rys = ry * ry;
			const x1ps = x1p * x1p;
			const y1ps = y1p * y1p;

			// Ensure radii are large enough
			const cr = x1ps / rxs + y1ps / rys;

			if ( cr > 1 ) {

				// scale up rx,ry equally so cr == 1
				const s = Math.sqrt( cr );
				rx = s * rx;
				ry = s * ry;
				rxs = rx * rx;
				rys = ry * ry;

			}

			const dq = ( rxs * y1ps + rys * x1ps );
			const pq = ( rxs * rys - dq ) / dq;
			let q = Math.sqrt( Math.max( 0, pq ) );
			if ( large_arc_flag === sweep_flag ) q = - q;
			const cxp = q * rx * y1p / ry;
			const cyp = - q * ry * x1p / rx;

			// Step 3: Compute (cx, cy) from (cx', cy')
			const cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;
			const cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;

			// Step 4: Compute θ1 and Δθ
			const theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );
			const delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );

			path.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );

		}

		function svgAngle( ux, uy, vx, vy ) {

			const dot = ux * vx + uy * vy;
			const len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );
			let ang = Math.acos( Math.max( -1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear
			if ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;
			return ang;

		}

		/*
		* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute
		* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough
		*/
		function parseRectNode( node ) {

			const x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );
			const y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );
			const rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );
			const ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );
			const w = parseFloatWithUnits( node.getAttribute( 'width' ) );
			const h = parseFloatWithUnits( node.getAttribute( 'height' ) );

			// Ellipse arc to Bezier approximation Coefficient (Inversed). See:
			// https://spencermortensen.com/articles/bezier-circle/
			const bci = 1 - 0.551915024494;

			const path = new ShapePath();

			// top left
			path.moveTo( x + rx, y );

			// top right
			path.lineTo( x + w - rx, y );
			if ( rx !== 0 || ry !== 0 ) {

				path.bezierCurveTo(
					x + w - rx * bci,
					y,
					x + w,
					y + ry * bci,
					x + w,
					y + ry
				);

			}

			// bottom right
			path.lineTo( x + w, y + h - ry );
			if ( rx !== 0 || ry !== 0 ) {

				path.bezierCurveTo(
					x + w,
					y + h - ry * bci,
					x + w - rx * bci,
					y + h,
					x + w - rx,
					y + h
				);

			}

			// bottom left
			path.lineTo( x + rx, y + h );
			if ( rx !== 0 || ry !== 0 ) {

				path.bezierCurveTo(
					x + rx * bci,
					y + h,
					x,
					y + h - ry * bci,
					x,
					y + h - ry
				);

			}

			// back to top left
			path.lineTo( x, y + ry );
			if ( rx !== 0 || ry !== 0 ) {

				path.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );

			}

			return path;

		}

		function parsePolygonNode( node ) {

			function iterator( match, a, b ) {

				const x = parseFloatWithUnits( a );
				const y = parseFloatWithUnits( b );

				if ( index === 0 ) {

					path.moveTo( x, y );

				} else {

					path.lineTo( x, y );

				}

				index ++;

			}

			const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;

			const path = new ShapePath();

			let index = 0;

			node.getAttribute( 'points' ).replace( regex, iterator );

			path.currentPath.autoClose = true;

			return path;

		}

		function parsePolylineNode( node ) {

			function iterator( match, a, b ) {

				const x = parseFloatWithUnits( a );
				const y = parseFloatWithUnits( b );

				if ( index === 0 ) {

					path.moveTo( x, y );

				} else {

					path.lineTo( x, y );

				}

				index ++;

			}

			const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;

			const path = new ShapePath();

			let index = 0;

			node.getAttribute( 'points' ).replace( regex, iterator );

			path.currentPath.autoClose = false;

			return path;

		}

		function parseCircleNode( node ) {

			const x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );
			const y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );
			const r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );

			const subpath = new Path();
			subpath.absarc( x, y, r, 0, Math.PI * 2 );

			const path = new ShapePath();
			path.subPaths.push( subpath );

			return path;

		}

		function parseEllipseNode( node ) {

			const x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );
			const y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );
			const rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );
			const ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );

			const subpath = new Path();
			subpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );

			const path = new ShapePath();
			path.subPaths.push( subpath );

			return path;

		}

		function parseLineNode( node ) {

			const x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );
			const y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );
			const x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );
			const y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );

			const path = new ShapePath();
			path.moveTo( x1, y1 );
			path.lineTo( x2, y2 );
			path.currentPath.autoClose = false;

			return path;

		}

		//

		function parseStyle( node, style ) {

			style = Object.assign( {}, style ); // clone style

			let stylesheetStyles = {};

			if ( node.hasAttribute( 'class' ) ) {

				const classSelectors = node.getAttribute( 'class' )
					.split( /\s/ )
					.filter( Boolean )
					.map( i => i.trim() );

				for ( let i = 0; i < classSelectors.length; i ++ ) {

					stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );

				}

			}

			if ( node.hasAttribute( 'id' ) ) {

				stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );

			}

			function addStyle( svgName, jsName, adjustFunction ) {

				if ( adjustFunction === undefined ) adjustFunction = function copy( v ) {

					if ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );

					return v;

				};

				if ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );
				if ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );
				if ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );

			}

			function clamp( v ) {

				return Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );

			}

			function positive( v ) {

				return Math.max( 0, parseFloatWithUnits( v ) );

			}

			addStyle( 'fill', 'fill' );
			addStyle( 'fill-opacity', 'fillOpacity', clamp );
			addStyle( 'fill-rule', 'fillRule' );
			addStyle( 'opacity', 'opacity', clamp );
			addStyle( 'stroke', 'stroke' );
			addStyle( 'stroke-opacity', 'strokeOpacity', clamp );
			addStyle( 'stroke-width', 'strokeWidth', positive );
			addStyle( 'stroke-linejoin', 'strokeLineJoin' );
			addStyle( 'stroke-linecap', 'strokeLineCap' );
			addStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );
			addStyle( 'visibility', 'visibility' );

			return style;

		}

		// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes

		function getReflection( a, b ) {

			return a - ( b - a );

		}

		// from https://github.com/ppvg/svg-numbers (MIT License)

		function parseFloats( input, flags, stride ) {

			if ( typeof input !== 'string' ) {

				throw new TypeError( 'Invalid input: ' + typeof input );

			}

			// Character groups
			const RE = {
				WHITESPACE: /[ \t\r\n]/,
				DIGIT: /[\d]/,
				SIGN: /[-+]/,
				POINT: /\./,
				COMMA: /,/,
				EXP: /e/i,
				FLAGS: /[01]/
			};

			// States
			const SEP = 0;
			const INT = 1;
			const FLOAT = 2;
			const EXP = 3;

			let state = SEP;
			let seenComma = true;
			let number = '', exponent = '';
			const result = [];

			function throwSyntaxError( current, i, partial ) {

				const error = new SyntaxError( 'Unexpected character "' + current + '" at index ' + i + '.' );
				error.partial = partial;
				throw error;

			}

			function newNumber() {

				if ( number !== '' ) {

					if ( exponent === '' ) result.push( Number( number ) );
					else result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );

				}

				number = '';
				exponent = '';

			}

			let current;
			const length = input.length;

			for ( let i = 0; i < length; i ++ ) {

				current = input[ i ];

				// check for flags
				if ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {

					state = INT;
					number = current;
					newNumber();
					continue;

				}

				// parse until next number
				if ( state === SEP ) {

					// eat whitespace
					if ( RE.WHITESPACE.test( current ) ) {

						continue;

					}

					// start new number
					if ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {

						state = INT;
						number = current;
						continue;

					}

					if ( RE.POINT.test( current ) ) {

						state = FLOAT;
						number = current;
						continue;

					}

					// throw on double commas (e.g. "1, , 2")
					if ( RE.COMMA.test( current ) ) {

						if ( seenComma ) {

							throwSyntaxError( current, i, result );

						}

						seenComma = true;

					}

				}

				// parse integer part
				if ( state === INT ) {

					if ( RE.DIGIT.test( current ) ) {

						number += current;
						continue;

					}

					if ( RE.POINT.test( current ) ) {

						number += current;
						state = FLOAT;
						continue;

					}

					if ( RE.EXP.test( current ) ) {

						state = EXP;
						continue;

					}

					// throw on double signs ("-+1"), but not on sign as separator ("-1-2")
					if ( RE.SIGN.test( current )
							&& number.length === 1
							&& RE.SIGN.test( number[ 0 ] ) ) {

						throwSyntaxError( current, i, result );

					}

				}

				// parse decimal part
				if ( state === FLOAT ) {

					if ( RE.DIGIT.test( current ) ) {

						number += current;
						continue;

					}

					if ( RE.EXP.test( current ) ) {

						state = EXP;
						continue;

					}

					// throw on double decimal points (e.g. "1..2")
					if ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {

						throwSyntaxError( current, i, result );

					}

				}

				// parse exponent part
				if ( state === EXP ) {

					if ( RE.DIGIT.test( current ) ) {

						exponent += current;
						continue;

					}

					if ( RE.SIGN.test( current ) ) {

						if ( exponent === '' ) {

							exponent += current;
							continue;

						}

						if ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {

							throwSyntaxError( current, i, result );

						}

					}

				}


				// end of number
				if ( RE.WHITESPACE.test( current ) ) {

					newNumber();
					state = SEP;
					seenComma = false;

				} else if ( RE.COMMA.test( current ) ) {

					newNumber();
					state = SEP;
					seenComma = true;

				} else if ( RE.SIGN.test( current ) ) {

					newNumber();
					state = INT;
					number = current;

				} else if ( RE.POINT.test( current ) ) {

					newNumber();
					state = FLOAT;
					number = current;

				} else {

					throwSyntaxError( current, i, result );

				}

			}

			// add the last number found (if any)
			newNumber();

			return result;

		}

		// Units

		const units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];

		// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)
		const unitConversion = {

			'mm': {
				'mm': 1,
				'cm': 0.1,
				'in': 1 / 25.4,
				'pt': 72 / 25.4,
				'pc': 6 / 25.4,
				'px': -1
			},
			'cm': {
				'mm': 10,
				'cm': 1,
				'in': 1 / 2.54,
				'pt': 72 / 2.54,
				'pc': 6 / 2.54,
				'px': -1
			},
			'in': {
				'mm': 25.4,
				'cm': 2.54,
				'in': 1,
				'pt': 72,
				'pc': 6,
				'px': -1
			},
			'pt': {
				'mm': 25.4 / 72,
				'cm': 2.54 / 72,
				'in': 1 / 72,
				'pt': 1,
				'pc': 6 / 72,
				'px': -1
			},
			'pc': {
				'mm': 25.4 / 6,
				'cm': 2.54 / 6,
				'in': 1 / 6,
				'pt': 72 / 6,
				'pc': 1,
				'px': -1
			},
			'px': {
				'px': 1
			}

		};

		function parseFloatWithUnits( string ) {

			let theUnit = 'px';

			if ( typeof string === 'string' || string instanceof String ) {

				for ( let i = 0, n = units.length; i < n; i ++ ) {

					const u = units[ i ];

					if ( string.endsWith( u ) ) {

						theUnit = u;
						string = string.substring( 0, string.length - u.length );
						break;

					}

				}

			}

			let scale = undefined;

			if ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {

				// Conversion scale from  pixels to inches, then to default units

				scale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;

			} else {

				scale = unitConversion[ theUnit ][ scope.defaultUnit ];

				if ( scale < 0 ) {

					// Conversion scale to pixels

					scale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;

				}

			}

			return scale * parseFloat( string );

		}

		// Transforms

		function getNodeTransform( node ) {

			if ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {

				return null;

			}

			const transform = parseNodeTransform( node );

			if ( transformStack.length > 0 ) {

				transform.premultiply( transformStack[ transformStack.length - 1 ] );

			}

			currentTransform.copy( transform );
			transformStack.push( transform );

			return transform;

		}

		function parseNodeTransform( node ) {

			const transform = new Matrix3$1();
			const currentTransform = tempTransform0;

			if ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {

				const tx = parseFloatWithUnits( node.getAttribute( 'x' ) );
				const ty = parseFloatWithUnits( node.getAttribute( 'y' ) );

				transform.translate( tx, ty );

			}

			if ( node.hasAttribute( 'transform' ) ) {

				const transformsTexts = node.getAttribute( 'transform' ).split( ')' );

				for ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {

					const transformText = transformsTexts[ tIndex ].trim();

					if ( transformText === '' ) continue;

					const openParPos = transformText.indexOf( '(' );
					const closeParPos = transformText.length;

					if ( openParPos > 0 && openParPos < closeParPos ) {

						const transformType = transformText.slice( 0, openParPos );

						const array = parseFloats( transformText.slice( openParPos + 1 ) );

						currentTransform.identity();

						switch ( transformType ) {

							case 'translate':

								if ( array.length >= 1 ) {

									const tx = array[ 0 ];
									let ty = 0;

									if ( array.length >= 2 ) {

										ty = array[ 1 ];

									}

									currentTransform.translate( tx, ty );

								}

								break;

							case 'rotate':

								if ( array.length >= 1 ) {

									let angle = 0;
									let cx = 0;
									let cy = 0;

									// Angle
									angle = array[ 0 ] * Math.PI / 180;

									if ( array.length >= 3 ) {

										// Center x, y
										cx = array[ 1 ];
										cy = array[ 2 ];

									}

									// Rotate around center (cx, cy)
									tempTransform1.makeTranslation( - cx, - cy );
									tempTransform2.makeRotation( angle );
									tempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );
									tempTransform1.makeTranslation( cx, cy );
									currentTransform.multiplyMatrices( tempTransform1, tempTransform3 );

								}

								break;

							case 'scale':

								if ( array.length >= 1 ) {

									const scaleX = array[ 0 ];
									let scaleY = scaleX;

									if ( array.length >= 2 ) {

										scaleY = array[ 1 ];

									}

									currentTransform.scale( scaleX, scaleY );

								}

								break;

							case 'skewX':

								if ( array.length === 1 ) {

									currentTransform.set(
										1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,
										0, 1, 0,
										0, 0, 1
									);

								}

								break;

							case 'skewY':

								if ( array.length === 1 ) {

									currentTransform.set(
										1, 0, 0,
										Math.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,
										0, 0, 1
									);

								}

								break;

							case 'matrix':

								if ( array.length === 6 ) {

									currentTransform.set(
										array[ 0 ], array[ 2 ], array[ 4 ],
										array[ 1 ], array[ 3 ], array[ 5 ],
										0, 0, 1
									);

								}

								break;

						}

					}

					transform.premultiply( currentTransform );

				}

			}

			return transform;

		}

		function transformPath( path, m ) {

			function transfVec2( v2 ) {

				tempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );

				v2.set( tempV3.x, tempV3.y );

			}

			function transfEllipseGeneric( curve ) {

				// For math description see:
				// https://math.stackexchange.com/questions/4544164

				const a = curve.xRadius;
				const b = curve.yRadius;

				const cosTheta = Math.cos( curve.aRotation );
				const sinTheta = Math.sin( curve.aRotation );

				const v1 = new Vector3( a * cosTheta, a * sinTheta, 0 );
				const v2 = new Vector3( - b * sinTheta, b * cosTheta, 0 );

				const f1 = v1.applyMatrix3( m );
				const f2 = v2.applyMatrix3( m );

				const mF = tempTransform0.set(
					f1.x, f2.x, 0,
					f1.y, f2.y, 0,
					0, 0, 1,
				);

				const mFInv = tempTransform1.copy( mF ).invert();
				const mFInvT = tempTransform2.copy( mFInv ).transpose();
				const mQ = mFInvT.multiply( mFInv );
				const mQe = mQ.elements;

				const ed = eigenDecomposition( mQe[ 0 ], mQe[ 1 ], mQe[ 4 ] );
				const rt1sqrt = Math.sqrt( ed.rt1 );
				const rt2sqrt = Math.sqrt( ed.rt2 );

				curve.xRadius = 1 / rt1sqrt;
				curve.yRadius = 1 / rt2sqrt;
				curve.aRotation = Math.atan2( ed.sn, ed.cs );

				const isFullEllipse =
					( curve.aEndAngle - curve.aStartAngle ) % ( 2 * Math.PI ) < Number.EPSILON;

				// Do not touch angles of a full ellipse because after transformation they
				// would converge to a sinle value effectively removing the whole curve

				if ( ! isFullEllipse ) {

					const mDsqrt = tempTransform1.set(
						rt1sqrt, 0, 0,
						0, rt2sqrt, 0,
						0, 0, 1,
					);

					const mRT = tempTransform2.set(
						ed.cs, ed.sn, 0,
						- ed.sn, ed.cs, 0,
						0, 0, 1,
					);

					const mDRF = mDsqrt.multiply( mRT ).multiply( mF );

					const transformAngle = phi => {

						const { x: cosR, y: sinR } =
							new Vector3( Math.cos( phi ), Math.sin( phi ), 0 ).applyMatrix3( mDRF );

						return Math.atan2( sinR, cosR );

					};

					curve.aStartAngle = transformAngle( curve.aStartAngle );
					curve.aEndAngle = transformAngle( curve.aEndAngle );

					if ( isTransformFlipped( m ) ) {

						curve.aClockwise = ! curve.aClockwise;

					}

				}

			}

			function transfEllipseNoSkew( curve ) {

				// Faster shortcut if no skew is applied
				// (e.g, a euclidean transform of a group containing the ellipse)

				const sx = getTransformScaleX( m );
				const sy = getTransformScaleY( m );

				curve.xRadius *= sx;
				curve.yRadius *= sy;

				// Extract rotation angle from the matrix of form:
				//
				//  | cosθ sx   -sinθ sy |
				//  | sinθ sx    cosθ sy |
				//
				// Remembering that tanθ = sinθ / cosθ; and that
				// `sx`, `sy`, or both might be zero.
				const theta =
					sx > Number.EPSILON
						? Math.atan2( m.elements[ 1 ], m.elements[ 0 ] )
						: Math.atan2( - m.elements[ 3 ], m.elements[ 4 ] );

				curve.aRotation += theta;

				if ( isTransformFlipped( m ) ) {

					curve.aStartAngle *= -1;
					curve.aEndAngle *= -1;
					curve.aClockwise = ! curve.aClockwise;

				}

			}

			const subPaths = path.subPaths;

			for ( let i = 0, n = subPaths.length; i < n; i ++ ) {

				const subPath = subPaths[ i ];
				const curves = subPath.curves;

				for ( let j = 0; j < curves.length; j ++ ) {

					const curve = curves[ j ];

					if ( curve.isLineCurve ) {

						transfVec2( curve.v1 );
						transfVec2( curve.v2 );

					} else if ( curve.isCubicBezierCurve ) {

						transfVec2( curve.v0 );
						transfVec2( curve.v1 );
						transfVec2( curve.v2 );
						transfVec2( curve.v3 );

					} else if ( curve.isQuadraticBezierCurve ) {

						transfVec2( curve.v0 );
						transfVec2( curve.v1 );
						transfVec2( curve.v2 );

					} else if ( curve.isEllipseCurve ) {

						// Transform ellipse center point

						tempV2.set( curve.aX, curve.aY );
						transfVec2( tempV2 );
						curve.aX = tempV2.x;
						curve.aY = tempV2.y;

						// Transform ellipse shape parameters

						if ( isTransformSkewed( m ) ) {

							transfEllipseGeneric( curve );

						} else {

							transfEllipseNoSkew( curve );

						}

					}

				}

			}

		}

		function isTransformFlipped( m ) {

			const te = m.elements;
			return te[ 0 ] * te[ 4 ] - te[ 1 ] * te[ 3 ] < 0;

		}

		function isTransformSkewed( m ) {

			const te = m.elements;
			const basisDot = te[ 0 ] * te[ 3 ] + te[ 1 ] * te[ 4 ];

			// Shortcut for trivial rotations and transformations
			if ( basisDot === 0 ) return false;

			const sx = getTransformScaleX( m );
			const sy = getTransformScaleY( m );

			return Math.abs( basisDot / ( sx * sy ) ) > Number.EPSILON;

		}

		function getTransformScaleX( m ) {

			const te = m.elements;
			return Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );

		}

		function getTransformScaleY( m ) {

			const te = m.elements;
			return Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );

		}

		// Calculates the eigensystem of a real symmetric 2x2 matrix
		//    [ A  B ]
		//    [ B  C ]
		// in the form
		//    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]
		//    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]
		// where rt1 >= rt2.
		//
		// Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html
		// -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)
		function eigenDecomposition( A, B, C ) {

			let rt1, rt2, cs, sn, t;
			const sm = A + C;
			const df = A - C;
			const rt = Math.sqrt( df * df + 4 * B * B );

			if ( sm > 0 ) {

				rt1 = 0.5 * ( sm + rt );
				t = 1 / rt1;
				rt2 = A * t * C - B * t * B;

			} else if ( sm < 0 ) {

				rt2 = 0.5 * ( sm - rt );

			} else {

				// This case needs to be treated separately to avoid div by 0

				rt1 = 0.5 * rt;
				rt2 = -0.5 * rt;

			}

			// Calculate eigenvectors

			if ( df > 0 ) {

				cs = df + rt;

			} else {

				cs = df - rt;

			}

			if ( Math.abs( cs ) > 2 * Math.abs( B ) ) {

				t = -2 * B / cs;
				sn = 1 / Math.sqrt( 1 + t * t );
				cs = t * sn;

			} else if ( Math.abs( B ) === 0 ) {

				cs = 1;
				sn = 0;

			} else {

				t = -0.5 * cs / B;
				cs = 1 / Math.sqrt( 1 + t * t );
				sn = t * cs;

			}

			if ( df > 0 ) {

				t = cs;
				cs = - sn;
				sn = t;

			}

			return { rt1, rt2, cs, sn };

		}

		//

		const paths = [];
		const stylesheets = {};

		const transformStack = [];

		const tempTransform0 = new Matrix3$1();
		const tempTransform1 = new Matrix3$1();
		const tempTransform2 = new Matrix3$1();
		const tempTransform3 = new Matrix3$1();
		const tempV2 = new Vector2();
		const tempV3 = new Vector3();

		const currentTransform = new Matrix3$1();

		const xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml

		parseNode( xml.documentElement, {
			fill: '#000',
			fillOpacity: 1,
			strokeOpacity: 1,
			strokeWidth: 1,
			strokeLineJoin: 'miter',
			strokeLineCap: 'butt',
			strokeMiterLimit: 4
		} );

		const data = { paths: paths, xml: xml.documentElement };

		// console.log( paths );
		return data;

	}

	static createShapes( shapePath ) {

		// Param shapePath: a shapepath as returned by the parse function of this class
		// Returns Shape object

		const BIGNUMBER = 999999999;

		const IntersectionLocationType = {
			ORIGIN: 0,
			DESTINATION: 1,
			BETWEEN: 2,
			LEFT: 3,
			RIGHT: 4,
			BEHIND: 5,
			BEYOND: 6
		};

		const classifyResult = {
			loc: IntersectionLocationType.ORIGIN,
			t: 0
		};

		function findEdgeIntersection( a0, a1, b0, b1 ) {

			const x1 = a0.x;
			const x2 = a1.x;
			const x3 = b0.x;
			const x4 = b1.x;
			const y1 = a0.y;
			const y2 = a1.y;
			const y3 = b0.y;
			const y4 = b1.y;
			const nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );
			const nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );
			const denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );
			const t1 = nom1 / denom;
			const t2 = nom2 / denom;

			if ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {

				//1. lines are parallel or edges don't intersect

				return null;

			} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {

				//2. lines are colinear

				//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)
				for ( let i = 0; i < 2; i ++ ) {

					classifyPoint( i === 0 ? b0 : b1, a0, a1 );
					//find position of this endpoints relatively to edge1
					if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {

						const point = ( i === 0 ? b0 : b1 );
						return { x: point.x, y: point.y, t: classifyResult.t };

					} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {

						const x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );
						const y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );
						return { x: x, y: y, t: classifyResult.t, };

					}

				}

				return null;

			} else {

				//3. edges intersect

				for ( let i = 0; i < 2; i ++ ) {

					classifyPoint( i === 0 ? b0 : b1, a0, a1 );

					if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {

						const point = ( i === 0 ? b0 : b1 );
						return { x: point.x, y: point.y, t: classifyResult.t };

					}

				}

				const x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );
				const y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );
				return { x: x, y: y, t: t1 };

			}

		}

		function classifyPoint( p, edgeStart, edgeEnd ) {

			const ax = edgeEnd.x - edgeStart.x;
			const ay = edgeEnd.y - edgeStart.y;
			const bx = p.x - edgeStart.x;
			const by = p.y - edgeStart.y;
			const sa = ax * by - bx * ay;

			if ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {

				classifyResult.loc = IntersectionLocationType.ORIGIN;
				classifyResult.t = 0;
				return;

			}

			if ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {

				classifyResult.loc = IntersectionLocationType.DESTINATION;
				classifyResult.t = 1;
				return;

			}

			if ( sa < - Number.EPSILON ) {

				classifyResult.loc = IntersectionLocationType.LEFT;
				return;

			}

			if ( sa > Number.EPSILON ) {

				classifyResult.loc = IntersectionLocationType.RIGHT;
				return;


			}

			if ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {

				classifyResult.loc = IntersectionLocationType.BEHIND;
				return;

			}

			if ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {

				classifyResult.loc = IntersectionLocationType.BEYOND;
				return;

			}

			let t;

			if ( ax !== 0 ) {

				t = bx / ax;

			} else {

				t = by / ay;

			}

			classifyResult.loc = IntersectionLocationType.BETWEEN;
			classifyResult.t = t;

		}

		function getIntersections( path1, path2 ) {

			const intersectionsRaw = [];
			const intersections = [];

			for ( let index = 1; index < path1.length; index ++ ) {

				const path1EdgeStart = path1[ index - 1 ];
				const path1EdgeEnd = path1[ index ];

				for ( let index2 = 1; index2 < path2.length; index2 ++ ) {

					const path2EdgeStart = path2[ index2 - 1 ];
					const path2EdgeEnd = path2[ index2 ];

					const intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );

					if ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {

						intersectionsRaw.push( intersection );
						intersections.push( new Vector2( intersection.x, intersection.y ) );

					}

				}

			}

			return intersections;

		}

		function getScanlineIntersections( scanline, boundingBox, paths ) {

			const center = new Vector2();
			boundingBox.getCenter( center );

			const allIntersections = [];

			paths.forEach( path => {

				// check if the center of the bounding box is in the bounding box of the paths.
				// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.
				// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.
				if ( path.boundingBox.containsPoint( center ) ) {

					const intersections = getIntersections( scanline, path.points );

					intersections.forEach( p => {

						allIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );

					} );

				}

			} );

			allIntersections.sort( ( i1, i2 ) => {

				return i1.point.x - i2.point.x;

			} );

			return allIntersections;

		}

		function isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {

			if ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {

				_fillRule = 'nonzero';

			}

			const centerBoundingBox = new Vector2();
			simplePath.boundingBox.getCenter( centerBoundingBox );

			const scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];

			const scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );

			scanlineIntersections.sort( ( i1, i2 ) => {

				return i1.point.x - i2.point.x;

			} );

			const baseIntersections = [];
			const otherIntersections = [];

			scanlineIntersections.forEach( i => {

				if ( i.identifier === simplePath.identifier ) {

					baseIntersections.push( i );

				} else {

					otherIntersections.push( i );

				}

			} );

			const firstXOfPath = baseIntersections[ 0 ].point.x;

			// build up the path hierarchy
			const stack = [];
			let i = 0;

			while ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {

				if ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {

					stack.pop();

				} else {

					stack.push( otherIntersections[ i ].identifier );

				}

				i ++;

			}

			stack.push( simplePath.identifier );

			if ( _fillRule === 'evenodd' ) {

				const isHole = stack.length % 2 === 0 ? true : false;
				const isHoleFor = stack[ stack.length - 2 ];

				return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };

			} else if ( _fillRule === 'nonzero' ) {

				// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.
				let isHole = true;
				let isHoleFor = null;
				let lastCWValue = null;

				for ( let i = 0; i < stack.length; i ++ ) {

					const identifier = stack[ i ];
					if ( isHole ) {

						lastCWValue = allPaths[ identifier ].isCW;
						isHole = false;
						isHoleFor = identifier;

					} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {

						lastCWValue = allPaths[ identifier ].isCW;
						isHole = true;

					}

				}

				return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };

			} else {

				console.warn( 'fill-rule: "' + _fillRule + '" is currently not implemented.' );

			}

		}

		// check for self intersecting paths
		// TODO

		// check intersecting paths
		// TODO

		// prepare paths for hole detection
		let scanlineMinX = BIGNUMBER;
		let scanlineMaxX = -999999999;

		let simplePaths = shapePath.subPaths.map( p => {

			const points = p.getPoints();
			let maxY = -999999999;
			let minY = BIGNUMBER;
			let maxX = -999999999;
			let minX = BIGNUMBER;

	      	//points.forEach(p => p.y *= -1);

			for ( let i = 0; i < points.length; i ++ ) {

				const p = points[ i ];

				if ( p.y > maxY ) {

					maxY = p.y;

				}

				if ( p.y < minY ) {

					minY = p.y;

				}

				if ( p.x > maxX ) {

					maxX = p.x;

				}

				if ( p.x < minX ) {

					minX = p.x;

				}

			}

			//
			if ( scanlineMaxX <= maxX ) {

				scanlineMaxX = maxX + 1;

			}

			if ( scanlineMinX >= minX ) {

				scanlineMinX = minX - 1;

			}

			return { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: -1, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };

		} );

		simplePaths = simplePaths.filter( sp => sp.points.length > 1 );

		for ( let identifier = 0; identifier < simplePaths.length; identifier ++ ) {

			simplePaths[ identifier ].identifier = identifier;

		}

		// check if path is solid or a hole
		const isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, ( shapePath.userData ? shapePath.userData.style.fillRule : undefined ) ) );


		const shapesToReturn = [];
		simplePaths.forEach( p => {

			const amIAHole = isAHole[ p.identifier ];

			if ( ! amIAHole.isHole ) {

				const shape = new Shape();
				shape.curves = p.curves;
				const holes = isAHole.filter( h => h.isHole && h.for === p.identifier );
				holes.forEach( h => {

					const hole = simplePaths[ h.identifier ];
					const path = new Path();
					path.curves = hole.curves;
					shape.holes.push( path );

				} );
				shapesToReturn.push( shape );

			}

		} );

		return shapesToReturn;

	}

	static getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {

		// Param width: Stroke width
		// Param color: As returned by THREE.Color.getStyle()
		// Param lineJoin: One of "round", "bevel", "miter" or "miter-limit"
		// Param lineCap: One of "round", "square" or "butt"
		// Param miterLimit: Maximum join length, in multiples of the "width" parameter (join is truncated if it exceeds that distance)
		// Returns style object

		width = width !== undefined ? width : 1;
		color = color !== undefined ? color : '#000';
		lineJoin = lineJoin !== undefined ? lineJoin : 'miter';
		lineCap = lineCap !== undefined ? lineCap : 'butt';
		miterLimit = miterLimit !== undefined ? miterLimit : 4;

		return {
			strokeColor: color,
			strokeWidth: width,
			strokeLineJoin: lineJoin,
			strokeLineCap: lineCap,
			strokeMiterLimit: miterLimit
		};

	}

	static pointsToStroke( points, style, arcDivisions, minDistance ) {

		// Generates a stroke with some width around the given path.
		// The path can be open or closed (last point equals to first point)
		// Param points: Array of Vector2D (the path). Minimum 2 points.
		// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object
		// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)
		// Param minDistance: Points closer to this distance will be merged. (Optional)
		// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)

		const vertices = [];
		const normals = [];
		const uvs = [];

		if ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {

			return null;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		return geometry;

	}

	static pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {

		// This function can be called to update existing arrays or buffers.
		// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.
		// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)
		// Returns number of written vertices / normals / uvs pairs
		// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)
		// 'normals' and 'uvs' buffers are optional

		const tempV2_1 = new Vector2();
		const tempV2_2 = new Vector2();
		const tempV2_3 = new Vector2();
		const tempV2_4 = new Vector2();
		const tempV2_5 = new Vector2();
		const tempV2_6 = new Vector2();
		const tempV2_7 = new Vector2();
		const lastPointL = new Vector2();
		const lastPointR = new Vector2();
		const point0L = new Vector2();
		const point0R = new Vector2();
		const currentPointL = new Vector2();
		const currentPointR = new Vector2();
		const nextPointL = new Vector2();
		const nextPointR = new Vector2();
		const innerPoint = new Vector2();
		const outerPoint = new Vector2();

		arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;
		minDistance = minDistance !== undefined ? minDistance : 0.001;
		vertexOffset = vertexOffset !== undefined ? vertexOffset : 0;

		// First ensure there are no duplicated points
		points = removeDuplicatedPoints( points );

		const numPoints = points.length;

		if ( numPoints < 2 ) return 0;

		const isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );

		

		let currentPoint;
		let previousPoint = points[ 0 ];
		let nextPoint;

		const strokeWidth2 = style.strokeWidth / 2;

		const deltaU = 1 / ( numPoints - 1 );
		let u0 = 0, u1;

		let innerSideModified;
		let joinIsOnLeftSide;
		let isMiter;
		let initialJoinIsOnLeftSide = false;

		let numVertices = 0;
		let currentCoordinate = vertexOffset * 3;
		let currentCoordinateUV = vertexOffset * 2;

		// Get initial left and right stroke points
		getNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );
		lastPointL.copy( points[ 0 ] ).sub( tempV2_1 );
		lastPointR.copy( points[ 0 ] ).add( tempV2_1 );
		point0L.copy( lastPointL );
		point0R.copy( lastPointR );

		for ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {

			currentPoint = points[ iPoint ];

			// Get next point
			if ( iPoint === numPoints - 1 ) {

				if ( isClosed ) {

					// Skip duplicated initial point
					nextPoint = points[ 1 ];

				} else nextPoint = undefined;

			} else {

				nextPoint = points[ iPoint + 1 ];

			}

			// Normal of previous segment in tempV2_1
			const normal1 = tempV2_1;
			getNormal( previousPoint, currentPoint, normal1 );

			tempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );
			currentPointL.copy( currentPoint ).sub( tempV2_3 );
			currentPointR.copy( currentPoint ).add( tempV2_3 );

			u1 = u0 + deltaU;

			innerSideModified = false;

			if ( nextPoint !== undefined ) {

				// Normal of next segment in tempV2_2
				getNormal( currentPoint, nextPoint, tempV2_2 );

				tempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );
				nextPointL.copy( currentPoint ).sub( tempV2_3 );
				nextPointR.copy( currentPoint ).add( tempV2_3 );

				joinIsOnLeftSide = true;
				tempV2_3.subVectors( nextPoint, previousPoint );
				if ( normal1.dot( tempV2_3 ) < 0 ) {

					joinIsOnLeftSide = false;

				}

				if ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;

				tempV2_3.subVectors( nextPoint, currentPoint );
				tempV2_3.normalize();
				const dot = Math.abs( normal1.dot( tempV2_3 ) );

				// If path is straight, don't create join
				if ( dot > Number.EPSILON ) {

					// Compute inner and outer segment intersections
					const miterSide = strokeWidth2 / dot;
					tempV2_3.multiplyScalar( - miterSide );
					tempV2_4.subVectors( currentPoint, previousPoint );
					tempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );
					innerPoint.copy( tempV2_5 ).negate();
					const miterLength2 = tempV2_5.length();
					const segmentLengthPrev = tempV2_4.length();
					tempV2_4.divideScalar( segmentLengthPrev );
					tempV2_6.subVectors( nextPoint, currentPoint );
					const segmentLengthNext = tempV2_6.length();
					tempV2_6.divideScalar( segmentLengthNext );
					// Check that previous and next segments doesn't overlap with the innerPoint of intersection
					if ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {

						innerSideModified = true;

					}

					outerPoint.copy( tempV2_5 ).add( currentPoint );
					innerPoint.add( currentPoint );

					isMiter = false;

					if ( innerSideModified ) {

						if ( joinIsOnLeftSide ) {

							nextPointR.copy( innerPoint );
							currentPointR.copy( innerPoint );

						} else {

							nextPointL.copy( innerPoint );
							currentPointL.copy( innerPoint );

						}

					} else {

						// The segment triangles are generated here if there was overlapping

						makeSegmentTriangles();

					}

					switch ( style.strokeLineJoin ) {

						case 'bevel':

							makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );

							break;

						case 'round':

							// Segment triangles

							createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );

							// Join triangles

							if ( joinIsOnLeftSide ) {

								makeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );

							} else {

								makeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );

							}

							break;

						case 'miter':
						case 'miter-clip':
						default:

							const miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;

							if ( miterFraction < 1 ) {

								// The join miter length exceeds the miter limit

								if ( style.strokeLineJoin !== 'miter-clip' ) {

									makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );
									break;

								} else {

									// Segment triangles

									createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );

									// Miter-clip join triangles

									if ( joinIsOnLeftSide ) {

										tempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );
										tempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );

										addVertex( currentPointL, u1, 0 );
										addVertex( tempV2_6, u1, 0 );
										addVertex( currentPoint, u1, 0.5 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( tempV2_6, u1, 0 );
										addVertex( tempV2_7, u1, 0 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( tempV2_7, u1, 0 );
										addVertex( nextPointL, u1, 0 );

									} else {

										tempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );
										tempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );

										addVertex( currentPointR, u1, 1 );
										addVertex( tempV2_6, u1, 1 );
										addVertex( currentPoint, u1, 0.5 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( tempV2_6, u1, 1 );
										addVertex( tempV2_7, u1, 1 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( tempV2_7, u1, 1 );
										addVertex( nextPointR, u1, 1 );

									}

								}

							} else {

								// Miter join segment triangles

								if ( innerSideModified ) {

									// Optimized segment + join triangles

									if ( joinIsOnLeftSide ) {

										addVertex( lastPointR, u0, 1 );
										addVertex( lastPointL, u0, 0 );
										addVertex( outerPoint, u1, 0 );

										addVertex( lastPointR, u0, 1 );
										addVertex( outerPoint, u1, 0 );
										addVertex( innerPoint, u1, 1 );

									} else {

										addVertex( lastPointR, u0, 1 );
										addVertex( lastPointL, u0, 0 );
										addVertex( outerPoint, u1, 1 );

										addVertex( lastPointL, u0, 0 );
										addVertex( innerPoint, u1, 0 );
										addVertex( outerPoint, u1, 1 );

									}


									if ( joinIsOnLeftSide ) {

										nextPointL.copy( outerPoint );

									} else {

										nextPointR.copy( outerPoint );

									}


								} else {

									// Add extra miter join triangles

									if ( joinIsOnLeftSide ) {

										addVertex( currentPointL, u1, 0 );
										addVertex( outerPoint, u1, 0 );
										addVertex( currentPoint, u1, 0.5 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( outerPoint, u1, 0 );
										addVertex( nextPointL, u1, 0 );

									} else {

										addVertex( currentPointR, u1, 1 );
										addVertex( outerPoint, u1, 1 );
										addVertex( currentPoint, u1, 0.5 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( outerPoint, u1, 1 );
										addVertex( nextPointR, u1, 1 );

									}

								}

								isMiter = true;

							}

							break;

					}

				} else {

					// The segment triangles are generated here when two consecutive points are collinear

					makeSegmentTriangles();

				}

			} else {

				// The segment triangles are generated here if it is the ending segment

				makeSegmentTriangles();

			}

			if ( ! isClosed && iPoint === numPoints - 1 ) {

				// Start line endcap
				addCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );

			}

			// Increment loop variables

			u0 = u1;

			previousPoint = currentPoint;

			lastPointL.copy( nextPointL );
			lastPointR.copy( nextPointR );

		}

		if ( ! isClosed ) {

			// Ending line endcap
			addCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );

		} else if ( innerSideModified && vertices ) {

			// Modify path first segment vertices to adjust to the segments inner and outer intersections

			let lastOuter = outerPoint;
			let lastInner = innerPoint;

			if ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {

				lastOuter = innerPoint;
				lastInner = outerPoint;

			}

			if ( joinIsOnLeftSide ) {

				if ( isMiter || initialJoinIsOnLeftSide ) {

					lastInner.toArray( vertices, 0 * 3 );
					lastInner.toArray( vertices, 3 * 3 );

					if ( isMiter ) {

						lastOuter.toArray( vertices, 1 * 3 );

					}

				}

			} else {

				if ( isMiter || ! initialJoinIsOnLeftSide ) {

					lastInner.toArray( vertices, 1 * 3 );
					lastInner.toArray( vertices, 3 * 3 );

					if ( isMiter ) {

						lastOuter.toArray( vertices, 0 * 3 );

					}

				}

			}

		}

		return numVertices;

		// -- End of algorithm

		// -- Functions

		function getNormal( p1, p2, result ) {

			result.subVectors( p2, p1 );
			return result.set( - result.y, result.x ).normalize();

		}

		function addVertex( position, u, v ) {

			if ( vertices ) {

				vertices[ currentCoordinate ] = position.x;
				vertices[ currentCoordinate + 1 ] = position.y;
				vertices[ currentCoordinate + 2 ] = 0;

				if ( normals ) {

					normals[ currentCoordinate ] = 0;
					normals[ currentCoordinate + 1 ] = 0;
					normals[ currentCoordinate + 2 ] = 1;

				}

				currentCoordinate += 3;

				if ( uvs ) {

					uvs[ currentCoordinateUV ] = u;
					uvs[ currentCoordinateUV + 1 ] = v;

					currentCoordinateUV += 2;

				}

			}

			numVertices += 3;

		}

		function makeCircularSector( center, p1, p2, u, v ) {

			// param p1, p2: Points in the circle arc.
			// p1 and p2 are in clockwise direction.

			tempV2_1.copy( p1 ).sub( center ).normalize();
			tempV2_2.copy( p2 ).sub( center ).normalize();

			let angle = Math.PI;
			const dot = tempV2_1.dot( tempV2_2 );
			if ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );

			angle /= arcDivisions;

			tempV2_3.copy( p1 );

			for ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {

				tempV2_4.copy( tempV2_3 ).rotateAround( center, angle );

				addVertex( tempV2_3, u, v );
				addVertex( tempV2_4, u, v );
				addVertex( center, u, 0.5 );

				tempV2_3.copy( tempV2_4 );

			}

			addVertex( tempV2_4, u, v );
			addVertex( p2, u, v );
			addVertex( center, u, 0.5 );

		}

		function makeSegmentTriangles() {

			addVertex( lastPointR, u0, 1 );
			addVertex( lastPointL, u0, 0 );
			addVertex( currentPointL, u1, 0 );

			addVertex( lastPointR, u0, 1 );
			addVertex( currentPointL, u1, 1 );
			addVertex( currentPointR, u1, 0 );

		}

		function makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {

			if ( innerSideModified ) {

				// Optimized segment + bevel triangles

				if ( joinIsOnLeftSide ) {

					// Path segments triangles

					addVertex( lastPointR, u0, 1 );
					addVertex( lastPointL, u0, 0 );
					addVertex( currentPointL, u1, 0 );

					addVertex( lastPointR, u0, 1 );
					addVertex( currentPointL, u1, 0 );
					addVertex( innerPoint, u1, 1 );

					// Bevel join triangle

					addVertex( currentPointL, u, 0 );
					addVertex( nextPointL, u, 0 );
					addVertex( innerPoint, u, 0.5 );

				} else {

					// Path segments triangles

					addVertex( lastPointR, u0, 1 );
					addVertex( lastPointL, u0, 0 );
					addVertex( currentPointR, u1, 1 );

					addVertex( lastPointL, u0, 0 );
					addVertex( innerPoint, u1, 0 );
					addVertex( currentPointR, u1, 1 );

					// Bevel join triangle

					addVertex( currentPointR, u, 1 );
					addVertex( nextPointR, u, 0 );
					addVertex( innerPoint, u, 0.5 );

				}

			} else {

				// Bevel join triangle. The segment triangles are done in the main loop

				if ( joinIsOnLeftSide ) {

					addVertex( currentPointL, u, 0 );
					addVertex( nextPointL, u, 0 );
					addVertex( currentPoint, u, 0.5 );

				} else {

					addVertex( currentPointR, u, 1 );
					addVertex( nextPointR, u, 0 );
					addVertex( currentPoint, u, 0.5 );

				}

			}

		}

		function createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {

			if ( innerSideModified ) {

				if ( joinIsOnLeftSide ) {

					addVertex( lastPointR, u0, 1 );
					addVertex( lastPointL, u0, 0 );
					addVertex( currentPointL, u1, 0 );

					addVertex( lastPointR, u0, 1 );
					addVertex( currentPointL, u1, 0 );
					addVertex( innerPoint, u1, 1 );

					addVertex( currentPointL, u0, 0 );
					addVertex( currentPoint, u1, 0.5 );
					addVertex( innerPoint, u1, 1 );

					addVertex( currentPoint, u1, 0.5 );
					addVertex( nextPointL, u0, 0 );
					addVertex( innerPoint, u1, 1 );

				} else {

					addVertex( lastPointR, u0, 1 );
					addVertex( lastPointL, u0, 0 );
					addVertex( currentPointR, u1, 1 );

					addVertex( lastPointL, u0, 0 );
					addVertex( innerPoint, u1, 0 );
					addVertex( currentPointR, u1, 1 );

					addVertex( currentPointR, u0, 1 );
					addVertex( innerPoint, u1, 0 );
					addVertex( currentPoint, u1, 0.5 );

					addVertex( currentPoint, u1, 0.5 );
					addVertex( innerPoint, u1, 0 );
					addVertex( nextPointR, u0, 1 );

				}

			}

		}

		function addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {

			// param center: End point of the path
			// param p1, p2: Left and right cap points

			switch ( style.strokeLineCap ) {

				case 'round':

					if ( start ) {

						makeCircularSector( center, p2, p1, u, 0.5 );

					} else {

						makeCircularSector( center, p1, p2, u, 0.5 );

					}

					break;

				case 'square':

					if ( start ) {

						tempV2_1.subVectors( p1, center );
						tempV2_2.set( tempV2_1.y, - tempV2_1.x );

						tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );
						tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );

						// Modify already existing vertices
						if ( joinIsOnLeftSide ) {

							tempV2_3.toArray( vertices, 1 * 3 );
							tempV2_4.toArray( vertices, 0 * 3 );
							tempV2_4.toArray( vertices, 3 * 3 );

						} else {

							tempV2_3.toArray( vertices, 1 * 3 );
							tempV2_3.toArray( vertices, 3 * 3 );
							tempV2_4.toArray( vertices, 0 * 3 );

						}

					} else {

						tempV2_1.subVectors( p2, center );
						tempV2_2.set( tempV2_1.y, - tempV2_1.x );

						tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );
						tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );

						const vl = vertices.length;

						// Modify already existing vertices
						if ( joinIsOnLeftSide ) {

							tempV2_3.toArray( vertices, vl - 1 * 3 );
							tempV2_4.toArray( vertices, vl - 2 * 3 );
							tempV2_4.toArray( vertices, vl - 4 * 3 );

						} else {

							tempV2_3.toArray( vertices, vl - 2 * 3 );
							tempV2_4.toArray( vertices, vl - 1 * 3 );
							tempV2_4.toArray( vertices, vl - 4 * 3 );

						}

					}

					break;

			}

		}

		function removeDuplicatedPoints( points ) {

			// Creates a new array if necessary with duplicated points removed.
			// This does not remove duplicated initial and ending points of a closed path.

			let dupPoints = false;
			for ( let i = 1, n = points.length - 1; i < n; i ++ ) {

				if ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {

					dupPoints = true;
					break;

				}

			}

			if ( ! dupPoints ) return points;

			const newPoints = [];
			newPoints.push( points[ 0 ] );

			for ( let i = 1, n = points.length - 1; i < n; i ++ ) {

				if ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {

					newPoints.push( points[ i ] );

				}

			}

			newPoints.push( points[ points.length - 1 ] );

			return newPoints;

		}

	}


}

class AutoSvg extends Mesh {

	constructor ( model, option = {}, material = null  ) {

		super();

		this.model = model;

		this.material = material;
		this.outMaterial = material ? true : false;

		this.XML = new XMLSerializer();
		this.color = new Color();
		this.opacity = 1;
		this.svgLoader = new SVGLoader();
		this.base = "http://www.w3.org/2000/svg";
		this.svg = document.createElementNS( this.base, 'svg' );
		this.layerUp = 0.0001;
		this.fill = true;
		this.stroke = true;

		this.size = option.size || 1;
		this.scaler = 1/this.size;

		//let w = 10
		//this.set( { viewBox:'0 0 '+w+' '+w, width:w, height:w, preserveAspectRatio:'none' })

		if( !this.model ) return;

		let o = {
			radius: 5, 
			min:90, 
			max:90, 
			strokeSize:0.25,
			...option
		};

		switch( this.model ){

			case 'angle':
			this.fill = o.fill !== undefined ? o.fill : true;
	        this.stroke = o.stroke !== undefined ? o.stroke : true;
	        let min = Math.abs(o.min);
			this.add( 'path', { d: this.circle(0,0, o.radius, 180,180+o.max, true ), stroke:'none', fill:'#FF0000', 'fill-opacity':0.1 } );
			this.add( 'path', { d: this.circle(0,0, o.radius, 180,180+o.max, false, false, 0.3), stroke:'#FF0000', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'round' } );
			this.add( 'path', { d: this.circle(0,0, o.radius, 180-min,180, true ), stroke:'none', fill:'#0050FF', 'fill-opacity':0.1 } );
	        this.add( 'path', { d: this.circle(0,0, o.radius, 180-min,180, false, false, 0.3, true), stroke:'#0050FF', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'round' } );
			break;

			case 'liner':
			let r = o.radius*0.5;
			let y1 = o.max*this.scaler;
			let y2 = o.min*this.scaler;
			this.fill = o.fill !== undefined ? o.fill : true;
	        this.stroke = o.stroke !== undefined ? o.stroke : true;
	        this.add( 'path', { d: this.segment({x:-r, y:0}, {x:r, y:0} ), stroke:'#FFFFFF', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'butt' } );
	        this.add( 'path', { d: this.segment({x:-r, y:y1}, {x:r, y:y1} ), stroke:'#FF0000', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'butt' } );
	        this.add( 'path', { d: this.segment({x:-r, y:y2}, {x:r, y:y2} ), stroke:'#0050FF', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'butt' } );
	        //
	        this.add( 'path', { d: this.segment({x:0, y:0}, {x:0, y:y1} ), stroke:'#FF0000', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'butt' } );
	        this.add( 'path', { d: this.segment({x:0, y:0}, {x:0, y:y2} ), stroke:'#0050FF', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'butt' } );
	        break;

			case 'needle':
			this.fill = o.fill !== undefined ? o.fill : true;
	        this.stroke = o.stroke !== undefined ? o.stroke : true;
			this.add( 'path', { d: this.circle(0,0, 0.7, 0, 360, false, true, 0), stroke:'#FFFFFF', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'butt' } );
			this.add( 'path', { d: this.segment({x:0, y:0}, {x:0, y:4.4} ), stroke:'#FFFFFF', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'round' } );
			break;

			case 'middle':
			let mm = o.radius*0.5;
			this.fill = o.fill !== undefined ? o.fill : true;
	        this.stroke = o.stroke !== undefined ? o.stroke : true;
			this.add( 'path', { d: this.circle(0,0, 0.7, 0, 360, false, true, 0), stroke:'#FFFFFF', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'butt' } );
			this.add( 'path', { d: this.segment({x:0, y:-mm}, {x:0, y:mm} ), stroke:'#FFFFFF', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'butt' } );
			this.add( 'path', { d: this.segment({x:-mm, y:0}, {x:mm, y:0} ), stroke:'#FFFFFF', 'stroke-opacity':1, 'stroke-width':o.strokeSize, fill:'none', 'stroke-linecap':'butt' } );
			break;


		}

		this.toMesh();

	}

	raycast(){
		return false;
	}

	update( option = {} ){

		let o = {};

		switch( this.model ){

			case 'angle':

			o = {
				radius: 5,
				min:-90,
				max:90,
				...option
			};

			let min = Math.abs(o.min);

			this.change( 'd', this.circle(0,0, o.radius, 180,180+o.max, true ), 0 );
			this.change( 'd', this.circle(0,0, o.radius, 180,180+o.max, false, false, 0.3), 1 );

			this.change( 'd', this.circle(0,0, o.radius, 180-min,180, true ), 2 );
	        this.change( 'd', this.circle(0,0, o.radius, 180-min,180, false, false, 0.3, true), 3 );



			break;

		}

		if( option.wireframe !== undefined ) this.material.wireframe = option.wireframe;

		// redraw
	    this.fill = o.fill !== undefined ? o.fill : true;
	    this.stroke = o.stroke !== undefined ? o.stroke : true;
		this.toMesh();

	}

	// SVG SIDE

	set( o = {}, parent ){
		for( let t in o ){
            if( parent ) parent.setAttributeNS( null, t, o[ t ] );
            else this.svg.setAttributeNS( null, t, o[ t ] );
        }
	}

	add( type, o = {} ){

		let g = document.createElementNS( this.base, type );
		this.set( o, g );
		this.svg.appendChild( g );

	}

	change( type, value, id ){

		this.svg.childNodes[ id ].setAttributeNS( null, type, value );

	}

	getString(){
		return this.XML.serializeToString(this.svg);
	}

	polarToCartesian( x, y, radius, angleInDegrees ){
	    var rad = (angleInDegrees-90) * Math.PI / 180.0;
	    return { x: x + (radius * Math.cos(rad)), y: y + (radius * Math.sin(rad)) };
	}

	circle( x, y, radius, startAngle = 0, endAngle = 360, tri = false, close = false, endTag = 0, over=false ){

		if( startAngle === 0 && endAngle === 360 ){ startAngle = 0.0001; close = true; }
	    let start = this.polarToCartesian(x, y, radius, endAngle);
	    let end = this.polarToCartesian(x, y, radius, startAngle);
	    let arcSweep = endAngle - startAngle <= 180 ? "0" : "1";
	    let d = [
	        "M", start.x, start.y, 
	        "A", radius, radius, 0, arcSweep, 0, end.x, end.y,
	    ];
	    if( tri ) d.push(
	    	"L", x,y,
	    	"L", start.x, start.y
	    );
	    if( close ) d.push( 'Z');

		if( endTag!==0 ){
			let p1 = this.polarToCartesian(x, y, radius-endTag, over ? startAngle:endAngle);
			let p2 = this.polarToCartesian(x, y, radius+endTag, over ? startAngle:endAngle);
			d.push( 'M', p1.x, p1.y,"L", p2.x, p2.y);
		}

	    return d.join(" ");

	}

	segment( p1, p2 ){
		let d = [ 'M', p1.x, p1.y,"L", p2.x, p2.y ];
		return d.join(" ");
	}

	// THREE SIDE

	geomColor( g, color, opacity = 1 ){

		let i = g.attributes.position.count;
		let cc = [];//, aa = []
		while(i--){ 
			cc.push( color.r, color.g, color.b, opacity );
			//aa.push( opacity )
		}

		//g.setAttribute( 'opacity', new Float32BufferAttribute( aa, 1 ) );
		g.setAttribute( 'color', new Float32BufferAttribute( cc, 4 ) );

	}

	toGeometry(){

		if ( !this.fill && !this.stroke ) return null;

		let geom = [];
		let layer = 0;
		let opacity = 1;
		let data = this.svgLoader.parse( this.getString() );
		
		for ( const path of data.paths ) {

			// FILL
			const fillColor = path.userData.style.fill;
			if ( this.fill && fillColor !== undefined && fillColor !== 'none' ) {

				this.color.setStyle( fillColor );
				opacity = path.userData.style.fillOpacity;
				if( opacity < this.opacity ) this.opacity = opacity;

				const shapes = SVGLoader.createShapes( path );

				for ( const shape of shapes ) {

					const geometry = new ShapeGeometry( shape );
					if ( geometry ) {

						this.geomColor( geometry, this.color, opacity );

						let gg = new BufferGeometry().copy(geometry).toNonIndexed();
						gg.translate( 0, 0, -layer*this.layerUp );
						geom.push( gg );

						layer++;
					}

				}
			}

			// STROKE
			const strokeColor = path.userData.style.stroke;
			if ( this.stroke && strokeColor !== undefined && strokeColor !== 'none' ) {

				this.color.setStyle( strokeColor );
				opacity = path.userData.style.strokeOpacity;
				if( opacity < this.opacity ) this.opacity = opacity;

				for ( const subPath of path.subPaths ) {

					const geometry = SVGLoader.pointsToStroke( subPath.getPoints(), path.userData.style, 6 );
					if ( geometry ) {
						this.geomColor( geometry, this.color, opacity );

						geometry.translate( 0, 0, -layer*this.layerUp );

						//console.log(geometry)
						geom.push( geometry );

						layer++;
					}
				}
			}

		}

		return geom;

	}

	toMesh(){

		let s = this.size;

		if( this.geometry ) this.geometry.dispose();
		
		let tmpG = this.toGeometry();
        
        if( tmpG ){
		    this.geometry = mergeGeometries( tmpG );
			this.geometry.scale( s, -s, s );
			this.geometry.rotateY( Math.PI );
			this.geometry.rotateZ( -Math.PI*0.5 );
			this.geometry.rotateY( Math.PI*0.5 );
			this.geometry.computeBoundingSphere();
		} else {
			this.geometry = new BufferGeometry();
		}

		if( this.material === null ){ 
			this.material = new MeshBasicMaterial({ vertexColors:true, transparent:this.opacity!==1, side:DoubleSide });
			this.material.defines = { 'USE_COLOR_ALPHA': '' };
		}

	}

	dispose(){
		
		if( this.material && !this.outMaterial ) this.material.dispose();
		if( this.geometry ) this.geometry.dispose();
	}

}

class JointDebug extends Basic3D {

	constructor( o = {}, motor ) {

	    super();

	    this.motor = motor;

	    this.isJoint = true;

	    this.type = 'joint';
	    this.mode = o.mode || 'hinge';
	    this.visible = o.visible !== undefined ? o.visible : false;
	    
	    this.mtx = new Matrix4();
	    this.size = o.helperSize || 0.1;

	    let material = this.motor.mat.get('line');
	    let mat, dt;

	    switch( this.mode ){
	    	case 'prismatic':
	    	    mat = this.motor.mat.get('svg');
		    	dt = {
					min:-180,
					max:180,
					fill:false,
					stroke:true,
					wireframe:false,
					size:this.size*0.5
				};

				if(o.lm){
					dt.min = o.lm[0];
					dt.max = o.lm[1];
				}
				this.m1 = new AutoSvg('liner', dt, mat );
		    	this.m2 = new AutoSvg('middle', dt, mat );

		    	this.m1.geometry.rotateY(90 * MathTool.torad);

		    	//this.m3 = this.m1.clone()
		    	//this.m3.rotation.x = 90 * MathTool.torad

		    	this.add( this.m1 );
		    	this.add( this.m2 );
		    	//this.add( this.m3 );

	    	break;
	    	case 'hinge': case 'cylindrical':

		    	mat = this.motor.mat.get('svg');
		    	dt = {
					min:-180,
					max:180,
					fill:false,
					stroke:true,
					wireframe:false,
					size:this.size*0.5
				};

				if(o.lm){
					dt.min = o.lm[0];
					dt.max = o.lm[1];
				}

				if(o.lmr){ // cylindrical
					dt.min = o.lmr[0];
					dt.max = o.lmr[1];
				}

		    	this.m1 = new AutoSvg('angle', dt, mat );
		    	this.m2 = new AutoSvg('needle', dt, mat );

		    	this.add( this.m1 );
		    	this.add( this.m2 );

	    	break;
	    	default:

		    	const geom = this.motor.geo.get('joint');
			    let g = geom.clone(); 
			    g.scale( this.size, this.size, this.size);
			    this.m1 = new LineSegments( g, material );
			    
			    
			    this.add( this.m1 );

			    g = geom.clone(); 
			    g.scale( this.size*0.8, this.size*0.8, this.size*0.8 );
			    this.m2 = new LineSegments( g, material );
			    //this.m2.scale.set( this.size, this.size, this.size)
			    this.add( this.m2 );
		    
	    	break;
	    }


	    this.m1.matrixAutoUpdate = false;
	    this.m2.matrixAutoUpdate = false;

		//    this.m2.updateMatrix()
		//    this.m1.updateMatrix()




	    this.body1 = null;
	    this.body2 = null;

	    this.mat1 = new Matrix4();
	    this.mat2 = new Matrix4();
	    this.end = new Vector3();

	    // experimental rotation ?
	    //Utils.refAxis( this.mat1, o.axis1 )
	    //Utils.refAxis( this.mat2, o.axis2 )

	    let qq = new Quaternion$1();
	    if(o.quat1) this.mat1.makeRotationFromQuaternion(qq.fromArray(o.quat1));
	    if(o.quat2) this.mat2.makeRotationFromQuaternion(qq.fromArray(o.quat2));

	    this.mat1.setPosition( o.pos1[0], o.pos1[1], o.pos1[2] );
	    this.mat2.setPosition( o.pos2[0], o.pos2[1], o.pos2[2] );
	    
	    
	    const positions = [ 0, 0, 0, 0, 0, 0 ];
	    const colors = [ 1, 0, 0, 1, 0, 0 ];
	    const gline = new BufferGeometry();
	    gline.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	    gline.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	    gline.computeBoundingSphere();


	    this.m3 = new LineSegments( gline, material );
	    this.add( this.m3 );
	    this.m3.matrixAutoUpdate = false;

	    this.pp = this.m3.geometry.attributes.position;

	}

	update () {

		if( !this.visible ) return

		if( this.body1 ){
			this.matrix.copy( this.body1.matrixWorld ).multiply( this.mat1 );
		} else {
			this.matrix.copy( this.mat1 );
		}

		if( this.body2 ){
			this.m2.matrix.copy( this.body2.matrixWorld ).multiply( this.mat2 );
		} else {
			this.m2.matrix.copy( this.mat2 );
		}

		this.m2.matrix.premultiply(this.matrix.clone().invert());
		this.end.setFromMatrixPosition( this.m2.matrix );





		//m.matrix = b.matrixWorld;
        //m.matrixAutoUpdate = false;

		//this.position.fromArray( r, n );
		//this.quaternion.fromArray( r, n + 3 );

		//this.updateMatrix();

		//this.m2.position.fromArray( r, n+7 );
		//this.m2.quaternion.fromArray( r, n+10 );
		//this.m2.matrix.compose( this.m2.position, this.m2.quaternion, {x:1,y:1,z:1} );

		//this.mtx.copy( this.matrix ).invert().multiply( this.m2.matrix );
		//this.mtx.decompose( this.m2.position, this.m2.quaternion, {x:1,y:1,z:1} );
		//this.m2.updateMatrix();

		//const position = this.m3.geometry.attributes.position;
		//position.setXYZ(1, this.m2.position.x, this.m2.position.y, this.m2.position.z)

		this.pp.setXYZ(1, this.end.x, this.end.y, this.end.z);
		this.pp.needsUpdate = true;

		if( this.mode === 'cylindrical' ){ 
			this.m1.position.copy( this.end );
			this.m1.updateMatrix();
		}

		if( !this.visible ) this.visible = true;

	}

	updateFromPhy ( r, n = 0 ) {

		//if( !this.isVisible ) return
		if( !this.visible ) return


		//m.matrix = b.matrixWorld;
        //m.matrixAutoUpdate = false;

		this.position.fromArray( r, n );
		this.quaternion.fromArray( r, n + 3 );

		this.updateMatrix();

		this.m2.position.fromArray( r, n+7 );
		this.m2.quaternion.fromArray( r, n+10 );
		this.m2.matrix.compose( this.m2.position, this.m2.quaternion, {x:1,y:1,z:1} );

		this.mtx.copy( this.matrix ).invert().multiply( this.m2.matrix );
		this.mtx.decompose( this.m2.position, this.m2.quaternion, {x:1,y:1,z:1} );
		this.m2.updateMatrix();


		this.pp.setXYZ(1, this.m2.position.x, this.m2.position.y, this.m2.position.z);
		this.pp.needsUpdate = true;

		if( this.mode === 'cylindrical' ){ 
			this.m1.position.copy( this.m2.position );
			this.m1.updateMatrix();
		}

		if( !this.visible ) this.visible = true;

	}

	dispose (){

		if( this.body1 ) this.body1.link--;
		if( this.body2 ) this.body2.link--;

		this.m1.geometry.dispose();
		this.m2.geometry.dispose();
		this.m3.geometry.dispose();
		this.children = [];

	}

}

//----------------
//  MOTOR JOINT 
//----------------

class Joint extends Item {

	constructor ( motor ) {

		super();

		this.motor = motor;
		this.engine = this.motor.engine;
		this.Utils = this.motor.utils;

		this.type = 'joint';

		this.v1 = new Vector3();
		this.v2 = new Vector3();

	}

	step (AR, N) {

		let i = this.list.length, j, n;
		
		while( i-- ){

			j = this.list[i];
			n = N + ( i * Num.joint );
			if( Num.joint === 16 ) j.updateFromPhy( AR, n );
			else j.update();

		}

	}

	///

	add ( o = {} ) {

		let name = this.setName( o );

		let body1 = null;
		let body2 = null;
		let isString;

		let isWorldAxis = false;

		if( !o.axis1 ) o.axis1 = [1,0,0];
		if( !o.axis2 ) o.axis2 = [1,0,0];

		if( !o.pos1 ) o.pos1 = [0,0,0];
		if( !o.pos2 ) o.pos2 = [0,0,0];

		if( o.limit ) o.lm = o.limit;
		else if( o.lm ) o.limit = o.lm;

		// STRICT MODE

		if(o.mode==='universal'||o.mode==='dof'||o.mode==='d6') o.mode = 'generic';
		if(o.mode==='revolute') o.mode = 'hinge';
		if(o.mode==='slider') o.mode = 'cylindrical';

		// GET BODY REFERENCY

		if( o.b1 ) {
			isString = typeof o.b1 === 'string';
			body1 = isString ? this.Utils.byName( o.b1 ) : o.b1;
			if( !isString ) o.b1 = o.b1.name;
			if( body1 ) body1.link ++;
		}

		if( o.b2 ) {
			isString = typeof o.b2 === 'string';
			body2 = isString ? this.Utils.byName( o.b2 ) : o.b2;
			if( !isString ) o.b2 = o.b2.name;
			if( body2 ) body2.link ++;
		}

		// world to local
		if ( o.worldPos ) o.worldAnchor = o.worldPos;
		if ( o.worldAnchor ){

			o.pos1 = body1 ? this.Utils.toLocal( this.v1.fromArray( o.worldAnchor ), body1 ).toArray() : o.worldAnchor;
			o.pos2 = body2 ? this.Utils.toLocal( this.v2.fromArray( o.worldAnchor ), body2 ).toArray() : o.worldAnchor;
			/*if(body1){ 
				this.v1 = body1.worldToLocal(this.v2.fromArray( o.worldAnchor ));
				o.pos1 = this.v1.toArray();
			}
			if(body2){ 
				this.v1 = body2.worldToLocal(this.v2.fromArray( o.worldAnchor ));
				o.pos2 = this.v1.toArray();
			}*/
			delete o.worldAnchor;
		}

		if ( o.worldAxis ){

			
			/*if( this.engine === 'JOLT'){
				o.axis1 = o.worldAxis;
				o.axis2 = o.worldAxis;
			}else{*/
				o.axis1 = body1 ? this.Utils.toLocal( this.v1.fromArray( o.worldAxis ), body1, true ).toArray() : o.worldAxis;
			    o.axis2 = body2 ? this.Utils.toLocal( this.v2.fromArray( o.worldAxis ), body2, true ).toArray() : o.worldAxis;
			//}
			
			//o.quat1 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis1).normalize() ).toArray();
		    //o.quat2 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis2).normalize() ).toArray();

			//console.log(o.worldAxis, o.axis1, o.axis2)
			isWorldAxis = true;

			delete o.worldAxis;

		}

		if ( o.worldQuat ){

			o.quat1 = this.Utils.quatLocal(o.worldQuat, body1);
			o.quat2 = this.Utils.quatLocal(o.worldQuat, body2);



			if( this.engine === 'OIMO' || this.engine === 'HAVOK' || this.engine === 'JOLT' ){

				//this.v1.fromArray( math.quadToAxisArray( o.worldQuat ) ).normalize()
				//this.v2.fromArray( math.quadToAxisArray( o.worldQuat ) ).normalize()

				//o.axis1 = Utils.axisLocal( math.quadToAxisArray( o.worldQuat ), body1)//this.v1.fromArray( math.quadToAxisArray( o.quat1 ) ).normalize().toArray()
				//o.axis2 = Utils.axisLocal( math.quadToAxisArray( o.worldQuat ), body2)//this.v2.fromArray( math.quadToAxisArray( o.quat2 ) ).normalize().toArray()

				o.axis1 = this.Utils.axisLocal( MathTool.quatToAxis( o.worldQuat ), body1);
				o.axis2 = this.Utils.axisLocal( MathTool.quatToAxis( o.worldQuat ), body2);

				//o.axis1 = body1 ? Utils.toLocal( this.v1, body1, true ).toArray():[1,0,0]
				//o.axis2 = body2 ? Utils.toLocal( this.v2, body2, true ).toArray():[1,0,0]

			}
			/*this.v1.fromArray( o.worldAxis ) 
			this.v2.fromArray( o.worldAxis )

			o.axis1 = body1 ? Utils.toLocal( this.v1, body1, true ).normalize().toArray():o.worldAxis
			o.axis2 = body2 ? Utils.toLocal( this.v2, body2, true ).normalize().toArray():o.worldAxis
*/
			//o.quat1 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis1).normalize() ).toArray();
		    //o.quat2 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis2).normalize() ).toArray();

			//console.log(o.worldQuat, o.quat1, o.quat2)

			delete o.worldQuat;

		}

		

		

		/*if( o.b2 ) body2 = typeof o.b2 !== 'string' ? o.b2 : Utils.byName(o.b2)
		if( o.b1 && typeof o.b1 !== 'string') o.b1 = o.b1.name;
		if( o.b2 && typeof o.b2 !== 'string') o.b2 = o.b2.name;*/

		if( o.rot1 !== undefined ){ o.quat1 = MathTool.quatFromEuler( o.rot1 ); delete ( o.rot1 ); }
		if( o.rot2 !== undefined ){ o.quat2 = MathTool.quatFromEuler( o.rot2 ); delete ( o.rot2 ); }

		if( !o.quat1 ) o.quat1 = new Quaternion$1().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis1).normalize() ).toArray();
		if( !o.quat2 ) o.quat2 = new Quaternion$1().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis2).normalize() ).toArray();

		if( this.engine === 'AMMO' && isWorldAxis && o.mode === 'hinge') {
			let ee = new Euler(0, -90*torad$3, 0);
			let qq = new Quaternion$1().setFromEuler(ee).toArray();
			o.quatX = qq;
			//o.quat1 = MathTool.quatMultiply(o.quat1, qq);
			//o.quat2 = MathTool.quatMultiply(o.quat2, qq);
		}

		if( o.drivePosition ) if( o.drivePosition.rot !== undefined ){ o.drivePosition.quat = MathTool.quatFromEuler( o.drivePosition.rot ); delete ( o.drivePosition.rot ); }

		let j = new JointDebug( o, this.motor );
		j.name = name;
		j.body1 = body1;
		j.body2 = body2;
		
		if( o.visible === undefined ) o.visible = this.motor.jointVisible || false;

		// apply option
		this.set( o, j );

		// add to world
		this.addToWorld( j, o.id );

		// add to worker 
		this.motor.post( { m:'add', o:o } );

		return j;

	}

	set ( o = {}, j = null ) {

		if( j === null ) j = this.byName( o.name );
		if( j === null ) return;
		if( o.visible !== undefined ) j.visible = o.visible;

	}

}

class Contact extends Item {

	constructor ( motor ) {

		super();

		this.motor = motor;
		this.Utils = this.motor.utils;

		this.type = 'contact';

	}

	step (AR, N) {

		let i = this.list.length, c, n;
		
		while( i-- ){

			c = this.list[i];

			n = N + ( i * Num.contact );

			//c.update( AR.slice( n, n+8 ) )
			c.update( AR, n );

		}

	}

	add ( o = {} ) {

		this.setName( o );

		let c = new Pair( o );

		if( o.callback ) delete ( o.callback );

		// add to world
		this.addToWorld( c, o.id );

		// add to worker 
		this.motor.post( { m:'add', o:o } );

		return c;

	}


}


class Pair {

	constructor ( o = {} ) {

		this.type = 'contact';

		this.name = o.name;
		this.callback = o.callback || function(){};

		this.b1 = o.b1 || null;
		this.b2 = o.b2 || null;
		this.ignore = o.ignore || [];

		this.always = o.always !== undefined ? o.always : true;
		this.simple = o.simple || false;

		this.data = {

			hit:false,
			point: [0,0,0],
			normal: [0,0,0],
			//object: null,
		};

	}

	update ( r, n = 0 ) {

		this.data.hit = r[n] > 0 ? true : false;

		if( !this.simple ){

			this.data.point = [ r[n+1], r[n+2], r[n+3] ];
			this.data.normal = [ r[n+4], r[n+5], r[n+6] ];

		}
		
		if( this.data.hit || this.always ) this.callback( this.data );

	}


}

let Mat$1 = null;

// THREE VEHICLE

class Vehicle extends Item {

	constructor ( motor ) {

		super();

		this.motor = motor;
		this.engine = this.motor.engine;
		this.Utils = this.motor.utils;

		this.motor.geo;
		Mat$1 = this.motor.mat;

		this.type = 'vehicle';
		this.num = Num[this.type];

	}

	step (AR, N) {

		let i = this.list.length, n, s;

		while( i-- ){

			s = this.list[i];
			n = N + ( i * this.num );
			s.step( AR, n );

		}

	}

	add ( o = {} ) {

		this.setName( o );
        const car = new Car( o, this.motor );

        // add to world
		this.addToWorld( car, o.id );

        // add to physics
        this.motor.post({ m:'add', o:car.o });

        return car

	}

	set ( o = {}, b = null ) {

		if( b === null ) b = this.byName( o.name );
		if( b === null ) return

	}

}



// CAR

class Car extends Basic3D {//extends Object3D {

	constructor( o, motor ) {

		super();

		this.motor = motor;
		this.Utils = this.motor.utils;

		// extra function // ex car selection
		if(o.extra){
			this.extra = o.extra;
			delete o.extra;
		}

		this.type = 'vehicle';
		this.name = o.name || 'car';
		this.isRay = o.ray || false;
		//this.withBody = false;
		this.actif = false;
		//this.position = new THREE.Vector3();
		this.steering = 0;
		this.suspension = [];
		this.rolling = [];
		this.init( o );

	}

	drive () {

	}

	raycast(){
		return
	}

	init ( o ) {

		this.mass = o.mass || 2000;

		this.model = null;

		//this.decal = o.bodyDecalY || 0;
		//this.circum = (Math.PI * 2 * o.radius);// in metter

        // CHASSIS
		this.size = o.size || [0.85*2, 0.5*2, 2.5*2];
		this.massCenter = o.massCenter || [0, 0.55, 1.594];
		this.chassisPos = o.chassisPos || [0, 0.83, 0];

		this.maxSteering = o.maxSteering || 24;
		this.incSteering = o.incSteering || 2;

		this.s_travel = o.s_travel || 0.4;
		this.s_ratio = 1 / ( this.s_travel * 0.5 );
		this.decaly = this.engine === 'PHYSX' ? this.s_travel * 0.5 : 0;


		//this.diff = math.vecSub( this.chassisPos, this.massCenter )
		//this.diff[2] = 0

		// WHEELS
		this.numWheel = o.numWheel || 4;
		this.radius = o.radius || 0.35;
		this.radiusBack = o.radiusBack || this.radius;
		this.deep = o.deep || 0.3;
		this.deepBack = o.deepBack || this.deep;

		let byAxe = this.numWheel < 4 ? 1 : 2;

		if(!o.wPos) o.wPos = [0.8, 0.1, 1.4];

		if( o.wPos ){

			this.wPos = o.wPos;

			var p, wp = o.wPos, axe, pp = [], s=1, back=0, y, x, z, pzz;
			wp.length === 3 ? true : false;
			wp.length === 4 ? true : false;

			for( let i=0; i < this.numWheel; i++ ){

				s = i%2 === 0 ? -1 : 1;
				axe = Math.floor(i * 0.5);
				back = i >= byAxe ? true: false;
				
				y = wp[ 1 ];
				if( y===0 ) y = back ? this.radiusBack : this.radius;

				x = wp[ 0 ];
				//if( x === 0 ) x = (back ? this.deepBack : this.deep)*0.5
				if( x instanceof Array ) x = wp[0][axe];

				z = back ? -wp[2] : wp[2];
			    if( wp[2] instanceof Array ) z = wp[2][axe];

			    	


				p = [ x * s, y, z ];

				pp.push( p );

			}

			//console.log(this.name, pp)

			this.wheelsPosition = pp;
			delete o.wPos;

		}

		if( o.wheelsPosition ) this.wheelsPosition = o.wheelsPosition;

		//console.log(this.wheelsPosition)

		const scale = o.meshScale || 1;


		const chassisShapes = [];// { type:'convex', shape:bodyShape, pos:[0,0,0], flag:8|2|1 } ];//, isExclusive:true

		//if( o.chassisShape ) chassisShapes.push( { type:'convex', shape:o.chassisShape, pos:[0,0,0], flag:8|2|1 } );
		//else chassisShapes.push( { type:'box', size:this.size, pos:[0,0,0], flag:8|2|1 } );

		if( o.chassisShape ) chassisShapes.push( { type:'convex', shape:o.chassisShape, size:[scale], pos:this.chassisPos, filter:[1, -1, 0, 0], isExclusive:true, ray:this.isRay  } );
		else chassisShapes.push( { type:'box', size:this.size, pos:this.chassisPos } ); 

		for( let i=0; i < this.numWheel; i++ ){
	    	if( i < byAxe ) chassisShapes.push({ type:'cylinder', size:[ this.radius, this.deep ], isWheel:true, radius:o.rad || 0.05 , shadow:false, ray:false });
	    	else chassisShapes.push({ type:'cylinder', size:[ this.radiusBack, this.deepBack ], isWheel:true, radius:o.rad || 0.05 , shadow:false, ray:false  });
	    	
	    }

	    /*for( var i=0; i < o.numWheel; i++ ){

	    	if( this.radiusBack !== this.radius ){
	    		if(i<2) chassisShapes.push( { type:'convex', shape:wheelShape, pos:[0,0,0] } );
	    		else chassisShapes.push(  { type:'convex', shape:wheelShapeBack, pos:[0,0,0] } );
	    	} else {
	    		chassisShapes.push(  { type:'convex', shape:wheelShape, pos:[0,0,0] } );
	    	}

	    }*/

	    var material = Mat$1.get( o.debug ? 'debug' : (o.chassisMesh === undefined ? 'body' : 'hide'));
	    //if( o.body === undefined ) material = 'move';

	    let n;

	    for ( let i = 0; i < chassisShapes.length; i ++ ) {
	    	n = chassisShapes[i];
	    	if( n.pos ) n.localPos = n.pos;
	    	n.size = MathTool.autoSize( n.size, n.type );
	    	this.motor.getGeometryRef(n, this, material);
	    }

	    //if( o.chassisShape ) console.log(  )


		let m;

		if(o.chassisMesh){
			m = o.noClone ? o.chassisMesh : o.chassisMesh.clone();
			m.position.set( 0, 0, 0 );
			this.Utils.noRay( m );
			m.scale.set( scale, scale, scale );
			this.children[0].add( m );
			this.model = m;
			delete o.chassisMesh;

			//this.chassis.children[0].castShadow = false;
			//this.chassis.children[0].receiveShadow = false;
		}


		//let back = false, 

		// wheel model
		if( o.wheelMesh ){
			
			
			for( let i = 1; i<this.numWheel+1; i++ ) {
				back = i >= byAxe+1;
				if( o.wheelMeshBack ) m = back ? o.wheelMeshBack.clone() : o.wheelMesh.clone();
				else m = o.wheelMesh.clone();
				this.Utils.noRay( m );
				m.position.set( 0, 0, 0 );
				if(i==2 || i ==4) m.scale.set( -scale, scale, scale );
				else m.scale.set( scale, scale, scale );
				this.children[i].add( m );

			    //this.chassis.children[i].castShadow = false;
			    //this.chassis.children[i].receiveShadow = false;
			}
			delete o.wheelMesh;
		}

		

		// suspension model
		if( o.suspensionMesh ){

			this.suspensionMesh = [];

			for( let i = 1; i<this.numWheel+1; i++ ) {

				m = o.suspensionMesh.clone();
				this.Utils.noRay( m );
				m.position.set( 0, 0, 0 );
				m.position.fromArray(this.wheelsPosition[i-1]);
				m.position.x = 0;
				if(i==2 || i ==4) m.scale.set( scale, scale, scale );
				else m.scale.set( -scale, scale, scale );
				this.children[0].add( m );
			    this.suspensionMesh.push( m );

			}
			delete o.suspensionMesh;

		}

		// suspension model
		if( o.brakeMesh ){

			this.brake = [];

			for( let i = 1; i<this.numWheel+1; i++ ) {
				back = i > 2;
				if( o.brakeMeshBack ) m = back ? o.brakeMeshBack.clone() : o.brakeMesh.clone();
				else m = o.brakeMesh.clone();
				this.Utils.noRay( m );
				m.position.set( 0, 0, 0 );
				m.position.fromArray(this.wheelsPosition[i-1]);
				if( o.brakeMeshBack ) pzz = scale;
				else pzz = back ? scale : -scale;
				if(i==2 || i ==4) m.scale.set( -scale, scale, pzz );
				else m.scale.set( scale, scale, pzz );
				this.children[0].add( m );
			    this.brake.push( m );

			}
			delete o.brakeMesh;

		}

		o.mass = this.mass;

		o.size = o.chassisShape ? chassisShapes[0].boxSize : this.size;
		o.numWheel = this.numWheel;
		o.wheelsPosition = this.wheelsPosition;
		o.radius = this.radius;
		o.radiusBack = this.radiusBack;
		o.deep = this.deep;
		o.deepBack = this.deepBack;

		o.chassisShape = chassisShapes[0];

		o.maxSteering = this.maxSteering;
		o.incSteering = this.incSteering;
		o.s_travel = this.s_travel;

		o.massCenter = this.massCenter;
		o.chassisPos = this.chassisPos;

		this.o = o;

	}

	set ( o ) {
		o.name = this.name;
		this.motor.change( o );
	}

	respawn ( o ) {

		//{ pos:[0,0,0], rot:[0,0,0], keepVelocity:false }

		o = o || {};
		o.respawn = true;
		o.name = this.name;

		if( o.keepRotation ) o.quat = this.quaternion.toArray();


		this.motor.change( o );

	}

	move(){

		/*phy.update({ 
		    name:this.name,
		    key: key
		});*/
	}

	dispose (){

		/*if(this.withBody){
			root.content.remove( this.body );
		}*/

		//root.remove( this.name + '_chassis' );
	}

	step ( AR, n ) {

		if( !this.actif ){
			let a = AR[n+0]+AR[n+1]+AR[n+2]+AR[n+3]+ AR[n+4]+AR[n+5]+AR[n+6]+AR[n+7];
			if( a===0 ) return;
			else this.actif = true;
		}

		

		this.position.fromArray( AR, n + 1 );
		this.quaternion.fromArray( AR, n + 4 );
		this.updateMatrix();

		let num = this.numWheel+1;
		let mesh;
		let s1 = 0, s2 = 0;
		let sp = [];
		let k = 0;

		for( let i = 0; i<num; i++ ){

			k = (i*8) + n;

			if(i===0) ( ( AR[ k ] ) / this.circum );
			if(i===1) s1 = AR[ k ];
			if(i===2) s2 = AR[ k ]; 
			
			mesh = this.children[i];
			

			if( mesh && i>0 ){

				//sp[i-1] = this.wheelsPosition[i-1][1] - AR[k+2]
				sp[i-1] = (this.wheelsPosition[i-1][1] - this.decaly ) - AR[k+2];

				// local
				
				mesh.position.fromArray( AR, k + 1 );
				//mesh.position.y += this.massCenter[1]
				mesh.quaternion.fromArray( AR, k + 4 );

				this.rolling[i-1] = mesh.rotation.x;

				if(this.brake){
					this.brake[i-1].position.copy( mesh.position );
					if(i==1 || i==2) this.brake[i-1].rotation.y = AR[k];
				}

			}

		}

		
		k = 4;
		while(k--){

			this.suspension[k] = MathTool.clamp( sp[k]*this.s_ratio, -1, 1 );
			
			if(this.suspensionMesh ){
				if ( this.suspension[k] > 0 ) {
					this.Utils.morph( this.suspensionMesh[k].children[0], 'low', this.suspension[k] );
					this.Utils.morph( this.suspensionMesh[k].children[0], 'top', 0 );
				} else {
					this.Utils.morph( this.suspensionMesh[k].children[0], 'low', 0 );
					this.Utils.morph( this.suspensionMesh[k].children[0], 'top', -this.suspension[k] );
				}
			}

		} 

		this.steering = Math.round(((s1+s2)*0.5)*todeg$1) / this.maxSteering;
		
		//console.log(this.steering)
		//console.log(acc)

	}
}

const _endMatrix = /*@__PURE__*/ new Matrix4();
const _p = /*@__PURE__*/ new Vector3();
const _q = /*@__PURE__*/ new Quaternion$1();
const _s = /*@__PURE__*/ new Vector3();


const _matrixWorldInv = /*@__PURE__*/ new Matrix4();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const Spine = [ 'hip', 'abdomen', 'chest', 'neck', 'head', 'rCollar', 'lCollar', 'lShldr', 'rShldr', 'lThigh', 'rThigh', 'rBreast', 'lBreast' ];

class SkeletonBody extends Object3D {

	constructor ( motor, name, model, bones, mass = null, option = {} ) {

		super();

        this.motor = motor;

		this.prefix = name || 'yoo_';

        this.mode = 'follow';

        this.withFinger = false;

        this.nodes = [];
		this.bones = bones;//character.model.skeleton.bones;
		this.model = model;//character.model.root;
       
        this.scaler = this.model.scale.x; 
        this.posRef = {};
        this.quatRef = {};

        this.useSolver = false; 
        if( this.motor.engine !== 'PHYSX' ) this.useSolver = false;

        this.nameList = [];
        this.jointList = [];

        this.breast = false;
        this.ready = false;

        this.matrixAutoUpdate = false;

        this.mass = mass; 
        this.friction = 0.5; 
        this.restitution = 0;
        this.option = option;
        this.useDrive = option.useDrive !== undefined ?  option.useDrive : true;
        this.showJoint = option.showJoint !== undefined ?  option.showJoint : false;

		this.init();

	}

    setMass( mass ){

        if( mass === this.mass ) return
        this.mass = mass;
        const d = [];
        let i = this.nodes.length;
        let m = this.mass/i;
        while( i-- ) d.push( { name:this.nodes[i].name, mass:m } );
        this.motor.change( d );

    }

    setMode( mode ){

        if( mode === this.mode ) return

        this.mode = mode;
        const data = [];

        let kinematic = this.mode === 'follow';

        let i = this.nodes.length, node;

        while( i-- ){

            node = this.nodes[i];
            data.push( { name:node.name, kinematic:kinematic } );
            node.kinematic = kinematic;
            node.bone.isPhysics = !kinematic;
            
        }

        this.motor.change( data );

    }

    freeBone( node ){

        if(!node.kinematic) return
        node.cc++;
        if(node.cc=== 20 ){
            node.cc = 0;
            node.kinematic = false;
            node.bone.isPhysics = true;
            this.motor.change( { name : node.name, kinematic:false } );
        }
        
    }

    isVisible( v ){

        //let i = this.nodes.length, node
        //while( i-- ) Utils.byName( this.nodes[i].name ).visible = v

        let i = this.nameList.length;
        while( i-- ) this.motor.byName( this.nameList[i] ).visible = v;
        /*let data = []
        i = this.jointList.length;
        while( i-- ) data.push( { name:this.jointList[i], visible:v } );
        root.motor.change( data );*/

    }


	init(){

        if( this.useSolver ) this.solver = this.motor.add({ 
            type:'solver', name:this.prefix+'_solver', iteration:32,
            fix:true, needData:true
        });

        this.useAggregate = this.motor.engine === 'PHYSX';// && this.option.useAggregate

		const data = [];
        
       

        // get character bones var bones = character.skeleton.bones;

        let scaleMatrix = new Matrix4().makeScale(this.scaler, this.scaler, this.scaler);
        

        let p = new Vector3();
        let s = new Vector3();
        let q = new Quaternion$1();
        let e = new Euler();
        let mtx = new Matrix4();

        let tmpMtx = new Matrix4();
        let tmpMtxR = new Matrix4();

        //this.model.updateWorldMatrix( true, false );
        _matrixWorldInv.copy( this.model.matrixWorld ).invert();

        let p1 = new Vector3();
        let p2 = new Vector3();

        let sizer  =  [1,1,1,1,1,1,1];
        if(this.option.sizer){
            sizer = this.option.sizer;
        }

        //let headDone = false

        let i, lng = this.bones.length, name, n, bone, parent;///, child, o, parentName;
        let size, dist, rot, type, kinematic, translate, phyName, motion;

        let averageMass = 0;
        if(this.mass) averageMass = this.mass / lng;

        for( i = 0; i < lng; i++ ){

        	type = null;
            bone = this.bones[i];
            name = bone.name;
            parent = bone.parent;

            if( parent ) {

            	n = parent.name;

                _boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
                p1.setFromMatrixPosition( _boneMatrix );

                _boneMatrix.multiplyMatrices( _matrixWorldInv, parent.matrixWorld );
                p2.setFromMatrixPosition( _boneMatrix );


            	//p1.setFromMatrixPosition( parent.matrixWorld );
            	//p2.setFromMatrixPosition( bone.matrixWorld );
                dist = p1.distanceTo( p2 );// * this.scaler;

                //if( n==='hip' && name==='abdomen' ) console.log( dist )

	            //translate = [ -dist * 0.5, 0, 0 ];
	            translate = [ 0, 0, dist * 0.5 ];
                size = [ dist, 1, 1 ];
                rot = null;//[0,0,0];
                kinematic = true;
                motion = false;

                //type = 'capsule'
                

                //if( n==='hip' && name==='abdomen' ){ type = 'capsule'; size = [  0.1,dist*1.8 ]; translate = [ 0, 0, -(dist*1.8) * 0.5 ]; rot = [0,0,90]; link='null';}
                
                // body
                //if( n==='hip' && name==='abdomen' ){ type = 'capsule'; size = [  0.1,dist*1.8 ]; translate = [ 0, 0, -(dist*1.8) * 0.5 ]; rot = [0,0,90]; link='null';}
                
                //if( n==='hip' && name==='abdomen' ){ type = 'capsule'; size = [  dist*1.8, 0.08 ]; translate = [ 0, 0, -dist * 0.5 ]; rot = [0,0,90]; link='null';}
                if( n==='hip' && name==='abdomen' ){ type = 'capsule'; size = [  dist*sizer[0], 0.08 ]; translate = [ 0, 0, -dist*sizer[0] ]; rot = [0,0,90];}
                if( n==='abdomen' && name==='chest'  ){ type = 'capsule'; size = [ dist*0.7*sizer[1], 0.08   ]; translate = [ 0, 0, (-dist * 0.5)-0.06 ]; rot = [90,0,0];}
                if( n==='chest' && name==='neck' ){ type = 'capsule'; size = [  dist*0.4*sizer[2], 0.04 ]; translate = [ 0, 0, (-dist * 0.5)-0.02 ]; rot = [0,0,90];}
                if( n==='neck' && name === 'head' ){ type = 'capsule'; size = [ 0.06*sizer[3], dist ]; translate = [ 0, 0, -dist * 0.5 ]; rot = [90,0,0]; }
                if( n==='head' && name === 'End_head' ){ type = 'capsule'; size = [ 0.1*sizer[4], dist-0.17 ]; translate = [ 0, 0.02, (-dist * 0.5)+0.02 ]; rot = [90,0,0]; }
                
                //if( n==='head' && !headDone ){ console.log(name); headDone = true; type = 'sphere'; dist=0.08; size = [ 0.08, 0.2, dist ]; translate = [ 0, 0.025, -0.08 ]; }
	            //if( n==='chest' && name==='neck' ){ type = 'box'; size = [  0.28, 0.24, dist ]; translate = [ 0, 0, -dist * 0.5 ]; }
	            //if( n==='abdomen' && name==='chest'  ){ type = 'box'; size = [ 0.24, 0.20,  dist ]; translate = [ 0, 0, -dist * 0.5 ]; }
              
                


                if( n==='chest' && name==='rBreast' && this.motor.engine!=='HAVOK' ){ n='rBreast'; parent = bone; type = 'sphere'; size = [ 0.065 ]; translate = [ 0.065,0,0 ]; this.breast=true; motion = true; }
                if( n==='chest' && name==='lBreast' && this.motor.engine!=='HAVOK' ){ n='lBreast'; parent = bone; type = 'sphere'; size = [ 0.065 ]; translate = [ 0.065,0,0 ]; this.breast=true; motion = true; }
                

                // arm

                let r = 0.04*sizer[5];
                let w = dist-r;

                if( n==='lCollar' && name==='lShldr'){ type = 'capsule'; size = [  r, dist*0.3 ]; translate = [dist*0.6 , 0, 0 ]; rot = [0,0,90]; }
                if( n==='lShldr' && name==='lForeArm'){ type = 'capsule'; size = [  r, w ]; translate = [w * 0.5, 0, 0 ]; rot = [0,0,90]; }
                if( n==='lForeArm' && name==='lHand'){ type = 'capsule'; size = [ r, w ]; translate = [w * 0.5, 0, 0 ]; rot = [0,0,90]; }
                if( n==='lHand' && name==='lMid1'){ type = 'box'; size = [ dist*2, 0.09, 0.05 ]; translate = [dist, 0, 0 ]; }

                if( n==='rCollar' && name==='rShldr'){ type = 'capsule'; size = [  r, dist*0.3 ]; translate = [-dist*0.6, 0, 0 ]; rot = [0,0,90]; }
                if( n==='rShldr' && name==='rForeArm'){ type = 'capsule'; size = [  r, w ]; translate = [-w * 0.5, 0, 0 ]; rot = [0,0,90]; }
                if( n==='rForeArm' && name==='rHand' ){ type = 'capsule'; size = [ r, w ]; translate = [-w * 0.5, 0, 0 ]; rot = [0,0,90]; }
                if( n==='rHand' && name==='rMid1'){ type = 'box'; size = [ dist*2, 0.09, 0.05 ]; translate = [-dist, 0, 0 ]; }

	            // legs

                r = 0.06*sizer[6];
                w = dist-r;

                if( n==='lThigh' ){ type = 'capsule'; size = [  r, dist ]; rot = [90,0,0]; translate = [ 0, 0, w * 0.5 ]; }
                if( n==='lShin' ){ type = 'capsule'; size = [  r, dist ]; rot = [90,0,0]; translate = [ 0, 0, w * 0.5 ]; }
                //if( n==='lFoot' ){ type = 'box'; size = [  0.1, dist*1.4, 0.06 ]; translate = [0, (dist * 0.5)-0.025, 0.06 ]; link:'lShin'; }
                if( n==='lFoot' ){ type = 'capsule'; size = [  0.05, dist ]; translate = [0, (dist * 0.5)-0.025, 0.04 ]; }

                if( n==='rThigh' ){ type = 'capsule'; size = [  r, dist ]; rot = [90,0,0]; translate = [ 0, 0, w * 0.5 ]; }
                if( n==='rShin' ){ type = 'capsule'; size = [  r, dist ]; rot = [90,0,0]; translate = [ 0, 0, w * 0.5 ]; }
                //if( n==='rFoot' ){ type = 'box'; size = [  0.1, dist*1.4, 0.06 ]; translate = [0, (dist * 0.5)-0.025, 0.06 ]; link:'rShin';}
                if( n==='rFoot' ){ type = 'capsule'; size = [  0.05, dist ]; translate = [0, (dist * 0.5)-0.025, 0.04 ]; }

                // extra ear
                r = 0.04;
                w = dist-r;
                
                
                if( n==='rEar_0'){ type = 'capsule'; size = [  r, dist ]; rot = [0,0,90]; translate = [ w * 0.5, 0, 0 ]; Spine.push('rEar_0'); }
                if( n==='rEar_1'){ type = 'capsule'; size = [  r, dist ]; rot = [0,0,90]; translate = [ w * 0.5, 0, 0 ]; Spine.push('rEar_1');}
                if( n==='rEar_2' ){ type = 'capsule'; size = [  r, dist ]; rot = [0,0,90]; translate = [ w * 0.5, 0, 0 ]; Spine.push('rEar_2');}
                if( n==='rEar_3' ){ type = 'capsule'; size = [  r, dist ]; rot = [0,0,90]; translate = [ w * 0.5, 0, 0 ]; }

                if( n==='lEar_0'){ type = 'capsule'; size = [  r, dist ]; rot = [0,0,90]; translate = [ w * 0.5, 0, 0 ]; Spine.push('lEar_0');}
                if( n==='lEar_1'){ type = 'capsule'; size = [  r, dist ]; rot = [0,0,90]; translate = [ w * 0.5, 0, 0 ]; Spine.push('lEar_1');}
                if( n==='lEar_2' ){ type = 'capsule'; size = [  r, dist ]; rot = [0,0,90]; translate = [ w * 0.5, 0, 0 ]; Spine.push('lEar_2');}   
                if( n==='lEar_3' ){ type = 'capsule'; size = [  r, dist ]; rot = [0,0,90]; translate = [ w * 0.5, 0, 0 ]; }

                //if( n==='rFoot' && name==='lToes' ){ n='lToes'; parent = bone; type = 'capsule'; size = [  0.05, 0.1 ]; translate = [0, 0, 0 ]; link='rFoot'; rot = [0,0,0]; }
                //if( n==='lFoot' && name==='rToes' ){ n='rToes'; parent = bone; type = 'capsule'; size = [  0.05, 0.1 ]; translate = [0, 0, 0 ]; link='rFoot'; rot = [0,0,0]; }

                if( this.withFinger ) {

                    if( n==='lHand' && name==='lMid1'){ type = 'box'; size = [ dist, 0.09, 0.05 ]; translate = [dist*0.5, 0, 0 ]; }
                    if( n==='rHand' && name==='rMid1'){ type = 'box'; size = [ dist, 0.09, 0.05 ]; translate = [-dist*0.5, 0, 0 ]; }


                    if( n==='rThumb1' && name==='rThumb2' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90]; }
                    if( n==='rThumb2' && name==='rThumb3' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90]; }


                    if( n==='rHand' && name==='rMid1' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90]; translate = [-dist*0.6, 0, 0 ]; }
                    if( n==='rMid1' && name==='rMid2' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90]; translate = [-dist*0.6, 0, 0 ]; }
                    if( n==='rMid2' && name==='rMid3' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90]; translate = [-dist*0.6, 0, 0 ]; }

                }

                if( type !== null ){

                    phyName = this.prefix +'_bone_'+n;

                	// translation
                    //translate = MathTool.scaleArray(translate,this.scaler,3);
                    tmpMtx.makeTranslation( translate[0], translate[1], translate[2] );

                    // rotation
                    if( rot ){
                        tmpMtxR.makeRotationFromEuler( e.set( rot[0]*torad$3, rot[1]*torad$3, rot[2]*torad$3 ) );
                        tmpMtx.multiply( tmpMtxR );
                    }

                    //_boneMatrix.multiplyMatrices( _matrixWorldInv, parent.matrixWorld );
                    
                    //parent.matrixWorld );
                    parent.updateWorldMatrix( true, false );
                    _boneMatrix.multiplyMatrices( _matrixWorldInv, parent.matrixWorld );
                    mtx.copy( _boneMatrix );
                    //mtx.multiplyMatrices( _matrixWorldInv, parent.matrixWorld )
                    //_tmpMatrix2.makeScale(this.scaler,this.scaler,this.scaler)
                   // mtx.multiply(_tmpMatrix2)//Matrices( _matrixWorldInv, bone.matrixWorld );
                    //p
                    //mtx.copy( parent.matrixWorld )//.multiply(tmpMtx)//parent.matrixWorld );
                    mtx.decompose( p, q, s );

                    //p.copy(parent.position)

                    //p.copy(p2)

                    this.posRef[phyName] = p.toArray();
                    //this.posRef[phyName] = p2.toArray()
                    // if( n==='lForeArm'  )console.log(this.posRef[phyName])
                    //this.posRef[phyName] = MathTool.scaleArray(p.toArray(),this.scaler,3)

                    if( n==='lForeArm' || n==='rForeArm' ){
                        _q.setFromAxisAngle( {x:0, y:1, z:0}, -90*torad$3 );
                        q.multiply( _q );
                    } 

                    this.quatRef[phyName] = q.toArray();
                     
                    //mtx.multiplyMatrices( parent.matrixWorld, tmpMtx );
                    mtx.multiplyMatrices( _boneMatrix, tmpMtx );
                    mtx.decompose( p, q, s );


                    //this.posRef[phyName] = p.toArray()
                    // collection

                    this.nameList.push( phyName );

                    

                    



                	// for physic body
                    let bb = {

                        name: phyName,

                        friction: this.friction,
                        restitution: this.restitution,
                        
                        type: type,
                        size: MathTool.scaleArray(size,this.scaler,3),
                        pos: p.toArray(),
                        //rot: rot,
                        quat: q.toArray(),
                        kinematic: kinematic,
                        
                        //group:16,
                        //mask:mask,
                        //mask:0,
                        material:'hide',
                        //material:'debug',
                        shadow:false,
                        neverSleep: true,
                        helper: true,
                        hcolor:[0.0, 0.5, 1],
                        hcolor2:[0.0, 0.2, 1],
                        //hcolor:[0.87, 0.76, 0.65],
                        //hcolor2:[0.9, 0.77, 0.64],

                        penetrationVelocity:3,
                        stabilization:0.1,
                        //maxVelocity:[100,10],
                        damping:[0.25,0.5],
                        //maxAngularVelocity:3,

                        //linked:link,
                        //iterations:[4,4],
                        //inertiaScale:[20,20,20],
                        //iterations:[4,2],


                        /*bone:parent,
                        decal:tmpMtx.clone(),
                        decalinv:tmpMtx.clone().invert(),*/

                        ...this.option
                        
                    };



                    if( this.useAggregate ){

                        // aggregate test
                        if( Spine.indexOf(n)!==-1 ){ 
                            bb['aggregate'] = this.prefix +'__Group';
                            bb['aggregateMax'] = 21;
                        }
                        bb['mask'] = 1|2;

                    } else {
                        let mask =  1|2;
                        if( n==='lForeArm' || n==='rForeArm' || n==='lShin' || n==='rShin'  ) mask = 1|2|32;
                        if( n==='rEar_1' || n==='rEar_2' || n==='rEar_3' || n==='lEar_1'|| n==='lEar_2'|| n==='lEar_3' ) mask = 1|2|32;
                        if( n==='rEar_0' || n==='rEar_0') mask = 0;

                        bb['group'] = 32;
                        bb['mask'] = mask;
                    }
                    

                    //
                    


                    if( this.mass !== null ) bb['mass'] = averageMass;
                    else bb['density'] = 1;

                    data.push(bb);



                    /*if( this.useSolver ){
                        physicData['solver'] = this.prefix+'_solver'
                        physicData['linked'] = this.prefix+'_bone_'+link
                        physicData['kinematic'] = false
                    }*/

                     //physicData )

                    let inv = tmpMtx.clone().invert().premultiply(scaleMatrix);

                    this.nodes.push({
                    	name: phyName,
                        kinematic: kinematic,
                        motion:motion,// auto move
                    	bone:parent,
                        decal:tmpMtx.clone(),
                        decalinv:inv,
                        quat:q.toArray(),
                        pos:p.toArray(),
                        //scaler:this.scaler,
                        cc:0,
                    });
                }

            }
        }

        //console.log( data )

        this.motor.add( data );

        //if( this.useSolver ) this.solver.start();
       
        this.addLink();

        
        this.dispatchEvent( { type: 'start', message: 'go !' } );
        this.ready = true;

	}

    existe( name ){
        return this.nameList.indexOf(name) !== -1 ? true : false
    }

    addLink () {

        // Stiffness / Damping
        // raideur / amortissement
        //let sp = [0.05,1]
        let sp = [0.05, 1, 0];
        if(this.motor.engine==='PHYSX'){
            // stiffness / damping / restitution / bounceThreshold / contactDistance
            //[0,0, 0, 0.5]
            // raideur / amortissement
            sp = [50,10, 0, 0.5];
        }

        let driveSetting = {
            stiffness:2,
            damping:0.1,
            forceLimit:10000000,
            isAcceleration:false,
        };

        /*driveSetting = {
            stiffness:10000,
            damping:500,
            forceLimit:100,
            isAcceleration:true,
        }*/




        let p = this.prefix+'_bone_';
        let data = [];
        let sett = {
            type:'joint', 
            mode:'d6',
            
            lm:[  ['ry',-180,180,...sp], ['rz',-180,180,...sp] ],

            collision:false,
            helperSize:0.05,
            visible:this.showJoint,

            //acc:true,

            //worldAxis:[1,0,0],

            //autoDrive: true,

            /*drives: [
            ['rx', driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration ],
            ['ry', driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration ],
            ['rz', driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration ]
            ],*/

        };

        if( this.useDrive ){
            sett['drives'] = [
            ['rx', driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration ],
            ['ry', driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration ],
            ['rz', driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration ]
            ];
        }

        let breastMotion = [-1e-3, 0.001, 100, 0.2, 0.5];
        

        data.push({ ...sett, b1:p+'hip', b2:p+'abdomen', worldPos:this.posRef[p+'abdomen'], worldQuat:this.quatRef[p+'hip'], lm:[ ['rx',-20,20,...sp], ['ry',-20,20,...sp], ['rz',-20,20,...sp]] });
        data.push({ ...sett, b1:p+'abdomen', b2:p+'chest', worldPos:this.posRef[p+'chest'], worldQuat:this.quatRef[p+'chest'], lm:[ ['rx',-20,20,...sp], ['ry',-20,20,...sp], ['rz',-20,20,...sp]] });
        //data.push({ ...sett, b1:p+'chest', b2:p+'neck', worldPos:this.posRef[p+'neck'], worldQuat:this.quatRef[p+'neck'], lm:[ ['rx',-60,60,...sp], ['ry',-1,1,...sp], ['rz',-30,30,...sp]] })
        //data.push({ ...sett, b1:p+'neck', b2:p+'head', worldPos:this.posRef[p+'head'], worldQuat:this.quatRef[p+'head'], lm:[ ['rx',-60,60,...sp], ['ry',-1,1,...sp], ['rz',-30,30,...sp]] })
        data.push({ ...sett, b1:p+'chest', b2:p+'neck', worldPos:this.posRef[p+'neck'], worldQuat:this.quatRef[p+'neck'], lm:[ ['rx',0,30,...sp], ['ry',-1,1,...sp], ['rz',-30,30,...sp]] });
        data.push({ ...sett, b1:p+'neck', b2:p+'head', worldPos:this.posRef[p+'head'], worldQuat:this.quatRef[p+'head'], lm:[ ['rx',0,30,...sp], ['ry',-1,1,...sp], ['rz',-30,30,...sp]] });
        //data.push({ type:'joint', mode:'d6', b1:this.prefix*'chest', b2:this.prefix*'abdomen' })

        // arm

        //data.push({ ...sett, b1:p+'chest', b2:p+'rCollar', worldPos:this.posRef[p+'rCollar'],  worldQuat:this.quatRef[p+'rCollar'], lm:[ ['rx',-10,10,...sp], ['ry',-10,10,...sp], ['rz',-10,10,...sp]] })
        //data.push({ ...sett, b1:p+'chest', b2:p+'lCollar', worldPos:this.posRef[p+'lCollar'],  worldQuat:this.quatRef[p+'lCollar'], lm:[ ['rx',-10,10,...sp], ['ry',-10,10,...sp], ['rz',-10,10,...sp]] })
        data.push({ ...sett, b1:p+'chest', b2:p+'rCollar', worldPos:this.posRef[p+'rCollar'],  worldQuat:this.quatRef[p+'rCollar'], mode:'fixe' });
        data.push({ ...sett, b1:p+'chest', b2:p+'lCollar', worldPos:this.posRef[p+'lCollar'],  worldQuat:this.quatRef[p+'lCollar'], mode:'fixe' });

        data.push({ ...sett, b1:p+'rCollar', b2:p+'rShldr', worldPos:this.posRef[p+'rShldr'],  worldQuat:this.quatRef[p+'rShldr'] });
        data.push({ ...sett, b1:p+'lCollar', b2:p+'lShldr', worldPos:this.posRef[p+'lShldr'],  worldQuat:this.quatRef[p+'lShldr'] });

       //data.push({ ...sett, b1:p+'chest', b2:p+'rShldr', worldPos:this.posRef[p+'rShldr'], worldQuat:this.quatRef[p+'rShldr'] })
        //data.push({ ...sett, b1:p+'chest', b2:p+'lShldr', worldPos:this.posRef[p+'lShldr'], worldQuat:this.quatRef[p+'lShldr'] })

        if( this.existe(p+'rForeArm') ) data.push({ ...sett, b1:p+'rShldr', b2:p+'rForeArm', worldPos:this.posRef[p+'rForeArm'], worldQuat:this.quatRef[p+'rForeArm'], lm:[['rx',0,160,...sp]] });
        if( this.existe(p+'lForeArm') ) data.push({ ...sett, b1:p+'lShldr', b2:p+'lForeArm', worldPos:this.posRef[p+'lForeArm'], worldQuat:this.quatRef[p+'lForeArm'], lm:[['rx',0,160,...sp]] });

        if( this.existe(p+'rHand') ) data.push({ ...sett, b1:p+'rForeArm', b2:p+'rHand', worldPos:this.posRef[p+'rHand'], worldQuat:this.quatRef[p+'rHand'], lm:[['rx',0,160,...sp], ['ry',-10,10,...sp]] });
        if( this.existe(p+'lHand') ) data.push({ ...sett, b1:p+'lForeArm', b2:p+'lHand', worldPos:this.posRef[p+'lHand'], worldQuat:this.quatRef[p+'lHand'], lm:[['rx',0,160,...sp], ['ry',-10,10,...sp]] });

        //data.push({ ...sett, b1:p+'rShldr', b2:p+'rForeArm', worldPos:this.posRef[p+'rForeArm'], worldAxis:[1,0,0], lm:[['rx',-120, 0]] })
        //data.push({ ...sett, b1:p+'lShldr', b2:p+'lForeArm', worldPos:this.posRef[p+'lForeArm'], worldAxis:[1,0,0], lm:[['rx',-120, 0]] })

        // leg

        data.push({ ...sett, b1:p+'hip', b2:p+'rThigh', worldPos:this.posRef[p+'rThigh'],  worldQuat:this.quatRef[p+'rThigh'] });
        data.push({ ...sett, b1:p+'hip', b2:p+'lThigh', worldPos:this.posRef[p+'lThigh'],  worldQuat:this.quatRef[p+'lThigh'] });

        if( this.existe(p+'rShin') )data.push({ ...sett, b1:p+'rThigh', b2:p+'rShin', worldPos:this.posRef[p+'rShin'], lm:[['rx',0,160,...sp]], worldQuat:this.quatRef[p+'rShin'] });
        if( this.existe(p+'lShin') )data.push({ ...sett, b1:p+'lThigh', b2:p+'lShin', worldPos:this.posRef[p+'lShin'], lm:[['rx',0,160,...sp]], worldQuat:this.quatRef[p+'lShin'] });

        if( this.existe(p+'rFoot') ) data.push({ ...sett, b1:p+'rShin', b2:p+'rFoot', worldPos:this.posRef[p+'rFoot'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]], worldQuat:this.quatRef[p+'rFoot'] });
        if( this.existe(p+'lFoot') ) data.push({ ...sett, b1:p+'lShin', b2:p+'lFoot', worldPos:this.posRef[p+'lFoot'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]], worldQuat:this.quatRef[p+'lFoot'] });

        if(this.breast){
            if( this.existe(p+'rBreast') ) data.push({ ...sett, b1:p+'chest', b2:p+'rBreast', worldPos:this.posRef[p+'rBreast'], worldQuat:this.quatRef[p+'rBreast'], lm:[['x',...breastMotion], ['y',...breastMotion], ['z',...breastMotion]] });
            if( this.existe(p+'lBreast') ) data.push({ ...sett, b1:p+'chest', b2:p+'lBreast', worldPos:this.posRef[p+'lBreast'], worldQuat:this.quatRef[p+'lBreast'], lm:[['x',...breastMotion], ['y',...breastMotion], ['z',...breastMotion]] });
        }

        // EAR

        if( this.existe(p+'lEar_0') ) data.push({ ...sett, b1:p+'head',   b2:p+'lEar_0', worldPos:this.posRef[p+'lEar_0'], worldQuat:this.quatRef[p+'lEar_0'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]] }); 
        if( this.existe(p+'lEar_1') ) data.push({ ...sett, b1:p+'lEar_0', b2:p+'lEar_1', worldPos:this.posRef[p+'lEar_1'], worldQuat:this.quatRef[p+'lEar_1'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]] });
        if( this.existe(p+'lEar_2') ) data.push({ ...sett, b1:p+'lEar_1', b2:p+'lEar_2', worldPos:this.posRef[p+'lEar_2'], worldQuat:this.quatRef[p+'lEar_2'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]] });
        if( this.existe(p+'lEar_3') ) data.push({ ...sett, b1:p+'lEar_2', b2:p+'lEar_3', worldPos:this.posRef[p+'lEar_3'], worldQuat:this.quatRef[p+'lEar_3'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]] });
        
        if( this.existe(p+'rEar_0') ) data.push({ ...sett, b1:p+'head',   b2:p+'rEar_0', worldPos:this.posRef[p+'rEar_0'], worldQuat:this.quatRef[p+'rEar_0'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]] });
        if( this.existe(p+'rEar_1') ) data.push({ ...sett, b1:p+'rEar_0', b2:p+'rEar_1', worldPos:this.posRef[p+'rEar_1'], worldQuat:this.quatRef[p+'rEar_1'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]] });
        if( this.existe(p+'rEar_2') ) data.push({ ...sett, b1:p+'rEar_1', b2:p+'rEar_2', worldPos:this.posRef[p+'rEar_2'], worldQuat:this.quatRef[p+'rEar_2'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]] });
        if( this.existe(p+'rEar_3') ) data.push({ ...sett, b1:p+'rEar_2', b2:p+'rEar_3', worldPos:this.posRef[p+'rEar_3'], worldQuat:this.quatRef[p+'rEar_3'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]] });


        let x = 0;
        for( let j in data ){
            data[j].name = this.prefix + '_joint_'+ x;
            //this.nameList.push( data[j].name )
            this.jointList.push( data[j].name );
            x++;
        }


        this.motor.add( data );

    }





    /*makeLink () {

        let p = this.prefix;
        let data = []
        data.push({ type:'joint', mode:'d6', b1:p+'hip', b2:p+'abdomen', visible:true })
        data.push({ type:'joint', mode:'d6', b1:p+'abdomen', b2:p+'chest', visible:true })
        //data.push({ type:'joint', mode:'d6', b1:this.prefix*'chest', b2:this.prefix*'abdomen' })

        //console.log(this.prefix, data)

        root.motor.add( data )

    }*/

	updateMatrixWorld( force ){

        if(!this.ready) return

		let up = [];

		const nodes = this.nodes;
		let i = nodes.length, node, bone, body, n=0;


		while( i-- ){

            node = nodes[n];
            bone = node.bone;
            n++;

            if( node.kinematic ){

                _endMatrix.multiplyMatrices( bone.matrixWorld, node.decal );
                _endMatrix.decompose( _p, _q, _s );

                node.pos = _p.toArray();
                node.quat = _q.toArray();

                up.push({ name:node.name, pos:node.pos, quat:node.quat });

                if( node.motion ) this.freeBone(node);

            } else {

                body = this.motor.byName( node.name );

                if(body){
                    _endMatrix.copy( body.matrixWorld ).multiply( node.decalinv );
                    bone.phyMtx.copy( _endMatrix );
                    bone.isPhysics = true;
                }
            }

        }

        if( up.length !== 0 ) this.motor.change( up, true );

	}

	dispose(){

        this.motor.remove( this.jointList );
        this.motor.remove( this.nameList );

        //if( this.useAggregate ) root.motor.remove(this.prefix +'__Group')

        this.nodes = [];
        this.posRef = {};
        this.quatRef = {};
		this.parent.remove( this );

        this.nameList = [];
        this.jointList = [];
		
	}

}

function clone( source ) {

	const sourceLookup = new Map();
	const cloneLookup = new Map();

	const clone = source.clone();

	parallelTraverse( source, clone, function ( sourceNode, clonedNode ) {

		sourceLookup.set( clonedNode, sourceNode );
		cloneLookup.set( sourceNode, clonedNode );

	} );

	clone.traverse( function ( node ) {

		if ( ! node.isSkinnedMesh ) return;

		const clonedMesh = node;
		const sourceMesh = sourceLookup.get( node );
		const sourceBones = sourceMesh.skeleton.bones;

		clonedMesh.skeleton = sourceMesh.skeleton.clone();
		clonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );

		clonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {

			return cloneLookup.get( bone );

		} );

		clonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );

	} );

	return clone;

}

function parallelTraverse( a, b, callback ) {

	callback( a, b );

	for ( let i = 0; i < a.children.length; i ++ ) {

		parallelTraverse( a.children[ i ], b.children[ i ], callback );

	}

}

class Tension {

	constructor( origin, target ) {


		this.target = target || origin;

		this.baseGeometry = origin.geometry;
		this.geometry = this.target.geometry;

		this.V = [ new Vector3(), new Vector3(), new Vector3() ];
		this.X = [ new Vector4(), new Vector4(), new Matrix4() ];
		this.M = [ new Vector3(), new Vector3(), new Vector3() ];

		this.isMorph = this.target.morphTargetInfluences ? true : false;
		this.isSkin = this.target.isSkinnedMesh ? true : false;

		this.init();

	}

	init(){

		if( this.geometry.attributes.position.count !== this.baseGeometry.attributes.position.count ){
			console.log('object not have same number of vertices !!');
			return
		}

		this.length = this.baseGeometry.attributes.position.count;
		this.indexLength = this.baseGeometry.index.count / 3 ;

		//console.log( this.length, this.indexLength )
		

		this.originEdges = new Array(this.length).fill(0);
		this.targetEdges = new Array(this.length).fill(0);

		if( this.isSkin || this.isMorph) this.back = new Array( this.length * 3 ).fill(0);
		this.num = new Array( this.length ).fill(0);

		this.getEdge( this.baseGeometry, this.originEdges );
		this.addColor();

		setTimeout( this.start.bind(this), 100 );

	}

	start(){
		this.ready = true;
		this.update();
	}

	addColor(){

		const g = this.geometry;
		//if( g.attributes.color ) return;
		let lng = g.attributes.position.array.length;
		g.setAttribute( 'color', new Float32BufferAttribute( new Array(lng).fill(0), 3 ) );

	}

	resetEdge( edges )
	{
		let j = edges.length;
		while(j--) edges[j] = 0;
	}

	getEdge( g, edges, isSkin = false, isMorph = false ) 
	{
		let positions = g.attributes.position.array;
		const indices = g.index.array;
		let vA = this.V[0], vB = this.V[1], vC = this.V[2];
		let j, i=0, a, b, c, ab, ac, bc;

		if( isMorph ) positions = this.getMorph();
		if( isSkin ) positions = this.getSkinned( positions );
		if( isSkin || isMorph ) this.resetEdge( edges );
		
		j = this.indexLength;

		while( j-- )
		{
		    a = indices[i];
		    b = indices[i+1];
		    c = indices[i+2];
		    vA.fromArray( positions, a * 3 );
		    vB.fromArray( positions, b * 3 );
		    vC.fromArray( positions, c * 3 );

		    ab = vA.distanceTo(vB);
		    ac = vA.distanceTo(vC);
		    bc = vB.distanceTo(vC);
	    
		    
		    edges[a] += (ab + ac)*0.5;
			edges[b] += (ab + bc)*0.5;
			edges[c] += (ac + bc)*0.5;
			
			/*
			edges[a] += (ab + ac);
			edges[b] += (ab + bc);
			edges[c] += (ac + bc);

			num[a] += 2;
			num[b] += 2;
			num[c] += 2;
			*/

			i+=3;
		}

		//j = this.length;
		//while( j-- ){ edges[j] /= num[j]; }
	}

	isZero(v){

		if(v.x===0 && v.y===0 && v.z ===0 ) return true
		return false

	}

	getMorph()
	{
		const morphInfluences = this.target.morphTargetInfluences;
		const morphRef = this.geometry.morphAttributes.position;
		const morphsMax = morphInfluences.length;
		const position = this.geometry.attributes.position.array;
		let lng = this.geometry.attributes.position.count, id, i, j;
		let vertex = this.M[0];
		let base = this.M[1];
		let temp = this.M[2];
		let relative = this.geometry.morphTargetsRelative;
		let data;

		 // the following code section is normally implemented in the vertex shader

		i = lng;
	    while(i--)
	    {
			id = i*3;
			base.fromArray( position, id );
			vertex.set( 0,0,0 );
			j = morphsMax;
			while(j--){

				if ( morphInfluences[ j ] != 0.0 ){
					data =  morphRef[j].data ? morphRef[j].data.array : morphRef[j].array;
					if( relative ) vertex.addScaledVector( temp.fromArray( data, id ), morphInfluences[ j ] );
					else vertex.addScaledVector( temp.fromArray( data, id ).sub(base), morphInfluences[ j ] );
				}

			}
			base.add( vertex );
			base.toArray( this.back, id );
		}
		return this.back

	}

	getSkinned( position )
	{

		const skeleton = this.target.skeleton;
	    skeleton.boneMatrices;
	    const geometry = this.geometry;
	    //const position = geometry.attributes.position.array;
	    const skinIndex = geometry.attributes.skinIndex.array;
	    const skinWeigth = geometry.attributes.skinWeight.array;

	    const bindMatrix = this.target.bindMatrix;
	    const bindMatrixInverse = this.target.bindMatrixInverse;

	    let vertex = this.V[0];
	    let skin = this.V[1];
	    let temp = this.V[2];
	    let skinIndices = this.X[0];
	    let skinWeights = this.X[1];
	    let boneMatrix = this.X[2];

	    let lng = geometry.attributes.position.count;
	    let i, j, boneIndex, weight, id;

	    // the following code section is normally implemented in the vertex shader
	    i = lng;
	    while(i--)
	    {
			id = i*3;
            skinIndices.fromArray( skinIndex, i*4 );
            skinWeights.fromArray( skinWeigth, i*4 );
            vertex.fromArray( position, id ).applyMatrix4( bindMatrix ); // transform to bind space
            skin.set( 0, 0, 0 );
            j = 4;
            while(j--)
            {
                weight = skinWeights.getComponent( j );
                if ( weight > 0 ) {
                	boneIndex = skinIndices.getComponent( j );
	                boneMatrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );
	                // weighted vertex transformation
	                skin.addScaledVector( temp.copy( vertex ).applyMatrix4( boneMatrix ), weight );
	            }

            }

            skin.applyMatrix4( bindMatrixInverse ); // back to local space
            skin.toArray( this.back, id );
        }
        return this.back
	}

	update() 
	{

		if(!this.ready) return

		this.getEdge( this.geometry, this.targetEdges, this.isSkin, this.isMorph );
		const color = this.geometry.attributes.color.array;
		let o, delta, n, i = this.length;

		while( i-- )
		{
			o = this.originEdges[i];
			delta = ( ( o - this.targetEdges[i] ) / o ) + 0.5;
			n = i*3;
			color[n] = delta > 0.5 ? (delta-0.5)*2 : 0;
			color[n+1] = 0;
			color[n+2] = delta < 0.5 ? (1-(delta*2)) : 0;
		}
		this.geometry.attributes.color.needsUpdate = true;
	}

}

class ExoSkeleton extends Object3D {

    constructor( object, skeleton ) {

        super();

        this.isReady = false;

        this.skeleton = skeleton;

        this.bones = this.skeleton.bones;//getBoneList( object );
        this.root = object;

        this.box = new BoxGeometry();

        //console.log(this.bones)

        //this.avatar = avatar;
        //this.nodes = [];
        this.mtxr = new Matrix4();
        this.mtx0 = new Matrix4();
        this.mtx1 = new Matrix4();

        this.mtx = new Matrix4();
        this.mtx2 = new Matrix4();

        this.p = new Vector3();
        this.s = new Vector3();
        this.q = new Quaternion$1();
        this.e = new Euler();

        this.mat = new MeshBasicMaterial({ color:0xCCCC80, wireframe:true, toneMapped:false });//root.mat.skinCollider;

        this.init();

        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;

    }

    updateMatrixWorld ( force ) {

        if( !this.isReady ) return;

        //THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        let nodes = this.children;
        let i = nodes.length, node, bone;

        this.mtxr.copy( this.root.matrixWorld ).invert();

        //console.log('up', i)

        while( i-- ){

            node = nodes[i];
            bone = node.userData.bone;

            //this.mtx1.fromArray( this.skeleton.boneMatrices, bone.idx )

            this.mtx0.multiplyMatrices(this.mtxr, bone.matrixWorld );
            //this.mtx0.scale( bone.scalling );

            this.mtx.multiplyMatrices( this.mtx0, node.userData.decal );
            //this.mtx.multiplyMatrices( this.mtx1, this.mtx );


            this.mtx.decompose( this.p, this.q, this.s );


            node.position.copy( this.p );
            node.quaternion.copy( this.q );

            node.updateMatrix();

        }

        super.updateMatrixWorld( force );

    }

    init () {

        this.mtxr.copy( this.root.matrixWorld ).invert();

        // get character bones
        const bones = this.bones; //object.skeleton.bones;
        //let nodes = [];

        let p1 = new Vector3();
        let p2 = new Vector3();

        let i, lng = bones.length, name, n, bone, parent;
        let size, dist, type, translate, rot, fx;

        for( i = 0; i < lng; i++ ){

            type = null;
            bone = bones[i];
            name = bone.name;
            parent = bone.parent;

            //bone.updateMatrix()


            if( parent ) {

                //parent.updateMatrix()

                n = parent.name;

                p1.setFromMatrixPosition( parent.matrixWorld );
                p2.setFromMatrixPosition( bone.matrixWorld );

                //p1.setFromMatrixPosition( this.mtx.multiplyMatrices(this.mtxr, parent.matrixWorld ) ) //parent.matrixWorld );
                //p2.setFromMatrixPosition( this.mtx.multiplyMatrices(this.mtxr, bone.matrixWorld ) ) //bone.matrixWorld );
                dist = p1.distanceTo( p2 );

                //console.log(n, dist)

                translate = [ 0, 0, dist * 0.5 ];
                size = [ dist, 1, 1 ];
                rot = [0,0,0];

                fx = '_C';

                if( n==='head' && name === 'End_head' ){ type = 'box'; size = [ 0.16, 0.2, dist ]; translate = [ 0, 0.025, -dist * 0.5 ]; }
                if( n==='chest' && name==='neck' ){ type = 'box'; size = [  0.30, 0.28, dist ]; translate = [ 0, 0, -dist * 0.5 ]; }
                if( n==='abdomen' ){ type = 'box'; size = [ 0.28, 0.24,  dist+0.14 ]; rot[2] = 0; translate = [ 0, 0, -dist * 0.5 ];translate[2] += 0.07;}

                 // legs
                if( n==='rThigh' ){ type = 'box'; size = [  0.15, 0.15, dist ];  }
                if( n==='lThigh' ){ type = 'box'; size = [  0.15, 0.15 , dist];  }
                if( n==='rShin' ){ type = 'box'; size = [  0.12, 0.12, dist+ 0.1, ]; translate[2] += 0.05; }
                if( n==='lShin' ){ type = 'box'; size = [  0.12, 0.12, dist+ 0.1, ]; translate[2] += 0.05; }

                // arm
                if( n==='rShldr'  ){ type = 'box'; size = [   dist+ 0.06, 0.12, 0.12  ]; translate[0] = -translate[2]+0.03; translate[2]=0; }
                if( n==='lShldr'  ){ type = 'box'; size = [  dist+ 0.06,0.12,   0.12, ];  translate[0] = translate[2]-0.03; translate[2]=0; }
                if( n==='rForeArm' ){ type = 'box'; size = [  dist + 0.1,0.1,  0.1 ];  translate[0] = -translate[2]-0.05; translate[2]=0; }
                if( n==='lForeArm' ){ type = 'box'; size = [  dist + 0.1,0.1,  0.1]; translate[0] = translate[2]+0.05; translate[2]=0; }

                if( type !== null ) this.addMesh( parent, type, size, translate, rot, fx );

            }
        }

        this.isReady = true;

    }

    addMesh ( parent, type, size, translate, rot, fx ) {

        // translation
        //this.mtx.makeTranslation( translate[0], translate[1], translate[2] );
        this.mtx.makeTranslation( translate[0], translate[1], translate[2] );
        // rotation
        //this.mtx2.makeRotationFromEuler( this.e.set( rot[0]*math.torad, rot[1]*math.torad, rot[2]*math.torad ) );
        //this.mtx.multiply( this.mtx2 );

       //let box = new BoxGeometry( size[0], size[1], size[2])


        var mesh = new Mesh( this.box, this.mat );
        mesh.scale.fromArray(size);

        //mesh.name = fx;
        mesh.userData.decal = this.mtx.clone();
        mesh.userData.bone = parent;
        mesh.userData.size = size;


        this.add( mesh );

        //mesh.userData.avatar = this.avatar;

    }

    dispose () {
        this.children = [];
        this.box.dispose();
        this.mat.dispose();
        this.isReady = false;
    }

}

/*
function getBoneList( object ) {

    const boneList = [];

    if ( object.isBone === true ) {

        boneList.push( object );

    }

    for ( let i = 0; i < object.children.length; i ++ ) {

        boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

    }

    return boneList;

}*/

const setting$5 = {

    mixRatio:0.0,
    threshold:0.1,
    normal:0.25,
    hair:0x752002,//0xa43412,
    bow:0x100402,
    sheen:1,//2.25,
    sheenRoughness:1.0,//1.0,
    metalness:0.6,
    roughness:0.4,
    
    vertexColors:false,
    alphaTest:0.1,//0.3,
    h_metal:0.0,//0.4,
    h_rough:0.5,//0.6,
    clearcoat:1.0,

    wireframe:false,
    transparent:false,
    opacity:1.0,
    
};

const Human = {

    refSize:1.81,

	isBreath:false,
	isEyeMove:false,
	
    haveHair:true,
    haveBlink:true,

    haveMorph:true,
    morphNormal:false,
    morphRelative:false,

    haveLOD:true,

    levelHigh:['body', 'Head', 'crane', 'eyelash', 'eyebrow', 'tear', 'eye_l', 'eye_r', 'eye_l_s', 'eye_r_s'],
    levelHair:['hair', 'hair_man'],
    levelLow:['body_low'],

    skeletonRef:'body',
	fullMorph: ['MUSCLE', 'LOW', 'BIG','MONSTER'],//, 

    textureQuality:1,
	textureRef:'avatar_c',
	texturePath: 'assets/textures/avatar_',
	textures: [
        'avatar_c.jpg', 'avatar_n.jpg', 'avatar_t.jpg',//'avatar_m.jpg', 'avatar_r.jpg', 'avatar_u.jpg',
        'mouth_c.jpg', 'mouth_a.jpg', 'mouth_n.jpg', 
        'eye_c.jpg', 'eye_n.jpg', 'hair.jpg', 'hair_a.jpg',
        'eyelash_c.jpg', 'eyelash_a.jpg', 'eyelash_n.jpg',
        'hair_man.jpg', 'hair_man_a.jpg', 'avatar_ao.jpg',
    ],

    modelPath: 'assets/models/avatar/',
    forceModel: null,

    setting:setting$5,

    materialRef:'skin',

    materials:{
        skin:{
            type:'Sss',
            map: 'avatar_c', 
            normalMap:'avatar_n',

            //envMapIntensity:0.7,
            //reflectivity:1.0,

            roughness:0.54,
            metalness:0.14,
            
            /*roughness:1,
            metalness:1,
            metalnessMap:'avatar_m',
            roughnessMap:'avatar_r',*/

            normalScale: new Vector2( setting$5.normal, -setting$5.normal ),
            
            /*sheen:setting.sheen,
            sheenColor:0xFFFFFF,
            sheenRoughness:setting.sheenRoughness,
            sheenColorMap:'avatar_c',
            /*sheenColor:0xff0000,
            sheenColorMap:'avatar_u',
            iridescence:0.1,*/
            wireframe:setting$5.wireframe,

            aoMap:'avatar_ao',
            aoMapIntensity:1.0,

            //ior:1.4,
            vertexColors:false,

            sssMap:'avatar_t',
            sssColor:new Color( 0xee2323 ),
            sssAmbient:0.5,
            sssDistortion:0.6,
            sssAttenuation:0.1,
            sssScale:6.0
            
        },
    	mouth:{
            type:'Standard',
    		map:'mouth_c',
            roughness:0.02,
            metalness:0.0,
            vertexColors:false,
            //shadowSide: BackSide,
            //roughness:0.6,
            //metalness:0.6,
            alphaMap:'mouth_a',
            alphaTest:0.5,
            normalMap:'mouth_n',
            normalScale: new Vector2( 0.5, -0.5 ),
    	},
    	sub_eye:{
            type:'Physical',
            roughness:0,//0.568,
            metalness:1,
            ior:1.376,
            opacity:0.1,
           //blending:AdditiveBlending,
            clearcoat:1,
            transparent:true,
            //envMapIntensity:0,
            //wireframe:true
        },
        eye:{
            type:'Physical',
        	map:'eye_c',
            roughness:0.7,
            metalness:0.15,
            normalMap:'eye_n',
            normalScale:new Vector2( 2, -2),
            clearcoat:0.25,
            //clearcoatRoughness:0.5,
        },
        hair:{
            type:'Standard',
        	//map:'hair',
            color:setting$5.hair,
            aoMap:'hair',
            metalnessMap:'hair',
            //bumpScale:-5,
            roughness:0.6,//setting.h_rough,
            metalness:1.0,//setting.h_metal,
            alphaMap:'hair_a',
            //alphaTest:setting.alphaTest,
            side: DoubleSide,
            emissive:setting$5.hair,
            emissiveIntensity:0.5,
            //opacity:1.0,
            transparent:true,
            blending:CustomBlending,
            blendDst:ZeroFactor,
            blendDstAlpha:SrcAlphaFactor,
            //forceSinglePass:true,
            //alphaHash:true,
            //premultipliedAlpha:true,
            alphaToCoverage:true,
        },
        hair_man:{
            type:'Standard',
            color:setting$5.hair,
        	//map:'hair_man',
            aoMap:'hair_man',
            metalnessMap:'hair_man',
            roughness:0.6,
            metalness:1.0,//setting.h_metal,
            alphaMap:'hair_man_a',
            side: DoubleSide,

            //alphaTest:setting.alphaTest,
            
            //opacity:1.0,
            //emissive:setting.hair,
            //emissiveIntensity:0.5,
            //sheen:1.0,
            //sheenColor:setting.hair,
            //sheenRoughness:1.0,
            transparent:true,
            blending:CustomBlending,
            blendDst:ZeroFactor,
            blendDstAlpha:SrcAlphaFactor,
            forceSinglePass:true,
            //alphaHash:true,
            //premultipliedAlpha:true,
            alphaToCoverage:true,
        },
        eyelash:{
            type:'Standard',
        	color:setting$5.hair,
            map:'eyelash_c',
            //roughness:setting.h_rough,
           // metalness:setting.h_metal,
            alphaMap:'eyelash_a',
            //alphaTest:setting.alphaTest,
            transparent:true,
            opacity:1,
            side: DoubleSide,
            alphaToCoverage:true,
            polygonOffset: true,                
            polygonOffsetFactor: -4,
            //normalMap:'eyelash_n',
            //normalScale:new Vector2( 1, -1)
        },
        tear:{
            type:'Standard',
        	map:'eyelash_c',
            roughness:0.0,
            metalness:1.0,
            alphaMap:'eyelash_a',
            transparent:true,
            alphaToCoverage:true,
            opacity:1,
        },
        low:{
            type:'Basic',
        	//color:0x000000,
            //wireframe: true,
        }

    },

    changeMaterial:( sx = {}, def = false ) => {

        if( !Pool.getMaterial( Human.materialRef ) ) return

        const s = Human.setting;
        const defMat = Human.materials;
        
        let change = false;

        for(let v in sx){
            if(s[v]!== undefined){ 
                if(s[v] !== sx[v]){ 
                    s[v] = sx[v];
                    change = true;
                }}
        }

        let m;

        if(change){

            for(let key in defMat){
                m = Pool.getMaterial( key );
                for(let v in sx){
                    if( m[v] !== undefined ){ 

                        if( def && defMat[key][v] ) m[v] = defMat[key][v];
                        else m[v] = sx[v];

                    }
                }
            }

        }


    },

    

    applyMaterial:( root, model ) => {

        // apply Material



        const startHigh = true;//!Human.haveLOD;
        //console.log(startHigh, Human.haveLOD)

        const def = Pool.getMaterial( 'skin' );

        root.traverse( ( node ) => {

            if ( node.isMesh ){
                switch( node.name ){
                    case 'body':
                    node.material = def;
                    node.receiveShadow = true;
                    node.castShadow = true;
                    node.visible = startHigh;
                    break;
                    case 'body_low': 
                        node.material = def;
                        node.receiveShadow = true;
                        node.castShadow = true;
                        node.visible = false;
                    break;
                    case 'Head': 
                    node.material = def;
                    node.receiveShadow = true;
                    node.castShadow = true;
                    node.visible = startHigh;
                    break;
                    case 'crane': 
                    node.material = def;
                    node.receiveShadow = true;
                    node.castShadow = false;
                    node.visible = !Human.haveHair;//startHigh
                    break;
                    case 'mouth':
                    node.material = Pool.getMaterial( 'mouth' ) || def;
                    node.receiveShadow = true;
                    node.castShadow = false;
                    node.visible = startHigh;
                    // correct bad light
                    node.geometry.computeVertexNormals();
                    break;
                    case 'eyelash':  case 'eyebrow':
                    node.material = Pool.getMaterial( 'eyelash' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    node.visible = startHigh;
                    break;
                    case 'tear': 
                    node.material = Pool.getMaterial( 'tear' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    node.visible = startHigh;
                    break;
                    case 'eye_l':case 'eye_r':
                    node.material = Pool.getMaterial( 'eye' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    break;
                    case 'eye_l_s':case 'eye_r_s':
                    node.material = Pool.getMaterial( 'sub_eye' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    node.visible = startHigh;
                    break;
                    case 'hair': 
                    node.material = Pool.getMaterial( 'hair' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;//true;
                    //node.matrixWorldAutoUpdate = false
                    node.visible = Human.haveHair ? startHigh : false;
                    break;
                    case 'hair_man': 
                    node.material = Pool.getMaterial( 'hair_man' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;//true;
                    //node.matrixWorldAutoUpdate = false
                    node.visible = Human.haveHair ? startHigh : false;
                    break;
                }
            }

        });

    },

    /*lowMode:( b ) => {

        if(b){
            setVisible()
        }


    },*/

    adjustment:() => {

        //return []

        return [
        //{name:'head', values:[-10,0,0]},
        {name:'neck', values:[-5,0,0]},
        {name:'chest', values:[5,0,0]},
        
        {name:'lCollar', values:[0,0,-10]},
        {name:'rCollar', values:[0,0,10]},

        {name:'lShldr', values:[-20,2,5]},
        {name:'rShldr', values:[-20,-2,-5]},

        //{name:'lShldr', values:[-5,2,0]},
        //{name:'rShldr', values:[-5,-2,0]},

        {name:'lForeArm', values:[0,0,10]},
        {name:'rForeArm', values:[0,0,-10]},

        {name:'lHand', values:[0,15,10]},
        {name:'rHand', values:[0,-15,-10]},
        //{name:'lThumb1', values:[0,-15,0]},
        //{name:'rThumb1', values:[0,15,0]},
        {name:'lThumb2', values:[0,25,10]},
        {name:'rThumb2', values:[0,-25,-10]},
        ]

    }





};

const setting$4 = {

    wireframe:false,
    normal:0.25,
    hair:0x252011,
    
};

const Human_low = {

	isBreath:false,
	isEyeMove:false,
	haveMorph:true,
    
    skeletonRef:'body_low',
	fullMorph: ['MUSCLE', 'LOW', 'BIG', 'MONSTER'],

	//haveQuality: true,
    //textureQuality:0,
    textureRef:'avatar_c_0k',
    texturePath: 'assets/textures/avatar/',
    textures: ['avatar_c_0k.jpg', 'avatar_n_0k.jpg', 'avatar_ao_0k.jpg', 'hair_man_a_0k.jpg', 'Hair_01_c.png', 'Hair_01_n.png'],

    modelPath: 'assets/models/avatar/',
    forceModel: null,

    setting:setting$4,

    materialRef:'skin_low',
    materials:{
        skin_low:{
            //color:0xE24C00,
            type:'Standard',//Physical',
            map: 'avatar_c_0k',
            aoMap:'avatar_ao_0k',
            normalMap: 'avatar_n_0k',

            normalScale: new Vector2( setting$4.normal, -setting$4.normal),
            //normalMapType: ObjectSpaceNormalMap,
            envMapIntensity:0.3,
            roughness:0.22,
            metalness:0.0,
            //reflectivity:0.05,
            vertexColors:false,
            /*sheen:1.0,
            sheenColor:0x692000,
            sheenRoughness:0.5,**/
            //side:DoubleSide,
            
            
        },
        hair_low:{
            //color:0xE24C00,
            type:'Standard',
            color:setting$4.hair,
            alphaMap: 'hair_man_a_0k',
            transparent:true,
            //blending:CustomBlending,
            //blendDst:ZeroFactor,
            //blendDstAlpha:SrcAlphaFactor,
            //alphaToCoverage:true,
        },

        hair_low_2:{
            //color:0xE24C00,
            type:'Standard',
            color:setting$4.hair,
            map:'Hair_01_c',
            normalMap: 'Hair_01_n'
        },

    },

    changeMaterial:( sx = {}, def = false ) => {

        if( !Pool.getMaterial( Human_low.materialRef ) ) return

            const defMat = Lee.materials;
        let m;

        for(let key in defMat){
            m = Pool.getMaterial( key );
            for(let v in sx){
                if( m[v] !== undefined ){ 
                    if( def && defMat[key][v] ) m[v] = defMat[key][v];
                    else m[v] = sx[v];
                }
            }
            //m.needsUpdate = true
        }

    },

    
    applyMaterial:( root, model ) => {

        // apply Material

        const def = Pool.getMaterial( Human_low.materialRef );

        root.traverse( ( node ) => {

            if ( node.isMesh ){
                switch( node.name ){
                    case 'body_low':
                    //Pool.symetric( node );
                    //node.geometry.deleteAttribute( 'normal' );
                    
                    //node.geometry.deleteAttribute( 'tangent' );
                    //node.geometry.computeVertexNormals()
                    node.material = def;
                    //node.material.normalMapType = ObjectSpaceNormalMap;

                    //node.material.needsUpdate = true

                    //Pool.objectSpaceNormal( node );
                    node.receiveShadow = true;
                    node.castShadow = true;
                    break;
                    case 'hair_low':
                    node.material = Pool.getMaterial( 'hair_low' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    break;
                    case 'hair_low_2':
                    node.material = Pool.getMaterial( 'hair_low_2' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    break;
                    
                }
            }

        });

    },

    adjustment:() => {

        return [
        {name:'neck', values:[-5,0,0]},
        {name:'chest', values:[5,0,0]},
        {name:'lCollar', values:[0,0,-10]},
        {name:'rCollar', values:[0,0,10]},
        {name:'lShldr', values:[-20,2,0]},
        {name:'rShldr', values:[-20,-2,0]},
        
        ]

    }





};

const setting$3 = {

    metalness:0.33,
    roughness:0.11,
    clearcoat:0.0,
    wireframe:false,
    
};

const Eva = {

    decalY:0.02,

	isBreath:false,
	isEyeMove:false,
	haveMorph:false,

	skeletonRef:'eva_SKIN',

	fullMorph: [],

	haveQuality: false,
	skinRef:'eva_00',
	texturePath: 'assets/textures/eva/',
	textures: ['eva00_c.jpg', 'eva01_c.jpg', 'eva02_c.jpg', 'eva_l.jpg', 'eva_ao.jpg'],

    modelPath: 'assets/models/',
    forceModel:'eva',

    setting:setting$3,

    materialRef:'eva00',
    materials:{
        eva00:{
            type:'Physical',
            map: 'eva00_c', 
            emissiveMap:'eva_l',
            emissive:0xffffff,
            roughness:setting$3.roughness,
            metalness:setting$3.metalness,
            wireframe:setting$3.wireframe,
            clearcoat:setting$3.clearcoat,
            //iridescence:0.5,
            aoMap:'eva_ao',
        },
        eva01:{
            type:'Physical',
            map: 'eva01_c',
            emissiveMap:'eva_l',
            emissive:0xffffff,
            roughness:setting$3.roughness,
            metalness:setting$3.metalness,
            wireframe:setting$3.wireframe,
            clearcoat:setting$3.clearcoat,
            //iridescence:0.5,
            aoMap:'eva_ao',
        },
        eva02:{
            type:'Physical',
            map: 'eva02_c', 
            emissiveMap:'eva_l',
            emissive:0xffffff,
            roughness:setting$3.roughness,
            metalness:setting$3.metalness,
            wireframe:setting$3.wireframe,
            clearcoat:setting$3.clearcoat,
            //iridescence:0.5,
            aoMap:'eva_ao',
        }
    },

    changeMaterial:( sx, def = false ) => {

        if( !Pool.getMaterial( Eva.materialRef ) ) return

        //const s = Eva.setting;
        const defMat = Eva.materials;
        
        /*let change = false;

        for(let v in sx){
            if(s[v]!== undefined){ 
                if(s[v] !== sx[v]){ 
                    s[v] = sx[v]
                    change = true;
                }}
        }*/

        let m;

        //if(change){

            for(let key in defMat){
                m = Pool.getMaterial( key );
                for(let v in sx){
                    if( m[v] !== undefined ){ 
                        if( def && defMat[key][v] ) m[v] = defMat[key][v];
                        else m[v] = sx[v];
                    }
                }
                m.needsUpdate = true;
            }

        //}

        /*

        const s = Eva.setting;

        if(Setting){
            for(let o in Setting){
                if( s[o] !== undefined) s[o] = Setting[o]
            }
        }
        
        let m = Pool.getMaterial( 'eva00' );
        m.roughness = s.roughness;
        m.metalness = s.metalness;
        m.wireframe = s.wireframe;
        m.clearcoat = s.clearcoat;
        m = Pool.getMaterial( 'eva01' );
        m.roughness = s.roughness;
        m.metalness = s.metalness;
        m.wireframe = s.wireframe;
        m.clearcoat = s.clearcoat;
        m = Pool.getMaterial( 'eva02' );
        m.roughness = s.roughness;
        m.metalness = s.metalness;
        m.wireframe = s.wireframe;
        m.clearcoat = s.clearcoat;*/

    },

    applyMaterial:( root, model ) => {

    	const def = Pool.getMaterial( model );

        root.traverse( ( node ) => {

            if ( node.isMesh ){
            	
            	node.material = def;
                node.receiveShadow = true;
                node.castShadow = true;
                //node.matrixWorldAutoUpdate = false

                switch( node.name ){

                    case 'eva_2_head': case 'eva_2_mach': 
                    node.visible = model === 'eva02' ? true : false;
                    break;

                    case 'eva_L_COLLAR': case 'eva_R_COLLAR': 
                    node.visible = model === 'eva00' ? false : true;
                    break;

                    case 'eva_HEAD': case 'eva_MACHOIR': 
                    node.visible = model === 'eva01' ? true : false;
                    break;

                    case 'eva_0_R_COLLAR':case 'eva_0_L_COLLAR':case 'eva_0_head': case 'eva_0_head2':
                    node.visible = model === 'eva00' ? true : false;
                    break;

                    case 'eva_0_CHEST2':
                    node.visible = model === 'eva01' ? false : true;
                    break;
                }
            }

        });

    }




};

const setting$2 = {

    metalness:0.2,
    roughness:0.8,
    wireframe:false,
    
};

const Lee$1 = {

    decalY:-0.06,

	isBreath:false,
	isEyeMove:false,
	haveMorph:false,

	skeletonRef:'leeSkin',

	fullMorph: [],

	haveQuality: false,
	//skinRef:'leeSkin',
	texturePath: 'assets/textures/',
	textures: ['lee_c.jpg', 'lee_ao.jpg'],

    modelPath: 'assets/models/',
    forceModel:'lee',

    setting:setting$2,

    materialRef:'lee_material',
    materials:{
        lee_material:{
            type:'Physical',
            map: 'lee_c', 

            roughness:0.3,
            metalness:0.08,
            //aoMap: 'lee_ao',
            wireframe:setting$2.wireframe,
            sheen:2.2,
            //emissive:0xFFFFFF,
            //emissiveMap:'lee_c',
            sheenColorMap:'lee_c',
            sheenColor:0xFFFFFF,
            sheenRoughness:0.4,
            envMapIntensity:1,
            //aoMapIntensity:0.5,
            //emissiveIntensity:0.25,

        },
    },

    /*changeMaterial:( Setting ) => {

        const s = Lee.setting;

        if(Setting){
            for(let o in Setting){
                if( s[o] !== undefined) s[o] = Setting[o]
            }
        }
        
        let m = Pool.getMaterial( 'lee_material' );
        m.roughness = s.roughness;
        m.metalness = s.metalness;
        m.wireframe = s.wireframe;

    },*/

    changeMaterial:( sx, def = false ) => {

        if( !Pool.getMaterial( Lee$1.materialRef ) ) return

        const defMat = Lee$1.materials;
        let m;

        for(let key in defMat){
            m = Pool.getMaterial( key );
            for(let v in sx){
                if( m[v] !== undefined ){ 
                    if( def && defMat[key][v] ) m[v] = defMat[key][v];
                    else m[v] = sx[v];
                }
            }
            //m.needsUpdate = true
        }

    },

    applyMaterial:( root, model ) => {

    	const def = Pool.getMaterial( 'lee_material' );

        root.traverse( ( node ) => {

            if ( node.isMesh ){
            	
            	node.material = def;
                node.receiveShadow = true;
                node.castShadow = true;

            }

        });

    },

    adjustment:() => {

        return [
            //{name:'lShldr', values:[0,-70,0]},
            {name:'lHand', values:[-60,0,0]},
            //{name:'rShldr', values:[0,70,0]},
            {name:'rHand', values:[-60,0,0]}
        ]

    }




};

const setting$1 = {

    metalness:0.2,
    roughness:0.8,
    wireframe:false,
    
};

const Barbados = {

    decalY:-0.06,

	isBreath:false,
	isEyeMove:false,
	haveMorph:false,

	skeletonRef:'barbados',

    multyMaterial:true,

	fullMorph: [],

	haveQuality: false,
	//skinRef:'leeSkin',
	texturePath: 'assets/textures/',
	textures: [],

    modelPath: 'assets/models/',
    forceModel:'barbados',

    setting:setting$1,

    materialRef:'bb',
    materials:{
        bb:{
            type:'Physical',

            roughness:0.3,
            metalness:0.08,
            //aoMap: 'lee_ao',
            wireframe:setting$1.wireframe,
            sheen:2.2,
            //emissive:0xFFFFFF,
            //emissiveMap:'lee_c',
            sheenColor:0xFFFFFF,
            sheenRoughness:0.4,
            envMapIntensity:1,
            //aoMapIntensity:0.5,
            //emissiveIntensity:0.25,

        },
    },

    /*changeMaterial:( Setting ) => {

        const s = Lee.setting;

        if(Setting){
            for(let o in Setting){
                if( s[o] !== undefined) s[o] = Setting[o]
            }
        }
        
        let m = Pool.getMaterial( 'lee_material' );
        m.roughness = s.roughness;
        m.metalness = s.metalness;
        m.wireframe = s.wireframe;

    },*/

    changeMaterial:( sx, def = false ) => {

       /* if( !Pool.getMaterial( Lee.materialRef ) ) return

        const defMat = Lee.materials;
        let m;

        for(let key in defMat){
            m = Pool.getMaterial( key );
            for(let v in sx){
                if( m[v] !== undefined ){ 
                    if( def && defMat[key][v] ) m[v] = defMat[key][v];
                    else m[v] = sx[v];
                }
            }
            //m.needsUpdate = true
        }*/

    },

    applyMaterial:( root, model ) => {

    	/*const def = Pool.getMaterial( 'bb' );

        root.traverse( ( node ) => {

            if ( node.isMesh ){
            	
            	node.material = def;
                node.receiveShadow = true;
                node.castShadow = true;

            }

        })*/

    },

    adjustment:() => {

        return [
            //{name:'lShldr', values:[0,-70,0]},
            //{name:'lHand', values:[-60,0,0]},
            //{name:'rShldr', values:[0,70,0]},
            //{name:'rHand', values:[-60,0,0]}
        ]

    }




};

/** __
*    _)_|_|_
*   __) |_| | 2023
*  @author lo.th / https://github.com/lo-th
* 
*  AVATAR
*/

const FrameTime = 30;
const TimeFrame = 1/30;
const torad$2 = Math.PI / 180;
const todeg = 180 / Math.PI;
const V = new Vector3();


const preloadAvatar = {

    tmp:[],
    model:[],
    avatar:null,
    callback:() => {},

    add:( names, callback ) => {

        preloadAvatar.tmp = [...names];
        preloadAvatar.callback = callback;

        if(preloadAvatar.tmp.length){
            preloadAvatar.loadOne();
        }

    },

    loadOne:() => {

        let name = preloadAvatar.tmp[0];
        preloadAvatar.avatar = new Avatar({ type:name, callback:preloadAvatar.next, morph:true, isPreload:true });

    },

    next:( name ) => {
        
        preloadAvatar.avatar.dispose();

        preloadAvatar.tmp.shift();
        if( preloadAvatar.tmp.length === 0 ){
            preloadAvatar.callback();
        }else {
            preloadAvatar.loadOne();
        }
    }

};

class Avatar extends Group$1 {

	constructor( o = {} ) {

        super();

        this.isPreload = o.isPreload || false;

        this.fixWeight = o.fixWeight !== undefined ? o.fixWeight : true;

        this.rootPath = o.path || './';
        this.lzmaPath = this.rootPath + 'src/libs/lzma_worker.js';
        Pool.dracoPath =  this.rootPath + 'src/libs/draco/';

        this.callback = o.callback || function (){};

        this.matrixAutoUpdate = false;
        this.isPause = true;

        //this.textureQuality = o.quality || 1;

        this.randomMorph = o.randomMorph || false;
        this.randomSize = o.randomSize || false;

        this.actionPose = null;

        this.model = o.type || 'man';
        this.startAnimation = o.anim || 'idle';

        this.bodyMorph = [0,0];
        this.faceMorph = [0,0];

        this.ref = null;

        switch( this.model ){
            case 'barbados': this.ref = Barbados; break;
            case 'lee': this.ref = Lee$1; break;
            case 'man': case 'woman': this.ref = Human; break;
            case 'man_low': case 'woman_low': this.ref = Human_low; break;
            case 'eva00': case 'eva01': case 'eva02': this.ref = Eva; break;
        }


        this.compact = o.compact !== undefined ? o.compact : true;
        this.haveMorph = o.morph !== undefined ? o.morph : false;
        this.fullMaterial = o.material !== undefined ? o.material : true;



        this.size = o.size || 1;
        this.realSize = 0;
        this.baseSize = 0;


        this.fullMorph = this.ref.fullMorph || [];
        if(this.randomMorph && this.fullMorph.length ) this.haveMorph = true;

        this.textureQuality = this.ref.textureQuality || 0;


        this.skeleton = null;
        //this.root = null;
        this.mixer = null;
        this.mesh = {};
        this.bones = {};
        this.done = false;
        this.isClone = false;
        
        this.isBreath = this.ref.isBreath || false;
        this.isEyeMove = this.ref.isEyeMove || false;
        this.haveBlink = this.ref.haveBlink || false;

        this.haveLOD = this.ref.haveLOD || false;
        if( o.noLOD ){
            this.ref.haveLOD = false; 
            this.haveLOD = false;
        }
        this.lod = -1;

        this.decalY = this.ref.decalY || 0;

        this.tensionTest = false;
        this.tensionActive = false;

        this.fixToe = false;
        this.clipsToesFix = [];

        this.n = Math.round(Math.random()*1000);

        this.actions = new Map();
        this.current = null;
        this.old = null;

        this.breath = 0;
        this.breathSide = -1;

        this.q = new Quaternion$1().setFromAxisAngle( {x:0, y:1, z:0}, Math.PI*0.5 );
        this.headBoneLook = new Vector3();
        this.eyeTarget = new Group$1();//new AxesHelper(0.01)//
        this.eyeTarget.position.set(0, 1, 0);

        this.tmpMtx = new Matrix4();
        this.tmpQ = new Quaternion$1();

        this.setting = {};

        //this.initMaterial();

        this.root = Pool.get( this.ref.forceModel ? this.ref.forceModel : this.model, 'O' );

        if( this.root ){
            this.isClone = true;
            this.tensionTest = false;
            this.root = clone( this.root );
            this.init();

        } else {
            if( this.fullMaterial ) this.load();
            else this.loadModels();
        }

    }

    rand( low = 0, high = 1 ){ 
        return low + Math.random() * ( high - low ) 
    }

    load(){

        if( !this.ref.textures || !this.ref.textures.length ){ 
            this.loadModels();
            return
        }

        this.skin = Pool.getTexture( this.ref.textureRef, { quality:this.textureQuality } );

        if( !this.skin ){

            const path = this.rootPath + this.ref.texturePath + ( this.textureQuality ? this.textureQuality + 'k/' : '' );
            //console.log(path)
            Pool.load( this.ref.textures, this.loadModels.bind(this), path, 'loading images...', this.textureQuality );

        } else {

            this.loadModels();

        }

    }

    loadModels(){

        const model = this.ref.forceModel ? this.ref.forceModel : this.model;
        const asset = [model+'.glb'];
        const path = this.rootPath + this.ref.modelPath;
        if( this.ref.haveMorph && this.haveMorph ) asset.push( model+'_morph.glb' );
        Pool.load( asset, this.init.bind(this), path, 'loading models...' );

    }

    update( delta ){

        if( !this.done ) return;
        if ( this.mixer ){

            this.mixer.update( delta );

            // blink
            if( this.haveBlink ) this.eyeBlink();
            

            if( !this.isClone ){
                this.look( delta*10 );
                this.breathing();
                this.autoToes();
            }

            if( this.tensionActive ){ 
                this.tension1.update();
                this.tension2.update();
            }

            if(this.actionPose){ 
                //console.log(this.getAction( 'idle' )._effectiveWeight)
                this.actionPose.setEffectiveWeight( this.getAction( 'idle' )._effectiveWeight );
            }

            /*if( this.ref.adjustment && !this.isClone ) {
                let dt = this.ref.adjustment()
                let m = dt.length, l
                while(m--){
                    l = dt[m]
                    this.setRot2( l.name, l.x, l.y, l.z )
                }
            }*/

            if( window.gui && window.gui.updateTimeBarre && this.current ){ 
                window.gui.updateTimeBarre( Math.round( this.current.time * FrameTime ), this.current.frameMax );
            }
        }

    }

    eyeBlink(){

        const n = this.n++; 
        let v = 0;
        let t = 10;
        let s = 1/t;

        if( n<=t) v = n*s;
        if( n>t && n<=t*2 ) v = 1-((n-t)*s);

        
        if( this.n>500 ){ this.n = 0;}

        this.setMorph( 'EyeBlink', v );
    
    }

    look( delta ){

        if(!this.isEyeMove) return;
        if(this.isPause) return;

        const v = window.mouse || {x:0, y:0};

        if(delta>1) delta = 1;

        this.headBoneLook.lerp({ x:-(v.y*20)*torad$2, y:0, z:-(v.x*20)*torad$2 }, delta );
        this.eyeTarget.position.lerp({ x:v.x*0.5, y:1, z:-v.y*0.25 }, delta );

        let e = this.headBoneLook;
        this.tmpQ.setFromEuler( { _x:e.x, _y:e.y, _z:e.z, _order:'XYZ' }, false );
        this.bones.head.quaternion.multiply(this.tmpQ);

        let ER = this.bones.ER;
        let EL = this.bones.EL;
        let up = {x:0, y:0, z:1};

        this.tmpMtx.lookAt( EL.position, this.eyeTarget.position.clone().add({x:0.03, y:0, z:-0.074}), up );
        EL.quaternion.setFromRotationMatrix( this.tmpMtx ).multiply(this.q);

        this.tmpMtx.lookAt( ER.position, this.eyeTarget.position.clone().add({x:-0.03, y:0, z:-0.074}), up );
        ER.quaternion.setFromRotationMatrix( this.tmpMtx ).multiply(this.q);

    }

    breathing(){

        if( !this.bones ) return;
        if( !this.isBreath ) return;
        if( !this.skeleton.setScalling ) return;

        let a = this.breath * 0.01;

        if(this.breathSide > 0){
            this.skeleton.setScalling( this.bones.chest, this.lerp (1,1.02, a), this.lerp (1,1.04, a), 1 );
            this.skeleton.setScalling( this.bones.abdomen, 1, this.lerp (1,0.92, a), 1 );
        }else {
            this.skeleton.setScalling( this.bones.chest, this.lerp (1.02,1, a), this.lerp (1.04,1, a), 1 );
            this.skeleton.setScalling( this.bones.abdomen, 1, this.lerp (0.92,1, a), 1 );
        }


        // !! just for testing 
        //this.skeleton.setScalling( this.bones.lShldr, 1.3, 2, 2 )
        //this.skeleton.setScalling( this.bones.lForeArm, 1.3, 2, 2 )

        this.breath ++;
        if( this.breath === 100 ){ this.breath = 0; this.breathSide = this.breathSide > 0 ? -1:1; }

    }

    setPosition( x, y, z ){

        this.position.set( x, y, z );
        this.updateMatrix();

    }

    setRotation( x, y, z, a ){

        let r  = this.lerp( this.rotation.y, y, a);
        this.rotation.set( x, r, z );
        this.updateMatrix();

    }

    lerp( x, y, t ) { return ( 1 - t ) * x + t * y }

    onReady(){}

    initMaterial(){

        if( Pool.getMaterial( this.ref.materialRef ) ) return

        if( !this.fullMaterial ){
            Pool.set( this.ref.materialRef, new MeshStandardMaterial() );
            return
        }

        let m, type, data;

        for( const name in this.ref.materials ){

            data = {...this.ref.materials[name]};
            type = data.type;
            delete data.type;
            for( const t in data ){
                if(t!=='envMapIntensity' && t!=='normalMapType' && t!=='aoMapIntensity' && t!=='aoMapIntensity'){
                    if(t==='map' || t.search('Map')!==-1 ) data[t] = Pool.getTexture( data[t], {quality:this.textureQuality } );
                }
            }


            if(type==='Basic') m = new MeshBasicMaterial( data );
            else if(type==='Standard') m = new MeshStandardMaterial( data );
            else if(type==='Physical') m = new MeshPhysicalMaterial( data );
            else if(type==='Sss') m = new MeshSssMaterial(data);
            m.name = name;

            Pool.set( name, m );

        }

        this.setting = this.ref.setting;

    }


    setMaterial(s, b){
        let m = Pool.getMaterial( this.ref.materialRef );
        if(!m) return;
        for(let p in s){
            if(m[p]!==undefined) m[p] = s[p];
        }

    }

    setMaterialNormal( v ){

        let m = Pool.getMaterial( 'skin' );
        if(!m) return
        if( v<0 ) v = 0;
        m.normalScale.set(v,-v);

    }

    getMaterial( name ){

        return Pool.getMaterial( name )
        
    }

    init(){

        this.initMaterial();

        if( !this.isClone ) {

            let modelName = this.ref.forceModel ? this.ref.forceModel : this.model;

            if( this.ref.multyMaterial ) Pool.getMesh(modelName, true);

            this.root = Pool.get( modelName, 'O' ); 
            this.ref.applyMaterial( this.root, this.model );
        }

        if( this.ref.forceModel && this.isClone ) this.ref.applyMaterial( this.root, this.model );

        this.realSize = 0;

        // get data
        this.root.traverse( function ( node ) {
            
            node.raycast = function(){ return };

            if ( node.isMesh ){

                if( node.name === this.ref.skeletonRef ){
                    node.matrixAutoUpdate = false;

                    this.skeleton = node.skeleton;
                    if( this.skeleton.resetScalling ) this.skeleton.resetScalling();

                    this.realSize = node.geometry.boundingBox.max.y;



                    //console.log( node.geometry.boundingSphere, node.geometry.boundingBox, node.frustumCulled )
                    //node.geometry.boundingSphere.radius = 0.1;
                }
                if( node.name === 'Head' ) this.realSize = node.geometry.boundingBox.max.y;
                
                this.mesh[node.name] = node;
            }
            if ( node.isBone ){
                this.bones[node.name] = node;
                //if(node.name==='rShldr' ) node.rotation.x = 80 * torad
               // console.log(node.name, node.rotation.x*todeg, node.rotation.y*todeg, node.rotation.z*todeg)
            }
        }.bind(this));

        this.realSizeRatio = 1 / this.realSize;
        this.baseSize = this.realSize;

        if( this.ref.isEyeMove ){
            this.bones.neck.add( this.eyeTarget );
        }
    
        //if( !this.isClone ){
        // for extra skin
        for( let m in this.mesh ){
            if( this.mesh[m].isSkinnedMesh && m !== this.ref.skeletonRef ){
                //this.mesh[m].skeleton.dispose();
                this.mesh[m].skeleton = this.skeleton;
            }
        }

        if( !this.isClone ){
            // add morph 
            if( this.haveMorph ) Pool.applyMorph( this.model+'_morph', this.mesh, this.ref.morphNormal, this.ref.morphRelative );
            Pool.set( this.model, this.root, 'O' );
            
        }

        if( this.size !== 1 ) this.root.scale.set(1,1,1).multiplyScalar(this.size);

        //if( this.tensionTest ) this.addTensionMap()



        // animation
        this.mixer = new AnimationMixer( this );

        

        if( Pool.clip.length === 0 ){ 
            // load animation include in json or the compacted version
            if( this.compact ) this.loadCompactAnimation(this.rootPath +'assets/animation/animations.bin');
            else this.loadAnimationJson(this.rootPath +'assets/animation/animations.json', this.start.bind(this) );

        } else {
            let i = Pool.clip.length;
            while(i--) this.addAction( Pool.clip[i] );
            this.start();
        }

        
             
    }

    setRealSize( s ){

        this.realSize = s;
        let r = 0.5 + ((this.baseSize / this.realSize)*0.5);
        this.setSize( this.realSize * this.realSizeRatio );
        this.setHeadSize( r );

    }

    setSize( s ){
        this.size = s;
        this.root.scale.set(1,1,1).multiplyScalar(this.size);
        //this.bones.head.scale.set(1,1,1).multiplyScalar(2);
    }

    setHeadSize( s ){
        this.bones.head.scale.set(1,1,1).multiplyScalar(s);
    }

    addTensionMap(){

        this.tension1 = new Tension( this.mesh.body );
        this.tension2 = new Tension( this.mesh.Head );
    }

    setBounding( r ){

        for( let m in this.mesh ){
            if(this.mesh[m].isMesh ){
                this.mesh[m].geometry.boundingSphere.radius = r;
            }
        }

    }

    /*setBoneScale( v ){

        const ingnor = [ 'head', 'lToes', 'rToes', 'rCollar', 'lCollar', 'rBreast', 'lBreast', 'neck'];
        const center = ['hip', 'abdomen', 'chest'];
        const legs = ['lThigh', 'rThigh', 'lShin', 'rShin'];
        const b = this.bones

        for( let n in b ){
            if(ingnor.indexOf(n) === -1) {
                if(center.indexOf(n) !== -1) b[n].scalling.z = v
                else if(legs.indexOf(n) !== -1) b[n].scalling.z = v
                else if( n === 'root' ) b[n].scalling.y = v
                else if( n === 'rFoot' || n === 'lFoot') b[n].scalling.y = v
                else b[n].scalling.x = v
            } 
        }

        this.setBounding(v)
    }*/

    setLevel( n ){

        if( !this.haveLOD ) return
        if( this.lod === n ) return

        this.lod = n;

        this.hideAll();

        if( this.lod === 0 ) this.setVisible( this.ref.levelLow, true );
        else { 
            this.setVisible( this.ref.levelHigh, true );
            if( this.ref.haveHair ){ 
                //this.mesh.body.visible = false;
                this.setVisible( this.ref.levelHair, true );
            }
        }
    
    }

    hideAll(){

        for( let m in this.mesh ) this.mesh[m].visible = false;
    
    }
 
    setVisible( names, v ){

        if( typeof names === 'string' ) names = [names];
        let i = names.length, name;
        while(i--){
            name = names[i];
            if( this.mesh[name] ) this.mesh[name].visible = v;
        }
    
    }


    /*eyeControl( v ){

        this.setMorph('EyeBlink', v)
    
    }*/

    setMorph( name, v ){

        v = v < 0 ? 0 : v;
        //v = v > 1 ? 1 : v;

        if( !this.haveMorph ) return
        this.morpher( 'eyelash', name, v);
        this.morpher( 'eyebrow', name, v);
        this.morpher( 'tear', name, v);
        this.morpher( 'mouth', name, v);
        this.morpher( 'body', name, v);
        this.morpher( 'Head', name, v);
        this.morpher( 'body_low', name, v);
    }

    morpher( obj, name, value ){

        if(!this.mesh[obj]) return
        if(!this.mesh[obj].morphTargetInfluences) return
        if(this.mesh[obj].morphTargetDictionary[name] === undefined ) return
        this.mesh[obj].morphTargetInfluences[ this.mesh[obj].morphTargetDictionary[name] ] = value;
    }

    lerp( x, y, t ) { return ( 1 - t ) * x + t * y; }

    clone( o ){

        return new this.constructor( {type:o.type}, this );
    
    }

    dispose(){

        if( this.exoskel ) this.addExo();
        if( this.helper ) this.addHelper();

        this.stop();
        //if( this.skeleton.resetScalling ) this.skeleton.resetScalling()
        this.mixer.uncacheRoot( this );

        //if(this.skeleton.boneTexture)this.skeleton.boneTexture.dispose();
        this.remove( this.root );

        this.skeleton.dispose();
        if( this.parent ) this.parent.remove(this);
        

        //console.log('hero remove')
        if(!this.isClone);
    }

    start(){

        if( this.isPreload ) { this.callback(); return; }
        if( this.done ) return;

        //this.updateMatrix()

        this.done = true;
 
        

        this.onReady();
        //this.playAll();
        
        this.play( this.startAnimation );

        if( this.ref.adjustment ){
            this.makePoseTrack('adjustment', this.ref.adjustment(), true );
        }

        // Random Human
        if( this.randomMorph ) this.setBodyMorph([this.rand(-1,1), this.rand(-1,1)]);
        if( this.randomSize ) this.setRealSize(this.rand(1,2));


        //this.add( this.root );


        //setTimeout( this.callback, 100 );
        setTimeout( function(){ 
            this.add( this.root );
            this.callback();
        }.bind(this), 100 );
        //this.callback()

    }

    setBodyMorph( v ){

        if(!this.haveMorph) return;

        if(v) this.bodyMorph = v;

        let vx = Number(this.bodyMorph[0]);
        let vy = Number(this.bodyMorph[1]);

        this.setMorph( 'MUSCLE', vy<0?-vy:0 );
        this.setMorph( 'LOW', vy>=0?vy:0 );

        this.setMorph( 'BIG', vx<0?-vx:0 );
        this.setMorph( 'MONSTER', vx>=0?vx:0 );

        let cx = ((vx+1)*0.5);
        let cy = (1-((vy+1)*0.5));

        this.setMaterialNormal( (cy+cx)*0.5 );

    }

    setFaceMorph( v ){

        if(!this.haveMorph) return;
        if(v) this.faceMorph = v;

        let vx = Number(this.faceMorph[0]);
        let vy = Number(this.faceMorph[1]);

        this.setMorph( 'Shock', vy<0?-vy:0 );
        this.setMorph( 'Frown', vy>=0?vy:0 );

        this.setMorph( 'SmileOpen', vx<0?-vx:0 );
        this.setMorph( 'Angry', vx>=0?vx:0 );

    }

    addHelper(){

        if( this.helper ){
            this.helper.dispose();
            this.remove( this.helper );
            this.helper = null;
        } else {
            this.helper = new SkeletonHelper( this.root );
            this.helper.raycast = function (){ return };
            this.helper.matrix = this.root.matrix;
            this.add( this.helper );
        }
    }

    addExo() {

        if( this.exoskel ){
            this.exoskel.dispose();
            this.remove( this.exoskel );
            this.exoskel = null;
        } else {
            this.exoskel = new ExoSkeleton( this.root, this.skeleton );
            this.exoskel.matrix = this.root.matrix;
            this.add( this.exoskel );

        }
        return this.exoskel;
    }

    attachToBone( m, b ){

        m.matrix = b.matrixWorld;
        m.matrixAutoUpdate = false;

    }

    loadAnimationJson( url, callback ){

        const request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.onreadystatechange = function() {
            if ( request.readyState === 4 ) {
                if ( request.status === 200 || request.status === 0 ) {
                    let data = JSON.parse( request.responseText );
                    this.urls = [];
                    for( let g in data ){
                        if( g === 'main' ) this.urls.push( ...data[g] );
                        else this.urls.push( ...data[g].map( x => g+'/'+x ) );
                    }
                    this.endCallback = callback || function(){}; 
                    this.loadOne();
                }
            }
        }.bind(this);
        request.send();

    }

    loadOne(){

        let name = this.urls[0];
        this.loadAnimationFbx( this.rootPath + 'assets/animation/fbx/'+name+'.fbx', this.next.bind(this) );

    }

    next(){

        this.urls.shift();
        if( this.urls.length === 0 ) this.endCallback();
        else this.loadOne();

    }

    loadCompactAnimation( url = './assets/models/animations.bin' ){

        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';

        const glb = { animations : [] };
        const self = this;

        request.onload = function() {
            LZMA.decompress( request.response, (result) => {
                const data = JSON.parse(result);
                
                for(let c in data) glb.animations.push( AnimationClip.parse( data[c] ) ); 
                //console.log( glb )
                self.applydAnimation( glb );
                self.start();
            });
        };
        request.send();

    }

    loadAnimationGlb( url, callback ){

        let name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        Pool.loaderGLTF().load( url, function ( glb ) {
            this.applydAnimation( glb, name );
            if( callback ) callback();
        }.bind(this), null, callback );
    }

    directGlb( data, name ){

        Pool.loaderGLTF().parse( data, '', function ( glb ) {
            this.stop();
            this.applydAnimation( glb, name );
        }.bind(this));
    }

    loadAnimationFbx( url, callback ){

        //if( !this.loaderFbx ) this.loaderFbx = new FBXLoader();
        let name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        Pool.loaderFBX().load( url, function ( node ) {
            this.convertFbx( name, node.animations[ 0 ] );
            if( callback ) callback();
        }.bind(this), null, callback );
    }

    directFbx( data, name ){

        //if( !this.loaderFbx ) this.loaderFbx = new FBXLoader();
        try {
            let node = Pool.loaderFBX().parse( data, '' );
            this.convertFbx( name, node.animations[ 0 ], true );
        } catch ( e ) {
            console.error( 'bug', e );
        }
    }

    applydAnimation( glb, name ){

        let i = glb.animations.length, autoplay = false;
        if( i === 1 ){
            if( name ) glb.animations[0].name = name;
            autoplay = true;
        } 
        while(i--){ 
            this.addClip( glb.animations[i] );
            this.addAction( glb.animations[i], autoplay );
        }

    }

    addClip( clip, additive = false ){

        // Make the clip additive and remove the reference frame
        if( additive ){ 
            AnimationUtils.makeClipAdditive( clip );
            //clip = AnimationUtils.subclip( clip, clip.name, 2, 3, 30 );
        }

        ///console.log(clip)

        let i = Pool.clip.length, removeId = -1;
        while(i--){ if( Pool.clip[i].name === clip.name ) removeId = i; }
        if( removeId !== -1 ) Pool.clip.slice( removeId, 1 );


        //clip.optimize();
        Pool.clip.push( clip );
    }

    addAction( clip, play ){

        const action = this.mixer.clipAction( clip );
        action.frameMax = Math.round( clip.duration * FrameTime );
        action.play();
        action.enabled = true;//false;
        if(clip.name.search('idle')!==-1) action.enabled = true;
        //action.setEffectiveWeight( 0 );
        if( clip.name === 'Jumping Up' ) action.loop = LoopPingPong;
        
        //action.play()
        this.actions.set( clip.name, action );



        /*
        if(clip.name.search('walk')!==-1) this.clipsToesFix.push(clip.name);
        if(clip.name.search('run')!==-1) this.clipsToesFix.push(clip.name);
        if(clip.name.search('strafe')!==-1) this.clipsToesFix.push(clip.name);
        if(clip.name.search('jog')!==-1) this.clipsToesFix.push(clip.name);
        if(clip.name.search('RUN')!==-1) this.clipsToesFix.push(clip.name);
        */

        //console.log(clip.name, action.frameMax)

        if( window.gui && window.gui.getAnimation ) window.gui.getAnimation();

       // if( play ) this.play( clip.name )

             
    }


    /// EXPORT

    getAnimation( toJson = false, fromPool = false ){

        let anim = [], n = 0;
        if(fromPool){
            let i = Pool.clip.length;
            while(i--){

                if( toJson ) anim[n] = Pool.clip[n].toJSON();
                else anim[n] = Pool.clip[n];
                // delete animations[n].uuid
                n++;
            }
        } else {
            this.actions.forEach( function ( action, key ) {
                if( toJson ) anim[n] = action._clip.toJSON();
                else anim[n] = action._clip;
                //delete data[n].uuid
                n++;
            });
        }

        return anim;

    }

    exportAnimationLzma( callback ){

        if(!this.lzma) this.lzma = new LZMA(this.lzmaPath);

        const data = this.getAnimation( true );

        this.lzma.compress( JSON.stringify(data), 2, function(result) {

            if( callback ) callback( {name:'animations', data:new Uint8Array(result), type:'bin'}  );
            else {
                let link = document.createElement("a");
                link.style.display = "none";
                document.body.appendChild(link);
                link.href = URL.createObjectURL( new Blob( [new Uint8Array(result)], {type: "application/octet-stream"} ) );
                link.download = 'animations.bin';
                link.click();
            }
        });
    }

    /*exportGLB( callback ){

        if( !this.exporter ) this.exporter = new GLTFExporter();
        
        const animations = this.getAnimation()

        this.exporter.parse( this.root, function( gltf ){

            if( callback ) callback( {name:'model', data:gltf, type:'glb'}  )
            else {
                let link = document.createElement("a");
                link.style.display = "none";
                document.body.appendChild(link);
                link.href = URL.createObjectURL( new Blob([gltf], { type: "application/octet-stream" }) );
                link.download = 'model.glb';
                link.click();
            }

            //self.loader.parse( JSON.stringify(glb, null, 2), '', function (r){ console.log(r) } )

        }, null, { animations:animations, binary: true, onlyVisible: true } )

    }*/

    armAngle(){

    }

    autoToes(){

        if(!this.fixToe) return;
        let r = this.getRot('rFoot');
        let l = this.getRot('lFoot');
        let v = this.getWorldPos('hip');
        let v0 = this.getWorldPos('rToes');
        let v1 = this.getWorldPos('lToes');
        if(r[0]>0 && (v0.z-v.z)<0) this.setRot('rToes', -r[0]*1.5, 0,0 );
        else if( r[0] !== 0 ) this.setRot('rToes', 0,0,0 );
        if(l[0]>0 && (v1.z-v.z)<0) this.setRot('lToes', -l[0]*1.5, 0,0 );
        else if( l[0] !== 0 ) this.setRot('lToes', 0,0,0 );
    }

    resetToes(){

        if(!this.fixToe) return;
        this.fixToe = false;
        this.setRot('rToes', 0,0,0 );
        this.setRot('lToes', 0,0,0 );

    }

    convertFbx( name, anim, autoplay ) {

        const torad = Math.PI / 180;
        let p = new Vector3();
        let q = new Quaternion$1();
        let RX = new Quaternion$1().setFromAxisAngle({x:1, y:0, z:0}, 90 * torad );

        const baseTracks = anim.tracks;
        const tracks = [];

        let i = baseTracks.length, j, n, t, b, k = 0;

        while(i--){
            t = baseTracks[k];
            b = t.name.substring(0, t.name.lastIndexOf('.') );

            if( t.name === 'hip.position' ){
                let rp = [];
                j = t.values.length / 3;
                while(j--){
                    n = j * 3;
                    p.set( t.values[n], t.values[n+1], 0).multiplyScalar(0.01);
                    p.toArray( rp, n );
                }
                tracks.push( new VectorKeyframeTrack( t.name, t.times, rp ) );

            } else {
                let rq = [];
                j = t.values.length / 4; 
                while(j--){
                    n = j * 4;
                    if( b==='hip') q.set(t.values[n], t.values[n+1], t.values[n+2], t.values[n+3]).multiply( RX );
                    else q.set(t.values[n], t.values[n+2], -t.values[n+1], t.values[n+3]);
                    q.toArray( rq, n );
                }
                tracks.push( new QuaternionKeyframeTrack( t.name, t.times, rq ) );
            }
            k++;
        }

        let clip = new AnimationClip( name, -1, tracks );
        clip.duration = anim.duration;

        //console.log( name, anim.duration )



        this.stop();
        this.addClip( clip );
        this.addAction( clip, autoplay );

    }

    makePoseTrack( name, data, isAdd = false ){

        const torad = Math.PI / 180;
        //let lockPosition = true;
        //let p = new Vector3();
        let q = new Quaternion$1();
        //let RX = new Quaternion().setFromAxisAngle({x:1, y:0, z:0}, 90 * torad );

        const baseTracks = data;// anim.tracks;
        const tracks = [];

        let i = baseTracks.length, j, n, n2, t, k = 0;

        let numFrame = 3;//3

   

        while(i--){
            t = baseTracks[i];
            t.name;//.substring(0, t.name.lastIndexOf('.') )

            /*if( t.name === 'hip.position' ){
                let rp = []
                j = t.values.length / 3;
                while(j--){
                    n = j * 3;
                    if( lockPosition ) p.set( t.values[n], t.values[n+1], 0).multiplyScalar(0.01);
                    else p.set( t.values[n], t.values[n+1], t.values[n+2]).multiplyScalar(0.01);
                    p.toArray( rp, n );
                }
                tracks.push( new VectorKeyframeTrack( t.name, t.times, rp ) );

            } else {*/
                let rq = [];
                let tt = [];
                k = 0;
                j = numFrame;//t.values.length / 3 
                while(j--){
                    n = 0;//j * 3
                    n2 = k * 4;

                    tt.push( k * 0.03333333507180214 );
                    //if( b==='hip') q.set(t.values[n], t.values[n+1], t.values[n+2], t.values[n+3]).multiply( RX );
                    //else q.set(t.values[n], t.values[n+2], -t.values[n+1], t.values[n+3]);
                    q.setFromEuler( {_x:t.values[n]*torad, _y:t.values[n+1]*torad, _z:t.values[n+2]*torad, _order:'XYZ'});
                    q.toArray( rq, n2 );
                    k++;
                }
                tracks.push( new QuaternionKeyframeTrack( t.name+'.quaternion', tt, rq ) );
            //}
            
        }


        // additive not work
        let blendMode = isAdd ? AdditiveAnimationBlendMode : NormalAnimationBlendMode;
        let clip = new AnimationClip( name, -1, tracks, blendMode );
        clip.duration = numFrame * 0.03333333507180214;//anim.duration;

        //console.log(clip)

        const action = this.mixer.clipAction( clip );
        //action.frameMax = numFrame;
        action.enabled = true;
        //action.time = 0;
        action.setEffectiveTimeScale( 1 );
        action.setEffectiveWeight( 1 );
        action.play();

        
        //action.paused = true;
        //this.actions.set( clip.name, action );

        //this.stop();
        //this.addClip( clip, true );
        //this.addAction( clip, autoplay );
        this.actionPose = action;



    }


    //---------------------
    //
    //  ANIMATION CONTROL
    //
    //---------------------

    prepareCrossFade( startAction, endAction, duration )  {
        //singleStepMode = false;

        this.isPause = false;
        this.unPause();
        // If the current action is 'idle' (duration 4 sec), execute the crossfade immediately;
        // else wait until the current action has finished its current loop
        if ( endAction._clip.name !== 'idle' ) {
            this.executeCrossFade( startAction, endAction, duration );
        } else {
            this.synchronizeCrossFade( startAction, endAction, duration );
        }

    }

    synchronizeCrossFade( startAction, endAction, duration ) {

        this.mixer.addEventListener( 'loop', onLoopFinished );
        const self = this;
        function onLoopFinished( event ) {
            if ( event.action === startAction ) {
                self.mixer.removeEventListener( 'loop', onLoopFinished );
                self.executeCrossFade( startAction, endAction, duration );
            }
        }

    }

    executeCrossFade( startAction, endAction, duration, warping = true ) {
        // Not only the start action, but also the end action must get a weight of 1 before fading
        // (concerning the start action this is already guaranteed in this place)
        this.setWeight( endAction, 1 );
        endAction.time = 0;
        // Crossfade with warping - you can also try without warping by setting the third parameter to false
        startAction.crossFadeTo( endAction, duration, true );
    }

    pause(){
        this.actions.forEach( function ( action ) { action.paused = true; });
        this.isPause = true;
    }

    unPause(){
        this.actions.forEach( function ( action ) { action.paused = false; });
        this.isPause = false;
    }

    playAll(){
        this.actions.forEach( function ( action ) { action.play(); });
    }

    setTimescale( timescale ) {

        this.actions.forEach( function ( action ) { action.setEffectiveTimeScale( timescale ); });

    }

    syncro( name ) {

        let action = this.getAction( name );
        if ( !action ) return;
        let time = action.time;
        this.actions.forEach( function ( action ) { action.time = time; });

    }

    /*setTimescale( action, timescale ) {

        action.enabled = true;
        action.setEffectiveTimeScale( timescale );

    }*/

    setWeight( action, weight ) {

        //if( typeof action === 'string' ) action = this.getAction( action );
        //if ( !action ) return;

        action.enabled = true;
        if(weight<0) weight = 0;
        if(weight>1) weight = 1;
        //let old = action.getEffectiveWeight()
        //if(old===0 && weight!== 0) action.time = 0;
        //action.setEffectiveTimeScale( weight );
        action.setEffectiveWeight( weight );

    }


    getAnimInfo( name ){

        let action = this.getAction( name );
        if ( !action ) return;
        return {
            name: name,
            time: action.time,
            frame: Math.round( action.time * FrameTime ),
            frameMax: action.frameMax,
            timeScale: action.timeScale,
        }

        //if( ui ) ui.updateTimeBarre( anim.frame, anim.frameTime, anim.frameMax );

    }

    getAction( name ) {
        //if ( !this.actions.has( name ) ) return;
        return this.actions.get( name );
    }

    play( name, fade = 0.5 ) {

        let action = this.getAction( name );
        if ( !action ) return false;

        if( !this.current ){
            this.stop();
            this.current = action;
            //action.play();
            action.setEffectiveWeight( 1 );
        } else {

            if( this.current !== action ){

                this.old = this.current;
                this.current = action;

                let isIdle = this.current.getClip().name === 'idle';
                isIdle = this.old.getClip().name === 'idle';

                if( this.clipsToesFix.indexOf(name) !== -1 ) this.fixToe = true;
                else this.resetToes();

                let oldEff = this.old.getEffectiveWeight();
                let currentEff = this.current.getEffectiveWeight();
                
                // keep current time to avoid reloop
                let time = this.current.time;
                // sycro if not idle on walk run leg position
                if( !isIdle ){ 
                    let ratio = this.current.getClip().duration / this.old.getClip().duration;
                    time = this.old.time * ratio;
                }

                // reset current
                this.current.reset();
                //currentEff = 0

                this.current.time = time;


                if( this.fixWeight ){

                    this.current.weight = 1.0;
                    this.current.stopFading();
                    this.old.stopFading();//.stopWarping();
                    this.old._scheduleFading( fade, oldEff, 0 );
                    this.current._scheduleFading( fade, currentEff, 1 );

                } else {

                    this.executeCrossFade( this.old, this.current, fade );

                    //this.current.crossFadeFrom( this.old, fade, true );

                }

            }
        } 

        this.isPause = false;

        return true;
    }

    playFrame ( name, frame, weight = 1 ) {



        let action = this.getAction( name );
        if ( !action ) return;

        action.time = frame * TimeFrame;
        action.setEffectiveWeight( weight );
        action.play();
        action.paused = true;
        this.isPause = true;

    }

    playOne ( frame, weight = 1 ) {

        if ( !this.current ) return;

        this.current.time = frame * TimeFrame;
        this.current.setEffectiveWeight( weight );
        this.current.play();
        this.current.paused = true;
        this.isPause = true;

    }

    stop(){

        this.actions.forEach( function ( action ) { action.setEffectiveWeight( 0 ); });
        //this.mixer.stopAllAction()
    }



    // bone control

    setRot( name, x, y, z ){

        let n = this.bones[name];
        if(!n) return
        n.rotation.set( x*torad$2, y*torad$2, z*torad$2, 'XYZ' );
        n.updateMatrix();
    }

    setRot2( name, x, y, z ){

        let n = this.bones[name];
        if(!n) return
        //let q1 = n.quaternion
        let q2 = new Quaternion$1().setFromEuler( {_x:x*todeg, _y:y*todeg, _z:z*todeg, _order:'XYZ'}).invert();
     
        n.quaternion.premultiply(q2);
       // n.rotation.set( x*torad, y*torad, z*torad, 'XYZ' );
        n.updateMatrix();
    }

    getRot( name ){

        let n = this.bones[name];
        if(!n) return
        let r = n.rotation.toArray();
        return [ Math.round(r[0]*todeg), Math.round(r[1]*todeg), Math.round(r[2]*todeg) ];
    }

    getWorldPos( name ){

        let n = this.bones[name];
        if(!n) return
        V.set(0,0,0);
        n.localToWorld(V);
        return { x:V.x, y:V.y, z:V.z };

    }


    //---------------------
    //  HIDE PART OF BODY
    //---------------------

    bodyMask( o = {arm:true, leg:true, foot:true, chest:true } ){

        let s = 0.25;
        if(!this.canvas) {
            this.canvas = document.createElement( 'canvas' );
            this.canvas.width = this.canvas.height = 1024*s;
        }

        const ctx = this.canvas.getContext( '2d' ); 
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, 1024*s, 1024*s);
        ctx.fillStyle = 'black';
        if(o.arm) ctx.fillRect( 784*s, 448*s, 236*s, 186*s );
        if(o.leg) ctx.fillRect( 512*s, 734*s, 287*s, 290*s );
        if(o.foot) ctx.fillRect( 817*s, 822*s, 206*s, 200*s );
        if(o.chest){ 
            ctx.fillRect( 480*s, 576*s, 300*s, 160*s );
            ctx.fillRect( 553*s, 466*s, 228*s, 110*s );
            ctx.fillRect( 533*s, 531*s, 20*s, 45*s );
        }

        let img = new Image();
        img.src = this.canvas.toDataURL();

        if(this.mask) this.mask.dispose();
        //this.mask = new CanvasTexture( this.canvas );

        this.mask = new Texture( img );
        this.mask.flipY = false;
        this.mask.needsUpdate = true;
        const m = Pool.getMaterial( 'skin' );
        m.alphaTest = 0.9;
        m.alphaMap = this.mask;
        //m.needsUpdate = true;
    }


    //---------------------
    //   TOOLS
    //---------------------

    zeroColor(g){

        if( g.isMesh ) g = g.geometry;
        let lng = g.attributes.position.array.length;
        g.setAttribute( 'color', new Float32BufferAttribute( new Array(lng).fill(0), 3 ) );

    }

    /*uv2( g, uv2 = true, tangent = true ) {

        if( g.isMesh ) g = g.geometry;
        g.setAttribute( 'uv2', g.attributes.uv );

    }*/

}

//
// not use native character function of physics engine 
// use some code from https://github.com/ErdongChen-Andrew/CharacterControl
// 

class Hero extends Basic3D {

	constructor( o = {}, motor ) {

		super();

		this.motor = motor;
		this.utils = this.motor.utils;

		this.isCharacter = true;
		this.isPlayer = false;
		this.enable = false;

		this.useImpulse = o.useImpulse || false;
		this.useFloating = o.floating || false;

		this.waitRotation = false;

		let floatHeight = 0.3;
		let radius = o.radius || 0.3;
		let height = o.height || 1.8;//0.7

		this.realHeight = height;

		if(this.useFloating){
			height -= floatHeight;
		}

		this.option = {

			debug: false,
			capsuleHalfHeight: height*0.5,
			capsuleRadius: radius,
			floatHeight: floatHeight,
			characterInitDir: 0, // in rad
			//followLight: false,
			// Follow camera setups
			camInitDis: -5,
			camMaxDis: -7,
			camMinDis: -0.7,
			// Base control setups
			maxVelLimit: 5,//2.5,
			turnVelMultiplier: 0.2,
			turnSpeed: 15,
			sprintMult: 2,
			jumpVel: 4,
			jumpForceToGroundMult: 5,
			slopJumpMult: 0.25,
			sprintJumpMult: 1.2,
			airDragMultiplier: 0.2,
			dragDampingC: 0.15,
			accDeltaTime: 8,
			rejectVelMult: 4,
			moveImpulsePointY: 0.5,
			camFollowMult: 11,
			fallingGravityScale: 2.5,
			fallingMaxVel: -20,
			wakeUpDelay: 200,
			// Floating Ray setups
			rayOriginOffest: { x: 0, y: -height*0.5, z: 0 },
			rayHitForgiveness: 0.1,
			rayLength: radius + 2,
			rayDir: { x: 0, y: -1, z: 0 },

			floatingDis: radius + floatHeight + 0.08,
			springK: 2, //1.2,
			dampingC: 0.2,//0.08,
			// Slope Ray setups
			showSlopeRayOrigin: false,
			slopeMaxAngle: 1, // in rad
			slopeRayOriginOffest: radius - 0.03,
			slopeRayLength: radius + 3,
			slopeRayDir: { x: 0, y: -1, z: 0 },
			slopeUpExtraForce: 0.1,
			slopeDownExtraForce: 0.2,
			// AutoBalance Force setups
			autoBalance: true,
			autoBalanceSpringK: 1.2,//0.3,
			autoBalanceDampingC: 0.04,
			autoBalanceSpringOnY: 0.7,
			autoBalanceDampingOnY: 0.05,
			// Animation temporary setups
			animated: false,
			mode:null,

			//...o

		};

		this.v = {

			movingObjectVelocityInCharacterDir: new Vector3(),
			movingObjectVelocity: new Vector3(),
			standingForcePoint: new Vector3(),

			pivotPosition: new Vector3(),
			//modelEuler: new Euler(),
			modelQuat: new Quaternion$1(),
			moveImpulse: new Vector3(),
			impulseCenter: new Vector3(),
			movingDirection: new Vector3(),
			moveAccNeeded: new Vector3(),
			jumpVelocityVec: new Vector3(),
			jumpDirection: new Vector3(),
			currentVel: new Vector3(),
			currentPos: new Vector3(),
			dragForce: new Vector3(),
			dragAngForce: new Vector3(),
			wantToMoveVel: new Vector3(),
			rejectVel: new Vector3(),

			// Floating Ray setup
			floatingForce:null,
			springDirVec: new Vector3(),
			rayOrigin: new Vector3(),
			characterMassForce: new Vector3(),

			// slope
			slopeAngle:null,
			actualSlopeNormal: new Vector3(),
			actualSlopeAngle:null,
			actualSlopeNormalVec: new Vector3(),
			floorNormal: new Vector3(0, 1, 0),
			slopeRayOriginRef: new Vector3(),
			slopeRayorigin: new Vector3(),

			canJump:false,
			isFalling:false,
			//run:false,
			isOnMovingObject:false,

		};

		//this.angvel = new Vector3();

		this.fixWeight = o.fixWeight !== undefined ? o.fixWeight : true;

		this.type = 'character';
		this.name = o.name || 'hero';
		o.name = this.name;

		this.isRay = false;

		this.ray = null;
		this.model = null;
		this.static = false;
		this.moving = false;
		this.running = false;
		this.wantJump = false;

		//this.lod = -1;

		this.radius = radius;
		this.height = height;
		this.mass = o.mass || 0.84;
		
		delete o.radius;

		this.fall = false;
		this.floor = true;

		this.distance = 0;
		this.rayAngle = 0;
		this.rayStart = -(this.height*0.5)+this.radius;
		//this.rayEnd = this.rayStart - (radius + 2);//this.height;
		this.rayEnd = this.rayStart - (4*floatHeight);//this.height;
		this.maxRayDistance = this.height;

		this.contact = false;

		this.tmpV1 = new Vector3();
		this.tmpV2 = new Vector3();
		this.ease = new Vector3();
		this.tmpAcc = 0;
		this.rs = 0;
		this.ts = 0;
		this.diagonal = 1/Math.sqrt(2);

		this.jump = false;
		this.crouch = false;
		this.toggle = true;
		this.oy = 0;
		this.vy = 0;

		this.timeScale = 1.25;

		this.angle = ( o.angle || 0 ) * torad$3;

		this.speed = {
		    idle:1,
		    fight:1,
		    walk:7.8,
		    crouch:7,
		    run:12,
		};

		this.valheimStyle = true;
		this.globalRay = o.ray || false;

		this.callback = o.callback || function (){};

		if( o.callback ) delete o.callback;

		this.initPhysic( o );

	}

	setHeight( H ) {

		if( this.model ) this.model.setRealSize( H );

	}

	reSizePhysics( h ) {
		
		if( h === this.realHeight ) return;

		this.realHeight = h;
		this.height = this.realHeight - (this.useFloating ? this.option.floatHeight : 0);
		let pos = this.position.toArray();
		pos[1] += (this.height*0.5) + (this.useFloating ? this.option.floatHeight : 0);
		let size = [ this.radius, this.height-(2*this.radius) ];

		this.phyData.pos = pos;
		this.phyData.size = size;

		this.motor.post({ m:'add', o:this.phyData });

	}

	initPhysic( o ){

	    if(!o.size) o.size = [ this.radius, this.height-(2*this.radius) ];
		if(!o.pos) o.pos = [0,0,0];

		o.pos[1] += this.height*0.5;
		if( this.useFloating ) o.pos[1] += this.option.floatHeight;

		if( this.globalRay ) this.motor.getGeometryRef( { ...o, type:'capsule', ray:true }, this, this.motor.mat.get('hide') );

		this.phyData = {
			name: this.name,
			size: o.size,
			pos: o.pos,
			type: 'character',
			shapeType: o.shapeType || 'capsule',
			density: 1,//o.density || 1,
			mass: this.mass, 
			friction: o.friction !== undefined ? o.friction : 0.5,
			angularFactor:[0,0,0],
			group: 16,
			regular:true,

			massInfo: o.massInfo,
		};

		if( o.mask ) this.phyData['mask'] = o.mask;

		//o.volume = MathTool.getVolume( 'capsule', o.size );
	

		// add to world
		this.motor.getCharacterRef().addToWorld( this, o.id );

        // add capsule to physics
        //root.post({ m:'add', o:o });
        this.motor.post({ m:'add', o:this.phyData });

        // add bottom RAY
        if( this.useFloating ) this.ray = this.motor.add({ type:'ray', name:this.name + '_ray', begin:[0,this.rayStart,0], end:[0,this.rayEnd, 0], callback:this.selfRay.bind(this), visible:false, parent:this.name });


        // add skinning character model
        if( o.gender ) this.addModel( o );
        else this.showHelper( true );

        this.enable = true;
		
	}

	extraRemove(){
		// TODO bug with delete ray ?!
		if( this.ray ) this.motor.remove( this.name + '_ray' );
	}

	/*clear(){
		root.motor.remove([this.name, this.name + '_ray']);
	}*/

    selfRay( r ){

    	if( r.hit ){ 
    		this.distance = r.distance; //MathTool.toFixed(r.distance-this.radius)
    		this.rayAngle = r.angle;
    		//this.v.canJump = true;
    		//console.log('true')
    	} else { 
	        this.distance =this.option.rayLength;//maxRayDistance;
	        this.rayAngle = 0;
	        //console.log('false')
	        //this.v.canJump = false;	    
	    }

    }

    hit( d ){

    	this.contact = d;

    }

    showHelper( b ){

    	if(b){
    		if(!this.helper){
    			this.helper = new CapsuleHelper(this.radius, this.height, true, this.motor.mat.get('line'), [1,0.6,0], [0.6,0.2,0] );
    			this.helper.setDirection( this.angle ); 
		        this.add( this.helper );
    		}
    	} else {
    		if(this.helper){
    			this.remove(this.helper);
    			this.helper.dispose();
    			this.helper = null;
    		}
    	}

    	if( this.ray ) this.ray.visible = b;

    }

    addSkeleton(){

    	if( this.skeletonBody ) return
    	if( !this.model ) return
    	//this.skeletonBody = new SkeletonBody( this )
        this.skeletonBody = new SkeletonBody( this.motor, this.name, this.model.root, this.model.skeleton.bones );
    	this.motor.scene.add( this.skeletonBody );
    	this.skeletonBody.isVisible( false );

    }

    debugMode( v = false ){

    	if( this.skeletonBody ) this.skeletonBody.isVisible(v);
    	//if( this.model ) this.model.setMaterial( { wireframe: v, visible:!v })
    	if( this.model && this.skeletonBody ) this.model.setMaterial( { transparent:v, opacity:v?0.8:1.0 }, !v );
    	
    	this.showHelper( v );
        

    }

    setMode( name ){

    	if( this.skeletonBody ) this.skeletonBody.setMode( name );

    	//this.skeletonBody = new SkeletonBody( this )
    	//this.model.add( this.skeletonBody )

    }

	addModel( o ){

		this.model = new Avatar({ 
			type:o.gender, 
			anim: o.anim !== undefined ? o.anim : 'idle', 
			compact:true, 
			material:!o.noMat, 
			morph:o.morph || false, 
			randomMorph:o.randomMorph || false,
			randomSize:o.randomSize || false,
			callback:this.callback,
			fixWeight: this.fixWeight,
			noLOD : o.noLOD || false,
		});

		this.add( this.model );
		///this.model.rotation.order = 'YXZ'
		let ypos = -(this.height*0.5);
		if( this.useFloating ) ypos -= this.option.floatHeight;
		this.model.setPosition(0, this.model.decalY + ypos, 0);
		this.model.rotation.y = this.angle;
		this.model.updateMatrix();

	}

	raycast(){
		return;// false;
	}

	/*preStep(){
		if(this.skeletonBody) this.skeletonBody.update()
	}*/

	step ( AR, n ) {
		
		this.position.fromArray( AR, n + 1 );
		this.quaternion.fromArray( AR, n + 4 );
		this.velocity.fromArray( AR, n + 8 );
		this.angular.fromArray( AR, n + 11 );

		this.fall = this.position.y < this.oy;
		this.floor = MathTool.nearEquals(this.position.y, this.oy, 0.1);
		this.oy = this.position.y;
		

		if( this.model ) {
			this.model.update( this.motor.delta );
			this.getDistanceToCamera();
		}


		if( this.useFloating && !this.isPlayer ){ 

			this.stopMoving();

			this.getFloating();

	    	this.motor.change({

			    name:this.name,
			    impulse: this.v.moveImpulse.toArray(), 
			    impulseCenter: this.v.impulseCenter.toArray(),

			});

			


	    }

		//if(this.skeletonBody) this.skeletonBody.update()
		this.updateMatrix();
		

	}

	getDistanceToCamera () {

		if( !this.model ) return
		if( !this.model.haveLOD ) return

		const camera = this.motor.getCamera();
		//this.tmpV1.setFromMatrixPosition( camera.matrixWorld );
		this.tmpV1.copy( this.motor.getCurrentCharacterPosition() );
		this.tmpV2.copy( this.position );//setFromMatrixPosition( this.matrixWorld );
		const distance = this.tmpV1.distanceTo( this.tmpV2 ) / camera.zoom;

		//console.log(distance)

		let level = distance > 3 ? 0 : 1;
		//if( level !== this.lod ){
		//	this.lod = level;
			this.model.setLevel( level );
		
	}

	set ( o ) {

		//console.log('set', o)
		if(o.morph){
			if(this.model) this.model.setMorph( o.morph, o.value );
		}

	}

	dispose () {

		//console.log('dispose')

		this.callback = null;
		if( this.skeletonBody ) this.skeletonBody.dispose();
		if( this.model ) this.model.dispose();
		if( this.helper ) this.showHelper();

		//if( this.ray ) root.motor.remove( this.name + '_ray' );
	    //this.ray = null;

		//this.ray.dispose()

		//console.log('model remove')

		super.dispose();
	}

	onFrame ( state, delta ){

		this.v;
		this.option;

	}

	autoBalance (){

		const v = this.v;
		const o = this.option;
		const r = this.rotation;

		v.dragAngForce.set(
		    -o.autoBalanceSpringK * r.x - this.angular.x * o.autoBalanceDampingC,
		    -o.autoBalanceSpringK * r.y - this.angular.y * o.autoBalanceDampingOnY,
		    -o.autoBalanceSpringK * r.z - this.angular.z * o.autoBalanceDampingC
		);

	}

	moveCharacter ( delta, angle = 0 ){

		const v = this.v;
		const o = this.option;
		const key = this.motor.getKey();
		this.motor.getAzimut();

		
		

		v.currentPos.copy(this.position);

		

		//v.movingObjectVelocity = 
		v.slopeAngle = 0;//azimut;



	    // Setup moving direction

	    // Only apply slope extra force when slope angle is between 0.2-slopeMaxAngle, actualSlopeAngle < slopeMaxAngle
	    if ( v.actualSlopeAngle < o.slopeMaxAngle &&  Math.abs(v.slopeAngle) > 0.2 && Math.abs(v.slopeAngle) < o.slopeMaxAngle ) {
	    	v.movingDirection.set(0, Math.sin(v.slopeAngle), Math.cos(v.slopeAngle));
	    } else if ( v.actualSlopeAngle >= o.slopeMaxAngle ) {
	    	v.movingDirection.set( 0, Math.sin(v.slopeAngle) > 0 ? 0 : Math.sin(v.slopeAngle), Math.sin(v.slopeAngle) > 0 ? 0.1 : 1 );
	    } else {
	    	v.movingDirection.set(0, 0, 1);
	    }



	    // Apply character quaternion to moving direction
	    //if( this.model ) v.movingDirection.applyQuaternion( this.model.quaternion );
	    v.movingDirection.applyAxisAngle( {x:0, y:1, z:0}, angle );

	    

	    // Calculate moving object velocity direction according to character moving direction
	    v.movingObjectVelocityInCharacterDir.copy(v.movingObjectVelocity).projectOnVector(v.movingDirection).multiply(v.movingDirection);
	    // Calculate angle between moving object velocity direction and character moving direction
	    const angleBetweenCharacterDirAndObjectDir = v.movingObjectVelocity.angleTo(v.movingDirection);

	    //Setup rejection velocity, (currently only work on ground)
	    const wantToMoveMeg = v.currentVel.dot(v.movingDirection);
	    v.wantToMoveVel.set( v.movingDirection.x * wantToMoveMeg, 0, v.movingDirection.z * wantToMoveMeg );
	    v.rejectVel.copy(v.currentVel).sub(v.wantToMoveVel);


	    // Calculate required accelaration and force: a = Δv/Δt
	    // If it's on a moving/rotating platform, apply platform velocity to Δv accordingly
	    // Also, apply reject velocity when character is moving opposite of it's moving direction
	    
	    v.moveAccNeeded.set(
	        (v.movingDirection.x * (o.maxVelLimit * (this.running ? o.sprintMult : 1) + v.movingObjectVelocityInCharacterDir.x) - (v.currentVel.x - v.movingObjectVelocity.x * Math.sin(angleBetweenCharacterDirAndObjectDir) + v.rejectVel.x * (v.isOnMovingObject ? 0 : o.rejectVelMult))) / o.accDeltaTime,
	        0,
	        (v.movingDirection.z * (o.maxVelLimit * (this.running ? o.sprintMult : 1) + v.movingObjectVelocityInCharacterDir.z) - (v.currentVel.z - v.movingObjectVelocity.z * Math.sin(angleBetweenCharacterDirAndObjectDir) + v.rejectVel.z * (v.isOnMovingObject ? 0 : o.rejectVelMult))) / o.accDeltaTime
	    );

	    // Wanted to move force function: F = ma
	    const moveForceNeeded = v.moveAccNeeded.multiplyScalar( this.mass );

	    //console.log(this.mass)

  
	    // Check if character complete turned to the wanted direction
	    //let characterRotated = Math.sin(this.rotation.y).toFixed(3) == Math.sin(v.modelEuler.y).toFixed(3);
	    let characterRotated = true;
	    if( this.waitRotation ) characterRotated = Math.sin( angle ).toFixed(3) == Math.sin(this.rotation.y).toFixed(3);

	    // If character hasn't complete turning, change the impulse quaternion follow characterModelRef quaternion
	    if ( !characterRotated ) {
	    	v.moveImpulse.set(
	    		moveForceNeeded.x * o.turnVelMultiplier * (v.canJump ? 1 : o.airDragMultiplier), // if it's in the air, give it less control
	    		v.slopeAngle === null || v.slopeAngle == 0 // if it's on a slope, apply extra up/down force to the body
	            ? 0 : v.movingDirection.y * o.turnVelMultiplier *
	            (v.movingDirection.y > 0 // check it is on slope up or slope down
	            ? o.slopeUpExtraForce : o.slopeDownExtraForce) * (this.running ? o.sprintMult : 1),
	            moveForceNeeded.z * o.turnVelMultiplier * (v.canJump ? 1 : o.airDragMultiplier) // if it's in the air, give it less control
	        );
	    }
	    // If character complete turning, change the impulse quaternion default
	    else {
	        v.moveImpulse.set(
	        	moveForceNeeded.x * (v.canJump ? 1 : o.airDragMultiplier),
	        	v.slopeAngle === null || v.slopeAngle == 0 // if it's on a slope, apply extra up/down force to the body
	        	? 0 : v.movingDirection.y * (v.movingDirection.y > 0 // check it is on slope up or slope down
	            ? o.slopeUpExtraForce : o.slopeDownExtraForce) * (this.running ? o.sprintMult : 1),
	            moveForceNeeded.z * (v.canJump ? 1 : o.airDragMultiplier)
	        );
	    }


	    v.impulseCenter.set( v.currentPos.x, v.currentPos.y + o.moveImpulsePointY, v.currentPos.z );

	    // Character current velocity
	    v.currentVel.copy(this.velocity);

	    // Jump impulse

	    if ( key[4] && v.canJump ) {
	    	v.jumpVelocityVec.set( v.currentVel.x, this.running ? o.sprintJumpMult * o.jumpVel : o.jumpVel, v.currentVel.z );
	    	v.moveImpulse.y = v.jumpVelocityVec.y;
	    }

	   //v.jumpDirection.set(0, ( this.running ? o.sprintJumpMult * o.jumpVel : o.jumpVel ) * o.slopJumpMult, 0).projectOnVector(v.actualSlopeNormalVec).add(v.jumpVelocityVec)
	    //root.motor.change({ name:this.name, linearVelocity:v.jumpDirection.toArray() });

	}

	getFloating (){
		
		const v = this.v;
		const o = this.option;

		const floatingForce = o.springK * (o.floatingDis - this.distance) - this.velocity.y * o.dampingC;
		v.moveImpulse.y = floatingForce * (this.mass);

	}

	stopMoving (){
		
		this.v;
		this.option;

		this.v.moveImpulse.set(0,0,0);

		// slowdown

		this.tmpV1.copy(this.velocity);//.multiplyScalar( 0.9 )
		this.tmpV1.x *= 0.9;
		this.tmpV1.z *= 0.9;

		if(this.tmpV1.x + this.tmpV1.z === 0 ) return;

		this.motor.change({

		    name:this.name,
		    //force: this.tmpV1.toArray(), forceMode:'velocity', 
		    linearVelocity: this.tmpV1.toArray(),
		    //angularVelocity: this.tmpV2.toArray(),
		    wake:false,
		    //noGravity:true 
		});

	}

	

	move () {

		this.v;

		const key = this.motor.getKey();
		const azimut = this.motor.getAzimut();
		const delta = this.motor.delta;
		
		// 1°/ find the good animation

		let anim = key[7] !== 0 ? 'run' : 'walk';
	    if( key[0] === 0 && key[1] === 0 ) anim = 'idle';//*= 0.9
	    let m = key[0] !== 0 && key[1] !== 0 ? this.diagonal : 1;

	    if( key[5] && this.toggle ){ 
	    	this.crouch = !this.crouch;
	    	this.toggle = false;
	    }
	    if( key[5] === 0 ) this.toggle = true;
	    if( ( anim==='walk' || anim==='run') && this.crouch ) anim = 'crouch';
	    if( key[6] === 1 ) anim = 'fight';

	    if( !this.jump && key[4] ){ this.vy = 22; this.jump = true; } // SPACE KEY

	    if( this.jump ){
	        this.vy-=1;
	        if(this.vy <= 0 ){ 
	            this.vy = 0; 
	            if( this.floor ) this.jump = false;

	            //if( MathTool.nearEquals(this.position.y, this.oy, 0.1)) this.jump = false;
	            //this.position.y === this.oy 
	        }
	    }

	    let mAnim = 'idle';
	    switch( anim ){
	    	case 'idle': mAnim = this.crouch ? 'Crouch Idle' : 'idle'; break;
	    	case 'walk': mAnim = 'Jog Forward'; break;
	    	case 'run': mAnim = 'Standard Run'; break;
	    	case 'crouch': mAnim = 'Crouch Walk'; break;
	    	case 'fight': mAnim = 'Attack'; break;
	    }


	    this.moving = key[0] !== 0 || key[1] !== 0;
	    this.running = key[7] !== 0;
	    this.wantJump = key[4] !== 0;

	    let angle = MathTool.unwrapRad( ( Math.atan2(key[0], key[1])) + azimut );


	    // 2°/ physic control

	    if( this.useImpulse ) {

	    	if( this.moving ) this.moveCharacter( delta, angle );
	    	else this.stopMoving();

	        if( this.useFloating ) this.getFloating();

	    	this.motor.change({

			    name:this.name,
			    impulse: this.v.moveImpulse.toArray(), 
			    impulseCenter: this.v.impulseCenter.toArray(),

			});

	    } else { // old method

	    	this.tmpAcc += delta*4;//MathTool.lerp( tmpAcc, 1, delta/10 )
	        //this.tmpAcc += MathTool.lerp( this.tmpAcc, 1, delta/10 )
	        //this.tmpAcc = MathTool.clamp( this.tmpAcc, 1, speed )

	        const genSpeed = 1.0;

	   		let speed = this.speed[anim] * genSpeed;

	        //this.rs += key[0] //* this.tmpAcc 
	        //this.ts += key[1] //* this.tmpAcc
			if( this.moving ){
		        this.rs = key[0] * speed; 
		        this.ts = key[1] * speed;
		    }

		    if( key[0] === 0 && key[1] === 0 ) this.tmpAcc = 0;//*= 0.9
		    if( this.tmpAcc>1 ) this.tmpAcc = 1;

		    this.ease.set( this.rs, 0, this.ts ).multiplyScalar( this.tmpAcc * m );

		    //let angle = math.unwrapRad( (Math.atan2(this.ease.z, this.ease.x)) + azimut );
		    //let angle = MathTool.unwrapRad( ( Math.atan2(key[0], key[1])) + azimut );
	    

		    this.ease.length(); //((Math.abs(this.ease.x) + Math.abs(this.ease.z)))

	        if( this.static ) this.ease.x = this.ease.z = 0;

		    let g = this.vy - 9.81;
		    this.ease.y = g;
		    this.tmpV1.copy( this.ease ).applyAxisAngle( { x:0, y:1, z:0 }, azimut );
		    //math.tmpV2.set( 0, rs, 0 );
		    this.tmpV2.set( 0, 0, 0 );

	    	this.motor.change({

			    name:this.name,
			    //force: this.tmpV1.toArray(), forceMode:'velocity', 
			    linearVelocity: this.tmpV1.toArray(), 
			    //angularVelocity: this.tmpV2.toArray(),
			    //wake:true, 
			    //noGravity:true 
			});
	    }



		if( this.helper ){ 

			this.helper.updateMatrix();
			this.helper.cone.rotation.y = azimut;//angle
			if( anim !== 'idle' ) this.helper.setDirection( angle ); 

		}


	   // if(anim!=='idle') this.model.setRotation( 0, azimut + Math.PI, 0, 0.25 )
        
        if( !this.model ) return


        //const distanceToCamera = this.getDistanceToCamera();

        //if()

        //this.model.setTimescale(this.tmpAcc)

        //this.model.setWeight( 'idle', 1-jj )
	    /*this.model.setWeight( 'Jog Forward', -this.ease.x )
	    this.model.setWeight( 'Jog Backward', this.ease.x )
	    this.model.setWeight( 'Jog Strafe Left',-this.ease.z )
	    this.model.setWeight( 'Jog Strafe Right', this.ease.z )*/
	    
	   

	    //if(anim!=='idle') this.model.syncro('Jog Forward')

	    //console.log(tmpAcc)

        
	    if( this.jump ){
	    	this.model.play( 'Jump', 0.5 );
	    	//this.model.setTimescale( 1 )
	    }else {

	    	this.model.play( mAnim, 0.75 );
	    	//this.model.setTimescale( this.timeScale )
	    	//this.model.setTimescale( 1 )
	    }

	    if( anim !== 'idle' ){

	    	//this.model.setTimescale( 2.0 )

	    	let pp = MathTool.unwrapRad( this.model.rotation.y );
	    	//if( anim === 'fight' ) pp = math.unwrapRad( azimut + Math.PI )
	    	let aa = MathTool.nearAngle( angle, pp );
	    	let diff = Math.abs(Math.floor((pp - aa)*math.todeg)/180);
	    	//console.log(diff)
	    	//this.model.rotation.y = anim === 'fight' ? (azimut + Math.PI) : math.lerp( pp, aa, 0.25 )
	    	this.model.rotation.y = anim === 'fight' ? (azimut + Math.PI) : MathTool.lerp( pp, aa, 0.2 - (diff*0.1) );
	    	this.model.updateMatrix();
	    	//this.model.setTimescale( this.tmpAcc * (1*genSpeed) )

	    	//let m = this.model.getAction( anim )
	    	//if( m ) m.setEffectiveTimeScale( this.tmpAcc * (1*genSpeed) );
	    	//if( m ) m.setEffectiveTimeScale( 0 );
	    }

	    //if( this.helper ) this.helper.setDirection( this.model.rotation.y )

	}


}

// THREE CHARACTER

class Character extends Item {

	constructor( motor ) {

		super();

		this.motor = motor;

		this.Utils = this.motor.utils;
		this.type = 'character';
		this.num = Num[this.type];

	}

	/*prestep () {

		let i = this.list.length;
		while( i-- ) this.list[i].preStep( );

	}*/

	step (AR, N) {
		
		let i = this.list.length, n, s;

		while( i-- ){

			s = this.list[i];
			n = N + ( i * this.num );

			if(s) s.step( AR, n );

		}

	}

	add ( o = {} ) {

		this.setName( o );
		const hero = new Hero( o, this.motor );
		return hero;

	}

	set ( o = {}, b = null ) {

		if( b === null ) b = this.byName( o.name );
		if( b === null ) return;
		b.set(o);

	}
	
}

//import { Shader } from '../Shader.js';


class Landscape extends Mesh {

    constructor( o = {} ) {

        super();

        this.ready = false;
        this.needUpdate = false;

        this.type = 'terrain';
        this.name = o.name;

        this.folder = o.folder || './assets/textures/terrain/';

        this.mapN = 0;
        this.mapMax = 7;//7

        // terrain, water, road
        this.ttype = o.terrainType || 'terrain';

        this.callback = o.callback || function(){};
        
        this.physicsUpdate = () => {};

        this.uvx = [ o.uv || 18, o.uv || 18 ];

        this.sample = o.sample == undefined ? [128,128] : o.sample;
        this.size = o.size === undefined ? [100,30,100] : o.size;

        let sx = this.sample[0] - 1;
        let sz = this.sample[1] - 1;

        this.rx = sx / this.size[0];
        this.rz = sz / this.size[2];

        this.zone = o.zone || 1;

        // why ??
        /*let pp = 0
        if( this.zone === 0.5 ) pp=2
        if( this.zone === 0.25 ) pp=3
        if( this.zone === 0.125 ) pp=7*/
        let square = [this.size[0]/sx, this.size[2]/sz];
        //let dx = (this.size[0]/sx)//*pp
        //let dz = (this.size[2]/sz)//**pp


        this.sampleZ = [o.sample[0] * this.zone, o.sample[1] * this.zone];
        //this.sizeZ = [(o.size[0]-dx) * this.zone, o.size[1], (o.size[2]-dz) * this.zone];

        this.sizeZ = [(this.sampleZ[0]-1) * square[0], o.size[1], ((this.sampleZ[1]-1)) * square[1]];

        this.lng = this.sample[0] * this.sample[1];
        this.lngZ = this.sampleZ[0] * this.sampleZ[1];

        //console.log(  this.sample, this.sampleZ)

        this.getZid();


        this.data = {
            level: o.level || [1,0.2,0.05],
            frequency: o.frequency || [0.016,0.05,0.2],
            expo: o.expo || 1,
        };

        this.isWater = o.water || false;
        this.isIsland = o.island || false;
        this.isBorder = false;
        this.wantBorder = o.border || false;

        this.isBottom = false;
        this.wantBottom = o.bottom || false;
        this.wantBorder = o.border || false;

        this.colorBase = this.isWater ? { r:0, g:0.7, b:1 } : { r:0.25, g:0.25, b:0.25 };

        this.maxspeed = o.maxSpeed || 0.1;
        this.acc = o.acc == undefined ? 0.01 : o.acc;
        this.dec = o.dec == undefined ? 0.01 : o.dec;

        this.deep = o.deep == undefined ? 0 : o.deep;

        this.ease = new Vector2();

        // for perlin
        this.complexity = o.complexity == undefined ? 30 : o.complexity;
        this.complexity2 = o.complexity2 == undefined ? null : o.complexity2;

        this.local = new Vector3();
        if( o.local ) this.local.fromArray( o.local );

        this.pp = new Vector3();

        this.ratioZ = 1 / this.sampleZ[0];
        this.ratio = 1 / this.sample[0];
        this.ruvx =  1.0 / ( this.size[0] / this.uvx[0] );
        this.ruvy = - ( 1.0 / ( this.size[2] / this.uvx[1] ) );

        this.is64 = o.is64 || false;
        this.isTurn = o.turn || false;

        this.heightData = new Float32Array( this.lngZ );
        this.height = [];

        // for physx 
        this.isAbsolute = o.isAbsolute || false;
        this.isTurned = o.isTurned || false;
        this.isReverse = o.isReverse || false;

        this.changeId = this.isReverse || this.isTurned;

        if( this.changeId ) this.getReverseID();

        this.colors = new Float32Array( this.lng * 3 );
        this.geometry = new PlaneGeometry( this.size[0], this.size[2], this.sample[0] - 1, this.sample[1] - 1 );
        this.geometry.rotateX( -math$1.PI90 );
        //if( this.isTurn ) 
        //this.geometry.rotateY( -math.PI90 );
        //if( this.isTurned ) this.geometry.rotateY( math.PI90 );


       // this.geometry.computeBoundingSphere();

        this.geometry.setAttribute( 'color', new BufferAttribute( this.colors, 3 ) );
        //this.geometry.setAttribute( 'uv2', this.geometry.attributes.uv );
        this.vertices = this.geometry.attributes.position.array;
        var clevels = new Quaternion$1( 0.5, 0.5, 0.1, 0.2 );//0.95, 0.8, 0.1, 0.05 ); 
        if( o.maplevels ) clevels.fromArray( o.maplevels );
        var T = TerrainShader;
        var maps = o.maps || [ 'sand', 'grass3', 'rock' ], txt = {};
        var name;

        if(this.isWater) maps = ['water'];

        for( let i in maps ){

            name = maps[i];

            txt[name+'_c'] = Pool.texture({ url:this.folder + name +'_c.jpg', flip:false, repeat:this.uvx, encoding:o.encoding || true , callback: this.mapcallback.bind(this)  });
            txt[name+'_n'] = Pool.texture({ url:this.folder + name +'_n.jpg', flip:false, repeat:this.uvx, callback: this.mapcallback.bind(this) });

            //txt[name+'_c'] = Pool.directTexture(this.folder + name +'_c.jpg', { flip:false, repeat:this.uvx, encoding:o.encoding || true , callback: this.mapcallback.bind(this)  });
            //txt[name+'_n'] = Pool.directTexture(this.folder + name +'_n.jpg', { flip:false, repeat:this.uvx, callback: this.mapcallback.bind(this) });
           // if( isORM )txt[name+'_n'] = Pool.directTexture('./assets/textures/terrain/'+name+'_n.jpg', { flip:false, repeat:this.uvx, callback: this.mapcallback.bind(this) });

        }

        //txt['noise'] = Pool.directTexture(this.folder + 'noise.png', { flip:false, repeat:[1,1], encoding:false , callback: this.mapcallback.bind(this)  });
        txt['noise'] = Pool.texture({ url:this.folder + 'noise.png', flip:false, repeat:[1,1], encoding:false , callback: this.mapcallback.bind(this)  });

        this.txt = txt;

        this.material = new MeshPhysicalMaterial({ name:'terrain', vertexColors:true, color:0xFFFFFF, map:txt[maps[0]+'_c'], normalMap:txt[maps[0]+'_n'] });

        if( o.envmap !== undefined ) this.material.envMap = o.envmap;

        if( this.isWater ){
            this.material.transparent = true;
            this.material.opacity = o.opacity || 0.4;
            this.material.side = DoubleSide;
            this.material.alphaMap = txt[maps[0]+'_c'];
            this.material.map = null;
            this.material.metalness  = 0.9;
            this.material.roughness = 0.1;
        } else {
            this.material.reflectivity = 0.0;
            this.material.metalness = o.metalness || 0.0;
            this.material.roughness = o.roughness || 0.3;//0.7; 
        }

        var ns = o.nScale || 0.5;
        this.material.normalScale.set(ns,-ns);

        if( !this.isWater ){

            let self = this;

            this.material.onBeforeCompile = function ( shader ) {

                let uniforms = shader.uniforms;

                //uniforms['fogTime'] = { value: 0 };

                uniforms['clevels'] = { value: clevels };

                uniforms['map1'] = { value: txt[maps[1]+'_c'] };
                uniforms['map2'] = { value: txt[maps[2]+'_c'] };

                uniforms['randomUv'] = { value: 1 };

                uniforms['normalMap1'] = { value: txt[maps[1]+'_n'] };
                uniforms['normalMap2'] = { value: txt[maps[2]+'_n'] };

                //uniforms['noise'] = { value: txt['noise'] };
                uniforms['noiseMap'] = { value: txt['noise'] };
                uniforms['useNoiseMap'] = { value: 1 };

                shader.uniforms = uniforms;

                let fragment = shader.fragmentShader;

                fragment = fragment.replace( '#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>' +  randomUV + T.fragmentAdd );

                fragment = fragment.replace( '#include <map_fragment>', T.map );
                fragment = fragment.replace( '#include <normal_fragment_maps>', T.normal );
                fragment = fragment.replace( '#include <color_fragment>', '' );
                
                shader.fragmentShader = fragment;

                self.material.userData.shader = shader;

                //if( o.shader ) o.shader.modify( shader );

                //Shader.modify( shader );

            };


            Object.defineProperty( this.material, 'randomUv', {
                  get() { return this.userData.shader.uniforms.randomUv.value ? true : false; },
                  set( value ) { this.userData.shader.uniforms.randomUv.value = value ? 1 : 0; }
            });

            Object.defineProperty( this.material, 'map1', {
                  get() { return this.userData.shader.uniforms.map1.value; },
                  set( value ) { this.userData.shader.uniforms.map1.value = value; }
            });

            Object.defineProperty( this.material, 'map2', {
                  get() { return this.userData.shader.uniforms.map2.value; },
                  set( value ) { this.userData.shader.uniforms.map2.value = value; }
            });

            Object.defineProperty( this.material, 'normalMap1', {
                  get() { return this.userData.shader.uniforms.normalMap1.value; },
                  set( value ) { this.userData.shader.uniforms.normalMap1.value = value; }
            });

            Object.defineProperty( this.material, 'normalMap2', {
                  get() { return this.userData.shader.uniforms.normalMap2.value; },
                  set( value ) { this.userData.shader.uniforms.normalMap2.value = value; }
            });

        } else {

            this.material.onBeforeCompile = function ( shader ) {

                var fragment = shader.fragmentShader;

                fragment = fragment.replace( '#include <alphamap_fragment>', T.alphamap );
           
                shader.fragmentShader = fragment;

            };

        }


        //THREE.Mesh.call( this, this.geometry, this.material );

       // super( this.geometry, this.material );

        if(o.debug){
            this.debugZone(o);
        }

        //root.garbage.push( this.geometry );
        

        if( this.wantBorder ) this.addBorder( o );
        if( this.wantBottom ) this.addBottom( o );

        if( o.pos ) this.position.fromArray( o.pos );


        // rotation is in degree or Quaternion
        o.quat = o.quat === undefined ? [ 0, 0, 0, 1 ] : o.quat;
        if( o.rot !== undefined ){ o.quat = math$1.toQuatArray( o.rot ); delete o.rot; }
        //console.log(o.quat)
        this.quaternion.fromArray( o.quat );

        if( o.decal ) this.position.y += o.decal;

        this.castShadow = true;
        this.receiveShadow = true;

        Pool.set( 'terrain' + this.name, this.material, 'material', true );

        this.update();

    }

    getZid(){ // zone id

        this.zid = {};

        let lx = (this.sample[0] - this.sampleZ[0])*0.5;
        let lz = (this.sample[1] - this.sampleZ[1])*0.5;
        let first = (this.sample[0] * lz) + lx;
        let line = 0;
        for (let j = 0; j<this.lngZ; j++ ){
            //line = j % this.sampleZ[0];
            line = Math.floor(j / this.sampleZ[0]);
            this.zid[ first + j + (line*((lx*2))) ] = j;
        }
    }

    debugZone(o) {

        this.geometryZ = new PlaneGeometry( this.sizeZ[0], this.sizeZ[2], this.sampleZ[0] - 1, this.sampleZ[1] - 1 );
        this.geometryZ.rotateX( -math$1.PI90 );
        this.verticesZ = this.geometryZ.attributes.position.array;
        
        const debuger = new Mesh( this.geometryZ, new MeshBasicMaterial({ color:0x000000, wireframe:true, transparent:true, opacity:0.1 } ));
        //if( o.pos ) debuger.position.fromArray( o.pos );
        this.add( debuger );

    }

    mapcallback (){

        this.mapN++;
        if( this.mapN == this.mapMax ){ 
           // this.material.needsUpdate = true;
            this.callback();
        }

    }

    addBottom ( o ){

    	var geometry = new PlaneGeometry( this.size[0], this.size[2], 1, 1 );
        geometry.rotateX( math$1.PI90 );
        

        this.bottomMesh = new Mesh( geometry, this.borderMaterial );

        this.add( this.bottomMesh );

        this.isBottom = true;
    }

    addBorder ( o ){

    	this.borderMaterial = new MeshStandardMaterial({ 

    		vertexColors: true, 
    		metalness: this.isWater ? 0.8 : 0.4, 
       		roughness: this.isWater ? 0.2 : 0.6, 
       
            //envMap: view.getEnvMap(),
            //normalMap:this.wn,
            normalScale:this.isWater ?  [0.25,0.25]:[2,2],
            transparent:this.isWater ? true : false,
            opacity: this.isWater ? (o.opacity || 0.8) : 1,
            envMap: o.envmap || null, 

    		//shadowSide : false

    	});

    	//view.getMat()[this.name+'border'] = this.borderMaterial;

        var front = new PlaneGeometry( this.size[0], 2, this.sample[0] - 1, 1 );
        var back = new PlaneGeometry( this.size[0], 2, this.sample[0] - 1, 1 );
        var left = new PlaneGeometry( this.size[2], 2, this.sample[1] - 1, 1 );
        var right = new PlaneGeometry( this.size[2], 2, this.sample[1] - 1, 1 );

        front.translate( 0,1, this.size[2]*0.5);
        back.rotateY( -math$1.Pi );
        back.translate( 0,1, -this.size[2]*0.5);
        left.rotateY( -math$1.PI90 );
        left.translate( -this.size[0]*0.5,1, 0);
        right.rotateY( math$1.PI90 );
        right.translate( this.size[0]*0.5,1, 0);

        this.borderGeometry = mergeVertices( mergeGeometries( [ front, back, left, right ] ) );
        this.borderVertices = this.borderGeometry.attributes.position.array;
        this.lng2 = this.borderVertices.length / 3;
        this.list = new Array( this.lng2 );
        this.borderColors = new Float32Array( this.lng * 3 );
        this.borderGeometry.setAttribute( 'color', new BufferAttribute( this.borderColors, 3 ) );
        this.borderMesh = new Mesh( this.borderGeometry, this.borderMaterial );

        var j = this.lng2, n, i;
        while(j--){
            n = j*3;
            i = this.borderVertices[n+1] > 0 ? this.findPoint( this.borderVertices[n], this.borderVertices[n+2] ) : -1;
            this.list[j] = i;

        }

        this.add( this.borderMesh );

        this.borderMesh.castShadow = true;
        this.borderMesh.receiveShadow = true;

        this.isBorder = true;

    }

    dispose () {

        if(this.isBottom){
            this.remove( this.bottomMesh );
            this.bottomMesh.geometry.dispose();
        }

        if(this.isBorder){
            this.remove( this.borderMesh );
            this.borderMesh.geometry.dispose();
            this.borderMesh.material.dispose();
        }

        this.geometry.dispose();
        this.material.dispose();
        for(let t in this.txt) this.txt[t].dispose();
        
    }

    easing ( key, azimuthal, wait ) {

        //var key = user.key;
        if( key[0]===0 && key[1]===0 ) return;

        //if( !key[0] || !key[1] ) return;

        var r = azimuthal || 0;//view.getAzimuthal();

        if( key[7] ) this.maxspeed = 1.5;
        else this.maxspeed = 0.25;

        //acceleration
        this.ease.y += key[1] * this.acc; // up down
        this.ease.x += key[0] * this.acc; // left right
        //speed limite
        this.ease.x = this.ease.x > this.maxspeed ? this.maxspeed : this.ease.x;
        this.ease.x = this.ease.x < -this.maxspeed ? -this.maxspeed : this.ease.x;
        this.ease.y = this.ease.y > this.maxspeed ? this.maxspeed : this.ease.y;
        this.ease.y = this.ease.y < -this.maxspeed ? -this.maxspeed : this.ease.y;

        //break
        if (!key[1]) {
            if (this.ease.y > this.dec) this.ease.y -= this.dec;
            else if (this.ease.y < -this.dec) this.ease.y += this.dec;
            else this.ease.y = 0;
        }
        if (!key[0]) {
            if (this.ease.x > this.dec) this.ease.x -= this.dec;
            else if (this.ease.x < -this.dec) this.ease.x += this.dec;
            else this.ease.x = 0;
        }

        if ( !this.ease.x && !this.ease.y ) return;

        this.local.z += Math.sin(r) * this.ease.x + Math.cos(r) * this.ease.y;
        this.local.x += Math.cos(r) * this.ease.x - Math.sin(r) * this.ease.y;

        this.update( wait );

    }

    

    getTri (){

        return this.geometry


    }

    getHeight ( x, z ) {



        x *= this.rx;
        z *= this.rz; 
        x += this.sample[0]*0.5;
        z += this.sample[1]*0.5;

        //this.pv.set( x, 0, z ).applyAxisAngle( {x:0, y:1, z:0}, -math.PI90 )

        /*if( this.isTurn ){
            x = Math.floor(-z);
            z = Math.floor(x);
        }else {*/
            x = Math.floor(x);
            z = Math.floor(z);
        //}

        
        
        var h = this.isTurn ? this.height[ this.findId2( x, z ) ] : this.height[ this.findId( x, z ) ];
        return ( h * this.size[ 1 ] ) + this.position.y;

    }

    findIdZ( x, z ){

        return x+(z*this.sampleZ[1]) //|| 1;

    }

    findId( x, z ){

        return x+(z*this.sample[1]) //|| 1;

    }

    findId2( x, z ){

        return z+(-x*this.sample[0]) || 1;

    }

    /*findId3( x, z ){

        return z+(x*this.sample[0]) //|| 1;

    }*/

    findPoint( x, z ){

        var i = this.lng, n;
        while( i-- ){
            n = i * 3;
            if( this.vertices[ n ] === x && this.vertices[ n + 2 ] === z ) return i;
        }

        return -1;

    }

    getReverseID () {

        this.invId = [];

        let i = this.lngZ, x, z;
        const sz = this.sampleZ[1] - 1;
        this.sampleZ[0] - 1;

        while(i--){

            x = i % this.sampleZ[0];
            z = Math.floor( i * this.ratioZ );
            if( this.isReverse ) z = sz - z;
            //xr = sx - x;
            //this.invId[i] = this.findId( x, sz - z )//
            this.invId[i] = this.isTurned ?  (this.lngZ-1)-this.findIdZ( z, x ) : this.findIdZ( x, z );

            //console.log(i, this.findId( x, sz - z ), (this.lng-1)-this.findId( z, x ))
        }

    }

    set( o ) {

        if( o.ease ) this.easing( o.key, o.azimut );
        if( o.decal ) this.decal( o.decal, true );

    }

    decal( v, wait ){

        this.local.x += v[0];
        this.local.y += v[1];
        this.local.z += v[2];
        this.update( wait );

    }

    updateUv () {

        if( this.isWater ){ 
            this.material.normalMap.offset.x+=0.002;
            this.material.normalMap.offset.y+=0.001;
        } else {
            let v = { x: this.local.x * this.ruvx, y: this.local.z * this.ruvy };
            if(this.material.map) this.material.map.offset.copy(v);
            if(this.material.normalMap) this.material.normalMap.offset.copy(v);
            
        }

    }

    distance ( a, b ) {

        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt( dx * dx + dy * dy );

    }

    clamp ( v, min = 0, max = 1 ) {
        v = v < min ? min : v;
        v = v > max ? max : v;
        return v;
    }

    update ( wait ) {

        let v = this.pp;
        let cc = [1,1,1];
        let i = this.lng, n, x, z,  c, id, result, idz;
        let oldz, oldh, ccY, ccc;

        while( i-- ){


            n = i * 3;
            x = i % this.sample[0];
            z = Math.floor( i * this.ratio );

            v.set( x + ( this.local.x*this.rx ), this.local.y, z + ( this.local.z*this.rz ) );

            c = math$1.noise( v, this.data );

            if( this.isIsland ){

                let d = 1-(this.distance({x:x, y:z},{x:(this.sample[0]-1)*0.5, y:(this.sample[1]-1)*0.5} )/((this.sample[0]-1)*0.5) );
                d *= 4;
                d = this.clamp(d);
                //console.log(d)
                c *= d;

            }



            //c = Math.quinticSCurve(c);
            //c = Math.cubicSCurve(c)
            //c = Math.linear(c,0.2, 1);
            //c = Math.clamp(c,0.2,1)

            c = Math.pow( c, this.data.expo );
            c = this.clamp(c);

            
            
            
            if( this.ttype === 'road' ) {

                if(oldz === z){
                    if(x===1 || x===2 || x===29 || x===30) c = oldh + 0.1;
                    else c = oldh;
                } else { 
                    oldz = z;
                    oldh = c;
                }

                //console.log(x)
            }

            this.height[ i ] = c;

            ccY = (c * this.size[ 1 ]) + this.deep;
            this.vertices[ n + 1 ] = ccY;

            //id = this.changeId ? this.invId[i] : i;
            result = this.isAbsolute ? c : c * this.size[1];

            if( this.zid[ i ] !== undefined ){
                idz = this.zid[ i ];
                id = this.changeId ? this.invId[idz] : idz;

                 // for physics
                this.heightData[ id ] = result;

                // for debug
                if(this.verticesZ) this.verticesZ[ ( idz * 3 ) + 1 ] = ccY;

            }

            // for physics
            //this.heightData[ id ] = result;

            

            

            if( this.isWater ){

                cc = [ c * this.colorBase.r, c * this.colorBase.g, c * this.colorBase.b ];

            } else {

                cc = [ c, 0, 0];

            }

            //ccc = math.clamp(cc[0]+0.25, 0.25, 1)
            ccc = cc[0];

            //if(ccc>mm) mm = ccc
            //if(ccc<mi) mi = ccc

            

            this.colors[ n ] = ccc;
            this.colors[ n + 1 ] = ccc;
            this.colors[ n + 2 ] = ccc;
            //oldx = x;
            

        }

        //console.log(mm, mi)


        if( this.isBorder ){

            let j = this.lng2, h;
            while(j--){
                n = j*3;
                if(this.list[j]!==-1){
                    h = this.height[ this.list[j] ];
                    this.borderVertices[n+1] = (h * this.size[1]) + this.deep;
                    ccc = math$1.clamp(h+0.25, 0.25, 1);
                    this.borderColors[n] = ccc; //* this.colorBase.r;//h * this.colorBase.r//ee;
                    this.borderColors[n+1] = ccc; //* this.colorBase.g;// h * this.colorBase.g//ee*0.5;
                    this.borderColors[n+2] = ccc; //* this.colorBase.b;// h * this.colorBase.b//ee*0.3;

                } else {
                    this.borderColors[n] = this.colorBase.r;//0.5;
                    this.borderColors[n+1] = this.colorBase.g;//0.25;
                    this.borderColors[n+2] = this.colorBase.b;//0.15;
                }
            }

        }

        if( wait ) this.needUpdate = true;
        else this.updateGeometry();

        

        if( this.ready ) this.physicsUpdate( this.name, this.heightData );

        this.ready = true;

        //if( phy ) root.view.update( { name:'terra', heightData:this.heightData, sample:this.sample } );

    }

    step (n) {

        if( !this.needUpdate ) return
        this.updateGeometry();
        this.needUpdate = false;
        
    }

    updateGeometry () {

        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.color.needsUpdate = true;
        this.geometry.computeVertexNormals();

        this.updateUv();

        if(this.geometryZ) this.geometryZ.attributes.position.needsUpdate = true;

        if( this.isBorder ){
        	this.borderGeometry.attributes.position.needsUpdate = true;
            this.borderGeometry.attributes.color.needsUpdate = true;
        }

    }

}

// SHADERS

// about no tiles
// https://iquilezles.org/articles/texturerepetition/

const TerrainShader = {

    fragmentAdd : /* glsl */`
        uniform vec4 clevels;
        uniform float randomUv;

        uniform sampler2D noise;

        uniform sampler2D normalMap1;
        uniform sampler2D normalMap2;

        uniform sampler2D roughnessMap1;
        uniform sampler2D roughnessMap2;

        uniform float aoMapIntensity;
        uniform sampler2D map1;
        uniform sampler2D map2;

        vec4 textureMAP( sampler2D mapper, in vec2 uv ){
            if( randomUv == 1.0 ) return textureNoTile( mapper, uv );
            else return texture2D( mapper, uv );
        }

        vec4 MappingMix( float slope, vec4 level, vec4 rocks, vec4 grasss, vec4 sands ){
            vec4 cc = rocks;
            if (slope < level.x) cc = grasss;
            if (slope < level.z) cc = sands;
            if (slope == 0.0 ) cc = sands;
            //if (( slope < level.x ) && (slope >= level.y)) cc = mix( grasss , rocks, (slope - level.y) * (1. / (level.x - level.y)));
            //if (( slope < level.y ) && (slope >= level.z)) cc = mix( sands , grasss, (slope - level.z) * (1. / (level.y - level.z)));

            float d = level.y;
            float rx = 1.0/level.y;

            if (( slope < level.x + d ) && (slope > level.x)) cc = mix( grasss , rocks, ( slope - (level.x) ) * rx );

            d = level.w;
            rx = 1.0/level.w;
            if (( slope < level.z + d ) && (slope > level.z )) cc = mix( sands , grasss, ( slope - (level.z) ) * rx );

            //cc = mix( grasss, cc, smoothstep(0.0,1.0, slope)*20.0 );
            return cc;
        }
    `,

    // map_fragment.glsl

    map : /* glsl */`
        #ifdef USE_MAP

            vec4 sand = textureMAP( map, vMapUv );
            vec4 grass = textureMAP( map1, vMapUv );
            vec4 rock = textureMAP( map2, vMapUv ); 

            vec4 sampledDiffuseColor = MappingMix(vColor.r, clevels, rock, grass, sand);

            diffuseColor *= sampledDiffuseColor;

        #endif
    `,

    // normal_fragment_maps

    normal : /* glsl */`

        #ifdef USE_NORMALMAP_OBJECTSPACE

            normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

            #ifdef FLIP_SIDED

                normal = - normal;

            #endif

            #ifdef DOUBLE_SIDED

                normal = normal * faceDirection;

            #endif

            normal = normalize( normalMatrix * normal );

        #elif defined( USE_NORMALMAP_TANGENTSPACE )

            vec4 sandN = textureMAP( normalMap, vNormalMapUv );
            vec4 grassN = textureMAP( normalMap1, vNormalMapUv );
            vec4 rockN = textureMAP( normalMap2, vNormalMapUv );
            vec3 mapN = MappingMix(vColor.r, clevels, rockN, grassN, sandN).xyz * 2.0 - 1.0;

            ///vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;

            mapN.xy *= normalScale;
            normal = normalize( tbn * mapN );

        #elif defined( USE_BUMPMAP )

            normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

        #endif
    `,

    alphamap : /* glsl */`
        #ifdef USE_ALPHAMAP
            diffuseColor.a = opacity +( texture2D( alphaMap, vAlphaMapUv ).g * opacity) * (1.0-opacity);
        #endif
    `,
    
};


const randomUV = /* glsl */`

uniform sampler2D noiseMap;
uniform float useNoiseMap;

float directNoise(vec2 p){
    vec2 ip = floor(p);
    vec2 u = fract(p);
    u = u*u*(3.0-2.0*u);
    
    float res = mix(
        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
    return res*res;
}

float sum( vec4 v ) { return v.x+v.y+v.z; }

vec4 textureNoTile( sampler2D mapper, in vec2 uv ){

    // sample variation pattern
    float k = 0.0;
    if( useNoiseMap == 1.0 ) k = texture2D( noiseMap, 0.005*uv ).x;
    else k = directNoise( uv );
    
    // compute index    
    float index = k*8.0;
    float f = fract( index );

    float ia = floor( index );
    float ib = ia + 1.0;
    // or
    //float ia = floor(index+0.5); // suslik's method (see comments)
    //float ib = floor(index);
    //f = min(f, 1.0-f)*2.0;

    // offsets for the different virtual patterns    
    vec2 offa = sin(vec2(3.0,7.0)*ia); // can replace with any other hash    
    vec2 offb = sin(vec2(3.0,7.0)*ib); // can replace with any other hash    

    // compute derivatives for mip-mapping    
    vec2 dx = dFdx(uv);
    vec2 dy = dFdy(uv);
    
    // sample the two closest virtual patterns    
    vec4 cola = textureGrad( mapper, uv + offa, dx, dy );
    vec4 colb = textureGrad( mapper, uv + offb, dx, dy );

    // interpolate between the two virtual patterns    
    return mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );

}
`;

// THREE TERRAIN
let Mat = null;

class Terrain extends Item {

	constructor( motor ) {

		super();

		this.motor = motor;
		this.engine = this.motor.engine;
		this.Utils = this.motor.utils;

		Mat = this.motor.mat;

		this.type = 'terrain';
		this.num = Num[this.type];

	}

	step (AR, N) {

		let i = this.list.length, s;

		while( i-- ){

			s = this.list[i];
			//n = N + ( i * this.num );
			s.step();// AR[n] );

		}

	}

	add ( o = {} ) {

		this.setName( o );

		if( this.engine === 'JOLT' ){
			o.isAbsolute = true;
			o.isTurned = false;
		}

		if( this.engine === 'PHYSX' ){
			o.isAbsolute = true;
			o.isTurned = true;
		}

		if( this.engine === 'HAVOK'){
			o.isAbsolute = true;
			o.isTurned = true;
			o.isReverse = false;
		}

		if( this.engine !== 'OIMO'){
			o.zone = o.zone || 0.25;
			//o.debuger = true
		}

		const t = new Landscape( o );

		Mat.extendShader( t.material, t.material.onBeforeCompile );

		t.physicsUpdate = ( name, h ) =>{

			this.motor.flow.tmp.push( { name:name, heightData:h } );
			//root.post({m:'change', o:{ name:'terra', heightData:h }})
		};

		// add to world
		this.addToWorld( t, o.id );

        // add to physics
        this.motor.post({ m:'add', o:toPhysics(t, this.engine) });

		return t

	}

	set ( o = {}, b = null ) {

		if( b === null ) b = this.byName( o.name );
		if( b === null ) return

		b.set(o);

	}
	
}

const toPhysics = function( t, engine ) {

	const o = {
		name:t.name,
		type:t.type,
		pos:t.position.toArray(),
		quat:engine === 'PHYSX' ? [0,0,0,1]:t.quaternion.toArray(), // physx terrain can't turn !!
	};

	if( engine === 'PHYSX' || engine === 'AMMO' || engine === 'HAVOK' || engine === 'JOLT'){
		o.type = 'terrain';
		o.size = t.sizeZ;
		o.sample = t.sampleZ;
		o.zone = t.zone;
		o.heightData = t.heightData;
	} else {
		o.type = 'mesh';
		o.v = MathTool.getVertex( t.geometry, engine === 'OIMO' );
		o.index = engine === 'OIMO' ? null : MathTool.getIndex( t.geometry );
	}

	return o

};

class Solver extends Item {

	constructor ( motor ) {

		super();

		this.motor = motor;
		this.Utils = this.motor.utils;
		
		this.type = 'solver';

	}

	step (AR, N) {

		let i = this.list.length, n;

		while( i-- ){

			n = N + ( i * Num[this.type] );
			this.list[i].update( AR, n );

		}

	}

	///

	add ( o = {} ) {

		this.setName( o );

        let solver = new Articulation( o, this.motor );

        // add to world
		this.addToWorld( solver, o.id );

        // add to worker
        this.motor.post({ m:'add', o:o });

        return solver;


	}

	set ( o = {} ) {

	}

}

// ARTICULATION SOLVER

class Articulation {//extends Basic3D 

	constructor( o, motor ) {

		this.motor = motor;

		//super();

		this.name = o.name;
		this.type = 'solver';
		this.needData = o.needData || false;
		this.bones = [];
		this.joints = [];
		this.jid = 0;
		this.speed = 1;

	}

	addBone( name ){

		this.bones.push( name );

	}

	dispose(){

		this.motor.remove( this.bones, true );
		
	}

	update ( AR, n ){

		if( !this.needData ) return

		let k = this.joints.length, j, m;

		while(k--){

			m = n + (k*7);

			j = this.joints[k];

			j.data.target.x = AR[ m + 0];
			j.data.target.y = AR[ m + 1];
			j.data.target.z = AR[ m + 2];

			j.data.target.rx = AR[ m + 3];//Math.round( AR[ m + 3] )
			j.data.target.ry = AR[ m + 4];//Math.round(  )
			j.data.target.rz = AR[ m + 5];//Math.round( AR[ m + 5] )

			/*j.data.target.twiwt = Math.round( AR[ m + 3] )
			j.data.target.swing1 = Math.round( AR[ m + 4] )
			j.data.target.swing2 = Math.round( AR[ m + 5] )*/

			j.data.target.count = AR[ m + 6 ];

		}

	}

	start (){

		this.motor.post({ m:'startArticulation', o:{ name:this.name } });

	}

	stop (){

		this.motor.post({ m:'stopArticulation', o:{ name:this.name } });

	}

	commonInit (){

		this.motor.post({ m:'commonInitArticulation', o:{ name:this.name } });

	}

	addJoint ( o ) {

		this.jid = this.joints.length;

		o.name = o.name || ( this.name + '_Joint_' + this.jid );
		o.solver = this.name;

		if( o.rot1 !== undefined ){ o.quat1 = MathTool.quatFromEuler( o.rot1 ); delete ( o.rot1 ); }
		if( o.rot2 !== undefined ){ o.quat2 = MathTool.quatFromEuler( o.rot2 ); delete ( o.rot2 ); }
		
		if(o.type !== 'fixe') {
			this.joints.push( new SolverJoint( o, this ) );
		}

		this.motor.post({ m:'addSolverJoint', o:o });

	}

	/*addBone ( mesh ) {

		console.log('bone is add')

		this.add( mesh );

	}*/

	driveJoints ( dt ) {

		let isInDrive = false;

		let k = this.joints.length, j, d, nup = [];

		while(k--){ 

			j = this.joints[k];
			j.update( dt );
			d = j.isDrive;
			if( j.nup ) nup.push( j.nup );
			isInDrive = d ? true : isInDrive;

		}

		// update or die
		if( isInDrive ) this.motor.change( nup );
		else {
			if(this.resolve){
				this.resolve();
				delete this.resolve;
			}
		}

	}

    setAngles ( angles, time ){

    	if(!angles) return

    	let j = this.joints.length;

    	while(j--){ 
    		this.joints[j].pose( angles[j] !== undefined ?  angles[j] : 0, time !== undefined ? time : this.speed );
    	}

    	return new Promise((resolve) => this.resolve = resolve );

    }


}

// ARTICULATION JOINT

class SolverJoint {

	constructor( o, solver ) {

		this.name = o.name;
		this.solver = solver;
		this.type = 'solverJoint';
		this.isDrive = false;
		//this.inverse = o.inverse || false

		this.current = 0;
		this.tmp = 0;
		this.target = 0;
		this.start = 0;
		this.time = 0;
		this.nup = null;

		this.data = {

			target:{ x:0, y:0, z:0, rx:0, ry:0, rz:0, count:0 },

			//target:{ x:0, y:0, z:0, twist:0, swing1:0, swing2:0, count:0 },

		};

		if( o.limits ){
			this.driveType = o.limits[0][0];
			this.min = o.limits[0][1];
			this.max = o.limits[0][2];
		}

		if( o.position ) o.target = o.position;

		if( o.target ){
			let i = o.target.length, t;

			while(i--){
				t = o.target[i];
				this.data.target[ t[0] ] = t[1];
				//if(t[0]===this.driveType)  this.current = t[1]

			}
		}

		//stiffness, damping, forceLimit, acceleration drive flag
		//o.drives = [[this.driveType, 100000, 0, Infinity, true ]];
		//solver.addJoint(o);
		
	}

	start (){

	}

	pose( target, time ){



		// linear target need to be clamp ?!
		this.target = MathTool.clamp( target, this.min, this.max );
		//this.current = this.data.target[ this.driveType ];
		this.current = MathTool.clamp( this.data.target[ this.driveType ], this.min, this.max );

		//console.log( this.target, this.current )

		if( this.target === this.current ) return;


		this.start = this.current;
		this.tmp = 0;
		this.time = time;

		this.isDrive = true;

		/*if( this.driveType !== 'z' ) this.isDrive = true;
		else{ 
			/*if(target===0.3 || target===-0.3) this.start = 0;
			else{

				if(this.name = 'A7') this.start = -0.3;
				else this.start = 0.3;
			}*/
		//	console.log( this.driveType, this.current )
		//}
		
		//return new Promise((resolve) => this.resolve = resolve);

	}
	
	update( dt ){

		if( this.isDrive ){

		    this.tmp += dt*this.time;
			let t = this.tmp;
			t = (t > 1) ? 1 : t;

			//this.tmp = 1;//dt;
			//let t = this.tmp // this.time;
			//t = (t > 1) ? 1 : t;

			let move = MathTool.lerp( this.start, this.target, t );//this.current + (this.target - this.current) * t;

			this.nup = { name:this.name, drivesTarget: [[ this.driveType, move ]] };

		    if( t === 1 ) this.isDrive = false;

		} else {
			this.nup = null;
		}

	}

}

class Textfield extends Mesh {

	constructor( o={} ) {

		super( new PlaneGeometry(), new MeshBasicMaterial({polygonOffset: true, polygonOffsetFactor: -4}));

		this.name = o.nam || 'text';
		this.canvas = null;

		this.w = o.w || 0;
		this.h = o.h || 0;

		this.weight = o.weight ?? 700;

		this.font = o.font ?? "'Mulish', sans-serif";
		this.fontSize = o.fontSize ?? 32;
		this.backgroundColor = o.backgroundColor ?? "#00000000";
		this.fontColor = o.fontColor ?? "#FFFFFF";
		this.material.alphaTest = 0.5;
		this.set( o.text );
		
		if( o.pos ) this.position.fromArray(o.pos);
		if( o.rot ) this.quaternion.fromArray( MathTool.quatFromEuler( o.rot ) );
		
	}

	set( str ){

		if(!this.canvas) this.canvas = document.createElement("canvas");
		let ctx = this.canvas.getContext("2d"), w, h, r;
		
		ctx.font = this.weight + " " + this.fontSize + "px " + this.font;
		

		let metrics = ctx.measureText( str );

		//resize to nearest power of 2
		w = 2 ** Math.ceil(Math.log2(metrics.width));
		h = 2 ** Math.ceil(Math.log2(ctx.measureText('M').width));



		
		this.canvas.width = w;
		this.canvas.height = h;

		ctx.fillStyle = this.backgroundColor;
		ctx.fillRect(0, 0, w, h);
		//var backgroundAlpha = ctx.getImageData(0, 0, 1, 1).data[3];

        ctx.fillStyle = this.fontColor;
		//ctx.font = this.fontSize + "px " + this.font;
		ctx.font = this.weight + " " + this.fontSize + "px " + this.font;
		ctx.textAlign = "center";
		ctx.textBaseline = 'middle';
		
		ctx.fillText( str, w*0.5, h*0.5 );

		this.material.map = new CanvasTexture(this.canvas);

		//if(this.w===0) this.w = w*0.02

		if( this.h !== 0 ){
			r = this.h / h;
			this.scale.set(w*r,this.h,0);
		}

		else if( this.w !== 0 ){
			r = this.w / h;
			this.scale.set(this.w,h*r,0);
		}

		else {
			this.scale.set(w*0.025,h*0.025,0);
		}


		//this.scale.set(this.w,h*r,0)

		/*let img = new Image(w, h);
        img.src = canvas.toDataURL( 'image/png' );

        let self = this

        img.onload = ()=>{

			//
			self.material.map = new Texture(img);
			self.material.map.needsUpdate = true
			//self.material.needsUpdate = true

			self.scale.set(w*0.05,h*0.05,0)
		}*/

	}

	dispose(){

		this.parent.remove(this);
		this.material.map.dispose();
		this.material.dispose();
		this.geometry.dispose();

	}

}

let Nb = 0;

class Button {

	constructor ( o={}, motor ) {

		this.motor = motor;

		this.down = false;


		this.time = o.time || 250;

		this.p = o.pos || [0,0,0];

		this.type = o.type || 'box';
		this.name = o.name || 'button' + Nb++;
		this.pos = o.pos || [0,0,0];
		this.size = o.size || [1,1,1];
		this.radius = o.radius || 0;
		this.axe = o.axe !== undefined ? o.axe : 1;

		this.fontSize = o.fontSize || 0.8; 
		this.fontScale = o.fontScale || 1.0;

		this.extraForce = true; 


		this.decal = this.type === 'sphere'? this.size[1]*0.5 : (this.size[1]*0.5) - this.radius;

		if( this.type !== 'sphere' ) this.pos[ this.axe ] += this.decal;


		this.origin = this.pos[this.axe];
	    let height = this.size[this.axe]-(this.radius*2);

		//this.range = [ this.origin - this.decal - (this.radius*2), this.origin ]
		this.range = [ this.origin - height, this.origin ];

		this.value = this.origin;
		this.target = this.origin;

		this.speed = (this.size[this.axe]/3) / (this.size[this.axe]);

	

		this.callback = function(){ 
			console.log("action down"); 
		};

		if( o.callback ){ 
			this.callback = o.callback; 
			delete o.callback;
		}

		o.button = true;
		o.pos = this.pos; 
		if(!o.material) o.material = 'button';
		o.kinematic = true;
		o.mask = 1;

		

		this.timeout = null;

		// add model & physics
		this.b = this.motor.add( o );

		this.b.userData['action'] = this.action.bind(this);
		this.b.userData['out'] = this.out.bind(this);

		// is bad ?
		this.b.userData['direct'] = this.callback.bind(this);

		// extra text on top 
		if( o.text ) this.addText( o.text );

	}

	addText( txt, size ){

		this.fontSize = this.type==='box' ? this.size[this.axe] * 0.8 : this.size[0] * 0.8;
		this.fontSize *= this.fontScale;
		let dt = { text:txt, pos:[ 0,this.size[1]*0.5,0 ], rot:[-90,0,0], h:this.fontSize };
		if( this.axe === 2 ) dt = { text:txt, pos:[ 0,0, this.size[2]*0.5 ], rot:[0,0,0], h:this.fontSize };
		this.txt = new Textfield( dt );
		this.b.add( this.txt );

	}

	action( p ){

		if( this.down ) return

		this.down = true;
	    this.target = this.range[0];
	    if(this.extraForce) this.motor.explosion( p || this.p, this.size[0]*2, 0.01 );
		this.callback();

	}

	out(){

		if(!this.down) return

		this.down = false;
	    this.target = this.range[1];
	    if(this.extraForce) this.motor.explosion( this.p, this.size[0]*2, 0.01 );

	}

	update(){

		if( this.value !== this.target ){

			//let side = this.target > this.value ? 1 : -1

			this.value = MathTool.lerp( this.value, this.target, this.speed );

			//this.value += 0.1 * side

			let t = MathTool.nearEquals( this.value, this.target, 0.0001);

			if(!t){
			    this.pos[this.axe] = this.value;
			    this.motor.change( {name:this.b.name, pos:this.pos} );
			} else {
				this.value = this.target;
			}


		}

	}

	dispose(){

		if(this.txt) this.txt.dispose();
	}

}

const _box = /*@__PURE__*/ new Box3();

class BoxHelper extends LineSegments {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );
		

		let c = new Color( color );
		let ar = [];
		let i = 8;
		while(i--) ar.push(c.r,c.g,c.b);
		const colors = new Float32Array( ar );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );
		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		super( geometry, new LineBasicMaterial( { vertexColors: true, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {
			_box.setFromObject( this.object );
		}

		if ( _box.isEmpty() ) return;

		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.object = source.object;

		return this;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class Container {

	constructor ( o = {}, motor ) {

		this.motor = motor;

		this.isCompound = true;
		this.remplace = o.remplace || false;
		this.init(o);

	}

	init ( o = {} ) {

		const intern = o.intern || false;


		let s = o.size || [5,3,8];
		let p = o.pos || [0,2,0];
		let w = o.wall || 0.1;

		if( o.size[3] !== undefined )  w = o.size[3];
		if(w<=0) w = 0.01;
		let mw = w * 0.5;
		let xw = w * 2;

		if(!o.face) o.face = {};
		let f = { up:1, down:1, left:1, right:1, front:1, back:1, ...o.face };
		delete o.face;

		//let geometry = new ChamferBox( s[ 0 ], s[ 1 ], s[ 2 ], o.radius || mw );
		//let mesh = new Mesh( geometry );

		const data = [];

		if(intern){

			if(f.up===1) data.push({ pos:[0, s[1]*0.5+mw, 0], size:[s[0]+xw, w, s[2]+xw] });
			if(f.down===1) data.push({ pos:[0, -mw-s[1]*0.5, 0], size:[s[0]+xw, w, s[2]+xw] });

			if(f.left===1) data.push({ pos:[-mw-s[0]*0.5, 0, 0 ], size:[w, s[1], s[2]] });
			if(f.right===1) data.push({ pos:[s[0]*0.5+mw, 0, 0 ], size:[w, s[1], s[2]] });

			if(f.back===1) data.push({ pos:[0, 0, -mw-s[2]*0.5], size:[s[0]+xw, s[1], w] });
			if(f.front===1) data.push({ pos:[0, 0, s[2]*0.5+mw], size:[s[0]+xw, s[1], w] });

		}else {

			if(f.up===1) data.push({ pos:[0, s[1]*0.5-mw, 0], size:[s[0], w, s[2]] });
			if(f.down===1) data.push({ pos:[0, mw-s[1]*0.5, 0], size:[s[0], w, s[2]] });

			if(f.left===1) data.push({ pos:[mw-s[0]*0.5, 0, 0 ], size:[w, s[1]-xw, s[2]] });
			if(f.right===1) data.push({ pos:[s[0]*0.5-mw, 0, 0 ], size:[w, s[1]-xw, s[2]] });

			if(f.back===1) data.push({ pos:[0, 0, mw-s[2]*0.5], size:[s[0]-xw, s[1]-xw, w] });
			if(f.front===1) data.push({ pos:[0, 0, s[2]*0.5-mw], size:[s[0]-xw, s[1]-xw, w] });

		}

		

		const faces = [];
		let i = data.length, n=0, pp, d;

		while( i-- ){

			d = data[n];
			pp = this.isCompound ? d.pos : MathTool.addArray(p, d.pos);
			faces.push( { type:'box', size:d.size, pos:pp, material:o.material } );
			n++;

		}

		

		if( this.isCompound ){
			let mesh = null;
			if( this.remplace ){
				if(o.radius===0) mesh = new Mesh( new BoxGeometry( s[ 0 ], s[ 1 ], s[ 2 ] ) );
				else mesh = new Mesh( new ChamferBox( s[ 0 ], s[ 1 ], s[ 2 ], o.radius || mw ) );

				if(o.material){
					if(o.material === 'debug'){ 
						mesh = new BoxHelper( mesh, o.color );
						o.material = 'line';
					}
				}
			}
			this.motor.add({
				...o,
				mesh:mesh,
				shapes:faces,
		        type:'compound',
		    });
		} else {
			this.motor.add( faces );
		}
		
	}

}

//----------------
//  MOUSE TOOL 
//----------------

class MouseTool {

	constructor ( controler, mode = 'drag', motor ) {

		this.motor = motor;

		this.needRay = false;

		//this.tmpSelected = null

		//root.viewSize = { w:window.innerWidth, h:window.innerHeight, r:0}
		//root.viewSize.r = root.viewSize.w/root.viewSize.h

		this.moveDirect = false;
		this.moveDeep = false;

		this.mode = mode;
		this.option = {};

		this.overObj = null;

		this.controler = controler;
		this.dom = this.controler.domElement;

		//this.dom.style.cursor =  "url('./assets/icons/logo.png'), move";

		this.selected = null;
		this.buttonRef = null;
		this.release = false;

		this.numBullet = 0;
		this.maxBullet = 10;

		this.sticky = false;

		this.pz = 0;

		this.isActive = false;
		this.raycastTest = false;
		this.firstSelect = false;
		this.mouseDown = false;
		this.mouseDown2 = false;
		this.mouseMove = false;
		//this.controlFirst = true;

		this.decal = new Vector3();
		this.tmpPos = new Vector3();
		this.tmpD = new Vector3();

		this.mouse = new Vector2();
		this.oldMouse = new Vector2();
		this.raycast = new Raycaster();
		this.raycast.far = 1000;

		this.button = 0;

		this.pos = new Vector3();
		this.velocity = new Vector3();
		this.angle = 0;

		this.helper = null;
		this.dragPlane = null;
		this.overLock = false;

	    //if( this.mode === 'drag' ) 
	    this.activeDragMouse( true );

	}

	addDrag(){

		if( this.dragPlane ) return

		//this.overLock = true;

		this.helper = new MoveHelper(this.motor);
		this.dragPlane = new Mesh( new PlaneGeometry( 1, 1 ), this.motor.mat.get('hide') );
	    this.dragPlane.castShadow = false;
	    this.dragPlane.receiveShadow = false;
	    this.dragPlane.scale.set( 1, 1, 1 ).multiplyScalar( 200 );

	    this.motor.scenePlus.add( this.helper );
	    this.motor.scenePlus.add( this.dragPlane );

	}

	clearDrag(){

		if( !this.dragPlane ) return

		//this.overLock = false;

		this.motor.scenePlus.remove( this.dragPlane );
		this.motor.scenePlus.remove( this.helper );

		this.dragPlane.geometry.dispose();
		this.helper.geometry.dispose();

		this.dragPlane = null;
		this.helper = null;

	}

    setMode ( mode, o = {} ) {

    	if( mode === this.mode ) return
    	this.mode = mode;
        this.option = o;

        if( this.mode === 'blast' && this.option.visible ) this.motor.initParticle();

    }

	activeDragMouse ( b ) {

		if( b ){
			if( !this.isActive ){
				this.dom.addEventListener( 'pointermove', this.mousemove.bind(this), false );
		        this.dom.addEventListener( 'pointerdown', this.mousedown.bind(this), false );
		        document.addEventListener( 'pointerup', this.mouseup.bind(this), false );
		        //document.addEventListener( 'contextmenu', this.contextmenu.bind(this), false )

		        this.controler.addEventListener( 'end', this.controleEnd.bind(this), false );
		        this.controler.addEventListener( 'start', this.controleStart.bind(this), false );
		        //this.controler.addEventListener( 'change', this.controleChange.bind(this), false )

		        this.isActive = true;
		        this.raycastTest = true;
		    }

		} else {
			if( this.isActive ){
				this.dom.removeEventListener( 'pointermove', this.mousemove.bind(this) );
			    this.dom.removeEventListener( 'pointerdown', this.mousedown.bind(this) );
			    document.removeEventListener( 'pointerup', this.mouseup.bind(this) );

			    this.controler.removeEventListener( 'end', this.controleEnd.bind(this) );
			    this.controler.removeEventListener( 'start', this.controleStart.bind(this), false );
		        //this.controler.removeEventListener( 'change', this.controleChange.bind(this) )

			    this.isActive = false;
			}
		}
	}

	controleEnd ( e ) {
		//this.controlFirst = true
		this.raycastTest = true;
		if( this.controler.getInfo ) this.controler.getInfo();
	}

	controleStart ( e ) {
		this.raycastTest = false;
	}

	controleChange ( e ) {

		

		

		//let state = this.controler.getState();

		//if( state !== -1 ) this.raycastTest = false;

		/*let state = this.controler.getState();
		console.log(state)
		if( state !== -1 ){
			if( this.controlFirst ) this.controlFirst = false;
			else this.raycastTest = false;
		}*/

		//this.controler.getInfo();
	}

	getMouse ( e ) {

		if(this.motor.viewSize){
			this.mouse.x =   ( e.offsetX / this.motor.viewSize.w ) * 2 - 1;
		    this.mouse.y = - ( e.offsetY / this.motor.viewSize.h ) * 2 + 1;
		} else {
			this.mouse.x =   ( e.offsetX / this.dom.clientWidth ) * 2 - 1;
			this.mouse.y = - ( e.offsetY / this.dom.clientHeight ) * 2 + 1;
		}

		//console.log(e.button)
		
		this.button = e.pointerType !== 'touch' ? e.button : 0;
		//if(this.button===2)this.moveDeep = !this.moveDeep

	}

	contextmenu ( e ) {
		//e.preventDefault();
		//this.mouseDown2 = true
		//this.controler.enabled = false;
		/*if( this.mouseDown ){

			//this.moveDeep = true
			console.log('yo ')
		}*/
	}

	mousedown ( e ) {

		if( this.sticky ){ 
			this.unSelect();
			console.log('unstick');
		}

		this.getMouse( e );
		//this.needRay = true;
		//this.overLock = true;

		switch( this.mode ){

			case 'drag': this.drag(); break;
			case 'shoot': this.shoot(); break;
			case 'blast': this.blast(); break;
			case 'build': this.build(); break;

		}

	}

	mouseup ( e ) {

		//console.log('up')

		this.release = true;
		//this.overLock = false;

		document.body.style.cursor = 'auto';

		this.mouseMove = this.oldMouse.distanceTo( this.mouse ) < 0.01 ? false : true;
		this.mouseDown = false;
		this.mouseDown2 = false;
		//this.motor.mouseDown = false



		if( this.sticky ) { this.controler.enabled = true; return; }

		this.unSelect();
		this.resetButton();

	}

	mousemove ( e ) {

		//if( this.release ) this.release = false;

		switch( this.mode ){

			case 'drag':
			this.getMouse( e );
			this.needRay = true;
		    //this.castray()
			break

		}

	}

	castray () {

		let inters, m, g, h, id, cursor = 'auto';

		if( this.selected !== null ){

			this.raycast.setFromCamera( this.mouse, this.controler.object );
			inters = this.raycast.intersectObject( this.dragPlane );
			if ( inters.length && this.mouseDown ){ 
				this.moveSelect( inters[0].point );
				//if( this.moveDirect ) root.motor.change({ name:this.selected.name, pos:inters[0].point.toArray() }, true )
				//else root.motor.change({ name:'mouse', pos:inters[0].point.toArray() }, true )
			}
			//return
		} else {

			if( !this.raycastTest ) return;

			//this.controler.enabled = false

			this.controler.enableRotate = false;
			this.controler.enablePan = false;

			this.raycast.setFromCamera( this.mouse, this.controler.object );

			inters = this.raycast.intersectObjects( this.motor.scene.children, true );

			this.tmpSelected = null;

			if ( inters.length > 0 ) {

				g = inters[ 0 ].object;
				

				//console.log(inters[ 0 ])

				if( g.isInstancedMesh ){
					// is instance mesh
					id = inters[ 0 ].instanceId;
					m = this.motor.byName( g.getIDName( id ) );
					//console.log(m)
					//m = root.motor.byName( g.name+id );
				} else {
					if( g.parent !== this.motor.scene ){
						h = g.parent;
						if( h.parent !== this.motor.scene ) m = h.parent;
						else m = h;
					} else m = g;
				}

				if( this.mouseDown2 ){
					if( m.extra ) m.extra( m.name );
					//console.log(m)
				}

				if( m && !m.isButton ){
					cursor = this.select( m, inters[ 0 ].point );
					//this.tmpSelected = m
					//this.tmpPoint = inters[ 0 ].point
				}
				else cursor = this.actionButton( m, inters[ 0 ] );
				//document.body.style.cursor = cursor

			} else {

				this.resetOver();
				this.controler.enableRotate = true;
				this.controler.enablePan = true;
				
				//this.controler.enabled = true
			}

			//console.log(this.release, cursor)
			if( this.release ){
				this.release = false;
				this.controler.enableRotate = true;
				this.controler.enablePan = true;
				cursor = 'auto';
				this.resetOver();
				
			}

			document.body.style.cursor = cursor;
		}

	}

	drag () {

		if( !this.mouseDown ){
			if( this.firstSelect ) this.firstSelect = false;
			this.oldMouse.copy( this.mouse );
		}



		if( this.button === 2 ){
		    this.mouseDown2 = true;
		    //this.castray()
		}

	    //if( this.button === 0 ){
		    this.mouseDown = true;
		    //this.motor.mouseDown = true
		    this.needRay = true;

		    //if(this.tmpSelected!== null) this.select(this.tmpSelected, this.tmpPoint )
		    //this.castray()
		//}

		

	}

	blast () {

		let hit = null;
		this.raycast.setFromCamera( this.mouse, this.controler.object );
		let inters = this.raycast.intersectObjects( this.motor.scene.children, true );

		if ( inters.length > 0 ) {

			if( !inters[ 0 ].object.isButton ) hit = inters[ 0 ];
			else inters[ 0 ].object.parent.userData.direct();
				
		} else {
			inters = this.raycast.intersectObjects( this.motor.scenePlus.children, true );
			if ( inters.length > 0 ) hit = inters[ 0 ];
		}

	    const o = this.option;

		if(hit){ 

			this.motor.explosion( hit.point, o.radius || 3, o.power || 0.1 );

			if( o.visible ) this.motor.addParticle({
				name:'blast',
				type:"cube",
				position:hit.point.toArray(),
				numParticles: 60,
				radius:0.2,
				radiusRange:0.1,
				//accelerationRange:[0.3,0.3,0.3],
				acceleration:[5*10,5,5*10],
				lifeTime: 0.5,
		        endTime: 0.5,
		        startTime: 0,
		        gravity:[0,0.2,0],
		        startSize: 0.5,
		        endSize: 0.1,
		        //spinSpeedRange:2,
		        tween:"outQuad",
		        //velocityRange: [ 0.6, 0.6, 0.6 ]
		        //lifeTimeRange:1,
		        //startTime: 0,
		        //startSize: 0.1,

			});
		}
		

	}

	shoot () {

		this.raycast.setFromCamera( this.mouse, this.controler.object );
		this.pos.copy( this.raycast.ray.direction ).add(  this.raycast.ray.origin );
		this.velocity.copy( this.raycast.ray.direction ).multiplyScalar( 60 );

		this.motor.add({
			name: 'bullet_' + this.numBullet,
			type:'sphere',
			density:20,
			size:[0.2], 
			material:'chrome',
			pos:this.pos.toArray(),
			linearVelocity:this.velocity.toArray(),
			bullet:true,
			/*ccdThreshold:0.0000001,
            ccdRadius:0.1,*/
		});

		this.numBullet++;
		if(this.numBullet > this.maxBullet) this.numBullet = 0;

	}

    resetButton () {

		if( this.buttonRef ){
			if( this.buttonRef.userData.out ) this.buttonRef.userData.out();
			this.buttonRef = null;
		}

		this.raycastTest = true;
		this.selected = null;
		this.firstSelect = true;
		//this.controler.enabled = true
		this.controler.enableRotate = true;
		this.controler.enablePan = true;

	}

	actionButton ( obj, inters ) {

		if( this.buttonRef ){
			if( this.buttonRef.name !== obj.name ){ 
				if( this.buttonRef.userData.out ) this.buttonRef.userData.out();
				this.buttonRef = obj;
			}
		} else {
			if( this.mouseDown ) this.buttonRef = obj;
		}
		if( this.mouseDown && this.buttonRef.userData.action ){ 
			let pos = inters.point;
			this.buttonRef.userData.action( pos );
		}

		//if( this.mouseDown ) this.controler.enabled = false
		   
		//return 'grab'
	    return 'pointer'

	}

	setOver( obj ){

		//if( this.overLock ) return;
		if( !obj ) return;

		if( this.overObj ){
			if( obj.name !== this.overObj.name ) this.resetOver();
		}

		this.overObj = obj;
		if( this.overObj.over ) this.overObj.over(true);

	}

	resetOver(){

		//if( this.overLock ) return;
		if( !this.overObj ) return;
		if( this.overObj.over ) this.overObj.over( false );
		this.overObj = null;

	}

	select ( obj, point ) {

		//this.controler.enabled = false

		//if( this.selected !== null ) return 'pointer'
		//if( !this.mouseDown ) return 'auto'
		//if( this.selected === obj ) return 'grab'//'pointer'

		if( !this.mouseDown ) this.setOver( obj );

		

		if( !this.mouseDown || this.selected === obj ){
			return 'grab'
		}

		//this.overLock = true;


		this.pz = 0;

		let pos = point;
	    let quat = [0,0,0,1];

		this.selected = obj;
		//this.setOver( obj );
		/*if( this.selected.isInstance ) quat = this.selected.instance.getInfo( this.selected.id ).quat;
		else if( this.selected.isObject3D ){
			this.selected.updateMatrix()
			quat = this.selected.quaternion.toArray()
		}*/

		this.decal.copy( pos ).sub( this.selected.position );
		this.tmpPos.copy( pos ).sub( this.decal );
		this.angle = this.controler.getAzimuthalAngle();


		

		let q = this.selected.quaternion;
		quat = q.toArray();//[ q._x, q._y, q._z, q._w ]


		/*if( this.selected.isInstance ){
			console.log(this.selected)
			return
		}*/

		/*if( this.selected.isButton ){
			if( this.buttonRef ){
				if(this.buttonRef.name !== this.selected.name ) this.buttonRef = obj
			} else {
				this.buttonRef = obj
			}
			if( this.buttonRef.userData.action ) this.buttonRef.userData.action()
			    this.unSelect ()
			return 'grab'
		}*/

		this.addDrag();

		//8root.scenePlus.add( this.helper )
	    //root.scenePlus.add( this.dragPlane )

	    this.dragPlane.rotation.set( 0, this.angle, 0 );
	    this.dragPlane.position.copy( pos );
	    this.dragPlane.position.y = 0;

	    this.helper.position.copy( pos );


	    let p = pos.toArray();

	    let revert = false;

	    this.motor.change({ name: this.selected.name, neverSleep:true, wake:true });
		//Motor.add({ name:'mouse', type:'sphere', size:[0.01], pos:p, quat:quat, mask:0, density:0, noGravity:true, kinematic:true, flags:'noCollision' })
		//root.motor.add({ name:'mouse', type:'null', pos:p, quat:quat })

		//let def = [-0.03, 0.03, 60, 5]
		//let defr = [-3, 3, 60, 5]

		//let def = [-0.03, 0.03, 60, 2]
		//let defr = [-3, 3, 60, 2]

		if( this.moveDirect ){
			this.motor.change({ name:this.selected.name, kinematic:false, gravity:false, damping:[0.9,0.9]  });
		} else {
			let def = [-0.1, 0.1, 600, 1];
			let defr = [-0.1, 0.1, 600, 1];
			//let defr = [0, 0]
			let notUseKinematic = this.motor.engine === 'OIMO' || this.motor.engine ==='RAPIER' || this.motor.engine ==='JOLT';//|| root.engine ==='HAVOK'
			let jtype = this.selected.link === 0 ? 'fixe' : 'd6';//root.engine === 'HAVOK' ? 'fixe' : 'd6';

			if( this.motor.engine === 'JOLT' ) jtype = 'fixe';

			let limite = [['x',...def], ['y',...def], ['z',...def], ['rx',...defr], ['ry',...defr], ['rz',...defr]];

			if( this.motor.engine === 'HAVOK' ) limite = [ ['x',...def], ['y',...def], ['z',...def] ];

			if( this.motor.engine === 'OIMO' ){
				revert = true;
				jtype = this.selected.link === 0 ? 'fixe' : 'spherical';
				limite = [ ['x',...def], ['y',...def], ['z',...def] ];
				//if(this.selected.link !== 0)
				//limite = [ 4.0, 1.0 ]
			}

			if( this.motor.engine === 'HAVOK' ){
				revert = true;
				jtype = this.selected.link === 0 ? 'fixe' : 'spherical';
				limite = [ -180, 180, 0.1, 0.1 ];
			}

			//console.log(jtype)

			this.motor.add([
				{ 
					name:'mouse', 
					type:'null', 
					pos:p, 
					quat:quat, 
					kinematic:notUseKinematic ? false : true,
					//mass:10,///10000000,
					//gravityFactor:0, 
				},
				{ 
					name:'mouseJoint', type:'joint',
					mode:jtype,
					lm:limite,
					sd:[4.0, 1.0],
					autoDrive: true,
					b1:revert ? this.selected.name : 'mouse',
					b2:revert ? 'mouse' : this.selected.name,  
					worldAnchor: p, 
					//worldQuat: quat,

					/*pos1: p, 
					quat1: quat,
					pos2: [0,0,0], 
					quat2: [0,0,0,1],*/
					//worldAxis:[1,0,0],
					visible:false,
				}
			]);

		}
		

		//this.raycastTest = false
		//this.controler.enabled = false

		//document.body.style.cursor = 'move'

		return "grabbing"//"url('./assets/icons/point.png') 8 8, move" //'move'

	}

	moveSelect ( point ) {

		if( this.selected === null ) return

		//this.setTmpOver( this.selected )

		if( point ){ 
			this.tmpPos.copy( point ).sub( this.decal ); 
		}

		if( this.moveDeep ){ // Z deep move

			let y = this.selected.position.y;
			let diff  = y-this.tmpPos.y;
			this.tmpPos.y = y;
			this.tmpD.set(0,0,diff).applyAxisAngle({x:0, y:1, z:0}, this.angle);
			this.tmpPos.add( this.tmpD );

		}

		this.helper.position.copy( this.tmpPos );

		let pos = this.tmpPos.toArray();

		if( this.moveDirect ){ 
			this.motor.change({ name:this.selected.name, pos:pos, reset:true });
		} else {
			this.motor.change({ name:'mouse', pos:point.toArray(), lockPos:true }, true );
		}
	}

	unSelect () {

		if( this.selected === null ) return

		this.resetOver();
		this.clearDrag();

		if( this.moveDirect ){
			this.motor.change({ name:this.selected.name, kinematic:false, wake:true, gravity:true, damping:[0,0.1] });
		} else {
			this.motor.remove(['mouseJoint','mouse']);
			this.motor.change({ name:this.selected.name, neverSleep:false, wake:true });
		}
		
		this.raycastTest = true;
		this.selected = null;
		this.firstSelect = true;
		
		//this.controler.enabled = true

	}

	step(){

		if( this.needRay ) this.castray();
	    this.needRay = false;

		if( this.selected === null ) return

		let key = this.motor.flow.key;

		if( key[1] !== 0 ){
			let pz = key[1] * 0.1;
			this.dragPlane.translateZ(pz);
			this.needRay = true;
		}

		//this.castray()
		if( this.moveDirect ) this.moveSelect();

		

	}


}






class MoveHelper extends Line$1 {

	constructor( motor ) {

		super( new BufferGeometry(), motor.mat.get('line') );

		let c = 0.75;

		const positions = [0,0,0, 0,-100,0];
	    const colors = [c,c,c, 0,0,0];

	    //this.geometry = new BufferGeometry();
	    this.geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	    this.geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	    //this.geometry.computeBoundingSphere();

	    this.vertices = this.geometry.attributes.position;
	    this.colors = this.geometry.attributes.color;
	    this.local = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];

	    //this.matrixAutoUpdate = false;
	    this.frustumCulled = false;

	}
}

/**
 * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.
 *
 * Usage:
 *
 * Use the function prepareBreakableObject to prepare a Mesh object to be broken.
 *
 * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)
 *
 * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.
 *
 * Requisites for the object:
 *
 *  - Mesh object must have a buffer geometry and a material
 *
 *  - Vertex normals must be planar (not smoothed)
 *
 *  - The geometry must be convex (this is not checked in the library). You can create convex
 *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives
 *  can also be used.
 *
 * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)
 * Use with caution and read the code when using with other libs.
 *
 * @param {double} minSizeForBreak Min size a debris can have to break.
 * @param {double} smallDelta Max distance to consider that a point belongs to a plane.
 *
*/

const _v1 = new Vector3();

class ConvexObjectBreaker {

	constructor( minSizeForBreak = 1.4, smallDelta = 0.0001 ) {

		this.minSizeForBreak = minSizeForBreak;
		this.smallDelta = smallDelta;

		this.tempLine1 = new Line3();
		this.tempPlane1 = new Plane();
		this.tempPlane2 = new Plane();
		this.tempPlane_Cut = new Plane();
		this.tempCM1 = new Vector3();
		this.tempCM2 = new Vector3();
		this.tempVector3 = new Vector3();
		this.tempVector3_2 = new Vector3();
		this.tempVector3_3 = new Vector3();
		this.tempVector3_P0 = new Vector3();
		this.tempVector3_P1 = new Vector3();
		this.tempVector3_P2 = new Vector3();
		this.tempVector3_N0 = new Vector3();
		this.tempVector3_N1 = new Vector3();
		this.tempVector3_AB = new Vector3();
		this.tempVector3_CB = new Vector3();
		this.tempResultObjects = { object1: null, object2: null };

		this.box1 = new Box3();
		this.box2 = new Box3();

		this.sph1 = new Sphere();
		this.sph2 = new Sphere();

		this.tt = new Vector3();
		this.s1 = new Vector3();
		this.s2 = new Vector3();


		this.segments = [];
		const n = 30 * 30;
		for ( let i = 0; i < n; i ++ ) this.segments[ i ] = false;

	}

	prepareBreakableObject( object, mass, velocity, angularVelocity, breakable ) {

		// object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.
		// Its material property is propagated to its children (sub-pieces)
		// mass must be > 0

		const userData = object.userData;
		userData.mass = mass;
		userData.velocity = velocity.clone();
		userData.angularVelocity = angularVelocity.clone();
		userData.breakable = breakable;

	}

	/*
	 * @param {int} maxRadialIterations Iterations for radial cuts.
	 * @param {int} maxRandomIterations Max random iterations for not-radial cuts
	 *
	 * Returns the array of pieces
	 */
	subdivideByImpact( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {

		const debris = [];

		const tempPlane1 = this.tempPlane1;
		const tempPlane2 = this.tempPlane2;

		this.tempVector3.addVectors( pointOfImpact, normal );
		tempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );

		const maxTotalIterations = maxRandomIterations + maxRadialIterations;

		const scope = this;

		function subdivideRadial( subObject, startAngle, endAngle, numIterations ) {

			if ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {

				debris.push( subObject );

				return;

			}

			let angle = Math.PI;

			if ( numIterations === 0 ) {

				tempPlane2.normal.copy( tempPlane1.normal );
				tempPlane2.constant = tempPlane1.constant;

			} else {

				if ( numIterations <= maxRadialIterations ) {

					angle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;

					// Rotate tempPlane2 at impact point around normal axis and the angle
					scope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );
					tempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );

				} else {

					angle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;

					// Rotate tempPlane2 at object position around normal axis and the angle
					scope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );
					scope.tempVector3_3.copy( normal ).add( subObject.position );
					tempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );

				}

			}

			// Perform the cut
			scope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );

			const obj1 = scope.tempResultObjects.object1;
			const obj2 = scope.tempResultObjects.object2;

			if ( obj1 ) {

				subdivideRadial( obj1, startAngle, angle, numIterations + 1 );

			}

			if ( obj2 ) {

				subdivideRadial( obj2, angle, endAngle, numIterations + 1 );

			}

		}

		subdivideRadial( object, 0, 2 * Math.PI, 0 );

		return debris;

	}

	cutByPlane( object, plane, output ) {

		let k;

		// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.
		// object2 can be null if the plane doesn't cut the object.
		// object1 can be null only in case of internal error
		// Returned value is number of pieces, 0 for error.

		const geometry = object.geometry;
		const coords = geometry.attributes.position.array;
		const normals = geometry.attributes.normal.array;

		const numPoints = coords.length / 3;
		let numFaces = numPoints / 3;

		let indices = geometry.getIndex();

		if ( indices ) {

			indices = indices.array;
			numFaces = indices.length / 3;

		}

		function getVertexIndex( faceIdx, vert ) {

			// vert = 0, 1 or 2.

			const idx = faceIdx * 3 + vert;

			return indices ? indices[ idx ] : idx;

		}

		const points1 = [];
		const points2 = [];

		const delta = this.smallDelta;

		// Reset segments mark
		const numPointPairs = numPoints * numPoints;
		for ( let i = 0; i < numPointPairs; i ++ ) this.segments[ i ] = false;

		const p0 = this.tempVector3_P0;
		const p1 = this.tempVector3_P1;
		const n0 = this.tempVector3_N0;
		const n1 = this.tempVector3_N1;

		// Iterate through the faces to mark edges shared by coplanar faces
		for ( let i = 0; i < numFaces - 1; i ++ ) {

			const a1 = getVertexIndex( i, 0 );
			const b1 = getVertexIndex( i, 1 );
			const c1 = getVertexIndex( i, 2 );

			// Assuming all 3 vertices have the same normal
			n0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );

			for ( let j = i + 1; j < numFaces; j ++ ) {

				const a2 = getVertexIndex( j, 0 );
				const b2 = getVertexIndex( j, 1 );
				const c2 = getVertexIndex( j, 2 );

				// Assuming all 3 vertices have the same normal
				n1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );

				const coplanar = 1 - n0.dot( n1 ) < delta;

				if ( coplanar ) {

					if ( a1 === a2 || a1 === b2 || a1 === c2 ) {

						if ( b1 === a2 || b1 === b2 || b1 === c2 ) {

							this.segments[ a1 * numPoints + b1 ] = true;
							this.segments[ b1 * numPoints + a1 ] = true;

						}	else {

							this.segments[ c1 * numPoints + a1 ] = true;
							this.segments[ a1 * numPoints + c1 ] = true;

						}

					}	else if ( b1 === a2 || b1 === b2 || b1 === c2 ) {

						this.segments[ c1 * numPoints + b1 ] = true;
						this.segments[ b1 * numPoints + c1 ] = true;

					}

				}

			}

		}

		// Transform the plane to object local space
		const localPlane = this.tempPlane_Cut;
		object.updateMatrix();
		ConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );

		// Iterate through the faces adding points to both pieces
		for ( let i = 0; i < numFaces; i ++ ) {

			const va = getVertexIndex( i, 0 );
			const vb = getVertexIndex( i, 1 );
			const vc = getVertexIndex( i, 2 );

			for ( let segment = 0; segment < 3; segment ++ ) {

				const i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );
				const i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );

				const segmentState = this.segments[ i0 * numPoints + i1 ];

				if ( segmentState ) continue; // The segment already has been processed in another face

				// Mark segment as processed (also inverted segment)
				this.segments[ i0 * numPoints + i1 ] = true;
				this.segments[ i1 * numPoints + i0 ] = true;

				p0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );
				p1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );

				// mark: 1 for negative side, 2 for positive side, 3 for coplanar point
				let mark0 = 0;

				let d = localPlane.distanceToPoint( p0 );

				if ( d > delta ) {

					mark0 = 2;
					points2.push( p0.clone() );

				} else if ( d < - delta ) {

					mark0 = 1;
					points1.push( p0.clone() );

				} else {

					mark0 = 3;
					points1.push( p0.clone() );
					points2.push( p0.clone() );

				}

				// mark: 1 for negative side, 2 for positive side, 3 for coplanar point
				let mark1 = 0;

				d = localPlane.distanceToPoint( p1 );

				if ( d > delta ) {

					mark1 = 2;
					points2.push( p1.clone() );

				} else if ( d < - delta ) {

					mark1 = 1;
					points1.push( p1.clone() );

				}	else {

					mark1 = 3;
					points1.push( p1.clone() );
					points2.push( p1.clone() );

				}

				if ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {

					// Intersection of segment with the plane

					this.tempLine1.start.copy( p0 );
					this.tempLine1.end.copy( p1 );

					let intersection = new Vector3();
					intersection = localPlane.intersectLine( this.tempLine1, intersection );

					if ( intersection === null ) {

						// Shouldn't happen
						console.error( 'Internal error: segment does not intersect plane.' );
						output.segmentedObject1 = null;
						output.segmentedObject2 = null;
						return 0;

					}

					points1.push( intersection );
					points2.push( intersection.clone() );

				}

			}

		}

		// Calculate debris mass (very fast and imprecise):
		object.userData.mass * 0.5;

		let box1 = this.box1;
		let box2 = this.box2;
		let numPoints1 = points1.length;
		let numPoints2 = points2.length;

		// reset box3
		box1.makeEmpty();
		box2.makeEmpty();
		
		// expand box3
		k = numPoints1;
		while(k--) box1.expandByPoint(points1[ k ]);

		k = numPoints2;
		while(k--) box2.expandByPoint(points2[ k ]);
	
		box1.getBoundingSphere(this.sph1);
		box2.getBoundingSphere(this.sph2);

		// Calculate debris Center of Mass Fastest
		this.tempCM1.copy(this.sph1.center);
		this.tempCM2.copy(this.sph2.center);
		k = numPoints1;
		while ( k-- ) points1[ k ].sub( this.tempCM1 );
		k = numPoints2;
		while ( k-- ) points2[ k ].sub( this.tempCM2 );

		this.tempCM1.add(object.position);
		this.tempCM2.add(object.position);

		box1.getSize(this.s1);
		box2.getSize(this.s2);

		// avoid too low radius
		if(2 * this.sph1.radius < this.minSizeForBreak) numPoints1 = 0;
		if(2 * this.sph2.radius < this.minSizeForBreak) numPoints2 = 0;

		// avoid too low size
		if(this.testSize(this.s1)) numPoints1 = 0;
		if(this.testSize(this.s2)) numPoints2 = 0;

		//this.tempCM1.add( object.position );
		//this.tempCM2.add( object.position )

		//let sizer1 = this.tt.copy(box1.max).add(box1.min).manhattanLength()
		//let sizer2 = this.tt.copy(box2.max).add(box2.min).manhattanLength()

		//if(sizer1<s) numPoints1 = 0
		//if(sizer2<s) numPoints2 = 0
	    //box1 = {x:Math.abs(box1.x), y:Math.abs(box1.y), z:Math.abs(box1.z)}
	    //box2 = {x:Math.abs(box2.x), y:Math.abs(box2.y), z:Math.abs(box2.z)}

	    //console.log(radius1, radius2)
	    //console.log(box1.manhattanLength(), box2.manhattanLength())

	    //console.log(box1, box2)



	    //console.log(sizer1, sizer2)


		//if( box1.x<s || box1.y<s || box1.z<s ) numPoints1 = 0
		//if( box2.x<s || box2.y<s || box2.z<s ) numPoints2 = 0

			//if( box1.x+box1.y+box1.z<s ) numPoints1 = 0
			//if( box2.x+box2.y+box2.z<s ) numPoints1 = 0
		//if( box1.manhattanLength()<s ) numPoints1 = 0
		//if( box2.manhattanLength()<s ) numPoints2 = 0

		//if( box1.length()<s ) numPoints1 = 0
		//if( box2.length()<s ) numPoints2 = 0


	

		let object1 = null;
		let object2 = null;

		let numObjects = 0;

		if ( numPoints1 > 4 ) {

			object1 = new Mesh( new ConvexGeometry( points1 ), object.material );
			object1.position.copy( this.tempCM1 );
			object1.quaternion.copy( object.quaternion );

			//this.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );

			numObjects ++;

		}

		if ( numPoints2 > 4 ) {


			object2 = new Mesh( new ConvexGeometry( points2 ), object.material );
			object2.position.copy( this.tempCM2 );
			object2.quaternion.copy( object.quaternion );

			//this.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );

			numObjects ++;

		}

		output.object1 = object1;
		output.object2 = object2;

		return numObjects;

	}

	testSize( s ) {
		let n = 0;
		if(s.x < 0.01 ) n++; 
		if(s.y < 0.01 ) n++; 
		if(s.z < 0.01 ) n++;
		return n>1 
	}

	static transformFreeVector( v, m ) {

		// input:
		// vector interpreted as a free vector
		// THREE.Matrix4 orthogonal matrix (matrix without scale)

		const x = v.x, y = v.y, z = v.z;
		const e = m.elements;

		v.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		v.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		v.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return v;

	}

	static transformFreeVectorInverse( v, m ) {

		// input:
		// vector interpreted as a free vector
		// THREE.Matrix4 orthogonal matrix (matrix without scale)

		const x = v.x, y = v.y, z = v.z;
		const e = m.elements;

		v.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;
		v.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;
		v.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;

		return v;

	}

	static transformTiedVectorInverse( v, m ) {

		// input:
		// vector interpreted as a tied (ordinary) vector
		// THREE.Matrix4 orthogonal matrix (matrix without scale)

		const x = v.x, y = v.y, z = v.z;
		const e = m.elements;

		v.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];
		v.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];
		v.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];

		return v;

	}

	static transformPlaneToLocalSpace( plane, m, resultPlane ) {

		resultPlane.normal.copy( plane.normal );
		resultPlane.constant = plane.constant;

		const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( _v1 ), m );

		ConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );

		// recalculate constant (like in setFromNormalAndCoplanarPoint)
		resultPlane.constant = - referencePoint.dot( resultPlane.normal );

	}

}

({textureScale:new Vector2(1,1),textureOffset:new Vector2});new Vector3;new Vector3;new Vector3;new Plane;new Plane;

class Breaker {

	constructor (motor) {

		this.motor = motor;

		this.convexBreaker = new ConvexObjectBreaker();
		this.tmpI = new THREE.Vector3();

		this.tpos = new THREE.Vector3();
		this.tnormal = new THREE.Vector3();

		this.nDebris = 0;
		this.maxDebris = 300;

		this.tt = null;

	}

	step () {

		let p;

		for( let n in this.motor.reflow.point ){

			p = this.motor.reflow.point[n];

			//if ( !b1.breakable && !b2.breakable ) continue;

			

			if ( p.distance !== 0 ) {

				this.makeBreak( p.b1, p.pos, p.normal, p.impulse, p.v1 );
				this.makeBreak( p.b2, p.pos, p.normal, p.impulse, p.v2 );
				
			} 
		}
	}

	makeBreak ( name, pos, normal, impulse, v ) {

		let mesh = this.motor.utils.byName( name );

		if ( !mesh ) return;
		if ( !mesh.breakable ) return;



		let breakOption = mesh.breakOption;
		//let imp = this.tmpI.fromArray( impulse ).length();

		//console.log( name, impulse )

		// not enoputh impulse to break
		if ( impulse < breakOption[ 0 ] ) return;


		//let parentMatrix = mesh.matrix.clone().invert()

		let debris = this.convexBreaker.subdivideByImpact( mesh, this.tpos.fromArray(pos), this.tnormal.fromArray(normal), breakOption[ 1 ], breakOption[ 2 ] );

		//console.log( debris.length )

		if(debris.length<1) return

		// remove one level
		breakOption[ 3 ] -= 1;
		
		const eritage = {
			material: mesh.material,
			linearVelocity: [v[0], v[1], v[2]],
			angularVelocity: [v[3], v[4], v[5]],
			density: mesh.density,
		};

		// add debris
		let list = [];
		let i = debris.length, n = 0;
		while ( i -- ){ 
			list.push( this.addDebris( debris[ n ], breakOption, eritage ) );
			n++;
		}

        // remove original object and add debrit
        //this.motor.remove( name, true )
        this.tt = setTimeout( ()=>{
        	this.motor.remove( name );
		    this.motor.add( list );
        }, 0 );
		

	}

	addDebris ( mesh, breakOption, eritage ) {

		let breakable = breakOption[ 3 ] > 0 ? true : false;

		let name = 'debris_' + (this.nDebris++);

		let deb = {

			...eritage,

			name: name,
			type: 'convex',
			shape: mesh.geometry,
			//size:[1,1,1],
			pos: mesh.position.toArray(),
			quat: mesh.quaternion.toArray(),
			breakable: breakable,
			breakOption:breakOption,

		};

		//this.nDebris++
		if( this.nDebris>this.maxDebris ) this.nDebris = 0;


		return deb

	}

}

//const SPHSystem_getNeighbors_dist = new Vector3()

// Temp vectors for calculation
new Vector3(); // Relative velocity

const SPHSystem_update_a_pressure = new Vector3();
const SPHSystem_update_a_visc = new Vector3();
const SPHSystem_update_gradW = new Vector3();
const SPHSystem_update_r_vec = new Vector3();
const SPHSystem_update_u = new Vector3();


class Particle {

	constructor ( o = {}, motor ) {

		this.motor = motor;

		this.name = o.name  || 'ppp';

		this.particles = [];
	    this.density = 0.01;
	    this.smoothingRadius = 0.2;
	    this.speedOfSound = 0.1;
	    this.viscosity = 0.03;
	    this.eps = 0.000001;

	    this.group = 1 << 8;

	    // Stuff Computed per particle
	    this.pressures = [];
	    this.densities = [];
	    this.neighbors = [];

	    this.tv = new Vector3();
	    this.tv2 = new Vector3();

	}

	add( pos ){

		let p = this.motor.add({ 

            instance:this.name,
            type:'particle', 
            //type:'sphere',
            flags:'noQuery',
            size:[0.1],
            pSize:0.03,
            pos:pos, 

            inertia:[0,0,0], 
            //iterations:[10,1],
            
            mass:0.001, 
            //density:0.0001,
            restitution:0.0, 
            friction:0.5, 
            //maxVelocity:[2,100],
            damping:[0.1,0.1],

            //group:this.group, 
            //mask:1|2,
            material:'hide',

        });

        p.force = new Vector3();

        this.particles.push( p );
        if (this.neighbors.length < this.particles.length) {
	        this.neighbors.push([]);
	    }

	}

	connect( link ){

		let i = link.length;
		console.log(i);
		let tmp = [], l, p1, p2, d = 0;

		while(i--){

			l = link[i];
			this.name+l[0];
			this.name+l[1];

			p1 = this.particles[l[0]].position;
			p2 = this.particles[l[1]].position;

			//p1.y = 0
			//p2.y = 0

			//console.log(p1,p2)

			d = this.tv.copy( p1 ).distanceTo(p2);

			

			//this.tv.copy( p2 ).sub( p1 ).multiplyScalar(0.5)
			this.tv.copy( p2 ).sub( p1 );//.multiplyScalar(0.5)

			

			tmp.push({ 
				type:'distance', 
			    helperSize:0.03, 
			    b1:this.name+l[0], 
			    b2:this.name+l[1], 
			    //limit:[d - 0.01, d + 0.01], 
			    limit:[d*0.5, d],
			    spring:[20, 1.0],
			    //spring:[0.0, 0.0],
			    friction:0,
			    /*visible:true, helperSize:0.02*/ 
		    });
		    /*tmp.push({ 
		    	helperSize:0.01,
			    type:'spherical', 
			    b1:b1, b2:b2, 
			    worldAxis: n===0 ? [1,0,0] : [0,0,1],
			    //pos1: this.tv2.set(0,0,0).add(this.tv).toArray(),
			    pos2: this.tv2.set(0,0,0).sub(this.tv).toArray(),
		        limit:[-180, 180, 0.01, 10 ], //spring:[100, 0.01], 
		    })
		    n++
		    if(n===2)n=0*/
		}

		this.motor.add(tmp);

	}

	getPosition(){

		let ar = [];
		let i = this.particles.length, p, n;
		while(i--){

			n = i*3;
	    	p = this.particles[i];
	    	ar[n] = p.position.x;
	    	ar[n+1] = p.position.y;
	    	ar[n+2] = p.position.z;
	    }

	    return ar

	}

	
    // Get neighbors within smoothing volume, save in the array neighbors
    getNeighbors( particle, neighbors ) {

	    const N = this.particles.length;
	    const id = particle.id;
	    const R2 = this.smoothingRadius * this.smoothingRadius;
	    let distance = 0;//SPHSystem_getNeighbors_dist
	    for (let i = 0; i !== N; i++) {
	        const p = this.particles[i];
	        //const dx = p.position.x - particle.position.x, dy = p.position.y - particle.position.y, dz = p.position.z - particle.position.z;
	        distance = this.distance(p, particle );//dx * dx + dy * dy + dz * dz
	        if (id !== p.id && distance < R2) {
	            neighbors.push(p);
	        }
	    }	
    }

    distance(p, v) {
	    const dx = p.position.x - v.position.x, dy = p.position.y - v.position.y, dz = p.position.z - v.position.z;
	    return dx * dx + dy * dy + dz * dz
	}

    // Calculate the weight using the W(r) weightfunction
	w(r) {
	    // 315
	    const h = this.smoothingRadius;
	    return (315.0 / (64.0 * Math.PI * h ** 9)) * (h * h - r * r) ** 3
	}

	// calculate gradient of the weight function
	gradw(rVec, resultVec) {

	    const r = rVec.length();
	    const h = this.smoothingRadius;
	    resultVec.copy(rVec).multiplyScalar( (945.0 / (32.0 * Math.PI * h ** 9)) * (h * h - r * r) ** 2 );
	    //rVec.scale((945.0 / (32.0 * Math.PI * h ** 9)) * (h * h - r * r) ** 2, resultVec)
	}

	// Calculate nabla(W)
	nablaw(r) {
	    const h = this.smoothingRadius;
	    const nabla = (945.0 / (32.0 * Math.PI * h ** 9)) * (h * h - r * r) * (7 * r * r - 3 * h * h);
	    return nabla
	}

	update() {

		const TMP = [];

		const N = this.particles.length;
	    const cs = this.speedOfSound;
	    const eps = this.eps;

	    let i = N, j;

	   //for (let i = 0; i !== N; i++) {
	    while(i--){

	    	const p = this.particles[i]; // Current particle
	    	p.force.set(0,0,0);
            const neighbors = this.neighbors[i];

            // Get neighbors
		    neighbors.length = 0;
		    this.getNeighbors(p, neighbors);
		    neighbors.push(this.particles[i]); // Add current too
		    const numNeighbors = neighbors.length;

		    // Accumulate density for the particle
		    let sum = 0.0;
		    j = numNeighbors;
		    while(j--){
		    //for (let j = 0; j !== numNeighbors; j++) {
		        //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
		        const weight = this.w( this.distance( p, neighbors[j] ) );
		        sum += neighbors[j].mass * weight;
		    }

		    // Save
		    this.densities[i] = sum;
		    this.pressures[i] = cs * cs * (this.densities[i] - this.density);

	    }

	    // Add forces

	    // Sum to these accelerations
	    const a_pressure = SPHSystem_update_a_pressure;
	    const a_visc = SPHSystem_update_a_visc;
	    const gradW = SPHSystem_update_gradW;
	    const r_vec = SPHSystem_update_r_vec;
	    const u = SPHSystem_update_u;

	    i = N;

	   //for (let i = 0; i !== N; i++) {
	    while(i--){

	    	const particle = this.particles[i];

		    a_pressure.set(0, 0, 0);
		    a_visc.set(0, 0, 0);

		    // Init vars
		    let Pij;
		    let nabla;

		    // Sum up for all other neighbors
		    const neighbors = this.neighbors[i];
		    const numNeighbors = neighbors.length;

		    j = numNeighbors;
		    while(j--){
		    //for (let j = 0; j !== numNeighbors; j++) {
		    	const neighbor = neighbors[j];

		    	// Get r once for all..
		    	r_vec.copy(particle.position).sub(neighbor.position);
		        //particle.position.vsub(neighbor.position, r_vec)
		        const r = r_vec.length();

		        // Pressure contribution
		        Pij =
		          -neighbor.mass *
		          (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) +
		            this.pressures[j] / (this.densities[j] * this.densities[j] + eps));

		        this.gradw(r_vec, gradW);
		        // Add to pressure acceleration
		        gradW.multiplyScalar(Pij); //scale(Pij, gradW)
		        a_pressure.add(gradW);//.vadd(gradW, a_pressure)


		        // Viscosity contribution
		        u.copy(neighbor.velocity).sub(particle.velocity);

		        /*TMP.push({
			    	name:neighbor.name,
			    	velocity : u.toArray()
			    })*/
		        //neighbor.velocity.vsub(particle.velocity, u)
		        u.multiplyScalar((1.0 / (0.0001 + this.densities[i] * this.densities[j])) * this.viscosity * neighbor.mass);
		        nabla = this.nablaw(r);
		        u.multiplyScalar(nabla);
		        // Add to viscosity acceleration
		        a_visc.add(u);


		    }

		    // Calculate force
		    a_visc.multiplyScalar(particle.mass);
		    a_pressure.multiplyScalar(particle.mass);

		    // Add force to particles

		    particle.force.add(a_visc);
            particle.force.add(a_pressure);

		    TMP.push({
		    	name: particle.name,
		    	force: particle.force.toArray()
		    });
            
	    }

	    this.motor.change(TMP);



	}

}

// Universal ray vehicule 

// ...ref
//https://forum.babylonjs.com/t/havok-raycastvehicle/40314 
//https://sketches.isaacmason.com/sketch/p2-es/marching-cubes-goo
//https://github.com/isaac-mason/sketches/tree/main
//https://playground.babylonjs.com/#8WQIA8
//https://github.com/Jaagrav/raycast-vehicle-engine
//https://asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games.html

const torad$1 = Math.PI / 180;
const directions = [
    new Vector3(1, 0, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 0, 1)
];

const calcRollingFriction_vel1 = new Vector3();
const calcRollingFriction_vel2 = new Vector3();
const calcRollingFriction_vel = new Vector3();

const updateFriction_surfNormalWS_scaled_proj = new Vector3();

const sideFrictionStiffness2 = 1;
const updateFriction_forwardWS = [];
const updateFriction_axle = [];

const tmpVec4 = new Vector3();
const tmpVec5 = new Vector3();
const tmpVec6 = new Vector3();

new Matrix4();

class RayCar {
	
	constructor( o = {}, motor ){

        this.motor = motor;

        this.extra = {};

		this.tmp = {
			forwardForce : 0,
			steerValue : 0,
			steerDirection : 0,
			brakeForce : 0,
		};

        this.localWheel = true;

		this.maxSpeed = 70;
		this.maxForce = 1500;
		this.maxBrakeForce = 45;
		this.maxSteer = 0.4;//0.6 
		this.steeringIncrement = 0.15;
		this.steerRecover = 0.15;

		this.name = o.name || 'car';
		this.mass = o.mass || 1000;//200;
		this.size = o.size || [1.5, 0.7, 3.8];
		this.pos = o.pos || [0,4,0];
		this.rot = o.rot || [0,0,0];
		this.friction = o.friction || 0.2;
		this.restitution = o.restitution || 0.3;
		this.massCenter = o.massCenter || [0,0,0];//[0,-0.2,0];

        this.driveWheel = o.driveWheel || null;


		/*this.body = root.motor.add({ 

			type:'box',
			name:this.name,  
	        size:this.size, 
	        pos:this.pos, 
	        rot:this.rot,
	        friction:this.friction, 
	        restitution:this.restitution,
	        neverSleep:true,
	        mass:this.mass,
	        massCenter:this.massCenter,
	        radius: 0.02,

	    });*/

        let shape = [ { type:'box', pos:this.massCenter, size:this.size, radius: 0.02 } ];
        if(o.shapeMesh){
            shape = [ { type:'convex', shape:o.shapeMesh.geometry,  pos:o.shapePos || [0,0,0] } ];
        }

        this.body = this.motor.add({ 

            type:'compound',
            shapes:shape,
            name:this.name,
            pos:this.pos,
            rot:this.rot,
            friction:this.friction,
            restitution:this.restitution,
            mass:this.mass,
            //neverSleep:true,
            //massInfo:true,

            //shadow:false,

            mesh:o.bodyMesh || null,
            //noClone: true,
            meshPos:o.meshPos || [0,-1.1,0],
            material:o.material,
            damping:[0.05,0.05],
            debug:false,

        });

	    //this.body.inertia.set( 1.416666865348816, 1.666666865348816, 0.416666716337204 );
        this.body.inertia.set( 283.33331298828125, 333.33331298828125, 83.33332824707031 );

	    this.vehicle = new RaycastVehicle({ chassis: this.body }, this.motor);

	    /*const wheelPositions = [
	        new Vector3(-0.95,0,-1.8),
	        new Vector3(0.95,0,-1.8),
	        new Vector3(-0.95,0,1.8),
	        new Vector3(0.95,0,1.8)
	    ]*/

        //let wy = 0

        let wp = o.wheelPosition || [0.61, 0, 1.2];

        const wheelPositions = [
            new Vector3(-wp[0], wp[1], -wp[2]),
            new Vector3(wp[0], wp[1], -wp[2]),
            new Vector3(-wp[0], wp[1], wp[2]),
            new Vector3(wp[0], wp[1], wp[2])
        ];

	    const options = {
	        radius: o.wheelRadius || 0.31,//0.32,//0.5,
	        directionLocal: new Vector3(0, -1, 0),
	        suspensionStiffness: 100,//30
	        suspensionRestLength: 0.5,//0.8
            suspensionMaxLength: 1,//2,//2
            maxSuspensionTravel: 0.3,//0.8//0.3,
	        frictionSlip: 4,
	        dampingRelaxation: 2.3,
	        dampingCompression: 4.4,
	        maxSuspensionForce: 100000,
	        rollInfluence: 0.001,//0.001,
	        axleLocal: new Vector3(1, 0, 0),
	        chassisConnectionPointLocal: new Vector3(1, 1, 0),
	        
	    };

        this.addParametre('frictionSlip', 4);
        
        this.addParametre('maxSuspensionTravel', 0.3);
        this.addParametre('suspensionRestLength', 0.5);
        this.addParametre('suspensionMaxLength', 1.0);

        //this._frictionSlip = 4

	    wheelPositions.forEach( positionLocal => {
	        options.chassisConnectionPointLocal.copy( positionLocal );
	        this.vehicle.addWheel( options );
	    });

        let wgeo;
        let m1, m2;

        let mat = this.motor.getMat('debug');

        if( o.wheelMesh ){

            /*wgeo = o.wheelMesh.geometry
            if(o.wheelMesh2) wgeo2 = o.wheelMesh2.geometry
            mat = o.material || mat;*/

            m1 = o.wheelMesh;
            m2 = o.wheelMesh2 ? o.wheelMesh2 : null;

            if(o.material){
                mat = o.material || mat;
                m1.material = mat;
                if(m2) m2.material = mat;
            }

        } else {

            wgeo = new CylinderGeometry( options.radius, options.radius, o.wheelDepth || 0.2 );
            wgeo.rotateZ( Math.PI * 0.5 );

            m1 = new Mesh( wgeo, mat );
            m2 = null;

        }

	    
	    

        this.vehicle.localWheel = this.localWheel;

        if(this.localWheel){
            this.vehicle.wheelMeshes = [ m2? m2 : m1.clone(), m1, m2? m2.clone() : m1.clone(), m1.clone() ];
            let k = this.vehicle.wheelMeshes.length, n=0;
            while(k--) this.body.add(this.vehicle.wheelMeshes[n++]);
        }else {
            m.matrixAutoUpdate = false;
            if(m2) m2.matrixAutoUpdate = false;
            this.vehicle.wheelMeshes = [
                this.motor.add(m2? m2 : m.clone()),
                this.motor.add(m),
                this.motor.add(m2? m2.clone() : m.clone()),
                this.motor.add(m.clone())
            ];
        }

	    
	
	}

	step(){

		this.tmp.forwardForce = 0;
	    this.tmp.brakeForce = 0;
	    this.tmp.steerDirection = 0;

	    let delta = this.motor.getDelta();
	    this.motor.getAzimut();
	    let key = this.motor.getKey();

	    this.tmp.forwardForce = key[1];
	    this.tmp.steerDirection = key[0]*-1;
	    this.tmp.brakeForce = key[4]===1 ? this.maxBrakeForce : 0;

	    this.tmp.steerValue += this.tmp.steerDirection * this.steeringIncrement;
	    this.tmp.steerValue = Math.min(Math.max(this.tmp.steerValue, -this.maxSteer), this.maxSteer);
	    this.tmp.steerValue *= 1-(1-Math.abs(this.tmp.steerDirection))*this.steerRecover;

	    let speed = Math.abs(this.vehicle.currentVehicleSpeedKmHour);
	    speed = Math.min(speed, this.maxSpeed);
	    (speed/this.maxSpeed)*100;
	    const acceleration = 1.0;//accelerationCurve.evaluate(prog)
	    const force = acceleration*this.tmp.forwardForce*this.maxForce;
	    const slipForce = 8;//-(slip*4)

	    /*this.vehicle.applyEngineForce(0, 0)
	    this.vehicle.applyEngineForce(0, 1)
	    this.vehicle.applyEngineForce(force, 2)
	    this.vehicle.applyEngineForce(force, 3)*/

        this.vehicle.applyEngineForce(force, 0);
        this.vehicle.applyEngineForce(force, 1);
        this.vehicle.applyEngineForce(force, 2);
        this.vehicle.applyEngineForce(force, 3);

	    this.vehicle.setSteeringValue(this.tmp.steerValue, 2);
	    this.vehicle.setSteeringValue(this.tmp.steerValue, 3);

	    this.vehicle.setBrake(this.tmp.brakeForce, 0);
	    this.vehicle.setBrake(this.tmp.brakeForce, 1);
	    this.vehicle.setBrake(0, 2);
	    this.vehicle.setBrake(0, 3);

	    this.vehicle.wheelInfos[0].frictionSlip = slipForce;
	    this.vehicle.wheelInfos[1].frictionSlip = slipForce;
	    this.vehicle.wheelInfos[2].frictionSlip = slipForce;
	    this.vehicle.wheelInfos[3].frictionSlip = slipForce;

	    this.vehicle.updateVehicle(delta);

        if( this.driveWheel ){ 
            this.driveWheel.rotation.y = this.tmp.steerValue * 180 * torad$1;
        }

	}

    /*get frictionSlip (){
        return this._frictionSlip
    }

    set frictionSlip (v){
        this._frictionSlip = v
        this.vehicle.setWheels({frictionSlip:this._frictionSlip})
    }*/

    addParametre( name, value ){

        this.extra[ name ] = value;

        Object.defineProperty( this, name, {
            get: () => ( this.extra[ name ] ),
            set: ( v ) => {
                this.extra[ name ] = v;
                if( this.vehicle ) this.vehicle.setWheels( name, this.extra[ name ] );
            }
        });
    }

}





class RaycastVehicle {

    constructor( o, motor ){

        this.motor = motor;

        this.chassisBody = o.chassis;
        this.wheelInfos = [];
        this.sliding = false;
        this.world = null;
        this.indexRightAxis = typeof(o.indexRightAxis) !== 'undefined' ? o.indexRightAxis : 0;
        this.indexForwardAxis = typeof(o.indexForwardAxis) !== 'undefined' ? o.indexForwardAxis : 2;
        this.indexUpAxis = typeof(o.indexUpAxis) !== 'undefined' ? o.indexUpAxis : 1;
        //this.rays = []
        this.wheelMeshes = [];
        this.brakeMeshs = null;
        this.localWheel = false;
        //this.wheelMatrix = [];
    }

    addWheel ( o = {} ){
    
        let info = new WheelInfo(o, this.motor );
        let index = this.wheelInfos.length-1;

        info.chassisBody = this.chassisBody;

        let raylen = info.suspensionRestLength + info.radius;
        
        info.ray = this.motor.add({
            type:'ray', 
            name:this.chassisBody.name + '_wheel_' + index, 
            begin:info.chassisConnectionPointLocal.toArray(), 
            end:[info.chassisConnectionPointLocal.x,-raylen, info.chassisConnectionPointLocal.z], 
            callback:function(r){ info.castRay(r); }, 
            visible:false, 
            parent:this.chassisBody 
        });

        this.wheelInfos.push(info);
        //this.wheelMatrix.push( new Matrix4() );

        return index;

    }

    setWheels (name, value) {

        let i = this.wheelInfos.length, w;
        while(i--){
            w = this.wheelInfos[i];
            if(w[name]) w[name] = value;
        }

    }

    setSteeringValue( value, wheelIndex ){

        let wheel = this.wheelInfos[wheelIndex];
        wheel.steering = value;

    }

    applyEngineForce(value, wheelIndex){
        this.wheelInfos[wheelIndex].engineForce = value;
    }

    setBrake(brake, wheelIndex){
        this.wheelInfos[wheelIndex].brake = brake;
    }

    getVehicleAxisWorld(axisIndex, result){
        result.set(
            axisIndex === 0 ? 1 : 0,
            axisIndex === 1 ? 1 : 0,
            axisIndex === 2 ? 1 : 0
        );
        TransformCoordinatesToRef(result, bodyTransform(this.chassisBody, new Matrix4()), result);
        return result;
    }

    updateVehicle( timeStep ) {

        let wheelInfos = this.wheelInfos;
        let numWheels = wheelInfos.length;
        let chassisBody = this.chassisBody;

        let i = numWheels; 

        while ( i-- ) {
            this.updateWheelTransform(i);
        }

        

        const cVel = bodyLinearVelocity(chassisBody, new Vector3());
        const cVelLocal = TransformNormalToRef(cVel, bodyTransform(chassisBody, new Matrix4()).invert(),new Vector3());
        this.currentVehicleSpeedKmHour = cVelLocal.z;

        let forwardWorld = new Vector3();
        this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

        //if (Dot(forwardWorld,bodyLinearVelocity(chassisBody, new Vector3())) < 0){
        if ( forwardWorld.dot( chassisBody.velocity ) < 0 ){
            this.currentVehicleSpeedKmHour *= -1;
        }

        // simulate suspension
        // auto on ray result
        //for (var i = 0; i < numWheels; i++) {
            //this.castRay(wheelInfos[i]);
        //}

        

        this.updateSuspension(timeStep);


        let impulse = new Vector3();
        new Vector3();
        for ( i = 0; i < numWheels; i++) {
            //apply suspension force
            let wheel = wheelInfos[i];
            let suspensionForce = wheel.suspensionForce;
            if (suspensionForce > wheel.maxSuspensionForce) {
                suspensionForce = wheel.maxSuspensionForce;
            }
            //impulse.copyFrom(wheel.raycastResult.hitNormalWorld).scaleInPlace(suspensionForce * timeStep)
            impulse.copy( wheel.raycastResult.hitNormalWorld ).multiplyScalar(suspensionForce * timeStep);
            //console.log(suspensionForce * timeStep)
            
            addImpulseAt( this.motor, chassisBody, impulse, wheel.raycastResult.hitPointWorld );
            
            //repos.copy( wheel.raycastResult.hitPointWorld ).sub( chassisBody.position );
            //addImpulseAt( chassisBody, impulse, repos );
        }

        this.updateFriction(timeStep);
        
 
        let hitNormalWorldScaledWithProj = new Vector3();
        let fwd  = new Vector3();
        let vel = new Vector3();
        for (i = 0; i < numWheels; i++) {
            let wheel = wheelInfos[i];
            velocityAt(chassisBody, wheel.chassisConnectionPointWorld, vel);
            // Hack to get the rotation in the correct direction
            let m = 1;
            switch(this.indexUpAxis){
            case 1:
                m = -1;
                break;
            }

            if (wheel.isInContact) {

                this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
                let proj = Dot(fwd, wheel.raycastResult.hitNormalWorld);
                //hitNormalWorldScaledWithProj.copyFrom(wheel.raycastResult.hitNormalWorld).scaleInPlace(proj)
                hitNormalWorldScaledWithProj.copy(wheel.raycastResult.hitNormalWorld).multiplyScalar(proj);

                //fwd.subtractToRef(hitNormalWorldScaledWithProj, fwd);
                fwd.sub(hitNormalWorldScaledWithProj);

                let proj2 = Dot(fwd, vel);
                wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
            }

            if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){
                // Apply custom rotation when accelerating and sliding
                wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
            }

            // Lock wheels
            if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){
                wheel.deltaRotation = 0;
            }

            //wheel.rotation += wheel.deltaRotation; // Use the old value
            wheel.rotation -= wheel.deltaRotation; // Use the old value
            wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
        }
    }


    updateSuspension( deltaTime ) {

        let chassisBody = this.chassisBody;
        let chassisMass = bodyMass(chassisBody);
        let wheelInfos = this.wheelInfos;
        let numWheels = wheelInfos.length;

        for (let w_it = 0; w_it < numWheels; w_it++){
            let wheel = wheelInfos[w_it];

            if (wheel.isInContact){
                let force;

                // Spring
                let susp_length = wheel.suspensionRestLength;
                let current_length = wheel.suspensionLength;
                let length_diff = (susp_length - current_length);

                force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;

                // Damper
                let projected_rel_vel = wheel.suspensionRelativeVelocity;
                let susp_damping;
                if (projected_rel_vel < 0) {
                    susp_damping = wheel.dampingCompression;
                } else {
                    susp_damping = wheel.dampingRelaxation;
                }
                force -= susp_damping * projected_rel_vel;

                wheel.suspensionForce = force * chassisMass;
                if (wheel.suspensionForce < 0) {
                    wheel.suspensionForce = 0;
                }
            } else {
                wheel.suspensionForce = 0;
            }
        }

    }

    updateFriction( timeStep ){

        let surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;

        //calculate the impulse, so that the wheels don't move sidewards
        let wheelInfos = this.wheelInfos;
        let numWheels = wheelInfos.length;
        let chassisBody = this.chassisBody;
        let forwardWS = updateFriction_forwardWS;
        let axle = updateFriction_axle;
        let i, wheel, groundObject;

        for ( i = 0; i < numWheels; i++) {

            wheel = wheelInfos[i];
            groundObject = wheel.raycastResult.body;
            
            wheel.sideImpulse = 0;
            wheel.forwardImpulse = 0;

            if(!forwardWS[i]) forwardWS[i] = new Vector3();
            if(!axle[i]) axle[i] = new Vector3();
            
        /*}
        
        for ( i = 0; i < numWheels; i++){

            wheel = wheelInfos[i];
    
            groundObject = wheel.raycastResult.body;*/
    
            if (groundObject) {

                let axlei = axle[i];
                let wheelTrans = this.getWheelTransformWorld(i);
    
                // Get world axle
                TransformNormalToRef( directions[this.indexRightAxis], wheelTrans, axlei );
        
                let surfNormalWS = wheel.raycastResult.hitNormalWorld;
                //if(i=== 0)console.log(axlei)
                let proj = Dot(axlei, surfNormalWS);
                
                //surfNormalWS.scaleToRef(proj, surfNormalWS_scaled_proj);
                //axlei.subtractToRef(surfNormalWS_scaled_proj, axlei);

                surfNormalWS_scaled_proj.copy(surfNormalWS).multiplyScalar(proj);
                axlei.sub(surfNormalWS_scaled_proj).normalize();
               
                CrossToRef(surfNormalWS, axlei, forwardWS[i]);
                forwardWS[i].normalize();
                //if(i=== 0)console.log(forwardWS[i])

                wheel.sideImpulse = resolveSingleBilateral(
                    chassisBody,
                    wheel.raycastResult.hitPointWorld,
                    groundObject,
                    wheel.raycastResult.hitPointWorld,
                    axlei
                );
                //if(i == 0) console.log(wheel.sideImpulse)
                wheel.sideImpulse *= sideFrictionStiffness2;
            }
        }



        let sideFactor = 1;
        let fwdFactor = 0.5;
        this.sliding = false;

        for ( i = 0; i < numWheels; i++) {

            wheel = wheelInfos[i];
            groundObject = wheel.raycastResult.body;

            let rollingFriction = 0;

            wheel.slipInfo = 1;
            if ( groundObject ) {
                let defaultRollingFrictionImpulse = 0;
                let maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;

                // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
                // rollingFriction = calcRollingFriction(contactPt);
                rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);

                rollingFriction += wheel.engineForce * timeStep;
                //rollingFriction *= 10

                // rollingFriction = 0;
                let factor = maxImpulse / rollingFriction;
                wheel.slipInfo *= factor;

                //console.log(rollingFriction)
            }

            //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)

            wheel.forwardImpulse = 0;
            wheel.skidInfo = 1;

            if ( groundObject ) {
                wheel.skidInfo = 1;

                let maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
                let maximpSide = maximp;

                let maximpSquared = maximp * maximpSide;

                wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;

                let x = (wheel.forwardImpulse * fwdFactor) / wheel.forwardAcceleration;
                let y = (wheel.sideImpulse * sideFactor) / wheel.sideAcceleration;

                let impulseSquared = x * x + y * y;

                ///console.log(impulseSquared)

                wheel.sliding = false;
                if ( impulseSquared > maximpSquared ) {
                    this.sliding = true;
                    wheel.sliding = true;

                    let factor = maximp / Math.sqrt( impulseSquared );

                    wheel.skidInfo *= factor;
                }
            }
        }

        if (this.sliding) {
            for (let i = 0; i < numWheels; i++) {
                wheel = wheelInfos[i];
                if (wheel.sideImpulse !== 0) {
                    if (wheel.skidInfo < 1){
                        wheel.forwardImpulse *= wheel.skidInfo;
                        wheel.sideImpulse *= wheel.skidInfo;
                    }
                }
            }
        }

        
        // apply the impulses // TODO !!!
        for ( i = 0; i < numWheels; i++) {

            wheel = wheelInfos[i];
    
            let rel_pos = new Vector3();
            rel_pos.copy( wheel.raycastResult.hitPointWorld ).sub( bodyPosition(chassisBody, new Vector3()) );
            //wheel.raycastResult.hitPointWorld.subtractToRef(bodyPosition(chassisBody, new Vector3()), rel_pos);
           
            if (wheel.forwardImpulse !== 0) {
                let impulse = new Vector3();
                impulse.copy(forwardWS[i]).multiplyScalar(wheel.forwardImpulse);
                //impulse.copyFrom(forwardWS[i]).scaleInPlace(wheel.forwardImpulse)
                addImpulseAt( this.motor, chassisBody, impulse, wheel.raycastResult.hitPointWorld);
            
            }
    
            if ( wheel.sideImpulse !== 0 ){

                groundObject = wheel.raycastResult.body;
    
                let rel_pos2 = new Vector3();
               
                rel_pos2.copy(wheel.raycastResult.hitPointWorld).sub(bodyPosition(groundObject, new Vector3()));
                //wheel.raycastResult.hitPointWorld.subtractToRef(bodyPosition(groundObject, new Vector3()), rel_pos2);
                let sideImp = new Vector3();
                sideImp.copy(axle[i]).multiplyScalar(wheel.sideImpulse);
                //sideImp.copyFrom(axle[i]).scaleInPlace(wheel.sideImpulse)
    
                TransformNormalToRef(rel_pos, bodyTransform(chassisBody, new Matrix4()).invert(), rel_pos);
                rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
                
                TransformNormalToRef(rel_pos, bodyTransform(chassisBody, new Matrix4()), rel_pos);
                addImpulseAt( this.motor, chassisBody, sideImp, bodyPosition(chassisBody, new Vector3()).add(rel_pos));
            
                //sideImp.scaleToRef(-1, sideImp);
                sideImp.multiplyScalar(-1);

                // add impulse on staic object ???
                addImpulseAt( this.motor, groundObject, sideImp, wheel.raycastResult.hitPointWorld );
                
            }
        }

    }


    updateWheelTransformWorld( wheel ){

        //wheel.isInContact = false;
        let chassisBody = this.chassisBody;
        const transform = chassisBody.matrixWorld;//bodyTransform( chassisBody, new Matrix4() )
      
        TransformCoordinatesToRef( wheel.chassisConnectionPointLocal, transform, wheel.chassisConnectionPointWorld );
        TransformNormalToRef( wheel.directionLocal, transform, wheel.directionWorld );
        //TransformNormalToRef( wheel.axleLocal, transform, wheel.axleWorld )
        
    }

    updateWheelTransform( wheelIndex ){

        let up = tmpVec4;
        let right = tmpVec5;
        let fwd = tmpVec6;

        let wheel = this.wheelInfos[wheelIndex];
        this.updateWheelTransformWorld(wheel);

        up.copy( wheel.directionLocal ).multiplyScalar(-1);
        right.copy(wheel.axleLocal);
        CrossToRef( up, right, fwd );
        fwd.normalize();
        right.normalize();

        // Rotate around steering over the wheelAxle
        let steering = wheel.steering;
        let steeringOrn = new Quaternion$1();
        RotationAxisToRef( up, steering, steeringOrn );

        let rotatingOrn = new Quaternion$1();
        RotationAxisToRef(right, wheel.rotation, rotatingOrn);

        // World rotation of the wheel
        let q = wheel.quaternion;
        bodyOrientation( this.chassisBody, q );
        q.multiply(steeringOrn).multiply(rotatingOrn).normalize();

        // world position of the wheel
        let p = wheel.position;
        p.copy( wheel.directionWorld );
        p.multiplyScalar( wheel.suspensionLength );
        let locP = p.clone();
        p.add( wheel.chassisConnectionPointWorld );

        wheel.matrix.compose( wheel.position, wheel.quaternion, {x:1,y:1,z:1} );

        if( this.localWheel ){
            locP.add( wheel.chassisConnectionPointLocal );
            this.wheelMeshes[wheelIndex].quaternion.copy(steeringOrn).multiply(rotatingOrn).normalize();
            this.wheelMeshes[wheelIndex].position.copy(locP);
            if(this.brakeMeshs){
                if(wheelIndex === 2 || wheelIndex === 3 ) this.brakeMeshs[wheelIndex].quaternion.copy(steeringOrn).normalize();
                this.brakeMeshs[wheelIndex].position.copy(locP);
                this.brakeMeshs[wheelIndex].updateMatrix();
            }
        } else {
            this.wheelMeshes[wheelIndex].position.copy(wheel.position);
            this.wheelMeshes[wheelIndex].quaternion.copy(wheel.quaternion);
            this.wheelMeshes[wheelIndex].updateMatrix();
        }

    }

    getWheelTransformWorld(id) {
        return this.wheelInfos[id].matrix;
        //return this.wheelMeshes[id].matrixWorld ;
    }



}




const Utilsdefaults = (options, defaults) => {
    options = options || {};

    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }

    return options;
};


var chassis_velocity_at_contactPoint = new Vector3();
var relpos = new Vector3();

class WheelInfo {
    constructor( options, motor ){

        this.motor = motor;

        options = Utilsdefaults(options, {
            chassisConnectionPointLocal: new Vector3(),
            chassisConnectionPointWorld: new Vector3(),
            directionLocal: new Vector3(),
            directionWorld: new Vector3(),
            axleLocal: new Vector3(),
            //axleWorld: new Vector3(),
            suspensionRestLength: 1,
            suspensionMaxLength: 2,
            radius: 1,
            suspensionStiffness: 100,
            dampingCompression: 10,
            dampingRelaxation: 10,
            frictionSlip: 10000,
            forwardAcceleration: 1,
            sideAcceleration: 1,
            steering: 0,
            rotation: 0,
            deltaRotation: 0,
            rollInfluence: 0.01,
            maxSuspensionForce: Number.MAX_VALUE,
            isFrontWheel: true,
            clippedInvContactDotSuspension: 1,
            suspensionRelativeVelocity: 0,
            suspensionForce: 0,
            skidInfo: 0,
            suspensionLength: 0,
            maxSuspensionTravel: 1,
            useCustomSlidingRotationalSpeed: false,
            customSlidingRotationalSpeed: -0.1
        });

        this.maxSuspensionTravel = options.maxSuspensionTravel;
        this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
        this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
        this.sliding = false;
        this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
        this.chassisConnectionPointWorld = options.chassisConnectionPointLocal.clone();
        this.directionLocal = options.directionLocal.clone();
        this.directionWorld = options.directionLocal.clone();
        this.axleLocal = options.axleLocal.clone();
        //this.axleWorld = options.axleLocal.clone();
        this.suspensionRestLength = options.suspensionRestLength;
        this.suspensionMaxLength = options.suspensionMaxLength;
        this.radius = options.radius;
        this.suspensionStiffness = options.suspensionStiffness;
        this.dampingCompression = options.dampingCompression;
        this.dampingRelaxation = options.dampingRelaxation;
        this.frictionSlip = options.frictionSlip;
        this.forwardAcceleration = options.forwardAcceleration;
        this.sideAcceleration = options.sideAcceleration;
        this.steering = 0;
        this.rotation = 0;
        this.deltaRotation = 0;
        this.rollInfluence = options.rollInfluence;
        this.maxSuspensionForce = options.maxSuspensionForce;
        this.engineForce = 0;
        this.brake = 0;
        this.isFrontWheel = options.isFrontWheel;
        this.clippedInvContactDotSuspension = 1;
        this.suspensionRelativeVelocity = 0;
        this.suspensionForce = 0;
        this.skidInfo = 0;
        this.suspensionLength = 0;
        this.sideImpulse = 0;
        this.forwardImpulse = 0;
        this.raycastResult = new RaycastResult();
        //this.raycastDirectionWorld = new Vector3()
        //this.worldTransform = new TransformNode("")
        //this.worldTransform.rotationQuaternion = new THREE.Quaternion()

        this.position = new Vector3().copy(this.chassisConnectionPointLocal);
        this.quaternion = new Quaternion$1();

        this.isInContact = false;
        this.chassisBody = null;
        this.ray = null;

        this.matrix = new Matrix4();

    }

    castRay( r ){

        if(r.hit){

            this.isInContact = true;
            //if( this.isInContact ){
            let hitDistance = r.distance;
            this.raycastResult.hitPointWorld.fromArray( r.point );
            this.raycastResult.hitNormalWorld.fromArray( r.normal );
            this.raycastResult.body = this.motor.byName( r.body );

            this.suspensionLength = hitDistance - this.radius;
            // clamp on max suspension travel
            let minSuspensionLength = this.suspensionRestLength - this.maxSuspensionTravel;
            let maxSuspensionLength = this.suspensionRestLength + this.maxSuspensionTravel;
            if (this.suspensionLength < minSuspensionLength) {
                this.suspensionLength = minSuspensionLength;
            }
            if (this.suspensionLength > maxSuspensionLength) {
                this.suspensionLength = maxSuspensionLength;
                this.raycastResult.reset();
            }
            let denominator = Dot(this.raycastResult.hitNormalWorld,this.directionWorld);

            //var chassis_velocity_at_contactPoint = new Vector3();
            velocityAt( this.chassisBody, this.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint );
            var projVel = Dot(this.raycastResult.hitNormalWorld, chassis_velocity_at_contactPoint );
            //let projVel = this.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint )

            if (denominator >= -0.1) {
                this.suspensionRelativeVelocity = 0;
                this.clippedInvContactDotSuspension = 1 / 0.1;
            } else {
                let inv = -1 / denominator;
                this.suspensionRelativeVelocity = projVel * inv;
                this.clippedInvContactDotSuspension = inv;
            }

        } else {

            this.isInContact = false;

            //put wheel info as in rest position
            this.suspensionLength = this.suspensionRestLength + 0 * this.maxSuspensionTravel;
            this.suspensionRelativeVelocity = 0.0;
            this.raycastResult.hitNormalWorld.copy( this.directionWorld ).multiplyScalar(-1);
            this.clippedInvContactDotSuspension = 1.0;

        }

        // change ray lenght on next frame ?
        /*let raylen = this.suspensionRestLength + this.radius;
        this.ray.setRay({end:[  this.chassisConnectionPointLocal.x, -raylen, this.chassisConnectionPointLocal.z ]})
        */

    }

    updateWheel( chassis ){

        let raycastResult = this.raycastResult;
    
        if (this.isInContact){
            let project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
            //var project = Dot(raycastResult.hitNormalWorld, raycastResult.directionWorld);
            relpos.copy( raycastResult.hitPointWorld ).sub( chassis.position );
            //raycastResult.hitPointWorld.subtractToRef( bodyPosition(chassis, new Vector3()), relpos);
            velocityAt( chassis, relpos, chassis_velocity_at_contactPoint );
           // velocityAt(chassis, raycastResult.hitPointWorld, relpos);
            //var projVel = Dot(raycastResult.hitNormalWorld, chassis_velocity_at_contactPoint );
            let projVel = raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );
            if (project >= -0.1) {
                this.suspensionRelativeVelocity = 0.0;
                this.clippedInvContactDotSuspension = 1.0 / 0.1;
            } else {
                let inv = -1 / project;
                this.suspensionRelativeVelocity = projVel * inv;
                this.clippedInvContactDotSuspension = inv;
            }
    
        } else {
            // Not in contact : position wheel in a nice (rest length) position
            raycastResult.suspensionLength = this.suspensionRestLength;
            this.suspensionRelativeVelocity = 0.0;
            raycastResult.hitNormalWorld.copy(raycastResult.directionWorld).scaleInPlace(-1);
            this.clippedInvContactDotSuspension = 1.0;
        }
    }
}






class RaycastResult {
    constructor(){
        this.body = null;
        this.hitPointWorld = new Vector3();
        this.hitNormalWorld = new Vector3();
        this.directionWorld = new Vector3();
    }
    reset(){
        this.body = null;
        this.hitPointWorld = new Vector3();
        this.hitNormalWorld = new Vector3();
        this.directionWorld = new Vector3();
    }
}


const bodyMass = (body) => ( body.mass );
const bodyInvMass = (body) => ( body.mass > 0 ? 1.0 / body.mass : 0 );

const bodyPosition = (body, res) => ( res.copy( body.position ) );
const bodyLinearVelocity = (body, res) => ( res.copy( body.velocity ) );
const bodyTransform = (body, res) => ( res.copy( body.matrixWorld ) );
const bodyOrientation = (body, res) => ( res.copy( body.quaternion ) );



// The force applies the given energy overtime, while the impulse applies the given energy immediately


const addImpulseAt = ( motor, body, impulse, point ) => {

    //impulse = body.worldToLocal( impulse )
    //root.motor.change({ name:body.name, impulse:impulse.toArray() })
    //point = body.worldToLocal( point )
    //impulse = body.localToWorld( impulse )
    //point = body.localToWorld( point )
    //root.motor.change({ name:body.name, worldForce
    //console.log({ name:body.name, impulse:impulse.toArray(), impulseCenter:point.toArray() })
    motor.change({ name:body.name, impulse:impulse.toArray(), impulseCenter:point.toArray() });
};

const velocityAt = (body, pos, res) => {
    
    res.copy( pos ).sub( body.position );
    res.crossVectors( body.angular, res );
    res.add( body.velocity );
    return res;

};

const bodyInertiaWorld = ( body, res ) => {

    res.copy( body.inertia );//.applyNormalMatrix( body.matrixWorld );
    //console.log(res)
    TransformNormalToRef(res, body.matrixWorld, res);
    res.x = res.x > 0 ? 1.0 / res.x : 0;
    res.y = res.y > 0 ? 1.0 / res.y : 0;
    res.z = res.z > 0 ? 1.0 / res.z : 0;
    return res
};


// vector3 function 

const Dot = ( v, w ) => ( v.x * w.x + v.y * w.y + v.z * w.z );

const CrossToRef = ( left, right, result ) => {
    const x = left.y * right.z - left.z * right.y;
    const y = left.z * right.x - left.x * right.z;
    const z = left.x * right.y - left.y * right.x;
    result.set( x, y, z );
    return result
};

const TransformCoordinatesToRef = ( v, t, result ) => {

    //result.copy(v).applyMatrix4(t)

    const x = v.x, y = v.y, z = v.z;
    const m = t.elements;
    const rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    const ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    const rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    const rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);

    result.x = rx * rw;
    result.y = ry * rw;
    result.z = rz * rw;
    return result;

};

const TransformNormalToRef = ( v, t, result ) => {

    const x = v.x, y = v.y, z = v.z;
    const m = t.elements;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
    return result//.normalize();

};

// Quaternion function 

const RotationAxisToRef = ( axis, angle, result ) => {

    const sin = Math.sin(angle / 2);
    axis.normalize();
    result.w = Math.cos(angle / 2);
    result.x = axis.x * sin;
    result.y = axis.y * sin;
    result.z = axis.z * sin;
    return result;

};









function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
    var j1 = 0;
    var contactPosWorld = frictionPosWorld;

    var vel1 = calcRollingFriction_vel1;
    var vel2 = calcRollingFriction_vel2;
    var vel = calcRollingFriction_vel;
   
    velocityAt(body0, contactPosWorld, vel1);
    velocityAt(body1, contactPosWorld, vel2);
    //vel1.subtractToRef(vel2, vel);
    //vel1.sub(vel2)
    vel.copy(vel1).sub(vel2);

    var vrel = Dot(frictionDirectionWorld, vel);

    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
    var relaxation = 1;
    var jacDiagABInv = relaxation / (denom0 + denom1);

    // calculate j that moves us to zero relative velocity
    j1 = -vrel * jacDiagABInv;

    if (maxImpulse < j1) {
        j1 = maxImpulse;
    }
    if (j1 < -maxImpulse) {
        j1 = -maxImpulse;
    }

    return j1;
}



var computeImpulseDenominator_r0 = new Vector3();
var computeImpulseDenominator_c0 = new Vector3();
var computeImpulseDenominator_vec = new Vector3();
var computeImpulseDenominator_m = new Vector3();

function computeImpulseDenominator(body, pos, normal) {

    var r0 = computeImpulseDenominator_r0;
    var c0 = computeImpulseDenominator_c0;
    var vec = computeImpulseDenominator_vec;
    var m = computeImpulseDenominator_m;

    //pos.subtractToRef(bodyPosition(body, new Vector3()), r0);
    r0.copy(pos).sub(bodyPosition(body, new Vector3()));
    CrossToRef(r0, normal, c0);
    // ???
    //bodyInertiaWorld(body, new Vector3()).multiplyToRef(c0, m)
    //bodyInertiaWorld( body, m ).multiply(c0)
    m.copy( bodyInertiaWorld(body, new Vector3()) ).multiply(c0);
    

    CrossToRef(m, r0, vec);

    return bodyInvMass(body) + Dot(normal, vec);
}



var resolveSingleBilateral_vel1 = new Vector3();
var resolveSingleBilateral_vel2 = new Vector3();
var resolveSingleBilateral_vel = new Vector3();



function resolveSingleBilateral( body1, pos1, body2, pos2, normal ){

    var normalLenSqr = normal.lengthSq();
    if (normalLenSqr > 1.1){
        return 0; // no impulse
    }
    let vel1 = resolveSingleBilateral_vel1;
    let vel2 = resolveSingleBilateral_vel2;
    let vel = resolveSingleBilateral_vel;
   
    velocityAt(body1, pos1, vel1);
    velocityAt(body2, pos2, vel2);
    
    //vel1.sub(vel2);
    vel.copy(vel1).sub(vel2);

    let rel_vel = Dot(normal, vel);
    let massTerm = 1 / (bodyInvMass(body1) + bodyInvMass(body2));
    let impulse = -0.1 * rel_vel * massTerm;

    //console.log(bodyInvMass(body1) )

    return impulse;
}

const skyOption = {

    sunPosition: new Vector3(0.27, 1, 0.5),
    sunTop: new Vector3(0, .99, 0),
    saturation:1,
    noiseMap:null,

	//shadow:1.0,

	//sunIntensity:100,//1.26,
	//hemiIntensity:1,//2,//2.79,
	nightLuminosity:0.03,

	//HOUR:12,
	//AZIMUTH:0,

	cloud_size:0.29,
	cloud_covr:0.1,//0.56,
	cloud_dens:0.4,
	cloud_dist:0.64,

	haze:0.1,
	mixRatio:0.76,

	SAMPLE:64,//128*0.5,
	STEP:4,//16

	cloudColor: new Color(0xfffff9).multiplyScalar(1),
	skyColor: new Color(0x425876),
	fogColor: new Color(0xabb5c0),
    groundColor: new Color(0x808080),
    sunColor: new Color(0xffffff).multiplyScalar(3),

};

const SkyShader = {
	defines:{
		'USE_NOISE_MAP' : false,
	},
	uniforms: {
		lightdir: { value: skyOption.sunPosition },
        sunTop: { value:skyOption.sunTop },
        noiseMap: { value:skyOption.noiseMap },
        
        mixRatio: { value: skyOption.mixRatio },

		cloud_size: { value: skyOption.cloud_size },
        cloud_covr: { value: skyOption.cloud_covr },
        cloud_dens: { value: skyOption.cloud_dens },
        cloud_dist: { value: skyOption.cloud_dist },
        nightLuminosity: { value: skyOption.nightLuminosity },
        haze: { value: skyOption.haze },
        saturation:{ value: skyOption.saturation },
        
        SAMPLE:{ value: skyOption.SAMPLE },
        STEP:{ value: skyOption.STEP },
        fogy: { value: skyOption.fogy },
        t: { value: 1.0 },
        // extra color

        fogColor: { value: skyOption.fogColor },
        groundColor: { value: skyOption.groundColor },
        cloudColor: { value: skyOption.cloudColor },
        skyColor: { value: skyOption.skyColor },
        sunColor: { value: skyOption.sunColor },
	},
	vertexShader: /* glsl */ `
varying vec3 worldPosition;
void main()	{
	worldPosition = ( modelMatrix * vec4( position, 1.0 )).xyz;
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}
`,
	fragmentShader: /* glsl */`
//precision highp float;
varying vec3 worldPosition;

uniform vec3 fogColor;
uniform vec3 groundColor;
uniform vec3 cloudColor;
uniform vec3 skyColor;
uniform vec3 sunColor;

uniform float saturation;

uniform float hue;
uniform float mixRatio;
uniform float fogy;

uniform vec3 sunTop;

uniform sampler2D noiseMap;
uniform vec3 lightdir;

uniform float cloud_size;
uniform float cloud_covr;
uniform float cloud_dens;
uniform float cloud_dist;

uniform float nightLuminosity;
uniform float haze;
uniform float t;

uniform int SAMPLE;
uniform int STEP;

//const float c = 6.36e6;
//const float d = 6.38e6;
const float c = 6.407e6;
const float d = 6.416e6;

//const float g = 0.76; // mix ratio
//const float h = g*g;
const float icc = 1.0/8e3;
const float jcc = 1.0/1200.0;
const float pi = 3.141592653589793;

const vec3 vm = vec3( 0,-c,0 );
//const vec3 vn = vec3( 2.1e-5 );
//const vec3 vo = vec3( 5.8e-6, 1.35e-5, 3.31e-5 );

//const vec3 vn = vec3( 0.000021 );
//const vec3 vo = vec3( 0.0000058, 0.0000135, 0.0000331 );// sky base color

//const vec3 vo = vec3( 0.000021 );// sky base color


#ifdef USE_NOISE_MAP

float noise( in vec3 x ){
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
    vec2 rg = texture2D( noiseMap, (uv+0.5)/256.0, -16.0 ).yx;
    return mix( rg.x, rg.y, f.z );
}

#else

float hash( float n ) { return fract(sin(n)*753.5453123); }
float noise( in vec3 x ){
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
    float n = p.x + p.y*157.0 + 113.0*p.z;
    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),
               mix(mix( hash(n+113.0), hash(n+114.0),f.x),
                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);
}

#endif

float NOISE( vec3 r )
{
	r.xz += t;
	r *= 0.5;
	float s;
	s = 0.5 * noise(r);
	r = r * 2.52;
	s += 0.25 * noise(r);
	r = r * 2.53;
	s += 0.125 * noise(r);
	r = r * 2.51;
	s += 0.0625 * noise(r);
	r = r * 2.53;
	s += 0.03125 * noise(r);
	r = r * 2.52;
	s += 0.015625 * noise(r);
	return s;
}

float MakeNoise( vec3 r )
{
	float s,tt;
	s = NOISE( r * 2e-4 * ( 1.0 - cloud_size ) );
	tt = ( 1.0 - cloud_covr ) * 0.5 + 0.2;
	s = smoothstep( tt, tt+.2 , s );
	s *= 0.5*(cloud_dens*100.0);
	return s;
}

void clouds( in vec3 r, out vec3 u )
{
	float v,w;
	v = length( r-vm ) - c;
	w = 0.0;
	if( 5e3 < v && v < 1e4 ) w = MakeNoise( r ) * (sin( pi*(v-5e3)/5e3 ));
	u = vec3( exp(-v*icc), exp(-v*jcc), w );
}

float ca( in vec3 r, in vec3 s, in float t )
{
	vec3 u = r - vm;
	float v,w,x,y,z,A;
	v = dot(u,s);
	w = dot(u,u)-t*t;
	x = v*v-w;
	if( x < 0.0 ) return -1.0;
	y = sqrt(x);
	z = -v-y;
	A = -v+y;
	return z >= 0.0 ? z : A;
}

vec3 czm_saturation(vec3 rgb, float adjustment)
{
    vec3 W = vec3(0.2125, 0.7154, 0.0721);
    vec3 intensity = vec3(dot(rgb, W));
    return mix(intensity, rgb, adjustment);
}


vec3 makeSky( in vec3 lightpos, in vec3 r, in vec3 world, out float mask )
{

	vec3 vn = vec3( 0.000021 );
	vec3 vo = skyColor;
	vo *= 0.00005;

	float u,v,w,x,y,z,m, M, N, S, H, F;
	vec3 p = lightpos;
	u = ca(r,world,d);
	v = dot(world,p);
	w = 1.0+v*v;

	float gg = mixRatio;
	float hh = gg*gg;

	x = 0.0596831*w;
	y = 0.0253662*(1.0-hh)*w/((2.0+hh)*pow(abs(1.0+hh-2.0*gg*v),1.5));
	z = 50.*pow(abs(1.+dot(world,-p)),2.0)*dot(vec3(0.,1.,0.),p)*(1.0-cloud_covr)*(1.0-min(fogy,1.0));

	m = 0.0;
	vec3 D,E, CB, CM, BB, BM, SX;

	F = u / float( SAMPLE );

	BB = vec3(0.0);
	BM = vec3(0.0);

	float count = 0.0;

	for( int G=0; G<SAMPLE; ++G ){

		H = float(G)*F;
		vec3 I = r + world * H;
		//CB = vec3(1.0);
		//BB = vec3(0.0);
		clouds( I, CB );
		CB += fogy;// add fog
		CB.y += CB.z;// add clound
		CB.xy *= F;
		BB += CB;

		M = ca(I,p,d);

		if( M > 0.0 ){

			N = M/float(STEP);
			BM = vec3(0.0);

			for( int R=0; R<STEP; ++R ){

				S = float(R)*N;
				vec3 T=I+p*S;
				clouds( T, CM );
				CM += fogy;// add fog
				CM.y += CM.z;// add clound
				BM += CM * N;

			}

			SX = exp(-(vo*(BM.x+BB.x)+vn*(BM.y+BB.y)* cloud_dist));

			m += CB.z;
			count += 1.0;
			D += SX*CB.x;
			E += (SX*CB.y)+z*m;
		}
		else return vec3(0.0);
	}
	//mask = m * 0.0125;
	//mask = m / count;
	mask = m / float( SAMPLE );

	return ((D * vo * x ) + (E * vn * y * sunColor)) * 15.0;
}


void main()
{
	vec3 light = normalize( lightdir );
	vec3 world = normalize( worldPosition.xyz );

	float uvy = acos( world.y ) / pi;

	//float luma = smoothstep(0.0, 4.0,  1.0-(abs(world.y)/0.8) );
    //float mid = smoothstep(0.0, 1.0,  abs(world.y) < haze ? 1.0-(abs(world.y)/(haze*1.0)) : 0.0 );
    //mid *= nightLuminosity;//pow(  mid, 1.0 );

    // ground reapeat sky
	//if( world.y < -0.15) world.y = -0.15+((-world.y-0.15)*0.1);
	if( world.y < 0.0) world.y = -world.y;

	float high = smoothstep(1.0, 0.0, (uvy)*10000.0);
	float top =  smoothstep(1.0, 0.0, (uvy-0.5)*50.0);
	float middle = uvy > 0.5 ? high : smoothstep(0.0, 1.0, (0.5-uvy)*((1.0-haze)*100.0));

	float middle2 = uvy > 0.5 ? smoothstep(0.0, 1.0, (0.5-uvy)*((1.0-haze)*100.0)) : smoothstep(0.0, 1.0, (0.5-uvy)*((1.0-haze)*100.0));

	vec3 s = sunTop;
	float lm = dot( s, light );
	float day = clamp((lm*4.0), 0.0, (1.0-nightLuminosity) )+nightLuminosity;

	if(lm <= 0.0) light *= -1.0;
	light.y = abs(light.y);

	//if(light.y < 0.1) light.y = 0.1;
	light.y = clamp(light.y, 0.1, 1.0 );
	//light.y += 0.5;

	float mask = 0.0;

	vec3 sky = makeSky( light, s, world, mask );
	mask = clamp(mask, 0.0, 1.0 );
	sky = mix( sky, cloudColor, mask ); //apply cloud color
	

	//sky = mix( sky, groundColor, 1.0-middle ); // apply ground color
	sky = mix( sky, fogColor, 1.0-middle2 ); // apply fog color
	
    //float dd = clamp(day+(nightLuminosity*0.5), 0.0, 1.0);
	//luma *= 1.0-dd;
	//clear = mix( clear, clear+skyColor, luma ); // extra luminosity on night

	sky *= day;
	//sky = czm_saturation(sky, saturation);
    //sky = clamp(sky, 0.0, 1.0 );


 	gl_FragColor = vec4( sky, 1.0 );

}
`,
	depthWrite: false,
	depthTest: false,
	side:1,
	toneMapped: false,
	fog:false,
};

const torad = Math.PI / 180;

class Envmap {

	constructor( o = {} ) {

		this.mainScene = o.scene;
		this.renderer = o.renderer;

		this.usePrem = o.usePmrem !== undefined ? o.usePmrem : false;
		this.useBackground = o.useBackground !== undefined ? o.useBackground : true;
		this.envBlur = o.envBlur !== undefined ? o.envBlur : 0;
		this.callback = o.callback || null;
		this.isSky = false;

		 if( this.usePrem ){
	        this.pmremGenerator = new PMREMGenerator( this.renderer );
	        this.pmremGenerator.compileEquirectangularShader();
	    }

		if(o.cube) this.initCubeEnv( o );
		if(o.url) this.load( o.url );
    
	}

	initCubeEnv( o = {} ) {

		this.isCubeEnv = true;
		this._quality = o.quality || 1;

		this.scene = new Scene();
		if(o.color) this.scene.background = new Color(o.color); 
		this.target = new WebGLCubeRenderTarget( 256*this._quality, {
			//magFilter: LinearFilter,
            minFilter: LinearFilter,
            type: HalfFloatType,
            //format: RGBAFormat,
            //colorSpace: LinearSRGBColorSpace,
            colorSpace: SRGBColorSpace, 
            //generateMipmaps: false,
            //depthBuffer: false,
            //generateMipmaps:true,
            anisotropy:1,
        });

        this.camera = new CubeCamera( o.near || 0.1, o.far || 100, this.target );
		this.mainScene.environment = this.target.texture;
		if( this.useBackground ) this.mainScene.background = this.target.texture;

	}

	addSky(){

		let g = new IcosahedronGeometry( 20, 1 );
		const mat = new ShaderMaterial( SkyShader );
		this.sky = new Mesh( g, mat );
		this.scene.add(this.sky);
		this.render();
		this.isSky = true;
		
	}

	getSkyOtion(){

		if(!this.isSky) return;
		return skyOption;

	}

	setSkyOtion( o ){

		if(!this.isSky) return;
		let u = this.sky.material.uniforms;
		for(let k in o){
			if(u[k]) u[k].value = o[k];
		}
	
	    if(this.timeout) clearTimeout(this.timeout);
	    this.timeout = setTimeout( this.render.bind(this), 0 );

	}

	render() {

		if(!this.isCubeEnv) return
		const renderer = this.renderer;
        const lastToneMapping = renderer.toneMapping;
        //const lastToneExposure = renderer.toneMappingExposure;
        renderer.toneMapping = NoToneMapping;
        //renderer.toneMappingExposure = 1.0;

		this.camera.update( renderer, this.scene );
        renderer.toneMapping = lastToneMapping;
        //renderer.toneMappingExposure = lastToneExposure;

	}

	load ( url ) {

		this.name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
	    this.type = url.substring( url.lastIndexOf('.')+1 ).toLowerCase();

		this.loader = null;

		switch( this.type ){
			case 'hdr': 
			    this.loader = new RGBELoader().load( url, this.end.bind(this), null, this.bug.bind(this) );
			break;
			case 'exr':
			    this.loader = new EXRLoader().load( url, this.end.bind(this), null, this.bug.bind(this) );
			break;
			/*case 'jpg': 
			    this.loader = new HDRJPGLoader( this.renderer ).load( url, this.end.bind(this), null, this.bug.bind(this) );
			break;*/
		}

	}

	bug () {

		console.log( 'Envmap is not find :', this.name );
		if( this.callback ) this.callback();

	}

	end () {

		let env;

		switch( this.type ){
			case 'hdr': case 'exr':
			    env = this.loader;
			    env.mapping = EquirectangularReflectionMapping;
			break;
			case 'jpg':
			    env = this.loader.renderTarget.texture;
			    env.mapping = EquirectangularReflectionMapping;
			    
			break;
		}

		if( this.usePrem ) {
            
            env = this.pmremGenerator.fromEquirectangular( env ).texture;
            this.pmremGenerator.dispose();

        }

        env.needsUpdate = true;

        const scene = this.isCubeEnv ? this.scene : this.mainScene;

        
		if( this.isCubeEnv || this.useBackground ) scene.background = env;
		if( this.envBlur ) scene.backgroundBlurriness = this.envBlur;
	    scene.environment = env;
	    
        this.loader.dispose();

		if( this.callback ) this.callback();

	}


	get intensity() {
        return this.mainScene.environmentIntensity;
    }
    set intensity(value) {
        this.mainScene.environmentIntensity = value;
    }

    get bgIntensity() {
        return this.mainScene.backgroundIntensity;
    }
    set bgIntensity(value) {
        this.mainScene.backgroundIntensity = value;
    }

    get blur() {
        return this.mainScene.backgroundBlurriness;
    }
    set blur(value) {
        this.mainScene.backgroundBlurriness = value;
    }

    rotate( x=0,y=0,z=0 ) {

        if(x!==0) x *= torad;
        if(y!==0) y *= torad;
        if(z!==0) z *= torad;

        this.mainScene.environmentRotation.set(x,y,z);
        this.mainScene.backgroundRotation.set(x,y,z);

    }

}

class AutoRagdoll {
	
	constructor( o = {}, motor ){

		this.motor = motor;
		this.utils = this.motor.utils;

		this.id = 0;
		this.type = 'autoRagdoll';
		this.name = o.name || this.type+this.id++;

		let b = this.utils.byName( this.name );
		if( b ) this.utils.remove( b );

		//this.isAutoRagdoll = true;

		this._mode = o.mode || 'follow';
		this._size = o.size || 1;
		this._debug = o.debug || false;

		const model = clone( o.model );
		model.scale.set(1,1,1).multiplyScalar( this._size );
		if(o.pos) model.position.fromArray(o.pos);

		model.raycast = function (){ return };
		model.name = this.name;
		//model.frustumCulled = false;

		let bones;

		model.traverse( ( child ) => {
			if ( child.isMesh ){
				child.frustumCulled = false;
			}
			if ( child.isSkinnedMesh ){
				child.raycast = function (){ return };
				child.frustumCulled = false;
				child.matrixAutoUpdate = false;
				child.receiveShadow = true;
				child.castShadow = true;
				if( o.material ) child.material = o.material;
				child.skeleton.resetScalling();
				bones = child.skeleton.bones;
			}
		});

		let mass = o.mass || null;
		
		this.skeletonBody = new SkeletonBody( this.motor, model.name, model, bones, mass, o.option );

		this.debug = this._debug;
		this.mode = this._mode;

		/*this.skeletonBody.addEventListener ( 'start', function ( event ) {
			console.log( event.message );
		});*/



		/* 
		// basic three helper
		let helper = new SkeletonHelper( m );
		helper.raycast = function (){ return }
        helper.matrix = m.matrix;
        root.scene.add( helper );
        */

		model.add( this.skeletonBody );

		this.model = model;

		this.utils.add( this );

		return this;

	}

	getRealPosition() {
		let node = this.utils.byName( this.skeletonBody.nodes[0].name );
		return node.position;
	}

	dispose () {

		if( this.skeletonBody ) this.skeletonBody.dispose();
		if( this.model ) this.model.parent.remove( this.model );

	}

	//

	get position () { return model.position; }

	get size () { return this._size; }
	set size (value) {
		this._size = value;
		this.model.scale.set(1,1,1).multiplyScalar( this._size );
	}

	//

	get debug () { return this._debug; }
	set debug (value) {
		this._debug = value;
		this.skeletonBody.isVisible( this._debug );
	}

	get mode () { return this._mode; }
	set mode (value) {
		this._mode = value;
		this.skeletonBody.setMode( this._mode );
	}



}

const _offsetMatrix = new Matrix4();
const _identityMatrix = new Matrix4();
new Vector3();

let K = Skeleton.prototype;

K.byName = function ( name ) {

    let i = this.bones.length;
    while(i--) if( this.bones[i].name === name ) return this.bones[i]
    return null

};

K.getId = function ( name ) {

    let i = this.bones.length;
    while(i--) if( this.bones[i].name === name ) return i
    return null

};

K.setExtraRotation = function ( b, x, y, z ) {

    //this.pose()

    /*let name = b.isBone ? b.name : b
    let degtorad = MathUtils.DEG2RAD

    let bone = this.byName( name )
    if( !bone ) return

    let id = this.getId( name )
    let tt = new Matrix4().makeRotationFromEuler( {x:x*degtorad, y:y*degtorad, z:z*degtorad, order:'XYZ'});

    //bone.matrixWorld.multiply( tt );
    bone.matrix.multiply( tt );
    bone.matrixWorld.multiplyMatrices( bone.parent.matrixWorld, bone.matrix );
    bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
    //bone.updateMatrixWorld( true )

    //bone.updateWorldMatrix( true, true )

    let j = bone.children.length, child;
    while(j--){
        child = bone.children[ j ]
        child.matrixWorld.multiplyMatrices( bone.matrixWorld, child.matrix )
    }



    this.calculateInverses()*/
//this.pose()


    let bone = b.isBone ? b : this.byName( b );
    if( !bone ) return
    MathUtils.DEG2RAD;
    
    //bone.extraRotation = new Matrix4().makeRotationFromEuler( {x:x*degtorad, y:y*degtorad, z:z*degtorad, order:'XYZ'});
    //bone.extraRotation = new Quaternion().setFromEuler( {_x:x*degtorad, _y:y*degtorad, _z:z*degtorad, _order:'XYZ'}).invert();

    //this.applyScalling()

};

K.setScalling = function ( b, x, y, z ) {

    let bone = b.isBone ? b : this.byName( b );
    if( !bone ) return
    bone.scalling = new Vector3(x, y, z);

};

K.resetScalling = function (b) {

    this.pose();

    this.scalled = true;

    for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

        //this.bones[i].scalling = new Vector3(1,1,1);
        this.bones[i].isPhysics = false;
        this.bones[i].phyMtx = new Matrix4();

    }

    if(!b) this.applyScalling();

};

K.childScale = function ( bone, matrix ) {

    if( !this.scalled ) return

    //

    if( bone.scalling ) matrix.scale( bone.scalling );
    //if( bone.extraRotation ) matrix.multiply( bone.extraRotation );
    //if( !bone.isBone ) return

    //if(bone.name === 'head') console.log(bone.children.length)


    let j = bone.children.length, child, k=0;

    while(j--){

        child = bone.children[ k ];
        k++;

        if( child.isBone ) {
            child.matrixWorld.multiplyMatrices( matrix, child.matrix );
            
        } else {

            //child.matrixAutoUpdate = false;
            //child.applyMatrix4(matrix)
            //child.matrixWorldNeedsUpdate = false;
            child.matrixWorld.multiplyMatrices( matrix, child.matrix );
            //child.matrixWorldNeedsUpdate = true;

            //child.updateWorldMatrix(false,true)
            //child.updateWorldMatrix(true, true);
            //child.updateMatrixWorld(true);
            //child.updateMatrix()
            //child.updateWorldMatrix( false, true );

            // BUG WITH HAIR !!!
         //   child.matrixWorld.multiplyMatrices( matrix, child.matrix )
           // child.matrixWorld.multiplyMatrices( matrix, child.matrix )

            //child.updateWorldMatrix(false, true)
            //child.matrix = matrix.clone();
            //child.matrixWorld.premultiply( matrix.clone() )
           
        }

        
        //child.matrixAutoUpdate = true
        //if( child.matrixAutoUpdate ) child.matrixAutoUpdate = false
        //if( child.matrixWorldAutoUpdate ) child.matrixWorldAutoUpdate = false
        //child.matrixWorldNeedsUpdate = false;
        //child.matrixWorld.copy( child.matrix ).premultiply( matrix )

        //child.matrixWorld.copy( matrix ).multiply( child.matrix )
        


        //scaleMatrix = matrix.clone()
        //scaleMatrix.multiply( child.matrix )
        //child.matrixWorld.copy( scaleMatrix )

       // if( child.isBone ) 
            //child.matrix.premultiply(matrix)
            //child.matrixWorld.copy( child.matrix );
            
            ///child.matrixWorldNeedsUpdate = true;
        //child.matrix.premultiply(matrix)
        //child.matrixWorld.setPosition( _decal.setFromMatrixPosition( scaleMatrix ) );
        //child.matrixWorld.setPosition( _decal.setFromMatrixPosition( scaleMatrix ) );
        
    }

};

K.applyScalling = function ( fingerPos ) {

    let b, i, lng = this.bones.length;
    let parent;

    for ( i = 0; i < lng; i ++ ) {

        b = this.bones[ i ];
        parent = b.parent || null;

        if( parent !== null && parent.scalling && b.name!=='root' ){//

          //  if( parent.scalling ) 
            b.position.multiply( parent.scalling );
            //if(parent.extraRotation) b.quaternion.premultiply( parent.extraRotation );
            //b.updateWorldMatrix( false, true )
            b.updateMatrixWorld( true );

        }

    }

    this.calculateInverses();

};


K.update = function () {

    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;

    // flatten bone matrices to array

    let i = bones.length, bone, n=0;

    while( i-- ){

        bone = bones[ n ];

        // compute the offset between the current and the original transform
        //if(bone && bone.isPhysics) bone.matrixWorld.copy(bone.phyMtx)
        //const matrix = bone ? bone.matrixWorld : _identityMatrix;

        const matrix = bone ? ( bone.isPhysics ? bone.phyMtx : bone.matrixWorld ) : _identityMatrix;

        // no need but break dragon demo ??
        //if( bone.isPhysics ) this.scalled = true
        
        this.childScale( bone, matrix );

        _offsetMatrix.multiplyMatrices( matrix, boneInverses[ n ] );
        _offsetMatrix.toArray( boneMatrices, n * 16 );

        n++;

    }

    if ( boneTexture !== null ) {

        boneTexture.needsUpdate = true;

    }

};

/** __
*    _)_|_|_
*   __) |_| | 2025
* @author lo.th / https://github.com/lo-th
*
*    THREE.JS BRIDGE ENGINE
*/

const Version = {
	
	PHY: '0.5.0',
	// best
    PHYSX: '5.06.10',
    HAVOK: '1.2.1',
    JOLT: '0.35.0',
    // old
    RAPIER: '0.14.0',
    OIMO: '1.2.4',
    AMMO: '3.2.6',

};


class PhyEngine {

	constructor( parameters = {} ) {

		this.geo = new Geo$1();
		this.mat = new Mat$3();

		this.math = MathTool;
		this.pool = Pool;
		//this.RayCar = RayCar;
		
		this.version = Version.PHY;
		this.Version = Version;

		this.engine = '';

		this.jointVisible = false;

		this.utils = new Utils(this);

		this.viewSize = null;
		this.debug = false;
		this.delta = 0;


		const _this = this;

        let useLocal = false;
        let useModule = false;

		let currentControle = null;
		let callbackReady = null;
		let worker = null;
		let isWorker = false;
		let isBuffer = false;
		let isTimeout = false;
		let outsideStep = true;
		let engineReady = false;
		let breaker = null;

		let isAdd = false;

		let timetest = { t1:0, t2:0, t3:0, t4:0 };

		let mouseTool = null;

		let directMessage = null;
		let controls = null;

		let isPause = false;
		let first = true;

		let timout = null;
		let timoutFunction = null;
		let timoutTime = 0;
		let elapsedTime = 0;

		let envmapUrl = '';
		let _envmap = null;

		// from three
		let renderer = null;
		let scene = null;


		const user = new User();
		const timer = new Timer(60);
		const tt = { start:0, end:0, startTime:'' };

		let azimut = ()=>(0);
		let endReset = ()=>{};
		let postUpdate = ()=>{};
		let addControl = ()=>{};

		let buttons = [];
		let textfields = [];
		let particles = [];

		const settings = {

			fps: 60,
			fixe: true,
			full: false,
			substep: 2,
			gravity: [0,-9.81,0],
			
		};


		// ------------------------------
		//     MAIN ARRAY POOL
		// ------------------------------

		let _Ar = null;
		let _ArPos = {};

		this.flow = {
			stamp:0,
			current:'',
			key:[],
			tmp:[],
			add:[],
			remove:[]
		};

		this.reflow = {
			ray:[],
			stat:{ fps:0, delta:0, ms:0 },
			point:{},
			velocity:{},
		};

		const items = {};
		//this.items = () => items;


		// ------------------------------
		//     MAIN SCENE FOR PHY
		// ------------------------------

		this.scene = null;
	    this.scenePlus = null;


		// ------------------------------
		//     GARBAGEE
		// ------------------------------

		this.garbage = [];
		this.tmpMesh = [];
		this.instanceMesh = {};
		this.tmpTex = [];

		this.disposeTmp = () => {
			// clear temporary mesh
			let i, j, m;
			for( i in this.tmpMesh ) {
				m = this.tmpMesh[i];
				if( m.children ){
					for( j in m.children ) this.disposeMesh( m.children[j] );
				}
				this.disposeMesh( m );
				if( m.parent ) m.parent.remove( m );
			}
			this.tmpMesh = [];

			// clear temporary textures
			for( i in this.tmpTex ) this.tmpTex[i].dispose();
			this.tmpTex = [];

		};

		this.disposeMesh = ( m ) => {

			if( m.geometry ) m.geometry.dispose();
			if( m.dispose ) m.dispose();
				
		};


		/*get onFrame() {
	        return this._name;
	    }*/
	    //this.version( f ) { return Version.PHY; }


	    this.setStep = ( f ) => { postUpdate = f; };

		this.debugMode = ( b ) => { this.setDebugMode(b); };
		this.setDebugMode = ( b ) => { this.debug = b; };

		this.useRealLight = (o) => { this.mat.useRealLight(o); };

		this.getSetting = () => { return settings; };

		this.setGravity = ( v ) => {

			if(v) settings.gravity = v;
			this.post({ m:'setGravity', o:{ gravity:settings.gravity } });

		};

		this.set = ( o = {} ) => {

			settings.fixe = o.fixe !== undefined ? o.fixe : true;
			settings.full = o.full !== undefined ? o.full : false;
			settings.gravity = o.gravity ? o.gravity : [0,-9.81,0];
		    settings.substep = o.substep ? o.substep : 2;
		    settings.fps = o.fps ? o.fps : 60;

			if( o.key ) addControl();

			items.body.setFull( settings.full );
			this.initArray( settings.full );

			elapsedTime = 0;
			isTimeout = isWorker;
			outsideStep = !isTimeout;

			//console.log( isTimeout, isWorker, outsideStep )

		    this.jointVisible = o.jointVisible || false;

			if( outsideStep ) timer.setFramerate( settings.fps );

			const data = {
				...settings,
				ArPos:_ArPos,
				isTimeout:isTimeout,
				outsideStep:outsideStep,
			};

			this.post({ m:'set', o:data });

		};

		this.activeMouse = ( controler, mode ) => { 
			if( !mouseTool ) mouseTool = new MouseTool( controler, mode, this );
		};

	    this.mouseMode = ( mode, o ) => { 
			if( mouseTool ) mouseTool.setMode( mode, o );
		};

	    this.getTime = () => { return Timer.now(); };
	    this.readTime =( t ) => { return Timer.format_time(t); };

	    this.startTime =() => { return tt.startTime; };

		this.getTimeTest =() => { return timetest; };

		this.setMaxFps = ( v ) => { };

		this.getMouse = () => { return mouseTool ? mouseTool.mouse : null; };

		this.setMaxAnisotropy = ( f ) => { Pool.maxAnisotropy = f; };

		this.setAddControl =( f ) => { addControl = f; };

		this.setPrevUpdate = ( f ) => { };
		this.setPostUpdate = ( f ) => { postUpdate = f !== null ? f : ()=>{}; };

		this.setAzimut = ( f ) => { azimut = f; };
		this.setRenderer = ( f ) => { 
			renderer = f;
			Pool.renderer = renderer;
		};

		this.setKey =(i, v) => { return user.setKey(i,v) };
		this.getKey =() => { return user.key };
		this.getKey2 =() => { return user.key2 };
		this.getAzimut =() => { return azimut() };

		this.setContent = ( Scene ) => {

			if( isAdd ) return;
			scene = Scene;
			scene.add( this.scene );
			scene.add( this.scenePlus );
			isAdd = true;

		};

		this.message = ( m ) => {

			let e = m.data;
			if( e.Ar ) _Ar = e.Ar;
			if( e.reflow ){
				this.reflow = e.reflow;
				if(this.reflow.stat.delta) elapsedTime += this.reflow.stat.delta;
			}
		
			_this[ e.m ]( e.o );

		};

		// Typically, on a Flame, the transfer speed is 80 kB/ms for postMessage 
		// This means that if you want your message to fit in a single frame, 
		// you should keep it under 1,300 kB

		this.post = ( e, buffer = null, direct = false ) => {

			if( !isWorker ){
				directMessage( { data : e } );
				return;
			}

			{
				if( e.o ){
			    	if( e.o.type === 'solver' ) direct = true;
			    	if( e.o.solver !== undefined ) direct = true;
			    }
			    if( direct ){
			    	worker.postMessage( e, buffer );
			    } else {
			    	if( e.m === 'add' ) this.flow.add.push( e.o );
			    	else if ( e.m === 'remove' ) this.flow.remove.push( e.o );
			    	else worker.postMessage( e, buffer );
			    }
			}

		};


		// return

		this.rayCar = ( o ) => {

			const arg = new RayCar( o, this );
			//this.scene.add( arg.model );
			return arg;

		};

		this.autoRagdoll = ( o ) => {

			const arg = new AutoRagdoll( o, this );
			this.scene.add( arg.model );
			return arg;

		};

		this.byName = ( name ) => ( this.utils.byName( name ) );
		this.getScene = () => ( this.scene );


		this.makeView = () => {};

		this.resize = ( size ) => { this.viewSize = size; };

		this.init = ( o = {} ) => {

			typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;

			tt.start = Timer.now();

			const compact = o.compact || false;

			// TODO find better solution
			let url = document.location.href.replace(/\/[^/]*$/,"/");
			let arr = url.split("/");
			url = arr[0] + "//" + arr[2] + '/';

			if( url === 'https://lo-th.github.io/' ) url = 'https://lo-th.github.io/phy/';

			let path = o.path || '';
			path += compact ? 'compact/' : 'build/';

			let type = o.type || 'PHYSX';

			let name = type.toLowerCase();
			let mini = name.charAt(0).toUpperCase() + name.slice(1);

			this.engine = type.toUpperCase();

			this.initItems();

			// garbage material
			Pool.materialRoot = this.mat.set.bind(this.mat);

			// extand shader
			//this.mat.initExtandShader();

			if( o.callback ){ 
				callbackReady = o.callback;
				delete o.callback;
			}

			isWorker = o.worker || false;

			this.scene = new Group$1();
			this.scene.name = 'phy_scene';
			this.scenePlus = new Group$1();
			this.scenePlus.name = 'phy_scenePlus';

			if( o.scene ){  // need for envmap
				this.setContent( o.scene );
				delete ( o.scene );
			}

			if( o.renderer ){ // need for envmap and ktx2
				this.setRenderer( o.renderer );
				delete ( o.renderer );
			}

			envmapUrl = o.envmap || '';

			useModule = o.useModule ? this.supportModuleWorker() : false;
			useLocal = o.useLocal || false;


			if( compact ){

				if( useLocal ){
				
					if( useModule ) Pool.load( new URL( '../' + path + mini + '.module.hex', import.meta.url), function(){ _this.onCompactDone(o); } );
		    		else Pool.load( new URL( '../' + path + mini + '.hex', import.meta.url), function(){ _this.onCompactDone(o); } );
				
				} else {

					if( useModule ) Pool.load( url + path + mini + '.module.hex', function(){ _this.onCompactDone(o); } );
					else Pool.load( url + path + mini + '.hex', function(){ _this.onCompactDone(o); } );

				}

			} else {

				if( isWorker ){ // is worker version

					// TODO test
					// https://aditya003-ay.medium.com/different-ways-to-share-data-between-main-thread-and-worker-thread-75a5d86ab441
					//const sharedBuffer = new SharedArrayBuffer(Float32Array.BYTES_PER_ELEMENT * 5);
					//const sharedArray = new Float32Array(sharedBuffer);
					// Start the worker and pass the shared buffer
					//const worker = new Worker('./worker-shared-buffer.js', { workerData: sharedBuffer });


					// https://web.dev/articles/module-workers?hl=fr
					// https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker

					if( useLocal ){
						
						if( useModule ) worker = new Worker( new URL( './' + mini + '.module.js', import.meta.url), {type:'module'} );
						else worker = new Worker( new URL( './' + mini + '.min.js', import.meta.url), {type:'classic'} );
						
					} else {

						if( useModule ) worker = new Worker( url + path + mini + '.module.js', {type:'module'} );
						else worker = new Worker( url + path + mini + '.min.js' );

					}

					

				    //worker = new Worker( url + path + mini + '.min.js' );
				    //worker = new Worker( url + path + mini + '.module.js', {type:'module'});


					worker.postMessage = worker.webkitPostMessage || worker.postMessage;
					worker.onmessage = this.message;

					// test if worker Shared buffer is compatible
					let ab = new ArrayBuffer( 1 );
					worker.postMessage( { m: 'test', ab:ab }, [ ab ] );
					isBuffer = ab.byteLength ? false : true;

					o.isBuffer = isBuffer;

					this.initPhysics( o );


				} else { // is direct version

					if( o.devMode ) this.preLoad( mini, o, url );
				    else this.preLoadMin( mini, o, url );

				}

			}

		};

		this.supportModuleWorker = () => {

			 let supports = false;
			 const tester = {
			      get type() { supports = true; }
			};
			try {
			    const worker = new Worker('data:,', tester).terminate();
			} finally {
			    return supports;
			}

		};

		this.onCompactDone = ( o ) =>{

			let name = this.engine.toLowerCase();
			let mini = name.charAt(0).toUpperCase() + name.slice(1);
			let code = useModule ? Pool.get( mini+'.module', 'H' ) : Pool.get( mini, 'H' );

			if( isWorker ){

				let blob;

				try {
				    blob = new Blob([code], {type: 'application/javascript'});//text/html
				} catch (e) { // Backwards-compatibility
				    window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
				    blob = new BlobBuilder();
				    blob.append(code);
				    blob = blob.getBlob();
				}

				if( useModule ) worker = new Worker( URL.createObjectURL(blob), {type:'module'} );
				else worker = new Worker( URL.createObjectURL(blob) );
			    //else worker = new Worker( url + path + mini + '.module.js', {type:'module'});

			    //console.log('can run worker module:', useModule )

				worker.postMessage = worker.webkitPostMessage || worker.postMessage;
				worker.onmessage = this.message;

				let ab = new ArrayBuffer( 1 );
				worker.postMessage( { m: 'test', ab:ab }, [ ab ] );
				isBuffer = ab.byteLength ? false : true;

				o.isBuffer = isBuffer;
				//console.log( st + ' Worker '+ type + (o.isBuffer ? ' with Shared Buffer' : '') );

				this.initPhysics( o );

			} else {

				let type = name.toUpperCase();
				//if(type==='RAPIER') type = 'RAPIER3D';

				let n = document.createElement("script");
	            n.language = "javascript";
	            n.type = "text/javascript";
	            n.charset = "utf-8";
	            n.async = true;
	            n.innerHTML = code;
	            document.getElementsByTagName('head')[0].appendChild(n);

	            directMessage = window[type].engine.message;
				o.message = this.message;
				this.initPhysics( o );

			}

			//console.log( code, isWorker )

		};

		this.loadWasmDirect = ( link, o, name, url ) => {

		    let s = document.createElement("script");
		    s.src = url + link;
		    document.body.appendChild( s );
		    s.onload = () => { this.preLoad( name, o, url ); };

		};

		this.preLoadMin = ( name, o, url ) => {

			let link = url + 'build/'+name+'.min.js';
			let type = name.toUpperCase();
			//if(type==='RAPIER') type = 'RAPIER3D';

			var xml = new XMLHttpRequest();
	        xml.open('GET', link );
	        xml.overrideMimeType( "text/javascript" );
	        xml.onreadystatechange = function() {
	            if ( xml.readyState === 4 ) {
	                if ( xml.status === 200 || xml.status === 0 ) {
	                    let n = document.createElement("script");
	                    n.language = "javascript";
	                    n.type = "text/javascript";
	                    n.charset = "utf-8";
	                    n.async = true;
	                    n.innerHTML = xml.responseText;
	                    //this.extraCode.push(n)
	                    document.getElementsByTagName('head')[0].appendChild(n);

					    directMessage = window[type].engine.message;
						o.message = this.message;
						this.initPhysics( o );
	                }
	                else console.error( "Couldn't load ["+ name + "] [" + xml.status + "]" );
	            }
	        }.bind(this);
	        xml.send(null);

		};

		this.preLoad = async( name, o, url ) => {

			let link = url + 'build/'+name+'.module.js';
			if( o.devMode ) link = url + 'src/'+name+'.js';
		    let M = await import( link );
		    directMessage = M.engine.message;
			o.message = this.message;
			this.initPhysics( o );

		};

		////

		this.initPhysics = ( o ) => {

			if( envmapUrl !== '' ){
				this.preloadEnvmap( o );
				return
			}

			//tt.start = Timer.now();
		
		    this.post({ m:'init', o:o });
		    engineReady = true;

		};

		this.addEnvmap = ( o ) => {
			if(!_envmap) _envmap = new Envmap( { renderer:renderer, scene:scene, ...o } );
			return _envmap;
		};

		this.preloadEnvmap = ( o ) => {

			_envmap = new Envmap( {
				url:envmapUrl,
				renderer:renderer,
				scene:scene,
				usePmrem:o.usePmrem,
				useBackground: o.useBackground !== undefined ? o.useBackground : true,
				envBlur: o.envBlur !== undefined ? o.envBlur : 0,
				callback:()=>{
					envmapUrl = '';
					this.initPhysics(o);
				}
			});

		};
		
		this.getPause = () => { return isPause; };

		this.pause = ( v ) => {

			if( v === isPause ) return
			isPause = v;
			if( isPause ) this.pausetimout();
			else this.playtimout();
			this.post({ m:'pause', o:{ value:isPause } });

		};

		this.flowReset = ( ) => {

			this.flow = { 
				stamp:0,
				current:'',
				key:[],
				tmp:[],
				add:[],
				remove:[],
				//point:[]
			};

		};

		this.reset = ( callback ) => {

			if( first ){
				first = false;
				callback();
				return;
			}

			buttons = [];

			currentControle = null;

			if( controls ) controls.resetAll();
			if( mouseTool ) mouseTool.unSelect();

			endReset = callback;

			postUpdate = function () {};

			this.clearText();
			//this.clearSkeleton()
			this.clearParticleSolver();

			this.cleartimout();

			this.flowReset();

			// clear instance
		    this.clearInstance();

		    // reset all items
		    this.resetItems();

			// clear temporary geometry
			this.geo.dispose();

		    // clear temporary material
		    this.mat.dispose();

		    // clear temporary mesh
			this.disposeTmp();

			this.garbage = [];

			if( breaker !== null ) breaker = null;
				
		    this.scenePlus.children = [];
		    this.scene.children = [];

			this.post({ m:'reset' });

		};

		this.clearGarbage = () => {

			this.remove(this.garbage);
			this.clearInstance();
			this.garbage = [];
			
		};

		this.clear = ( callback ) => {

			this.reset(callback);
			
		};

		this.resetCallback = () => {

			endReset();

		};

		this.dispose = () => {

			this.reset(()=>{

				if( worker ){ 
					worker.terminate();
					worker = null;
				}

				if( isAdd ){
					_this.scene.parent.remove( _this.scene );
					_this.scenePlus.parent.remove( _this.scenePlus );
					isAdd = false;
				}

			});

		};

		this.ready = () => {

			tt.end = Timer.now();
			tt.startTime = Timer.format_time( tt.end - tt.start );

			console.log( '%c'+this.engine + ' %c' + Version[this.engine] +'%c | '+ (useModule ? 'Module ' : '' ) + ( isWorker?'Worker': 'Direct') +' '+ tt.startTime, 
				"font-size:16px", 
				"font-size:12px", 
				"font-size:12px" 
			);
			if( callbackReady ) callbackReady();

		};

		this.start = ( o = {} ) => { this.post({ m:'start', o:o }); };

		this.morph = ( obj, name, value ) => { this.utils.morph( obj, name, value ); };

		this.getFps = () => { return this.reflow.stat.fps };
		this.getMs = () => { return this.reflow.stat.ms.toFixed(1) };
		
		this.getDelta2 = () => { return this.delta };
		this.getElapsedTime2 = () => { return elapsedTime };

		this.setDelta = (v) => { timer.delta = v; };
		this.getDelta = () => { return timer.delta };
		this.getElapsedTime = () => { return timer.elapsedTime };

		this.doStep = ( stamp ) => {

			if( !engineReady ) return;
			if( !outsideStep ) return;
			if( timer.up( stamp ) ) {
				this.post( { m:'step', o:stamp } );
			}

		};

		this.step = () => {

			// time of physic engine step
			this.delta = this.reflow.stat.delta;
	        // user key interaction
			this.flow.key = user.update();
			this.flow.current = currentControle !== null ? currentControle.name : '';
	        //prevUpdate( timer.delta )

			this.stepItems();

			if( mouseTool ) mouseTool.step();

			if( breaker !== null ) breaker.step();

			if( currentControle !== null ) currentControle.move();

			

			// TODO fix dt 0 when no doStep ??

			let dd = outsideStep ? timer.delta : this.delta;

			postUpdate( dd );

			//items.character.prestep()

			// update this.object for this side !
			this.changes( this.flow.tmp );

			// finally post flow change to physx
			if( isBuffer ) this.post( { m:'poststep', flow:this.flow, Ar:_Ar }, [ _Ar.buffer ] );
			else this.post( { m:'poststep', flow:this.flow });

			//	this.stepItems()
			this.flowReset();

		};

	    

		this.initArray = ( full = false ) => {

		    // dynamics array
			_ArPos = {...getArray( this.engine, full )};

		};

	    this.takeControl = ( name = null ) => {

	    	this.control( name );

	    };

		this.control =( name = null ) => { // for character and vehicle

			if( currentControle !== null ){
				if( name === null ) {
					if( currentControle.isPlayer ) currentControle.isPlayer = false;
					currentControle = null;
				} else  {
					if( name !== currentControle.name ) {
						currentControle = this.byName( name );
						if( currentControle ) currentControle.isPlayer = true;
					}
				}
			} else if( name !== null ){
				currentControle = this.byName( name );
				if( currentControle ) currentControle.isPlayer = true;
			}

		};

		

		this.getAllBody = ( name ) => {

			return items.body.list;

		};


		//-----------------------
		//  ITEMS
		//-----------------------

		this.initItems = () => {

			items['body'] = new Body(_this);
			items['ray'] = new Ray(_this);
			items['joint'] = new Joint(_this);
			items['solid'] = new Solid(_this);
			items['contact'] = new Contact(_this);
			items['terrain'] = new Terrain(_this);
			items['character'] = new Character(_this);

			// vehicle only on physx and ammo
			if( this.engine === 'PHYSX' || this.engine === 'AMMO' ){ 
				items['vehicle'] = new Vehicle(_this);
			}

			// solver is only on physx
			if( this.engine === 'PHYSX' ) items['solver'] = new Solver(_this);

		};

		this.getBodyRef = () => items.body;
		this.getCharacterRef = () => items.character;

		// on Hero / vehicle
		this.getGeometryRef = ( o, b, m ) => { items.body.geometry( o, b, m ); }; 

		this.clearBody = () => { items.body.reset(); };

		this.resetItems = () => {

			Object.values(items).forEach( v => v.reset() );

		};

		this.stepItems = () => {

		    Object.values( items ).forEach( v => v.step( _Ar, _ArPos[v.type] ) );
			this.upInstance();
			this.upButton();

		};


		//-----------------------
		//  INSTANCE
		//-----------------------

		this.upInstance = () =>{

	    	Object.values( this.instanceMesh ).forEach( value => value.update() );

	    };

		this.clearInstance = () => {

	    	Object.values( this.instanceMesh ).forEach( value => value.dispose() );
	    	this.instanceMesh = {};

		};


		//-----------------------
		//  ADD
		//-----------------------

		this.adds = ( r = [], direct = false ) => {

			let i = r.length, n = 0;
			while(i--) this.add( r[n++], direct );

		};

		this.add = ( o = {}, direct = false ) => {

			if( o.isObject3D ) return this.addDirect( o );
			if( o.constructor === Array ) return this.adds( o, direct );
			if( o.type === 'container' ) return new Container( o, this );
			
			if( o.bounce !== undefined ) o.restitution = o.bounce;
			if( o.type === undefined ) o.type = 'box';
			if( o.mode !== undefined ) o.type = 'joint';

			let type = getType( o );

			if( type === 'joint' && o.mode === undefined ){ 
				o.mode = o.type;
				o.type = 'joint';
			}

			let m = items[type].add( o );
			this.garbage.push( m.name );
			return m;

		};

		this.addDirect = ( b ) => {

			this.scenePlus.add( b );
			this.tmpMesh.push( b );
			return b;

		};


		//-----------------------
		//  REMOVE
		//-----------------------

		this.removes = ( r = [], direct ) => { 

			let i = r.length, n = 0;
			while(i--) this.remove( r[n++], direct );

		};
		
		this.remove = ( name, direct = false ) => {

			if ( name.constructor === Array ) return this.removes( name, direct );

			let b = this.byName( name );
			if( b === null ){ 
				if( this.instanceMesh[ name ] ) items.body.clearInstance( name );
				return;
			}

			if(b.type === 'autoRagdoll' ) {
				this.utils.remove(b);
				return 
			}
			if( b.extraRemove ) b.extraRemove();

			// remove on three side
			items[b.type].clear( b );
			// remove on physics side
			this.post( { m:'remove', o:{ name:name, type:b.type } }, null, direct );

		};


		//-----------------------
		//  CHANGE
		//-----------------------

		this.changes = ( r = [], direct = false ) => { 

			let i = r.length, n = 0;
			while( i-- ) this.changeOne( r[n++], direct );

		};

	    this.change = ( o, direct = false ) => {

	    	if( direct ){
	    		if( o instanceof Array ) this.changes( o, true );
	    		else this.changeOne( o, true );
	    	} else {
	    		if( o instanceof Array ) this.flow.tmp.push( ...o );
	    		else this.flow.tmp.push( o );
	    	}

		};

		this.changeOne = ( o = {}, direct = false ) => {

			if( o.heightData ) return

			let b = this.byName( o.name );
			if( b === null ) return null;
			let type = b.type;

			if( o.drivePosition ){
				if( o.drivePosition.rot !== undefined ){  
					o.drivePosition.quat = MathTool.quatFromEuler( o.drivePosition.rot ); 
					delete ( o.drivePosition.rot ); 
				}
			}
			if( o.rot !== undefined ){ o.quat = MathTool.quatFromEuler( o.rot ); delete ( o.rot ); }
			//if( o.rot1 !== undefined ){ o.quat1 = math.toQuatArray( o.rot1 ); delete ( o.rot1 ); }
			//if( o.rot2 !== undefined ){ o.quat2 = math.toQuatArray( o.rot2 ); delete ( o.rot2 ); }
			if( o.localRot !== undefined ){ o.quat = MathTool.toLocalQuatArray( o.localRot, b ); delete ( o.localRot ); }


			//if( o.type === 'solver' ) direct = true;
			//if( o.solver !== undefined ) direct = true;

			switch( type ){

				case 'terrain': b = items.terrain.set( o, b ); direct = false; break;
				case 'ray': b = items.ray.set( o, b ); direct = false; break;
				case 'character': b = items.character.set( o, b ); break;
				case 'solid': b = items.solid.set( o, b ); break;
				case 'joint': b = items.joint.set( o, b );  break;
				case 'body':
				if( b.isKinematic ) items.body.set( o, b );
	            if( !b.actif || b.sleep ) items.body.set( o, b );
	            if( o.sleep ) items.body.set( o, b );
				break;

			}
			
			if( direct ){
				this.post({ m:'change', o:o }, null, direct );
			}

		};


		//-----------------------
		//  CAMERA CONTROLS
		//-----------------------

		this.setControl = ( Controls ) => { 

			controls = Controls;
			azimut = controls.getAzimuthalAngle;

		};

		this.getCurrentCharacterPosition = () => {

			return controls.followGroup.position;

		};

		this.getCamera = ( o = {} ) => {

			return controls.object;

		};

		this.setCamera = ( o = {} ) => {

			controls.moveCam( o );

		};

		this.follow = ( m = '', o = {} ) => {

			let mesh = null;

			if ( typeof m === 'string' || m instanceof String ) mesh = m === '' ? null : this.byName( m );
			else if ( m.isObject3D ) mesh = m;

			if( mesh === null ) controls.resetFollow();
			else controls.startFollow( mesh, o );

		};


	    //-----------------------
		//  INTERN timout
		//-----------------------

		this.setTimeout = ( f, time = 0, single = false ) => {

			if(single) timout = setTimeout( f, time );
			else {
				timoutFunction = f; 
				timoutTime = time; 
				timout = setTimeout( timoutFunction, timoutTime );
			}

		};

		this.playtimout = () => {

			if( timoutFunction === null ) return
			timout = setTimeout( timoutFunction, timoutTime );

		};

		this.pausetimout = () => {

			if( timout === null ) return
			clearTimeout( timout );

		};

		this.cleartimout = ( f, time ) => {

			if( timout === null ) return
			timoutFunction = null;
			timoutTime = 0; 
			clearTimeout( timout );
			timout = null;

		};


		//-----------------------
		//  TEXTURE
		//-----------------------

		this.texture = ( o={} ) => ( Pool.texture( o ) );
		this.getTexture = ( name, o={} ) => ( Pool.getTexture( name, o ) );
		//this.texture( o = {} ) { return Pool.texture( o );}


		//-----------------------
		//  MATERIAL
		//-----------------------

		this.setExtendShader = ( f ) => { this.mat.extendShader = f; };
		this.addMaterial = ( m, direct ) => { this.mat.set( m, direct ); };
		this.directIntensity = ( v ) => { /*this.mat.directIntensity(v);*/ };
		this.setEnvmapIntensity = ( v ) => { /*this.mat.setEnvmapIntensity(v);*/ };

		// return
		this.getMatRef = () => ( this.mat );
		this.getMat = ( name ) => ( this.mat.get( name ) );
		this.getMaterial = ( name ) => ( this.mat.get( name ) );
		this.getMaterialList = () => ( this.mat.getList() );
		this.material = ( o={} ) => ( this.mat.create( o ) );
		this.changeRenderMode = ( n ) => ( this.mat.changeRenderMode( n ) );


		//-----------------------
		//
		//  POOL
		//
		//-----------------------

		this.load = Pool.load; // ( Urls, Callback, Path = '', msg = '' )
		this.get = Pool.get; // ( name, type )
		//this.getGlb = Pool.getGLB;
		this.getGroup = Pool.getGroup;
		this.getScript = Pool.getScript;

		this.preload = ( Urls, Callback ) => {

			preloadAvatar.add( Urls, Callback );
			//Pool.load( Urls, Callback, Path, msg )
		};

		/*this.load ( Urls, Callback, Path = '', msg = '' ){
			Pool.load( Urls, Callback, Path, msg );
		}*/

		// TODO ?? 

		/*this.async loadAsync ( Urls, Path = '', msg = '' ){
			await Pool.loadAsync( Urls, Path, msg );
		}*/

		this.applyMorph = ( modelName, meshs = null, normal = true, relative = true )=>{
			Pool.applyMorph( modelName, meshs = null, normal = true, relative = true );
		};

		this.getMesh = ( obj, keepMaterial, multyMaterialGroup )=>{
			if( keepMaterial ){
				let mm = Pool.getMaterials(obj);
				for( let m in mm ){
					this.addMaterial( mm[m] );
				}
			}
			return Pool.getMesh( obj, multyMaterialGroup );
		};

		this.getGlb = ( obj, keepMaterial, multyMaterialGroup )=>{
			if( keepMaterial ){
				let mm = Pool.getMaterials(obj);
				for( let m in mm ){
					this.addMaterial( mm[m] );
				}
			}
			return Pool.getGLB( obj, multyMaterialGroup );
			
		};

		this.getGlbMaterial = ( obj )=>{
			let ms = Pool.getMaterials( obj );
			this.mat.addToMat( ms );
			return ms;
		};

		this.poolDispose = ()=>{
			return Pool.dispose();
		};

		this.setDracoPath = ( src ) => {
			return Pool.dracoPath = src;
		};


		//-----------------------
		//  PARTICLE
		//-----------------------

		this.initParticle = ()=>{};
		this.addParticle = ()=>{};
		this.getParticle = ()=>{};

		this.addParticleSolver = ( o )=>{
			let s = new Particle( o, this );
			particles.push(s);
			return s;
		};

		this.updateParticleSolver = () =>{ 

			let i = particles.length;
			while( i-- ) particles[i].update();
			
		};

		this.clearParticleSolver = () => { 

			particles.length;
			//while( i-- ) particles[i].dispose()
	    	particles = [];
			
		};


		this.addRayCar = (o) => {

			let b = new RayCar( o, this );
			return b;

		};


		//-----------------------
		//  BUTTON
		//-----------------------

		this.addButton = (o) => {

			let b = new Button( o, this );
			buttons.push( b );
			return b;

		};

		this.upButton = (o) => {
			for ( const key in buttons ) buttons[key].update();
		};


		//-----------------------
		//  TEXT
		//-----------------------

		this.addText = ( o ) => {

			let t = new Textfield( o );
			if( o.parent ) o.parent.add( t );
			else this.scenePlus.add( t );
			textfields.push(t);
			return t;

		};

		this.clearText = () => {

			let i = textfields.length;
			while( i-- ) textfields[i].dispose();
	    	textfields = [];
			
		};

		//-----------------------
		// BREAK
		//-----------------------

		this.screenshot = () => {

			var w = window.open('', '');
		    w.document.title = "Screenshot";
		    w.document.body.style.cssText = 'margin:0; padding:0; overflow:hidden;';
		    //w.document.body.style.backgroundColor = "red";
		    var img = new Image();
		    // Without 'preserveDrawingBuffer' set to true, we must render now
		    renderer.render(scene, this.getCamera());
		    img.src = renderer.domElement.toDataURL();
		    w.document.body.appendChild(img); 

		};


		//-----------------------
		// BREAK
		//-----------------------

		this.addBreaker = () => {

			if( breaker !== null ) return;
			breaker = new Breaker(this);

		};


		//-----------------------
		//  EXPLOSION
		//-----------------------

		this.explosion = ( position = [0,0,0], radius = 10, force = 1 )=>{

			let r = [];
		    let pos = new Vector3();

		    if( position ){
		    	if( position.isVector3 ) pos.copy(position);
		    	else pos.fromArray( position );
		    }
		    
		    let dir = new Vector3();
		    let i = items.body.list.length, b, scaling;

		    while( i-- ){

		        b = items.body.list[i];
		        dir.copy( b.position ).sub( pos );
		        scaling = 1.0 - dir.length() / radius;

		        if( b.isKinematic ) continue;
		        if ( scaling < 0 ) continue;
		        	
		        dir.setLength( scaling );
		        dir.multiplyScalar( force );

		        r.push({ name:b.name, impulse:dir.toArray(), wake:true });
		        //r.push({ name:b.name, impulse:[0,0.01,0], impulseCenter:pos.toArray(), wake:true })
		    }
		    
			this.change( r );
		};
	}

	set onStep ( f ) {

		this.setStep( f );

	}
	
}



//--------------
//
//  SOLID ONLY 
//
//--------------

class Solid extends Body {
	constructor ( motor ) {
		super( motor );
		this.type = 'solid';
	}
	step (){}
}




//-------------------
//
//  UTILS
//
//-------------------

class Utils {


	constructor ( motor ) {

		this.map = new Map();
		this.motor = motor;

	}

	byName ( name ) {

		if ( !this.map.has( name ) ) return null;
		return this.map.get( name );

	}

	add ( b, parent ) {

		if( b.type !== 'contact' && !b.isInstance && b.isObject3D ){

			//console.log('add', b.name, b.type )

			if(!parent){
				if(b.isButton){ this.motor.scene.add( b ); }
				else {
					switch( b.type ){
						case 'terrain': case 'solid': case 'joint': case 'ray': case 'articulation': this.motor.scenePlus.add( b ); break;
						default: this.motor.scene.add( b ); break;
					}
				}
				
			} else {
				parent.add( b );
			}

		}

		if( b.isInstance && b.refName !== b.name ) this.map.set( b.refName, b );

		this.map.set( b.name, b );

	}

	remove( b ) {

		if( b.dispose ) b.dispose();
		if( b.parent ) b.parent.remove( b );
		if( b.isInstance ) { 
			if( b.refName !== b.name ) this.map.delete( b.refName );
			b.instance.remove( b.id );
		}
		this.map.delete( b.name );

	}

	noRay( b ) {
		if( b.isObject3D ){
			b.raycast = () => {return};
			b.traverse( ( child ) => {
				if ( child.isObject3D ) child.raycast = () => {return};
			});
		}
	}

    morph ( obj, name, value ) {
        
        if(!obj.morphTargetInfluences) return
        if(obj.morphTargetDictionary[name] === undefined ) return
        obj.morphTargetInfluences[ obj.morphTargetDictionary[name] ] = value;
    
    }


    toLocal ( v, obj, isAxe = false ) {

    	//if( obj.isObject3D ) obj.updateWorldMatrix( true, false )
    	// apply position
    	if(!isAxe) v.sub( obj.position );
    	//v.multiply(obj.scale)
    	// apply invers rotation
    	let q = obj.quaternion;//.normalize();
    	//v.applyQuaternion(q.clone().invert())
    	//v.applyQuaternion({x:-q.x, y:-q.y, z:-q.z, w:q.w})
    	v.applyQuaternion({x:-q._x, y:-q._y, z:-q._z, w:q._w});
    	//if(isAxe) v.normalize()
    	return v

    }

    quatLocal ( q, obj ) {

    	if( obj.isObject3D ) obj.updateWorldMatrix( true, false );
    	// apply position
    	//if(!isAxe) v.sub( obj.position )
    	// apply invers rotation
    	let q1 = new Quaternion$1().fromArray(q);
    	let q2 = obj.quaternion.clone().invert();
    	q1.premultiply(q2);
    	//v.applyQuaternion({x:-q.x, y:-q.y, z:-q.z, w:q.w})
    	return q1.normalize().toArray();

    }

    axisLocal ( v, obj ) {

    	if( obj.isObject3D ) obj.updateWorldMatrix( true, false );
    	// apply position

        let m3 = new Matrix3().setFromMatrix4( obj.matrixWorld );//.invert()
        //m3.invert()
        let vv = new Vector3().fromArray(v).applyMatrix3( m3 );

        //let vv = new Vector3().fromArray(v).applyMatrix4( obj.matrixWorld.clone().invert() );

    	return vv.toArray()

    }


    quatToAngular ( qb, qa ) {

    	// invert
    	qa[0] *= -1;
    	qa[1] *= -1;
    	qa[2] *= -1;

    	let x = qa[0] * qb[3] + qa[3] * qb[0] + qa[1] * qb[2] - qa[2] * qb[1];
		let y = qa[1] * qb[3] + qa[3] * qb[1] + qa[2] * qb[0] - qa[0] * qb[2];
		let z = qa[2] * qb[3] + qa[3] * qb[2] + qa[0] * qb[1] - qa[1] * qb[0];
		let w = qa[3] * qb[3] - qa[0] * qb[0] - qa[1] * qb[1] - qa[2] * qb[2];

    	let angle = 2 * Math.acos(w), ax;
	    let s = Math.sqrt(1-w*w); // assuming quaternion normalised then w is less than 1, so term always positive.
	    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
	        // if s close to zero then direction of axis not important
	        // if it is important that axis is normalised then replace with x=1; y=z=0;
	        ax = [0,0,0];
	    } else {
	        //x = q[0] / s; // normalise axis
	        ax =  [x / s,y / s,z / s];
        }
    	
        const v = new Vector3().fromArray(ax);
    	const timeDiff = 1;//time2 - time1;
    	v.multiplyScalar( angle / timeDiff );

    	//console.log('result',v)

    }

    refAxis( m, axe ) {

    	let zAxis = new Vector3().fromArray(axe);
	    let xAxis = new Vector3(1, 0, 0);
	    let yAxis = new Vector3(0, 1, 0);
	    if ( Math.abs( axe[1] ) > 0.9999 ){
			yAxis.copy( xAxis ).cross( zAxis ).normalize();
		} else {
			xAxis.copy( zAxis ).cross( yAxis ).normalize();
			yAxis.copy( xAxis ).cross( zAxis ).normalize();
		}

		m.makeBasis( xAxis, yAxis, zAxis );

    }

}

//import { MotorOld } from './motor_old/MotorOld.js';


const phy$1 = new PhyEngine();

const z={getColor(t){let e=t.toString();e=e.substring(e.lastIndexOf(".")+1);let a,n=[255,255,255];switch(e){case "grass":n=[.223,.827,.325],a=[.741,.498,.258];break;case "dirt":n=[.741,.498,.258];break;case "leaves":n=[.152,.682,.376];break;case "sand":n=[.878,.819,.686];break;case "ice":n=[.65,.882,.96];break;case "stone":n=[.537,.64,.65];break;case "cobblestone":n=[.666,.647,.588];break;case "wood":n=[.603,.321,.152];break;case "snow":n=[.905,.976,1];}return a?[n[0],n[1],n[2],a[0],a[1],a[2]]:[n[0],n[1],n[2]]},fire:{type:"star",numParticles:20,position:[0,0,0],colors:[1,1,0,0,1,1,0,1,1,0,0,1,1,0,0,1,1,0,0,.5,0,0,0,0],lifeTime:2,timeRange:2,startSize:.3,endSize:.9,velocity:[0,.8,0],velocityRange:[.15,.15,.15],gravity:[0,-0.2,0],spinSpeedRange:4},smoke:{position:[-2,-0.2,0],colors:[0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0],numParticles:20,lifeTime:2,timeRange:2,startSize:.5,endSize:2,velocity:[0,1.6,0],velocityRange:[.2,0,.2],gravity:[0,-0.25,0],spinSpeedRange:4,blending:"normal"},addBlock:{type:"cube",numParticles:30,lifeTime:1.5,endTime:1.5,startTime:0,startSize:.25,endSize:.5,sizeRange:.25,spinSpeedRange:2,radius:.25,velocity:[1,0,1],velocityRange:[.25,0,.25],acceleration:[1,0,1],accelerationRange:[.25,0,.25],gravity:[0,.05,0],tween:"outQuad",blending:"normal",alphaTest:.1},removeBlock:{type:"cube",lifeTime:1.5,endTime:1.5,startTime:0,startSize:.5,sizeRange:.25,endSize:.1,spinSpeedRange:2,accelerationRange:[.5,.5,.5],gravity:[0,-0.1,0],tween:"outQuad",blending:"normal",alphaTest:.1},explosion:{colors:[1,0,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,1,1,.5,1,1,1,0],type:"cloud",radius:.5,radiusRange:.5,numParticles:400,positionRange:[2,1,2],lifeTime:3,endTime:4,lifeTimeRange:1,startTime:0,startSize:.1,endSize:2,sizeRange:1,accelerationRange:[1,.3,1],acceleration:[.8,.8,.8],gravity:[0,-0.5,0],spinSpeedRange:2,luma:false},playerMove:{trail:true,colors:[1,1,1,1,.2,.2,.2,0],type:"round",blending:"normal",numParticles:4,maxParticles:1e3,positionRange:[.2,0,.2],lifeTime:1.5,startSize:.5,endSize:1,sizeRange:.25,velocityRange:[.6,0,.6],gravity:[0,.1,0]},vehicleMove:{trail:true,colors:[.5,.5,.5,.25,.2,.2,.2,0],type:"round",blending:"normal",numParticles:4,maxParticles:2e3,positionRange:[.25,0,.25],lifeTime:1.5,startSize:.5,endSize:1,sizeRange:.25,velocityRange:[.6,0,.6],gravity:[0,.2,0]},vehicleTrack:{trail:true,colors:[.2,.2,.2,.1,.2,.2,.2,0],type:"Round2",blending:"normal",startSize:.3,endSize:.3,numParticles:4,maxParticles:2e3,position:[0,-0.1,0],lifeTime:6,oriented:true},underWater:{trail:true,colors:[1,1,1,1,.5,.5,1,0],type:"bubble",blending:"normal",numParticles:1,maxParticles:1e3,positionRange:[.25,0,.25],lifeTime:1.5,startSize:.1,endSize:.5,sizeRange:.05,velocity:[0,1,0],velocityRange:[1,0,1],acceleration:[.2,0,.2],gravity:[0,1,0]},bazookaFire:{trail:true,colors:[1,0,0,1,1,1,0,.5,1,1,1,0],type:"round",numParticles:2,maxParticles:600,positionRange:[.1,.1,.1],lifeTime:1.5,startSize:.5,endSize:1,sizeRange:.1,velocityRange:[.6,.6,.6],gravity:[0,.1,0],luma:false}},P=["pixel","basic","cube","cloud","round","round2","donut","bubble","smoke","circle","field","star","octo"];function R(){this.parent=null,this.position=[0,0,0],this.rotation=[0,0,0],this.name="default",this.type="round",this.tween="linear",this.trail=false,this.model="",this.numParticles=1,this.maxParticles=0,this.numFrames=1,this.frameDuration=1,this.frameStart=0,this.frameStartRange=0,this.timeRange=99999999,this.startTime=null,this.lifeTime=1,this.endTime=-1,this.lifeTimeRange=0,this.sizeRange=0,this.startSize=1,this.startSizeRange=0,this.endSize=1,this.endSizeRange=0,this.pposition=[0,0,0],this.positionRange=[0,0,0],this.velocity=[0,0,0],this.velocityRange=[0,0,0],this.acceleration=[0,0,0],this.accelerationRange=[0,0,0],this.spinStart=0,this.spinStartRange=0,this.spinSpeed=0,this.spinSpeedRange=0,this.colorMult=[1,1,1,1],this.colorMultRange=[0,0,0,0],this.worldVelocity=[0,0,0],this.gravity=[0,0,0],this.oriented=false,this.orientation=[0,0,0,1],this.colors=[1,1,1,1],this.blending="additive",this.radius=0,this.axis="Y",this.radiusRange=0,this.tmpRotation=null,this.alphaTest=0,this.renderOrder=0,this.luma=true,this.depthWrite=false,this.transparent=true;}const C={torad:Math.PI/180,todeg:180/Math.PI,random:()=>Math.random(),rand:(t,e)=>t+C.random()*(e-t),randInt:(t,e)=>t+Math.floor(C.random()*(e-t+1)),plusMinus:t=>(C.random()-.5)*t*2,plusMinusVector:t=>{const e=[];let a=t.length;for(;a--;)e.push(C.plusMinus(t[a]));return e},toTexture:t=>{let e=new Texture(t);return e.minFilter=LinearFilter,e.magFilter=LinearFilter,e.flipY=false,e.colorSpace=SRGBColorSpace,e.needsUpdate=true,e},createTextureFromFloats:(n,i,r,o)=>{let s=null;if(null==o){const o=new Uint8Array(r.length);let l;for(let t=0;t<r.length;t++)l=255*r[t],o[t]=l;return s=new DataTexture(o,n,i,RGBAFormat),s.minFilter=LinearFilter,s.magFilter=LinearFilter,s.needsUpdate=true,s}return s=o,s}},M=function(t){let e;switch(t){case "linear":e="float tween( float k ) { return k; }";break;case "inQuad":e="float tween( float k ) { return k * k; }";break;case "outQuad":e="float tween( float k ) { return k * ( 2.0 - k ); }";break;case "inOutQuad":e="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0 ) return 0.5 * k * k;\n            return - 0.5 * ( --k * ( k - 2.0 ) - 1.0 ); \n        }";break;case "inCubic":e="float tween( float k ) { return k * k * k; }";break;case "outCubic":e="float tween( float k ) { return --k * k * k + 1.0; }";break;case "inOutCubic":e="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0 ) return 0.5 * k * k * k;\n\t\t\treturn 0.5 * ( ( k -= 2.0 ) * k * k + 2.0 ); \n        }";break;case "inQuart":e="float tween( float k ) { return k * k * k * k; }";break;case "outQuart":e="float tween( float k ) { return 1.0 - ( --k * k * k * k ); }";break;case "inOutQuart":e="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0) return 0.5 * k * k * k * k;\n\t\t\treturn - 0.5 * ( ( k -= 2.0 ) * k * k * k - 2.0 ); \n        }";break;case "inQuint":e="float tween( float k ) { return k * k * k * k * k; }";break;case "outQuint":e="float tween( float k ) { return --k * k * k * k * k + 1.0; }";break;case "inOutQuint":e="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0 ) return 0.5 * k * k * k * k * k;\n\t\t\treturn 0.5 * ( ( k -= 2.0 ) * k * k * k * k + 2.0 );\n        }";break;case "inSine":e="#define PI_90 1.570796326794896\n        float tween( float k ) { float j = k * PI_90; return 1.0 - cos( j ); }";break;case "outSine":e="#define PI_90 1.570796326794896\n\t\tfloat tween( float k ) { float j = k * PI_90; return sin( j ); }";break;case "inOutSine":e="#define M_PI 3.14159265358979323846\n\t\tfloat tween( float k ) { \n\t\t\tfloat j = k * M_PI; return 0.5 * (1.0-cos(j));\n        }";break;case "inExpo":e="float tween( float k ) { return k == 0.0 ? 0.0 : pow( 1024.0, k - 1.0 ); }";break;case "outExpo":e="float tween( float k ) { return k == 1.0 ? 1.0 : 1.0 - pow( 2.0, - 10.0 * k ); }";break;case "inOutExpo":e="float tween( float k ) { \n\t\t\tif ( k == 0.0 ) return 0.0;\n\t\t    if ( k == 1.0 ) return 1.0;\n\t\t    if ( ( k *= 2.0 ) < 1.0 ) return 0.5 * pow( 1024.0, k - 1.0 );\n\t\t    return 0.5 * ( - pow( 2.0, - 10.0 * ( k - 1.0 ) ) + 2.0 );\n        }";break;case "inCirc":e="float tween( float k ) { return 1.0 - sqrt( 1.0 - k * k ); }";break;case "outCirc":e="float tween( float k ) { return sqrt( 1.0 - ( --k * k ) ); }";break;case "inOutCirc":e="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0) return - 0.5 * ( sqrt( 1.0 - k * k ) - 1.0 );\n\t\t\treturn 0.5 * ( sqrt( 1.0 - ( k -= 2.0 ) * k ) + 1.0 ); \n        }";break;case "inElastic":e="#define TWO_PI 6.28318530717958647692\n        float tween(float k) {\n\t\t    float s;\n\t\t    float a = 0.1;\n\t\t    float p = 0.4;\n\t\t    if ( k == 0.0 ) return 0.0;\n\t\t    if ( k == 1.0 ) return 1.0;\n\t\t    if ( a < 1.0 ) { a = 1.0; s = p * 0.25; }\n\t\t    else s = p * asin( 1.0 / a ) / TWO_PI;\n\t\t    return - ( a * pow( 2.0, 10.0 * ( k -= 1.0 ) ) * sin( ( k - s ) * TWO_PI / p ) );\n\t\t}";break;case "outElastic":e="#define TWO_PI 6.28318530717958647692\n\t\tfloat tween(float k) {\n\t\t    float s;\n\t\t    float a = 0.1; \n\t\t    float p = 0.4;\n\t\t    if ( k == 0.0 ) return 0.0;\n\t\t    if ( k == 1.0 ) return 1.0;\n\t\t    if ( a < 1.0 ) { a = 1.0; s = p * 0.25; }\n\t\t    else s = p * asin( 1.0 / a ) / TWO_PI;\n\t\t    return ( a * pow( 2.0, - 10.0 * k) * sin( ( k - s ) * TWO_PI / p ) + 1.0 );\n\t\t}";break;case "inOutElastic":e="#define TWO_PI 6.28318530717958647692\n\t\tfloat tween(float k) {\n\t\t    float s;\n\t\t    float a = 0.1;\n\t\t    float p = 0.4;\n\t\t    if ( k == 0.0 ) return 0.0;\n\t\t    if ( k == 1.0 ) return 1.0;\n\t\t    if ( a < 1.0 ) { a = 1.0; s = p * 0.25; }\n\t\t    else s = p * asin( 1.0 / a ) / TWO_PI;\n\t\t    if ( ( k *= 2.0 ) < 1.0 ) return - 0.5 * ( a * pow( 2.0, 10.0 * ( k -= 1.0 ) ) * sin( ( k - s ) * TWO_PI / p ) );\n\t\t    return a * pow( 2.0, -10.0 * ( k -= 1.0 ) ) * sin( ( k - s ) * TWO_PI / p ) * 0.5 + 1.0;\n\t\t}";break;case "inBack":e="float tween(float k) {\n\t\t    float s = 1.70158;\n\t\t    return k * k * ( ( s + 1.0 ) * k - s );\n\t\t}";break;case "outBack":e="float tween(float k) {\n\t\t    float s = 1.70158;\n\t\t    return --k * k * ( ( s + 1.0 ) * k + s ) + 1.0;\n\t\t}";break;case "inOutBack":e="float tween(float k) {\n\t\t    float s = 1.70158 * 1.525;\n\t\t    if ( ( k *= 2.0 ) < 1.0 ) return 0.5 * ( k * k * ( ( s + 1.0 ) * k - s ) );\n\t\t    return 0.5 * ( ( k -= 2.0 ) * k * ( ( s + 1.0 ) * k + s ) + 2.0 );\n\t\t}";break;case "inBounce":e="float outBounce(float k) {\n\t\t    if ( k < ( 1.0 / 2.75 ) ) return 7.5625 * k * k;\n\t\t    else if ( k < ( 2.0 / 2.75 ) ) return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\n\t\t    else if ( k < ( 2.5 / 2.75 ) ) return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\n\t\t    else return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\n\t\t}\n\t\tfloat tween(float k) { return 1.0 - outBounce( 1.0 - k ); }";break;case "outBounce":e="float tween(float k) {\n\t\t    if ( k < ( 1.0 / 2.75 ) ) return 7.5625 * k * k;\n\t\t    else if ( k < ( 2.0 / 2.75 ) ) return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\n\t\t    else if ( k < ( 2.5 / 2.75 ) ) return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\n\t\t    else return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\n\t\t}";break;case "inOutBounce":e="float outBounce(float k) {\n\t\t    if ( k < ( 1.0 / 2.75 ) ) return 7.5625 * k * k;\n\t\t    else if ( k < ( 2.0 / 2.75 ) ) return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\n\t\t    else if ( k < ( 2.5 / 2.75 ) ) return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\n\t\t    else return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\n\t\t}\n\t\tfloat inBounce(float k) { return 1.0 - outBounce( 1.0 - k ); }\n\t\tfloat tween(float k) {\n\t\t    if ( k < 0.5 ) return inBounce( k * 2.0 ) * 0.5;\n\t\t    return outBounce( k * 2.0 - 1.0 ) * 0.5 + 0.5;\n\t\t}";}return e},B=[[-0.5,-0.5],[.5,-0.5],[.5,.5],[-0.5,.5]],E=28,I=new Float32Array(28);class O extends Points{constructor(t,e){super(),this.pe=t,this.count=0,this.color=null,this.texture=null,this.localTime=0,this.time=0,this.endTime=-1,this.num=0,this.matrixAutoUpdate=false,this.frustumCulled=false,this.receiveShadow=false,this.castShadow=false,this.birthIndex=0,this.luma=true,e&&this.setParameters(e);}setParameters(t){this.validateParameters(t),this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose(),this.name=t.name,this.isTrail=t.trail||false,this.parameters=t;const e=this.isTrail?t.maxParticles:t.numParticles;this.allocateParticles_(e,t),this.isTrail||this.createParticles_(0,e,t),t.parent?t.parent.add(this):this.pe.scene.add(this);}makeGeometry(t){this.geometry=t.oriented?new InstancedBufferGeometry:new BufferGeometry,this.isMesh=t.oriented;}setColorRamp(t){const e=t.length/4;if(e%1!=0)throw "colorRamp must have multiple of 4 entries";this.color=C.createTextureFromFloats(e,1,t);}validateParameters(t){var e=new R;for(let a in t)if(void 0===e[a])throw 'unknown particle parameter "'+a+'"';for(let a in e) void 0===t[a]&&(t[a]=e[a]);}perParticle(t,e){}birthParticles(t,e){var a=this.parameters.numParticles;this.parameters.pposition=t,this.parameters.startTime=this.time,this.endTime=this.time+this.parameters.lifeTime,e&&this.setColorRamp(e),this.createParticles_(this.birthIndex,a,this.parameters),this.birthIndex+=a,this.birthIndex+a>=this.parameters.maxParticles&&(this.birthIndex=0);}createParticles_(t,e,a){const n=C.plusMinus,i=C.plusMinusVector,r=this.interleavedBuffer.array;let o,s=e;for(;s--;){this.perParticle(s,a);let m=a.lifeTime+n(a.lifeTimeRange),f=null===a.startTime?s*a.lifeTime/e:a.startTime,h=a.frameStart+n(a.frameStartRange),p=(new Vector3).addVectors((new Vector3).fromArray(a.pposition),(new Vector3).fromArray(i(a.positionRange))),g=(new Vector3).addVectors((new Vector3).fromArray(a.velocity),(new Vector3).fromArray(i(a.velocityRange))),k=(new Vector3).addVectors((new Vector3).fromArray(a.acceleration),(new Vector3).fromArray(i(a.accelerationRange))),b=(new Vector4).addVectors((new Vector4).fromArray(a.colorMult),(new Vector4).fromArray(i(a.colorMultRange))),v=a.spinStart+n(a.spinStartRange),w=a.spinSpeed+n(a.spinSpeedRange),y=a.startSize+n(a.sizeRange||a.startSizeRange),S=a.endSize+n(a.sizeRange||a.endSizeRange),x=(new Vector4).fromArray(a.orientation);if(a.positionRange[0],a.positionRange[1],a.positionRange[2],a.radius){let t=a.axis||"Y",e=C.rand(0,2*Math.PI);a.tmpRotation=[90,-e*C.todeg,90,"YXZ"];let i=a.radius+n(a.radiusRange),r=Math.cos(e),o=Math.sin(e),s=new Vector3;switch(t){case "X":s.y=r,s.z=o;break;case "Y":s.x=r,s.z=o;break;case "Z":s.x=r,s.y=o;}switch(s.multiplyScalar(i),t){case "X":s.x=1;break;case "Y":s.y=1;break;case "Z":s.z=1;}k.multiply(s),g.multiply(s);}a.tmpRotation&&(x=(new Quaternion$1).setFromEuler(new Euler(a.tmpRotation[0]*C.torad,a.tmpRotation[1]*C.torad,a.tmpRotation[2]*C.torad,a.tmpRotation[3])));o=0+s*E*4+t*E*4,r[0+o]=p.x,r[0+o+1]=p.y,r[0+o+2]=p.z,r[0+o+3]=f,r[4+o]=B[0][0],r[4+o+1]=B[0][1],r[4+o+2]=m,r[4+o+3]=h,r[8+o]=g.x,r[8+o+1]=g.y,r[8+o+2]=g.z,r[8+o+3]=y,r[12+o]=k.x,r[12+o+1]=k.y,r[12+o+2]=k.z,r[12+o+3]=S,r[16+o]=v,r[16+o+1]=w,r[16+o+2]=0,r[16+o+3]=0,r[20+o]=x.x,r[20+o+1]=x.y,r[20+o+2]=x.z,r[20+o+3]=x.w,r[24+o]=b.x,r[24+o+1]=b.y,r[24+o+2]=b.z,r[24+o+3]=b.w;}this.interleavedBuffer.needsUpdate=true,this.material.uniforms.worldVelocity.value.fromArray(a.worldVelocity),this.material.uniforms.gravity.value.fromArray(a.gravity),this.material.uniforms.timeRange.value=a.timeRange,this.material.uniforms.frameDuration.value=a.frameDuration,this.material.uniforms.numFrames.value=a.numFrames,this.material.uniforms.rampSampler.value=this.color,this.material.uniforms.colorSampler.value=this.texture,this.material.blending="normal"===a.blending?NormalBlending:AdditiveBlending,this.updateMatrix();}allocateParticles_(t,e){if(this.count!==t){if(e.oriented||(e.oriented=false),e.position&&this.position.fromArray(e.position),e.rotation&&this.quaternion.setFromEuler(new Euler(e.rotation[0]*C.torad,e.rotation[1]*C.torad,e.rotation[2]*C.torad)),this.setColorRamp(e.colors),this.pe.textures.has(e.type)||-1!==P.indexOf(e.type)&&this.pe.textures.make(e.type),this.texture=this.pe.textures.get(e.type),this.texture||console.log("this texture is undefined !!"),this.endTime=e.endTime||-1,this.luma=e.luma,this.makeGeometry(e),this.count=t,e.oriented){var a=new InterleavedBuffer(new Float32Array([0,0,0,0,-0.5,-0.5,0,0,0,0,0,0,.5,-0.5,0,0,0,0,0,0,.5,.5,0,0,0,0,0,0,-0.5,.5,0,0]),8);this.geometry.setAttribute("position",new InterleavedBufferAttribute(a,3,0)),this.geometry.setAttribute("uv",new InterleavedBufferAttribute(a,2,4)),this.geometry.setIndex(new BufferAttribute(new Uint16Array([0,1,2,0,2,3]),1)),this.interleavedBuffer=new InstancedInterleavedBuffer(new Float32Array(t*I.byteLength),E,1).setUsage(DynamicDrawUsage);}else this.interleavedBuffer=new InterleavedBuffer(new Float32Array(t*I.byteLength),E).setUsage(DynamicDrawUsage);this.geometry.setAttribute("position",new InterleavedBufferAttribute(this.interleavedBuffer,3,0)),this.geometry.setAttribute("startTime",new InterleavedBufferAttribute(this.interleavedBuffer,1,3)),this.geometry.setAttribute("uvLifeTimeFrameStart",new InterleavedBufferAttribute(this.interleavedBuffer,4,4)),this.geometry.setAttribute("velocityStartSize",new InterleavedBufferAttribute(this.interleavedBuffer,4,8)),this.geometry.setAttribute("accelerationEndSize",new InterleavedBufferAttribute(this.interleavedBuffer,4,12)),this.geometry.setAttribute("spinStartSpinSpeed",new InterleavedBufferAttribute(this.interleavedBuffer,4,16)),this.geometry.setAttribute("orientation",new InterleavedBufferAttribute(this.interleavedBuffer,4,20)),this.geometry.setAttribute("colorMult",new InterleavedBufferAttribute(this.interleavedBuffer,4,24)),this.geometry.boundingSphere=new Sphere,this.geometry.boundingSphere.radius=3;let i=AdditiveBlending;switch(e.blending){case "sub":case "subtractive":i=SubtractiveBlending;break;case "multi":case "multiply":i=MultiplyBlending;break;case "normal":i=NormalBlending;break;default:i=AdditiveBlending;}var n={worldVelocity:{value:new Vector3},gravity:{value:new Vector3},timeRange:{value:0},time:{value:0},timeOffset:{value:0},frameDuration:{value:0},numFrames:{value:0},rampSampler:{value:null},colorSampler:{value:null},scale:{value:.5*window.innerHeight},luma:{value:this.luma?this.pe.luminosity:1},alphaTest:{value:e.alphaTest}};this.material=new ShaderMaterial({defines:{USE_ORIENTATION:e.oriented},uniforms:n,vertexShader:(this.pe.isGl2?"":"\nmat4 inverse(mat4 m) {\n\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3], a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3], a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3], a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n    b00 = a00 * a11 - a01 * a10,\n    b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,\n    b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,\n    b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,\n    b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,\n    b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,\n    b11 = a22 * a33 - a23 * a32,\n\n  det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4( a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03, a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07, a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06, a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00, a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n")+M(e.tween||"linear")+"\nprecision mediump float;\nprecision mediump int;\n\n#ifdef USE_ORIENTATION\n\t//uniform mat4 worldViewProjection;\n\t//uniform mat4 world;\n\tattribute vec3 offset;\n\tattribute vec4 orientation;\n#else\n    uniform float scale;\n#endif\n\nuniform vec3 worldVelocity;\nuniform vec3 gravity;\nuniform float timeRange;\nuniform float time;\nuniform float timeOffset;\nuniform float frameDuration;\nuniform float numFrames;\n\nattribute vec4 uvLifeTimeFrameStart;\nattribute float startTime;\nattribute vec4 velocityStartSize;\nattribute vec4 accelerationEndSize;\nattribute vec4 spinStartSpinSpeed;\nattribute vec4 colorMult;\n\nvarying vec2 outputTexcoord;\nvarying float outputPercentLife;\nvarying vec4 outputColorMult;\nvarying mat2 rotationMtx;\n\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n//#include <clipping_planes_pars_vertex>\n\nvec3 lerp( vec3 a, vec3 b, float p ){ return a + (b - a) * p; }\n\nvoid main() \n{\n    float lifeTime = uvLifeTimeFrameStart.z;\n    float frameStart = uvLifeTimeFrameStart.w;\n    float startSize = velocityStartSize.w;\n\n    //vec3 velocity = (modelMatrix * vec4(velocityStartSize.xyz, 0.0)).xyz + worldVelocity;\n\t//vec3 acceleration = (modelMatrix * vec4(accelerationEndSize.xyz, 0.0)).xyz + gravity;\n\n    //vec3 velocity = velocityStartSize.xyz + worldVelocity;\n\t//vec3 acceleration = accelerationEndSize.xyz + gravity;\n\n\tvec3 velocity = velocityStartSize.xyz + (inverse(modelMatrix) * vec4(worldVelocity, 0.0)).xyz;\n\tvec3 acceleration = accelerationEndSize.xyz + (inverse(modelMatrix) * vec4(gravity, 0.0)).xyz;\n\n    float endSize = accelerationEndSize.w;\n    float spinStart = spinStartSpinSpeed.x;\n    float spinSpeed = spinStartSpinSpeed.y;\n\n    float localTime = mod((time - timeOffset - startTime), timeRange);\n    //localTime = tween( localTime );\n    float percentLife = localTime / lifeTime;\n    percentLife = tween( percentLife );\n\n    vec3 posEnd = velocity * lifeTime + acceleration * lifeTime * lifeTime;\n\n    float frame = mod(floor(localTime / frameDuration + frameStart), numFrames);\n    float uOffset = frame / numFrames;\n    float u = uOffset + (uv.x + 0.5) * (1. / numFrames);\n\n    outputTexcoord = vec2(u, uv.y + 0.5);\n    outputColorMult = colorMult;\n\n    float size = mix(startSize, endSize, percentLife);\n\tsize = (percentLife < 0. || percentLife > 1.0) ? 0.0 : size;\n\n\tfloat s = sin(spinStart + spinSpeed * localTime);\n\tfloat c = cos(spinStart + spinSpeed * localTime);\n\n    #ifdef USE_ORIENTATION\n\t\t\n\t\tvec4 rotatedPoint = vec4((uv.x * c + uv.y * s) * size, 0., (uv.x * s - uv.y * c) * size, 1.);\n\t\t//vec3 center = velocity * localTime + acceleration * localTime * localTime + position + offset;\n\t\tvec3 center = (posEnd * percentLife) + position + offset;\n\n\t\tvec4 q2 = orientation + orientation;\n\t\tvec4 qx = orientation.xxxw * q2.xyzx;\n\t\tvec4 qy = orientation.xyyw * q2.xyzy;\n\t\tvec4 qz = orientation.xxzw * q2.xxzz;\n\n\t\tmat4 localMatrix = mat4(\n\t\t    (1.0 - qy.y) - qz.z,  qx.y + qz.w,  qx.z - qy.w, 0,\n\t\t    qx.y - qz.w, (1.0 - qx.x) - qz.z, qy.z + qx.w, 0,\n\t\t    qx.z + qy.w, qy.z - qx.w, (1.0 - qx.x) - qy.y, 0,\n\t\t    center.x, center.y, center.z, 1\n\t\t);\n\t\trotatedPoint = localMatrix * rotatedPoint;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * rotatedPoint;\n\n\t#else\n\n\t    //vec3 pos = position + velocity * localTime + acceleration * localTime * localTime;\n\n\t    vec3 pos = (posEnd * percentLife) + position;\n\t    \n\t    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n        //gl_PointSize = size * 1.5 * ( scale / length( mvPosition.xyz ) );\n        gl_PointSize = size * 1.5 * ( scale / - mvPosition.z );\n\n        mat2 r = mat2( c, -s, s, c);\n        r *= 0.5; r += 0.5;  r = r * 2.0 - 1.0;\n        rotationMtx = r;\n\n        gl_Position = projectionMatrix * mvPosition;\n\n\t#endif\n\n\toutputPercentLife = percentLife;\n\n\t#include <logdepthbuf_vertex>\n\t//#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",fragmentShader:"\nprecision mediump float;\nprecision mediump int;\n\nuniform sampler2D rampSampler;\nuniform sampler2D colorSampler;\nuniform float luma;\nuniform float alphaTest;\n\nvarying vec2 outputTexcoord;\nvarying float outputPercentLife;\nvarying vec4 outputColorMult;\nvarying mat2 rotationMtx;\n\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n//#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t//#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\n\tvec4 diffuseColor = texture2D( rampSampler, vec2(outputPercentLife, 0.5) ) * outputColorMult;\n\n    vec2 uv = vec2(0.0);\n    #ifdef USE_ORIENTATION\n        uv = outputTexcoord;\n\t#else\n\t    uv = gl_PointCoord;\n\t    uv -= 0.5; uv = uv * rotationMtx; uv += 0.5;\n\t#endif\n\n\t// texture\n\tdiffuseColor *= texture2D( colorSampler, uv );\n\n\tif ( diffuseColor.a < alphaTest ) discard;\n\n\tdiffuseColor.rgb *= luma;\n\n\tgl_FragColor = diffuseColor; \n\t#include <fog_fragment>\n\n}\n",side:e.oriented?DoubleSide:FrontSide,blending:i,depthTest:true,depthWrite:e.depthWrite,transparent:e.transparent,forceSinglePass:true}),this.renderOrder=e.renderOrder||0;}}draw(t=0){if(!this.material.uniforms)return;const e=this.material.uniforms;this.time+=this.pe.delta,e.time.value=this.time,e.timeOffset.value=t,e.scale.value=this.pe.hscale,e.luma.value=this.luma?this.pe.luminosity:1,-1!==this.endTime&&this.time>=this.endTime&&this.pe.remove(this.name);}dispose(){this.parent.remove(this),this.geometry.dispose(),this.material.dispose(),this.color.dispose();}raycast(){}clone(t){return void 0===t&&(t=this.pe.createEmitter(this.texture)),t.time=0,t.endTime=this.endTime,t.geometry=this.geometry,t.material=this.material.clone(),t.material.uniforms.rampSampler.value=this.color,t.material.uniforms.colorSampler.value=this.texture,super.copy(t),this.num++,t.name=this.name+this.num,t}}class F extends Map{constructor(){super();}dispose(){this.forEach((t=>{t.dispose();})),this.clear();}add(t,e){this.has(t)||this.set(t,e);}make(t){if(!this.has(t)){let e=this["make"+t[0].toUpperCase()+t.substring(1)]();this.set(t,e);}}makePixel(){const t=[];for(let e=0;e<2;++e)for(let e=0;e<2;++e)t.push(1,1,1,1);return C.createTextureFromFloats(2,2,t)}makeBasic(){const t=[0,.2,.7,1,.7,.2,0,0],e=[];for(let a=0;a<8;++a)for(let n=0;n<8;++n){let i=t[n]*t[a];e.push(i,i,i,1);}return C.createTextureFromFloats(8,8,e)}makeCube(){let t=document.createElement("canvas");t.width=t.height=8;const e=t.getContext("2d");return e.fillStyle="rgba(255,255,255,1.0)",e.fillRect(2,2,4,4),C.toTexture(t)}makeCloud(){let t=16,e=document.createElement("canvas");e.width=e.height=t;const a=e.getContext("2d");let n="rgba(255,255,255,1)",i="rgba(255,255,255,0)",r=a.createRadialGradient(8,6.4,0,8,6.4,6.4);return r.addColorStop(.3,n),r.addColorStop(1,i),a.fillStyle=r,a.fillRect(0,0,t,t),r=a.createRadialGradient(6.4,9.92,0,6.4,9.92,5.6),r.addColorStop(.3,n),r.addColorStop(1,i),a.fillStyle=r,a.fillRect(0,0,t,t),r=a.createRadialGradient(4.32,6.4,0,4.32,6.4,4.16),r.addColorStop(.2,n),r.addColorStop(1,i),a.fillStyle=r,a.fillRect(0,0,t,t),r=a.createRadialGradient(12.16,9.6,0,12.16,9.6,3.68),r.addColorStop(.2,n),r.addColorStop(1,i),a.fillStyle=r,a.fillRect(0,0,t,t),C.toTexture(e)}makeRound(){let t=16,e=document.createElement("canvas");e.width=e.height=t;const a=e.getContext("2d"),n=a.createRadialGradient(8,8,0,8,8,8);return n.addColorStop(0,"rgba(255,255,255,1)"),n.addColorStop(.3,"rgba(255,255,255,0.1)"),n.addColorStop(.9,"rgba(255,255,255,0)"),n.addColorStop(1,"rgba(255,255,255,0)"),a.fillStyle=n,a.fillRect(0,0,t,t),C.toTexture(e)}makeRound2(){let t=16,e=document.createElement("canvas");e.width=e.height=t;const a=e.getContext("2d"),n=a.createRadialGradient(8,8,0,8,8,8);return n.addColorStop(0,"rgba(255,255,255,1)"),n.addColorStop(.9,"rgba(255,255,255,1)"),n.addColorStop(1,"rgba(255,255,255,0)"),a.fillStyle=n,a.fillRect(0,0,t,t),C.toTexture(e)}makeDonut(){let t=32,e=document.createElement("canvas");e.width=e.height=t;const a=e.getContext("2d"),n=a.createRadialGradient(16,16,0,16,16,16);return n.addColorStop(0,"rgba(255,255,255,1)"),n.addColorStop(.9,"rgba(255,255,255,0.1)"),n.addColorStop(1,"rgba(255,255,255,0)"),a.fillStyle=n,a.beginPath(),a.arc(16,16,16,0,2*Math.PI,false),a.arc(16,16,8,0,2*Math.PI,true),a.fill(),C.toTexture(e)}makeBubble(){let t=64,e=document.createElement("canvas");e.width=e.height=t;let a="rgba(0,255,255,0)";const n=e.getContext("2d"),i=n.createRadialGradient(25.6,25.6,0,32,32,32);return i.addColorStop(.4,a),i.addColorStop(.9,"rgba(0,255,255,0.6)"),i.addColorStop(.99,"rgba(0,255,255,1)"),i.addColorStop(1,a),n.fillStyle=i,n.fillRect(0,0,t,t),n.fillStyle="rgba(255,255,255,1)",n.beginPath(),n.arc(44.8,25.6,8.96,0,2*Math.PI,false),n.fill(),n.beginPath(),n.arc(12.8,41.6,3.2,0,2*Math.PI,false),n.fill(),C.toTexture(e)}makeSmoke(){let t=document.createElement("canvas");t.width=t.height=64;const e=t.getContext("2d");let a=new Image;a.src=q;let n=C.toTexture(t);return a.onload=function(){e.drawImage(a,0,0),n.needsUpdate=true;},n}makeCircle(){let t=document.createElement("canvas");t.width=t.height=64;const e=t.getContext("2d");return e.strokeStyle="white",e.lineWidth=4,e.beginPath(),e.arc(32,32,30,0,2*Math.PI),e.stroke(),C.toTexture(t)}makeField(){let t=64,e=document.createElement("canvas");e.width=e.height=t;const a=e.getContext("2d"),n=a.createLinearGradient(0,0,0,t);return n.addColorStop(0,"rgba(255,255,255,0)"),n.addColorStop(.8,"rgba(255,255,255,0.4)"),n.addColorStop(1,"rgba(255,255,255,0)"),a.fillStyle=n,a.fillRect(24,0,16,t),C.toTexture(e)}makeStar(){let t=64,e=document.createElement("canvas");e.width=e.height=t;const a=e.getContext("2d"),n=a.createRadialGradient(32,32,0,32,32,32);return n.addColorStop(0,"rgba(255,255,255,0.5)"),n.addColorStop(.5,"rgba(255,255,255,0.1)"),n.addColorStop(.9,"rgba(255,255,255,0)"),a.fillStyle=n,this.star(a,32,6.4,32,32,3),this.star(a,32,25.6,32,32,3),C.toTexture(e)}makeOcto(){let t=64,e=document.createElement("canvas");e.width=e.height=t;const a=e.getContext("2d"),n=a.createRadialGradient(32,32,0,32,32,32);return n.addColorStop(.4,"rgba(255,255,255,0.2)"),n.addColorStop(1,"rgba(255,255,255,0.4)"),a.fillStyle=n,this.star(a,25.6,22.4,32,32,6),a.strokeStyle="rgba(255,255,255,0.1)",a.lineWidth=6,a.stroke(),C.toTexture(e)}star(t,e,a,n,i,r){let o,s,l;t.beginPath(),t.moveTo(n+e,i);for(var c=1;c<=2*r;c++)c%2==0?(l=c*(2*Math.PI)/(2*r),o=n+e*Math.cos(l),s=i+e*Math.sin(l)):(l=c*(2*Math.PI)/(2*r),o=n+a*Math.cos(l),s=i+a*Math.sin(l)),t.lineTo(o,s);t.closePath(),t.fill();}}const q="data:image/png;base64,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\nJRU5ErkJggg==";class D{constructor(t,e){this.scene=t,this.isGl2=true,this.emitters=new Map,this.textures=new F,this.loader=null,this.now=0,this.last=0,this.delta=0,this.num=0,this.hscale=.5*window.innerHeight,this.luminosity=1;}get(t){return this.emitters.has(t)?this.emitters.get(t):null}add(t,e){t.name||(t.name="PP"+this.num++),this.remove(t.name),t.model&&z[t.model]&&(t={...z[t.model],...t});let a=new O(this,t);return this.emitters.set(t.name,a),a}addTexture(t,e,a=true){this.textures.has(t)?console.log("this name of texture is already take !"):"string"==typeof e?(this.loader||(this.loader=new TextureLoader),this.loader.load(e,(e=>{e.flipY=false,a&&(e.colorSpace=SRGBColorSpace),this.textures.add(t,e);}))):e.isTexture&&(e.flipY=false,this.textures.add(t,e));}load(t){const e=t.substring(t.lastIndexOf("/")+1,t.lastIndexOf("."));var a=new XMLHttpRequest;a.open("GET",t),a.onreadystatechange=function(){if(4===a.readyState)if(200===a.status||0===a.status){let t=JSON.parse(a.responseText);for(let e in t)this.add(t[e]);}else console.error("Couldn't load ["+e+"] ["+a.status+"]");}.bind(this),a.send();}remove(t){this.emitters.has(t)&&(this.emitters.get(t).dispose(),this.emitters.delete(t));}onresize(t){this.hscale=.5*t;}loop(t){this.delta=t,this.emitters.forEach((t=>{t.draw();}));}update(t){this.now=void 0!==t?t:Date.now(),this.delta=.001*(this.now-this.last),this.last=this.now,this.emitters.forEach((t=>{t.draw();}));}dispose(t=true){this.emitters.forEach((t=>{t.dispose();})),this.emitters.clear(),t&&this.textures.dispose(),this.num=0;}addBlock(t,e){let a=t[1]<=4?-2:0,n=z.getColor(e),i=n[0],r=n[1],o=n[2];n.length>3&&(i=n[3],r=n[4],o=n[5]),t[0]+=.5,t[2]+=.5,this.add({position:t,colors:[i,r,o,1,i,r,o,0],renderOrder:a,...z.addBlock});}delBlock(t,e){let a=t[1]<=4?-2:0,n=z.getColor(e),i=n[0],r=n[1],o=n[2];t[0]+=.5,t[2]+=.5,t[1]+=.5;let s=30;n.length>3&&(s=20,this.add({position:[t[0],t[1]+.375,t[2]],positionRange:[.5,.25,.5],colors:[i,r,o,.5,i,r,o,0],numParticles:10,renderOrder:a,...z.removeBlock}),i=n[3],r=n[4],o=n[5]),this.add({position:t,positionRange:[.5,.5,.5],colors:[i,r,o,.5,i,r,o,0],numParticles:s,renderOrder:a,...z.removeBlock});}removePlayerTrail(t){this.remove("PlayerTrail_"+t);}onPlayerWalk(t,e,a){let n=this.get("PlayerTrail_"+e);null===n&&(n=this.addTrail({name:"PlayerTrail_"+e,...z.playerMove}));let i=t.toArray();i[1]+=.2;let r=z.getColor(a),o=[r[0],r[1],r[2],.75,r[0],r[1],r[2],0];r.length>3&&(o=[r[0],r[1],r[2],.75,r[3],r[4],r[5],0]),n.birthParticles(i,o);}onVehicleDrive(t,e){let a=this.get("VehicleTrail_"+e);null===a&&(a=this.addTrail({name:"VehicleTrail_"+e,...z.vehicleMove})),a.birthParticles(t.toArray());}onBazookaFire(t,e){let a=this.get("BazookaTrail_"+e);null===a&&(a=this.addTrail({name:"BazookaTrail_"+e,...z.bazookaFire})),a.birthParticles(t.toArray());}onExplosion(t){this.add({position:t.toArray(),...z.explosion});}}

// WEBGPU test
//import WebGPU from './jsm/capabilities/WebGPU.js';
//import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';


/** __
*    _)_|_|_
*   __) |_| | 2024
*  @author lo.th / https://github.com/lo-th
* 
*  MAIN THREE.JS / PHY
*/


const Motor = phy$1;

let activeWebGPU = false;
let isWebGPU = false;

//let drawCall = false
//let debugLight = false

let oldPause = false;

let version, introText;
let oldLeft = 0;

let childEditor = null;
let isExternEditor = false;
let particles = null;

let stats = null;
let maxFps = 60;

let groundColor = 0x808080;
let groundAutoColor = true;

const CameraBase = {
	
	theta:0,
	phi:12,
	distance:12,
	fov:50,
	x:0,
	y:2,
	z:0,
	time:0
};




// default config
const setting = {

	//exposure: 1,
	envmap:'clear',//'basic',
	
	groundSize:[ 60, 60 ],
	groundPos:[ 0, 0, 0 ],
	groundAlpha: true,
	groundOpacity:1,
	groundReflect:0.1,
	ground:true,
	water:false,
	fog:false,
	vignette:true,
	shadow:0.75,

	exposure: 0.68,//1,
	direct:3.14,
	spherical: 1,
	envIntensity:1.3,
	bgIntensity:1,
	shadowIntensity:1,

};


const options = {

	renderMode: 'color',

	debug: false,
	day: true,
	key: false,

	mode:'HIGH',
	quality: 2,

	demo:'start',
	envmap:'null', //'basic',
	substep:1,
	fps:60,
	gravity:[0,-9.81,0],

	tone:'ACESFilmic',

	exposure: 0.68,//1,,
	direct:3.14,
	spherical: 1,
	envIntensity:1.3,
	bgIntensity:1,

	//envPower:1,//1
	envBlur:0,
	legacy:false,

	//light_1: 3.14,
	//light_2: 1,

	show_light: false,
	show_stat: false,

	shadow:0.5,//0.25,
	shadowType: 'PCFSoft',
	shadowGamma:1,//0.25,//1,
	shadowLuma:0.5, //0.75,//0,
    shadowContrast:2,//2.5,//1,

    reflect:0.1,
    
    fogMode:1,

    lightSizeUV:0.1,//1.3,
    nearPlane:3,//9.5,
    rings:4,//11,
    nSample:16,//17,

    composer:false,

};



let vignette = null;
let renderStart = false;
let dom, camera, controls, scene, renderer, loop = null, composer = null, followGroup, helperGroup, ground = null;

let code = '';
let editor = null;
let script = null;
let isLoadCode = true;
let needResize = true;

//const timer = new Timer(60)
const size = { w:0, h:0, r:0, left:0 };
const tm = { now:0, delta:0, then:0, tmp:0, n:0, dt:0, fps:0 };

const toneMappingOptions = {
	None: THREE$1.NoToneMapping,
	Linear: THREE$1.LinearToneMapping,
	Reinhard: THREE$1.ReinhardToneMapping,
	Cineon: THREE$1.CineonToneMapping,
	Agx: THREE$1.AgXToneMapping,
	ACESFilmic: THREE$1.ACESFilmicToneMapping,
	Uncharted2: THREE$1.CustomToneMapping
};

const shadowMapType = {
	PCSS: THREE$1.BasicShadowMap, // remplace by super soft
	PCF: THREE$1.PCFShadowMap,
	PCFSoft: THREE$1.PCFSoftShadowMap,
	VSM: THREE$1.VSMShadowMap
};

//let isMobile = false

const Main$1 = {

	Hub:Hub,

	engineType:'',
	currentDemmo:'',
	isWorker:true,
	devMode:false,
	engineList: [ 'OIMO', 'AMMO', 'PHYSX', 'HAVOK', 'RAPIER', 'JOLT' ],
	demoList:[],
	demoLink:[],
	devLink:[],
	devDemo:{},
	envList:[],
	isMobile:false,
	isEditor:false,

	motor:Motor,

	start: async ( o = {} ) => {

		// todo don't get the good model scale 
		//DualQuat();

		Hub.setMain( Main$1 );
		Gui.setMain( Main$1, Hub.getCorner() );
		Gui.setTextureConstrutor( THREE$1.Texture );

		activeWebGPU = o.useWebgpu || false;

		const gpuTier = await A$1();
	    const perf = gpuTier;
	    //console.log(perf)

	    Main$1.isMobile = perf.isMobile;

		if( Main$1.isMobile || perf.fps < 60 ){ 
			options.mode = 'LOW';
			options.quality = 1;
		}

		switch(perf.tier){
			case 1: options.fps = 15; break
			case 2: options.fps = 30; break
			case 3: options.fps = 60; break
		}

		Main$1.engineType = o.type || 'PHYSX';

		Main$1.isWorker = Main$1.isMobile ? false : true;

		let urlParams = new URLSearchParams( window.location.search );
		if( urlParams.has('E') ){
			let eng = urlParams.get('E');
			Main$1.isWorker = eng.search('w_') !== -1;
			Main$1.devMode = eng.search('dev_') !== -1;
			Main$1.engineType = eng.substring( eng.lastIndexOf('_')+1 ).toUpperCase();
		}

		let n = Main$1.engineType.toLowerCase();
		n.charAt(0).toUpperCase() + n.slice(1);

		version = Motor.Version[ Main$1.engineType ];

		// test cannon physics
		//if( Main.devMode ) Main.engineList.push('CANNON');

		//o.link = LinkWasm[ engineName ]
		o.type = Main$1.engineType;
		o.devMode = Main$1.devMode;
		o.worker = Main$1.isWorker;
		o.callback = init;

		introText = ( Main$1.isWorker ? 'WORKER ' : 'DIRECT ' ) + Main$1.engineType + ' ' + version;

		//options.show_stat = Main.devMode;

		//Motor.engine = Main.engineType
		window.engine = Main$1.engineType;//Motor.engine

		//o.renderer = renderer
		//console.log('yo', renderer)

		Motor.init( o );
	
	},

	getCorner:() => { return Hub.getCorner(); },


    setComposer:( b ) => { setComposer(); },
    showDebugLight:( b ) => { showDebugLight(b); },
    showStatistic:( b ) => { showStatistic(b); },

    setShadow:( v ) => { setShadow(v); },
    setShadowType:() => { setShadowType(); },
    upShader:() => { upShader(); },

    getCamera:() => ( controls.info ),
    setCamera:(o) => { setCamera(o); },

    getCode:() => ( code ),
	getScene:() => ( scene ),
	getRenderer:() => ( renderer ),
	getControler:() => ( controls ),
	getCodeName:() => ( options.demo ),
	getGround:() => ( ground ),

	getHub3d:() => ( vignette ),
	//getWorker:() => ( 'Worker' + (Main.isWorker ? ' On' : ' Off') ),
	getDemos:() => {

		let d = Motor.get('demos', 'json');
		Main$1.demoLink = [ ...d.Basic, ...d.Advanced, ...d[Main$1.engineType] ];
		Main$1.devLink = [ ...d.Dev ];
		if( Main$1.devMode ){ 
			Main$1.demoLink = [ ...Main$1.demoLink, ...d.Dev ];
			let j = d.Dev.length;
			while(j--){
				let name = d.Dev[j];
				name = name.substring( name.lastIndexOf('/')+1 );
				name = name.toUpperCase().substring(0,1) + name.substring(1).toLowerCase();
				Main$1.devDemo[name] = true;
			}
		}

		let i = Main$1.demoLink.length, l;
	    while(i--){
	    	l =  Main$1.demoLink[i];
	    	Main$1.demoList[i] = l.substring( l.lastIndexOf('/')+1 );
	    }

		Main$1.envList = [...d.Envmap];
		//return Main.demoList
	},

	lightIntensity:() => { lightIntensity(); },
	changeShadow:(o) => { changeShadow(o); },
	envmapIntensity:() => { setEnvmapIntensity(); },
	bgIntensity:() => { setbgIntensity(); },
	shadowIntensity:() => { setshadowIntensity(); },
	setReflect:(v) => { setReflect(v); },

	getOption:() => ( options ),
	getSetting:() => ( setting ),
	getComposer:() => ( composer ),
	getToneMappingOptions:() => ( toneMappingOptions ),

	setLeft:( x ) => { size.left = x; onResize(); },
	setCode:( code ) => { },
	getMouseDown:() => { return mouseDown },
	externEditor:() => { externEditor(); },
	injectCode: ( cc ) => { inject(cc); },

	addParticle: ( o ) => { return addParticle( o ) },
	getParticle: ( name ) => { return getParticle( name ) },
	initParticle: () => { return initParticle() },

	loadDemo: ( name ) => { loadDemo( name ); },
	extraCode: ( url, callback ) => { editor.loadExtra( url, callback ); },

	showEditor: ( b ) => { editor.show( b ); },
	changeMode: ( v ) => {
	    let low = options.mode === 'LOW';
	    setShadow( low ? 0 : 0.5 );
		setReflect( low ? 0 : 0.8 );
	},

	showGui: () => { Gui.showHide(); },
	resetGui: () => { Gui.reset(); },
	setEnv: (name, chageUI) => { setEnv(name); },
	setBlur: (v) => {
        Env.setBlur( options.envBlur );
	},

	setColors: ( palette ) => {

		//console.log( palette )

		if( vignette ) vignette.color = Gui.tool.htmlToHex( palette.darkVibrant ); 

		groundColor = Gui.tool.htmlToHex( palette.ground );

		if( ground && groundAutoColor ) ground.setColor( groundColor );

		let m = Motor.getMatRef();
	    //console.log(m)
	    if( m.isRealism ) m.setColor( palette );

		//let c = Gui.tool.htmlRgba( palette.darkMuted, 0.4 );
		//Hub.setTopColor( Gui.tool.htmlRgba(palette.darkMuted, 0.4) );

	},

	debugMode: ( b ) => {

		options.debug = b;
		Motor.setDebugMode( options.debug );

	},

	changeRenderMode: ( v ) => {

		let n = 0;
		if(v==='depth') n = 1;
		if(v==='normal') n = 2;
		Motor.changeRenderMode( n );

	}

};

Motor.log = Hub.log;


Motor.changeShadow = Main$1.changeShadow;

Motor.initParticle = Main$1.initParticle;
Motor.addParticle = Main$1.addParticle;
Motor.getParticle = Main$1.getParticle;
Motor.getGround = Main$1.getGround;

Motor.extraCode = Main$1.extraCode;
Motor.debugMode = Main$1.debugMode;
Motor.gui = Gui.extraUi;


window.phy = Motor;
window.math = Motor.math;
window.Main = Main$1;

window.THREE = THREE$1;
window.hub = Hub;
window.Planet = Planet;
window.Building = Building;
window.Sparkle = Sparkle;

window.Diamond = Diamond;
window.Fluid = Fluid;
window.TWEEN = TWEEN$1;


const init = () => {

	isWebGPU = activeWebGPU || false;
	// ? WebGPU.isAvailable() : false
 
	if( isWebGPU ) console.log('use webgpu !!');

	// https://threejs.org/docs/#api/en/renderers/WebGLRenderer

	let powerPreference ='default';
	//let powerPreference ='high-performance'
	//let powerPreference ='low-power'// for mobile

	let pixelRatio = 1 ;
	let antialias = true;

	if(options.mode === 'LOW') antialias = false;

	Motor.getScene();

	size.w = window.innerWidth;
	size.h = window.innerHeight;
	size.r = size.w / size.h;

	// RENDERER

	if( isWebGPU ){
	    renderer = new THREE$1.WebGPURenderer({ antialias:antialias });
	} else {
		renderer = new THREE$1.WebGLRenderer({ 
			antialias:antialias, 
			powerPreference:powerPreference,
			alpha: false,
		    depth: true,
		    stencil: true,
		    premultipliedAlpha: true,
		    preserveDrawingBuffer: false,
		    failIfMajorPerformanceCaveat: false,
		});
	}
	
	renderer.setPixelRatio( pixelRatio );
	renderer.setSize( size.w, size.h );
	renderer.setClearColor( 0x000000, 1 );
	renderer.toneMapping = toneMappingOptions[options.tone];
	renderer.toneMappingExposure = options.exposure;

	window.renderer = renderer;

	///THREE.ColorManagement.legacyMode = false;

	if( options.mode !== 'LOW' && !isWebGPU ) Motor.setMaxAnisotropy( renderer.capabilities.getMaxAnisotropy() );

	Motor.setRenderer(renderer);

	// DOM
    document.body.appendChild( renderer.domElement );
	dom = renderer.domElement;
	dom.style.position = 'absolute';

	// SHADER

	//Shader.renderer = renderer;

	/*if( !isWebGPU && options.mode !== 'LOW' && highShadow ){
		Shader.setGl2( isWebGPU ? false : renderer.capabilities.isWebGL2 );
		Shader.init( options );
		Motor.setExtendShader( Shader.add );
	}*/

	// SCENE

	scene = new THREE$1.Scene();
	renderer.setClearColor ( new THREE$1.Color( 0x000000 ) );
	//scene.background = new THREE.Color( 0x272822 )

	// GROUP

	followGroup = new THREE$1.Group();
	followGroup.name = 'followGroup';
	scene.add( followGroup );

	helperGroup = new THREE$1.Group();
	helperGroup.name = 'helperGroup';
	scene.add( helperGroup );

	scene.helper = helperGroup;


	addLight();

	// CAMERA / CONTROLER

	camera = new THREE$1.PerspectiveCamera( 50, size.r, 0.1, 1000 );
	scene.add( camera );

	controls = new Controller( camera, renderer.domElement, followGroup );
	controls.resetAll();
	//controls.target.y = 2
	/*controls.minDistance = 0.1
    controls.maxDistance = 100
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = true
    controls.zoomToCursor = true*/
    //controls.enable = false
    //controls.maxPolarAngle = Math.PI / 2

    //setCamera()

	//controls.update()

	
	// avoid track run in background
	document.addEventListener( 'visibilitychange', onVisible );

	window.addEventListener( 'resize', onResize );
	document.body.addEventListener( 'dragover', function(e){ e.preventDefault(); }, false );
    document.body.addEventListener( 'dragend', function(e){ e.preventDefault(); }, false );
    document.body.addEventListener( 'dragleave', function(e){ e.preventDefault();}, false );
	document.body.addEventListener( 'drop', drop, false );

	Hub.init( camera, size, introText );

	editor = new Editor();

	Env.init( renderer, scene );
	Env.setMain( Main$1 );

	start();

	Motor.load( 'demos.json', next );

};

const drop = (e) => {

	e.preventDefault();
	const file = e.dataTransfer.files[0];
    const reader = new FileReader();
    const name = file.name;
    const type = name.substring(name.lastIndexOf('.')+1, name.length );
    const finalName = name.substring( name.lastIndexOf('/')+1, name.lastIndexOf('.') );

    //console.log(type, name)

    switch( type ){
    	case 'js': reader.readAsText( file ); break;
    	case 'fbx': case 'glb':  reader.readAsArrayBuffer( file ); break;
    	case 'hdr' : case 'exr' :
    	options.envmap = finalName;
    	Env.load( ( window.URL || window.webkitURL ).createObjectURL( file ), null, type ); 
    	break;
    }

    reader.onload = function ( e ) {

    	switch(type){
	    	case 'js': directDemo( finalName, e.target.result ); break;
	    	
	    }
    };

};

const next = () => {

	Main$1.getDemos();


	//hideMat = Motor.getHideMat()

    Motor.setContent( scene );
    Motor.setControl( controls );
    //Motor.setExtendShader( Shader.add )
    Motor.setAddControl( addControl );

    // activate mouse drag
    Motor.activeMouse( controls );


	let hash = location.hash.substr( 1 );
    if( hash !== '' ) options.demo = hash;

    Hub.endLoading();

	loadDemo( options.demo );


	//if(isWebGPU) options.show_stat = false
	//if( options.show_stat ) showStatistic( true )

};

const start = () => {

	if( renderStart ) return;
	if( isWebGPU ) renderer.setAnimationLoop( render );
	else { if( loop === null) render(0); }
	//if( loop === null) render(0);
	renderStart = true;
};

/*const upExpose = () => {
	if( renderer.toneMappingExposure < options.exposure ) renderer.toneMappingExposure+=0.001
}*/

const addControl = () => {

	if( Main$1.isMobile ) Hub.addJoystick();

};


//--------------------
//   LIGHT
//--------------------

const changeShadow = (o) => {

	if(o.distance);
	Lights.setShadow( Lights.byName('sun'), o );

};

const lightIntensity = (a,b,c) => {

	if( a !== undefined ) options.direct = a;
	if( b !== undefined ) options.spherical = b;
	if( c !== undefined ) options.exposure = c;

	Lights.update({ sunIntensity:options.direct, hemiIntensity:options.spherical });
	renderer.toneMappingExposure = options.exposure;

};

Motor.lightIntensity = lightIntensity;

const addLight = () => {

	Lights.define( options, followGroup, isWebGPU );

	/*let s 

	Lights.add({ 
		type:'direct', name:'sun',
		//intensity:options.mode !== 'LOW' ? options.light_1*0.3 : options.light_1, 
		intensity:options.light_1,
		distance:10, parent:followGroup,
	    shadow:{ range:20, near:5, far:50, bias:!isWebGPU ? -0.0005 : 0.005, radius:4, quality: 2048 * options.quality }
	})


	/////
	if( options.mode !== 'LOW' ){
		/*Lights.add({ 
		    type:'direct', name:'sun2',
		    intensity:options.light_1*0.7, distance:6, parent:followGroup,
	        shadow:{ range:4, near:1, far:20, bias:-0.0005, radius:4, quality: 1024 * options.quality },
		})*/
	//}

	/////

	/*Lights.add({ 
	    type:'direct', name:'moon',
	    intensity:options.light_2, distance:10, parent:followGroup,
	   // shadow:{ range:20, near:1, far:20, bias:-0.0005, radius:1, quality: 2048 * options.quality }
	})*/

	//if( !isWebGPU ){	
		/*Lights.add({ 
			type:'hemi', name:'hemi',
			intensity:options.light_2, 
			pos:[0,1,0], 
			parent:followGroup 
		})*/
	//}

	////


	if( options.mode === 'LOW' ){
		options.shadow = 0;
		options.reflect = 0;
	}

	if( !isWebGPU ){

		Lights.castShadow( options.shadow !== 0 );
		renderer.shadowMap.enabled = options.shadow !== 0; 
		renderer.shadowMap.type = shadowMapType[options.shadowType];
		//renderer.shadowMap.autoUpdate = false;
		//renderer.shadowMap.needsUpdate= true;

	}

	////

};

/*const clearShadow = ( o ) => {

	if(light) light.shadow.dispose()
	if(light3) light3.shadow.dispose()
	
}*/

const resetLight = ( o ) => {

	const dt = {
		sunPos: [0.27, 1, 0.5],
		sunColor: 0xFFFFFF,
		skyColor: 0xFFFFFF,
		groundColor: 0x808080, 
	};

	Lights.update( dt );

};

const showDebugLight = ( b ) => {

	let v = Lights.addHelper( b, helperGroup );
	Env.preview( v );

};

const setShadowType = () => {

	renderer.shadowMap.type = shadowMapType[options.shadowType];
	//Main.upShader();

};

const setShadow = ( v ) => {

	//if( isWebGPU ) return;

	options.shadow = v;

	if( options.shadow === 0 ){
		Lights.castShadow( false );
		//if( !isWebGPU ) 
			renderer.shadowMap.enabled = false;
		//clearShadow()
	} else {
		if( !renderer.shadowMap.enabled ){
			Lights.castShadow( true );
			//if( !isWebGPU ) 
				renderer.shadowMap.enabled = true;
		}
	}

	//if( light.shadowHelper ) light.shadowHelper.visible = options.shadow !== 0

	//Main.upShader();

};



// 

//--------------------
//   GROUND
//--------------------

const addVignette = ( o ) => {

	if( vignette === null && !isWebGPU ){

		vignette = new Vignette();
		camera.add( vignette );

	}

};

const removeVignette = () => {

	if( vignette === null ) return

    //camera.remove( vignette );
	vignette.dispose();
    vignette = null;

};

	
//--------------------
//   GROUND
//--------------------

const addGround = ( o ) => {

	//groundAutoColor = !o.groundColor//false
    if( o.groundReflect !== undefined ) options.reflect = o.groundReflect;
    if( o.reflect !== undefined ) options.reflect = o.reflect;

	//if( isWebGPU ) return

	if( ground === null ){

		// add reflect ground
		ground = new Reflector({

	    	textureSize: 1024 * options.quality,
	        clipBias:0.003,
	        encoding:true,
	        reflect: options.mode === 'LOW' ? 0 : options.reflect,
	        water:o.water,
	        //color:groundColor,
	        round:true,
	        normal:true

	    });
	    scene.add( ground );

	} else {
		ground.reset();
	}

    ground.setSize( o.groundSize );
    ground.position.fromArray( o.groundPos );

    if( o.groundColor !== undefined ){ 
    	ground.setColor( o.groundColor );
    	groundAutoColor = false;
    } else {
    	ground.setColor( groundColor );
    }

	ground.setAlphaMap( o.groundAlpha );
	ground.setOpacity( o.groundOpacity );
	if( o.groundReflect !== undefined ) ground.setReflect( o.groundReflect );
	ground.setWater( o.water );
    //scene.add( ground )
    Motor.addMaterial( ground.material,  true );

    //Gui.reset()

};

const removeGround = () => {

	if( ground === null ) return

	//scene.remove( ground )
	ground.dispose();
    ground = null;

};




//--------------------
//
//   CODE SIDE
//
//--------------------

const directDemo = ( name, result ) => {

	//let findDemo = Gui.resetDemoGroup( name )

	//unSelect()

	Main$1.currentDemo = name;
	options.demo = name;
	location.hash = name;

	Hub.upMenu();

	inject( result, true );

};

const loadDemo = ( name ) => {

	let idd = Main$1.demoList.indexOf(name);
	let expath = '';
	if( Main$1.devLink.indexOf(name)!==-1 ) expath = 'dev/'; 

	if( idd === -1 && expath === '' ){ 
		name = 'start';
		idd = 0;
	}

	//let findDemo = Gui.resetDemoGroup( name )
	//if(!findDemo) name = 'start'

	//unSelect()
    
    Main$1.currentDemo = name;
	options.demo = name;
	location.hash = name;

	//console.log(options.demo)

	Hub.upMenu();

	//Motor.load( './demos/' + expath + Main.demoLink[idd] + '.js', inject )
	Motor.load( './demos/' + expath + name + '.js', inject );

};

const inject = ( newCode, force = false ) => {

	isLoadCode = !newCode;
	code = isLoadCode ? Motor.getScript( options.demo ) : newCode;

	if( force ) isLoadCode = true;

	if( window['onReset'] ){ 
		window['onReset']();
		window['onReset'] = null;
	}

	//Hub.log()
	TWEEN$1.removeAll();
	Hub.reset();
	//Shader.reset()
	editor.reset();
	Gui.resetExtra();

	//resetLight()

	if( particles ) particles.dispose();
	
	
	if( isLoadCode ){
		//console.log('is full reset !!!')
		//Shader.reset()
	    resetLight(); 
		Motor.poolDispose();
	}

	Motor.mouseMode('drag');
	Motor.reset( refreshCode );

};

const refreshCode = () => {

	if( script !== null){ 
		script.remove();
		script = null;
	}
		
	script = document.createElement("script");
    script.language = "javascript";
    script.type = "text/javascript";
    script.id = "demo";
    script.async = false;//true;
    script.innerHTML = '{' + code + '}';
    document.body.appendChild( script );

    if( isLoadCode ) changeEditorCode();

    let ev = code.search( 'phy.view' );
    let evh = code.search( '//phy.view' );
	
    if( ev === -1 || evh !== -1 ) view( setting );
    /*else {

    	let t = code.substring(ev+10, code.indexOf('})'))
    	//let f = JSON.parse('{'+t+'}');
    	console.log( t )
    }*/
    if( code.search( 'phy.set' ) === -1 ) Motor.set();

    window['demo']();

    Gui.doReset();

};

const changeEditorCode = () => {

	if( isExternEditor ) send({ type:'set', code:code, name:options.demo });
    else editor.set( code, options.demo );

};

//--------------------
//   STOP ENGINE
//--------------------

const onVisible = () => {

	if( document.hidden ) {
		oldPause = Motor.getPause();
		Motor.pause( true );
	}
	else Motor.pause( oldPause );

};


//--------------------
//   RESIZE
//--------------------

const onResize = () => {

	size.w = window.innerWidth - size.left;
	size.h = window.innerHeight;
	size.r = size.w / size.h;
	needResize = true;

};

const doResize = () => {

	//if( !needResize ) return
	dom.style.left = size.left + 'px';
	camera.aspect = size.r;
	camera.updateProjectionMatrix();
	renderer.setSize( size.w, size.h );
	if(composer) composer.resize( size );
	if(particles) particles.onresize( size.h );

	
	Hub.resize( size );
    Motor.resize( size );
	needResize = false;

	//console.log(dom.clientLeft)

};



//--------------------
//   RENDER
//--------------------

const render = ( stamp = 0 ) => {

    //console.time('step')
	// TIME
	tm.now = stamp;
	tm.delta = tm.now - tm.then;
	tm.dt = tm.delta * 0.001;

	if( needResize ) doResize();

    

	// UPDATE PHY
	if( !Main$1.isWorker ) Motor.doStep( stamp );
	else Motor.setDelta(tm.dt);

	// UPDATE PARTICLE
    if( particles ) particles.update( stamp );

	// UPDATE CAMERA CONTROLER
    if( controls ) controls.up( tm.dt );
	/*if( controls ){ 
		if( controls.enableDamping && controls.enable ) controls.update();
		if( controls.follow ) controls.follow( tm.dt );
	}*/

    // UPDATE TWEEN
	TWEEN$1.update( stamp );



	// RENDER
	if( composer && composer.enabled ) composer.render( tm.dt );
	else renderer.render( scene, camera );

	Gui.update();

	upStat();

	//console.timeEnd('step')


	if( !isWebGPU ) loop = requestAnimationFrame( render );

	//if( renderer.shadowMap.enabled ) renderer.shadowMap.needsUpdate = true;

	

};

const upStat = () => {

	//Hub.showTimeTest( Motor.getTimeTest() )

	// three fps
	if ( tm.now - 1000 > tm.tmp ){ 
		tm.tmp = tm.now; 
		tm.fps = tm.n; 
		tm.n = 0; 
	}

	tm.n++;
	tm.then = tm.now;

	if( tm.fps > maxFps ) {
		maxFps = tm.fps;
		Motor.setMaxFps( maxFps );
	}

	//Hub.setFps( 'T:' + tm.fps + ' | P:' + Motor.getFps() )
	Hub.setFps(  tm.fps + ' ~ ' + Motor.getFps() + ' | ' + Motor.getMs()+' ms' );
	getFullStats();

};

const setReflect = ( v ) => {

	if(v!==undefined) options.reflect = v;

	if(!ground) return
	ground.setReflect( options.reflect );

};




/*function firstFunction() {
      return new Promise((resolve, reject) => {
          let y = 0
          setTimeout(() => {
            for (let i=0; i<10; i++) {
               y++
            }
             console.log('Loop completed.')  
             resolve(y)
          }, 2000)
      })
    }*/
//async 
const view = ( o = {} ) => {

	o = { ...setting, ...o };

	groundAutoColor = !o.groundColor;//false

	if( options.mode === 'LOW' ){
		o.shadow = 0;
		o.groundReflect = 0;
		options.reflect = 0;
		options.quality = 1;
	}

	options.direct = o.direct;
	options.spherical = o.spherical;
	options.exposure = o.exposure;
	options.envIntensity = o.envIntensity;
	options.bgIntensity = o.bgIntensity;
	options.shadowIntensity = o.shadowIntensity;

	Motor.lightIntensity();

	Env.reset();

	//console.log('view', o)

	//const result = await firstFunction()

	if( o.envmap ){ 
		setEnv( o.envmap);
		options.envBlur = o.envblur || 0;
		Env.setBlur( options.envBlur );
		if( o.background ) Env.setBackgroud( o.background );
		if( o.envFloor ) Env.project( o.background );
	}

	setShadow( o.shadow );

	// FOG
	let fogMode = o.fogMode || 0; 
	if( o.fog ){ 
		let range = o.fogRange || [1,50];
		scene.fog = new THREE$1.Fog( Env.getFogColor().getHex(), range[0], range[1] );
		options.fogMode = fogMode;
	}
	else if( o.fogexp ){ 
		scene.fog = new THREE$1.FogExp2( Env.getFogColor().getHex(), o.fogexp || 0.01 );
		options.fogMode = fogMode;
	}
	else scene.fog = null;

	// reflect floor
	if( o.ground ) addGround( o );
	else removeGround();

	if( o.vignette ) addVignette();
	else removeVignette();

	//if( isLoadCode ) controls.moveCam( {...cam, ...o })

	if( isLoadCode ) setCamera( o );

	//Shader.up( options )

    //if( o.envPower ) options.envPower = o.envPower;
    //else options.envPower = 1.0;

    setEnvmapIntensity();
    setbgIntensity();
    setshadowIntensity();
	
};

Motor.view = view;

const setCamera = ( o ) => {

	//if(o) for( let i in o ){ if( cam[i] !== undefined ) cam[i] = o[i] }

    controls.moveCam( {...CameraBase, ...o } );
    controls.update();

};



//async function setEnv( name, chageUI ) {
const setEnv = ( name, chageUI ) => {

	//if(isWebGPU) return

	if( name !== options.envmap ){

		if ( !isNaN(name) ) options.envmap = 'null';
		else options.envmap = name;

		Env.set( name );
		
	}




	//options.envmap = name
	//Env.load( './assets/textures/equirectangular/'+options.envmap+'.hdr' )

};

//--------------------
//   EXTERN EDITOR
//--------------------

const externEditor = () => {

	if( !childEditor ){
		let hash = location.hash;
		oldLeft = size.left || 500;
		isExternEditor = true;
		childEditor = window.open('editor.html'+hash, 'Editor', 'height='+size.h+', width='+oldLeft);
	    window.addEventListener( 'message', message, false );

	    //window.open('/pageaddress.html','winname','directories=no,titlebar=no,status=no,menubar=no,scrollbars=no,resizable=no,width=400,height=350');

	    childEditor.onload = () => {
	    	send( { type : 'connect' } ); 
	    	editor.close();
	    	size.left = 0;
	    	onResize();
	    };

	} 

	/*if( isExternEditor ){
		isExternEditor = false; 
		size.left = oldLeft
		send( { type : 'close' } )
	}*/

	

};

const message = ( e ) => {

	switch( e.data.type ){

		case 'connect' :

            console.log('connect'); 

        break;

        case 'inject' :

           inject( e.data.code );

        break;

        case 'close' :
           //console.log('close') 
           send( { type : 'close' } );
           window.removeEventListener( 'message', message, false );
           childEditor = null;
           isExternEditor = false; 
           editor.open();
		   size.left = oldLeft;
        break;

	}

};

const send = ( data ) => {

	if( childEditor ) childEditor.postMessage( data,'*' );

};


//--------------------
//   OPTION
//--------------------

const setshadowIntensity = () => {

	Lights.setShadow( Lights.byName('sun'), { intensity:options.shadowIntensity } );

};

const setbgIntensity = () => {

	scene.backgroundIntensity = options.bgIntensity;

};

const setEnvmapIntensity = () => {

	scene.environmentIntensity = options.envIntensity;

	//Motor.setEnvmapIntensity( options.envPower )

	/*let g = Motor.getScene()
	g.traverse( function ( node ) {
		if( node.isMesh ){ 
			if( !node.material.userData.envp ) node.material.userData.envp = node.material.envMapIntensity
			node.material.envMapIntensity = node.material.userData.envp * options.envPower
		}
	})*/

	//if(!ground.material.userData.envp) ground.material.userData.envp = ground.material.envMapIntensity
	//ground.material.envMapIntensity = ground.material.userData.envp * options.envPower

};

const showStatistic = ( b ) => {

	if( isWebGPU ) return

	if( b && !stats ){
		stats = new Stats( renderer );
	}

	if( !b && stats ){

		stats = null;
		Hub.setStats();
		
	}

};



const getFullStats = () => {

    if ( !stats ) return
    Hub.setStats( stats.get() );
    
};


//--------------------
//   POST PROCESS
//--------------------

const setComposer = ( b ) => {

	if( options.composer ){
		if( composer === null ) composer = new Composer( renderer, scene, camera, controls, size );
		composer.enabled = true;
		if( vignette ) vignette.visible = false;

	} else {
		if( composer ){
			composer.dispose();
			composer = null;
			if(vignette) vignette.visible = true;
		}
	}

	Gui.postprocessEdit();

};


//--------------------
//  PARTICLE
//--------------------

const initParticle = ( ) => {

   if( !particles ) particles = new D( scene, renderer );

};

const addParticle = ( o = {} ) => {

   if( !particles ) particles = new D( scene, renderer );
   return particles.add( o )

};

const getParticle = ( name ) => {
	
	if( !particles ) particles = new D( scene, renderer );
   return particles.get( name )

};

export { Main$1 as Main };
